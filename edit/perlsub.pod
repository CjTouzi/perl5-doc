=encoding utf8

=EN =encoding utf8

=CN =encoding utf8

=EN =head1 NAME X<subroutine> X<function>

=CN =head1 名称 X<subroutine> X<function>

=EN perlsub - Perl subroutines

=CN perlsub(？) - Perl(？) 子程序

=EN =head1 SYNOPSIS

=CN =head1 范例

=EN To declare subroutines: X<subroutine, declaration> X<sub>

=CN To(？) 宣布，声明 子程序: X<subroutine, declaration> X<sub>

=EN     sub NAME;              # A "forward" declaration.

=CN     sub NAME;              # A "向前的，向前" 宣布，宣告.

=EN     sub NAME(PROTO);          #  ditto, but with prototypes

=CN     sub NAME(PROTO);          #  同上, 但是，除了 同，一起，用 原型

=EN     sub NAME : ATTRS;          #  with attributes

=CN     sub NAME : ATTRS;          #  同，一起，用 属性

=EN     sub NAME(PROTO) : ATTRS;      #  with attributes and prototypes

=CN     sub NAME(PROTO) : ATTRS;      #  同，一起，用 属性 和，与，而 原型

=EN     sub NAME BLOCK          # A declaration and a definition.

=CN     sub NAME BLOCK          # A 宣布，宣告 和，与，而 a 定义，解释.

=EN     sub NAME(PROTO) BLOCK      #  ditto, but with prototypes

=CN     sub NAME(PROTO) BLOCK      #  同上, 但是，除了 同，一起，用 原型

=EN     sub NAME : ATTRS BLOCK      #  with attributes

=CN     sub NAME : ATTRS BLOCK      #  同，一起，用 属性

=EN     sub NAME(PROTO) : ATTRS BLOCK #  with prototypes and attributes

=CN     sub NAME(PROTO) : ATTRS BLOCK #  同，一起，用 原型 和，与，而 属性

=EN To define an anonymous subroutine at runtime: X<subroutine, anonymous>

=CN To(？) 下定义，界定，规定 一个 匿名 子程序 在，处于，以 runtime(？): X<subroutine, anonymous>

=EN     $subref = sub BLOCK;         # no proto

=CN     $subref = sub BLOCK;         # 不毫不，没有 款

=EN     $subref = sub (PROTO) BLOCK;     # with proto

=CN     $subref = sub (PROTO) BLOCK;     # 同，一起，用 款

=EN     $subref = sub : ATTRS BLOCK;     # with attributes

=CN     $subref = sub : ATTRS BLOCK;     # 同，一起，用 属性

=EN     $subref = sub (PROTO) : ATTRS BLOCK; # with proto and attributes

=CN     $subref = sub (PROTO) : ATTRS BLOCK; # 同，一起，用 款 和，与，而 属性

=EN To import subroutines: X<import>

=CN To(？) 进口，引进，进口货 子程序: X<import>

=EN To call subroutines: X<subroutine, call> X<call>

=CN To(？) 叫，称为，打电话 子程序: X<subroutine, call> X<call>

=EN     NAME(LIST);       # & is optional with parentheses.

=CN     NAME(LIST);       # & 是 可任选的，随意的 同，一起，用 括号.

=EN     NAME LIST;       # Parentheses optional if predeclared/imported.

=CN     NAME LIST;       # Parentheses(？) 可任选的，随意的 如果，虽然，是否 predeclared(？)/imported(？).

=EN     &NAME(LIST);   # Circumvent prototypes.

=CN     &NAME(LIST);   # Circumvent(？) 原型.

=EN     &NAME;       # Makes current @_ visible to called subroutine.

=CN     &NAME;       # Makes(？) 现令的，流 @_ 看得见的 向，到 称为 子程序.

=EN =head1 DESCRIPTION

=CN =head1 描述

=EN Like many languages, Perl provides for user-defined subroutines. These may be located anywhere in the main program, loaded in from other files via the C<do>, C<require>, or C<use> keywords, or generated on the fly using C<eval> or anonymous subroutines. You can even call a function indirectly using a variable containing its name or a CODE reference.

=CN Like(？) 许多的，许多 语言, Perl(？) 提供 给，作，用的 使用者，用户-定义 子程序. These(？) 可以，也许，祝愿 是，存在 located(？) 无论何地 在，内，穿戴 （定冠词）那，这 主要的 节目，规划，项目, 装载 在，内，穿戴 自，从，来 其他的，别的 文件 经由，取道 （定冠词）那，这 C<do>, C<require>, 或者，即，否则 C<use> 关键词, 或者，即，否则 产生 在，上，关于 （定冠词）那，这 飞，驾机，苍蝇 使用 C<eval> 或者，即，否则 匿名 子程序. You(？) aux，能，会，可以 平坦的，均匀的 叫，称为，打电话 a 作用，集会，函数 间接地 使用 a 可变的，变量 含有 它的 姓名，名称，命名 或者，即，否则 a CODE(？) 参考（书），推荐书.

=EN The Perl model for function call and return values is simple: all functions are passed as parameters one single flat list of scalars, and all functions likewise return to their caller one single flat list of scalars.Any arrays or hashes in these call and return lists will collapse, losing their identities--but you may always use pass-by-reference instead to avoid this.Both call and return lists may contain as many or as few scalar elements as you'd like.(Often a function without an explicit return statement is called a subroutine, but there's really no difference from Perl's perspective.) X<subroutine, parameter> X<parameter>

=CN The(？) Perl(？) 模范，模型，模特儿 给，作，用的 作用，集会，函数 叫，称为，打电话 和，与，而 回归，归还，归来 价值观 是 简单的，朴素的: 所有的，一切 功能 是 通过 一样，作为 参数 一个 单个的，单身的 平的，平淡的 表，名单，列表 的(表示领属等) scalars(？), 和，与，而 所有的，一切 功能 同样，照样 回归，归还，归来 向，到 他们的，它们的 打电话的人 一个 单个的，单身的 平的，平淡的 表，名单，列表 的(表示领属等) scalars(？).Any(？) 阵列 或者，即，否则 破解 在，内，穿戴 这些 叫，称为，打电话 和，与，而 回归，归还，归来 列表 aux，将，愿，意志 倒塌v，坍塌, losing(？) 他们的，它们的 identities(？)--但是，除了 你，你们 可以，也许，祝愿 总是，始终 使用，用途，利用 经过，传给，关口-在，旁边，按照-参考（书），推荐书 代替，而是 向，到 避免，逃避 这，这个.Both(？) 叫，称为，打电话 和，与，而 回归，归还，归来 列表 可以，也许，祝愿 含有，容纳，抑制 一样，作为 许多的，许多 或者，即，否则 一样，作为 少的，少数 标量 元素 一样，作为 你，你们'd 喜欢，像.(Often(？) a 作用，集会，函数 没有，在，外部 一个 清楚的，明晰的 回归，归还，归来 声明，陈述 是 称为 a 子程序, 但是，除了 那里，到那里's，（缩）轮船 真正地，果然 不毫不，没有 差异，差别 自，从，来 Perl(？)'s，（缩）轮船 展望，观点，透视.) X<subroutine, parameter> X<parameter>

=EN Any arguments passed in show up in the array C<@_>.Therefore, if you called a function with two arguments, those would be stored in C<$_[0]> and C<$_[1]>.The array C<@_> is a local array, but its elements are aliases for the actual scalar parameters.In particular,  if an element C<$_[0]> is updated, the corresponding argument is updated (or an error occurs if it is not updatable).If an argument is an array or hash element which did not exist when the function was called, that element is created only when (and if) it is modified or a reference to it is taken.(Some earlier versions of Perl created the element whether or not the element was assigned to.) Assigning to the whole array C<@_> removes that aliasing, and does not update any arguments. X<subroutine, argument> X<argument> X<@_>

=CN Any(？) 争论 通过 在，内，穿戴 显示，表明，演出 向上，起床 在，内，穿戴 （定冠词）那，这 装扮，排列 C<@_>.Therefore(？), 如果，虽然，是否 你，你们 称为 a 作用，集会，函数 同，一起，用 两 争论, 那些 将 是，存在 储存 在，内，穿戴 C<$_[0]> 和，与，而 C<$_[1]>.The(？) 装扮，排列 C<@_> 是 a 地方的，当地的 装扮，排列, 但是，除了 它的 元素 是 化名 给，作，用的 （定冠词）那，这 现实的，实际的 标量 参数.In(？) 特殊的，项目,  如果，虽然，是否 一个 成分，元素 C<$_[0]> 是 updated(？), （定冠词）那，这 相应的，通信的 争论，论点 是 updated(？) (或者，即，否则 一个 错误，过失 发生 如果，虽然，是否 它 是 不 updatable(？)).If(？) 一个 争论，论点 是 一个 装扮，排列 或者，即，否则 哈希 成分，元素 哪个，那个 做 不 存在，生存 何时 （定冠词）那，这 作用，集会，函数 是 称为, 那那个，那么 成分，元素 是 创造 唯一的，仅仅 何时 (和，与，而 如果，虽然，是否) 它 是 改良的，改进的 或者，即，否则 a 参考（书），推荐书 向，到 它 是 采取.(Some(？) 早些时候 版本 的(表示领属等) Perl(？) 创造 （定冠词）那，这 成分，元素 是否，还是， 或者，即，否则 不 （定冠词）那，这 成分，元素 是 assigned(？) 向，到.) Assigning(？) 向，到 （定冠词）那，这 全部的，全部 装扮，排列 C<@_> removes(？) 那那个，那么 走样, 和，与，而 做 不 更新 任何，一些 争论. X<subroutine, argument> X<argument> X<@_>

=EN A C<return> statement may be used to exit a subroutine, optionally specifying the returned value, which will be evaluated in the appropriate context (list, scalar, or void) depending on the context of the subroutine call.If you specify no return value, the subroutine returns an empty list in list context, the undefined value in scalar context, or nothing in void context.If you return one or more aggregates (arrays and hashes), these will be flattened together into one large indistinguishable list.

=CN A C<return> 声明，陈述 可以，也许，祝愿 是，存在 使用 向，到 出口，安全门，离开 a 子程序, 选择性地 指定 （定冠词）那，这 回来 价值，评价，估价, 哪个，那个 aux，将，愿，意志 是，存在 评估 在，内，穿戴 （定冠词）那，这 恰当的，拨给 上下文，语境，环境 (表，名单，列表, 标量, 或者，即，否则 空的，无效的) 根据 在，上，关于 （定冠词）那，这 上下文，语境，环境 的(表示领属等) （定冠词）那，这 子程序 叫，称为，打电话.If(？) 你，你们 详细说明，指定 不毫不，没有 回归，归还，归来 价值，评价，估价, （定冠词）那，这 子程序 返回 一个 空的，空虚的 表，名单，列表 在，内，穿戴 表，名单，列表 上下文，语境，环境, （定冠词）那，这 未定义的 价值，评价，估价 在，内，穿戴 标量 上下文，语境，环境, 或者，即，否则 没有东西，毫不 在，内，穿戴 空的，无效的 上下文，语境，环境.If(？) 你，你们 回归，归还，归来 一个 或者，即，否则 更多的更，更 aggregates(？) (阵列 和，与，而 破解), 这些 aux，将，愿，意志 是，存在 夷为平地, 共同，一起，同时 到，里面，，成 一个 大的，巨大的 indistinguishable(？) 表，名单，列表.

=EN If no C<return> is found and if the last statement is an expression, its value is returned.If the last statement is a loop control structure like a C<foreach> or a C<while>, the returned value is unspecified.The empty sub returns the empty list. X<subroutine, return value> X<return value> X<return>

=CN If(？) 不毫不，没有 C<return> 是 创办，使有根据 和，与，而 如果，虽然，是否 （定冠词）那，这 最后的，上次 声明，陈述 是 一个 表达，措辞，表情, 它的 价值，评价，估价 是 回来.If(？) （定冠词）那，这 最后的，上次 声明，陈述 是 a 环，回路，环绕 控制，管理 结构，构造，组织 喜欢，像 a C<foreach> 或者，即，否则 a C<while>, （定冠词）那，这 回来 价值，评价，估价 是 unspecified(？).The(？) 空的，空虚的 子 返回 （定冠词）那，这 空的，空虚的 表，名单，列表. X<subroutine, return value> X<return value> X<return>

=EN Perl does not have named formal parameters.In practice all you do is assign to a C<my()> list of these.Variables that aren't declared to be private are global variables.For gory details on creating private variables, see L<"Private Variables via my()"> and L<"Temporary Values via local()">.To create protected environments for a set of functions in a separate package (and probably a separate file), see L<perlmod/"Packages">. X<formal parameter> X<parameter, formal>

=CN Perl(？) 做 不 有，不得不，拿 命名 形式上的，正式的 参数.In(？) 练习，习惯，实施 所有的，一切 你，你们 做，干，足够，制作 是 分配，指定 向，到 a C<my()> 表，名单，列表 的(表示领属等) 这些.Variables(？) 那那个，那么 还't 宣布 向，到 是，存在 私人的，秘密的 是 全世界的，总的 变量.For(？) gory(？) 细节 在，上，关于 创造 私人的，秘密的 变量, 看见，明白，查看 L<"Private Variables via my()"> 和，与，而 L<"Temporary Values via local()">.To(？) 创造，创作，造成 protected(？) environments(？) 给，作，用的 a 放，指定，全套 的(表示领属等) 功能 在，内，穿戴 a 分离，分隔，分手 包裹，打包 (和，与，而 或许，大概 a 分离，分隔，分手 档案，纵列，锉刀), 看见，明白，查看 L<perlmod/"Packages">. X<formal parameter> X<parameter, formal>

=EN Example:

=CN Example(？):

=EN Example:

=CN Example(？):

=EN     # get a line, combining continuation lines

=CN     # 获得，记住，到达 a 行，线条，界线, 结合 continuation(？) lines(？)

=EN     #  that start with whitespace

=CN     #  那那个，那么 开始，着手，发动 同，一起，用 空白

=EN     $thisline = $lookahead;  # global variables!

=CN     $thisline = $lookahead;  # 全世界的，总的 变量!

=EN     $lookahead = <STDIN>;    # get first line

=CN     $lookahead = <STDIN>;    # 获得，记住，到达 第一的，首先 行，线条，界线

=EN Assigning to a list of private variables to name your arguments:

=CN Assigning(？) 向，到 a 表，名单，列表 的(表示领属等) 私人的，秘密的 变量 向，到 姓名，名称，命名 你的，你们的 争论:

=EN Because the assignment copies the values, this also has the effect of turning call-by-reference into call-by-value.Otherwise a function is free to do in-place modifications of C<@_> and change its caller's values. X<call-by-reference> X<call-by-value>

=CN Because(？) （定冠词）那，这 任务，作业 copies(？) （定冠词）那，这 价值观, 这，这个 也 已经 （定冠词）那，这 后果，效力，导致 的(表示领属等) 拐角，旋转的 叫，称为，打电话-在，旁边，按照-参考（书），推荐书 到，里面，，成 叫，称为，打电话-在，旁边，按照-价值，评价，估价.Otherwise(？) a 作用，集会，函数 是 自由的，空闲的 向，到 做，干，足够，制作 在，内，穿戴-地方，位置，放置 modifications(？) 的(表示领属等) C<@_> 和，与，而 变化，零钱，改变 它的 打电话的人's，（缩）轮船 价值观. X<call-by-reference> X<call-by-value>

=EN     upcase_in($v1, $v2);  # this changes $v1 and $v2

=CN     upcase_in($v1, $v2);  # 这，这个 变化 $v1 和，与，而 $v2

=EN You aren't allowed to modify constants in this way, of course.If an argument were actually literal and you tried to change it, you'd take a (presumably fatal) exception.For example, this won't work: X<call-by-reference> X<call-by-value>

=CN You(？) 还't 允许 向，到 修改，减轻，修饰 constants(？) 在，内，穿戴 这，这个 方法，路，方向, 的(表示领属等) 过程，路线，课程.If(？) 一个 争论，论点 是 实际上，居然 字面的，不夸张的 和，与，而 你，你们 tried(？) 向，到 变化，零钱，改变 它, 你，你们'd 拿，带，吃，乘 a (也许，大概 致命的) 除外，例外.For(？) 例子，榜样, 这，这个 赢得't 劳动，工作，作品: X<call-by-reference> X<call-by-value>

=EN It would be much safer if the C<upcase_in()> function were written to return a copy of its parameters instead of changing them in place:

=CN It(？) 将 是，存在 许多的，许多 safer(？) 如果，虽然，是否 （定冠词）那，这 C<upcase_in()> 作用，集会，函数 是 写作的，书面的 向，到 回归，归还，归来 a 抄写，复制，副本 的(表示领属等) 它的 参数 代替，而是 的(表示领属等) 改变 他（她）们，它们 在，内，穿戴 地方，位置，放置:

=EN     ($v3, $v4) = upcase($v1, $v2);  # this doesn't change $v1 and $v2

=CN     ($v3, $v4) = upcase($v1, $v2);  # 这，这个 没有't 变化，零钱，改变 $v1 和，与，而 $v2

=EN     return unless defined wantarray;  # void context, do nothing

=CN     return unless defined wantarray;  # 空的，无效的 上下文，语境，环境, 做，干，足够，制作 没有东西，毫不

=EN Notice how this (unprototyped) function doesn't care whether it was passed real scalars or arrays.Perl sees all arguments as one big,  long, flat parameter list in C<@_>.This is one area where Perl's simple argument-passing style shines.The C<upcase()> function would work perfectly well without changing the C<upcase()> definition even if we fed it things like this:

=CN Notice(？) 如何，多么，怎样 这，这个 (unprototyped(？)) 作用，集会，函数 没有't 注意，小心，关心 是否，还是， 它 是 通过 真的，纯粹的 scalars(？) 或者，即，否则 阵列.Perl(？) 看到 所有的，一切 争论 一样，作为 一个 大的，重大的,  长的，长久, 平的，平淡的 参数，参量 表，名单，列表 在，内，穿戴 C<@_>.This(？) 是 一个 地区，面积，领域 哪里 Perl(？)'s，（缩）轮船 简单的，朴素的 争论，论点-传球 风格，时尚，作风 shines(？).The(？) C<upcase()> 作用，集会，函数 将 劳动，工作，作品 完全地，完美地 井，好，充分 没有，在，外部 改变 （定冠词）那，这 C<upcase()> 定义，解释 平坦的，均匀的 如果，虽然，是否 我们 美联储 它 事情 喜欢，像 这，这个:

=EN Do not, however, be tempted to do this:

=CN Do(？) 不, 可是，然而, 是，存在 试探 向，到 做，干，足够，制作 这，这个:

=EN Like the flattened incoming parameter list, the return list is also flattened on return.So all you have managed to do here is stored everything in C<@a> and made C<@b> empty.See L<Pass by Reference> for alternatives.

=CN Like(？) （定冠词）那，这 夷为平地, incoming(？) 参数，参量 表，名单，列表, （定冠词）那，这 回归，归还，归来 表，名单，列表 是 也 夷为平地, 在，上，关于 回归，归还，归来.So(？) 所有的，一切 你，你们 有，不得不，拿 managed(？) 向，到 做，干，足够，制作 这里，在这里 是 储存 事事，一切 在，内，穿戴 C<@a> 和，与，而 使 C<@b> 空的，空虚的.See(？) L<Pass by Reference> 给，作，用的 alternatives(？).

=EN A subroutine may be called using an explicit C<&> prefix.The C<&> is optional in modern Perl, as are parentheses if the subroutine has been predeclared.The C<&> is I<not> optional when just naming the subroutine, such as when it's used as an argument to defined() or undef().Nor is it optional when you want to do an indirect subroutine call with a subroutine name or reference using the C<&$subref()> or C<&{$subref}()> constructs,  although the C<< $subref->() >> notation solves that problem. See L<perlref> for more about all that. X<&>

=CN A 子程序 可以，也许，祝愿 是，存在 称为 使用 一个 清楚的，明晰的 C<&> 前缀.The(？) C<&> 是 可任选的，随意的 在，内，穿戴 现代的，时髦的 Perl(？), 一样，作为 是 括号 如果，虽然，是否 （定冠词）那，这 子程序 已经 被 predeclared(？).The(？) C<&> 是 I<not> 可任选的，随意的 何时 只，刚才 命名 （定冠词）那，这 子程序, 这样的，如此的 一样，作为 何时 它's，（缩）轮船 使用 一样，作为 一个 争论，论点 向，到 定义() 或者，即，否则 C<undef(？)>().Nor(？) 是 它 可任选的，随意的 何时 你，你们 想要，通辑，缺乏 向，到 做，干，足够，制作 一个 间接的，侧面的 子程序 叫，称为，打电话 同，一起，用 a 子程序 姓名，名称，命名 或者，即，否则 参考（书），推荐书 使用 （定冠词）那，这 C<&$subref()> 或者，即，否则 C<&{$subref}()> 构建,  虽然 （定冠词）那，这 C<< $subref->() >> 符号 solves(？) 那那个，那么 课题，难题，问题. See(？) L<perlref> 给，作，用的 更多的更，更 关于，大约 所有的，一切 那那个，那么. X<&>

=EN Subroutines may be called recursively.If a subroutine is called using the C<&> form, the argument list is optional, and if omitted,  no C<@_> array is set up for the subroutine: the C<@_> array at the time of the call is visible to subroutine instead.This is an efficiency mechanism that new users may wish to avoid. X<recursion>

=CN Subroutines(？) 可以，也许，祝愿 是，存在 称为 recursively(？).If(？) a 子程序 是 称为 使用 （定冠词）那，这 C<&> 形状，类型，表格, （定冠词）那，这 争论，论点 表，名单，列表 是 可任选的，随意的, 和，与，而 如果，虽然，是否 省略了,  不毫不，没有 C<@_> 装扮，排列 是 放，指定，全套 向上，起床 给，作，用的 （定冠词）那，这 子程序: （定冠词）那，这 C<@_> 装扮，排列 在，处于，以 （定冠词）那，这 时间，时候，次数 的(表示领属等) （定冠词）那，这 叫，称为，打电话 是 看得见的 向，到 子程序 代替，而是.This(？) 是 一个 效率，功效 机制，机械装置 那那个，那么 新的，重新的 用户 可以，也许，祝愿 希望，祝愿，想要 向，到 避免，逃避. X<recursion>

=EN     &foo(1, 2, 3);    # pass three arguments

=CN     &foo(1, 2, 3);    # 经过，传给，关口 三 争论

=EN     foo(1, 2, 3);        # the same

=CN     foo(1, 2, 3);        # （定冠词）那，这 同样的

=EN     foo();        # pass a null list

=CN     foo();        # 经过，传给，关口 a 无 表，名单，列表

=EN     &foo();        # the same

=CN     &foo();        # （定冠词）那，这 同样的

=EN     &foo;        # foo() get current args, like foo(@_) !!

=CN     &foo;        # 师父() 获得，记住，到达 现令的，流 参数, 喜欢，像 师父(@_) !!

=EN     foo;        # like foo() IFF sub foo predeclared, else "foo"

=CN     foo;        # 喜欢，像 师父() IFF(？) 子 师父 predeclared(？), 别的，否则 "师父"

=EN Not only does the C<&> form make the argument list optional, it also disables any prototype checking on arguments you do provide.This is partly for historical reasons, and partly for having a convenient way to cheat if you know what you're doing.See L<Prototypes> below. X<&>

=CN Not(？) 唯一的，仅仅 做 （定冠词）那，这 C<&> 形状，类型，表格 做，制造，种类 （定冠词）那，这 争论，论点 表，名单，列表 可任选的，随意的, 它 也 disables(？) 任何，一些 原型 检查 在，上，关于 争论 你，你们 做，干，足够，制作 供给，提供，准备.This(？) 是 部分地 给，作，用的 历史的 原因, 和，与，而 部分地 给，作，用的 有 a 便利的，方便的 方法，路，方向 向，到 欺骗，作弊，骗子 如果，虽然，是否 你，你们 知道，认识，懂 什么，什么的 你，你们'读，阅读，朗诵 做.See(？) L<Prototypes> 在，下面. X<&>

=EN Subroutines whose names are in all upper case are reserved to the Perl core, as are modules whose names are in all lower case.A subroutine in all capitals is a loosely-held convention meaning it will be called indirectly by the run-time system itself, usually due to a triggered event. Subroutines that do special, pre-defined things include C<AUTOLOAD>, C<CLONE>,  C<DESTROY> plus all functions mentioned in L<perltie> and L<PerlIO::via>.

=CN Subroutines(？) 谁的 名字 是 在，内，穿戴 所有的，一切 上部的，较高的 事实，案例，箱子 是 保留 向，到 （定冠词）那，这 Perl(？) 核，核心, 一样，作为 是 模块 谁的 名字 是 在，内，穿戴 所有的，一切 降低，减弱 事实，案例，箱子.A 子程序 在，内，穿戴 所有的，一切 capitals(？) 是 a loosely(？)-held(？) 大会，协定，惯例 意义，意图 它 aux，将，愿，意志 是，存在 称为 间接地 在，旁边，按照 （定冠词）那，这 跑，竞选，行驶-时间，时候，次数 系统，体制，制度 它自己, 通常，平常 到期的，预定的 向，到 a 触发 事件，场合，比赛. Subroutines(？) 那那个，那么 做，干，足够，制作 特别的，专门的, pre(？)-定义 事情 包括 C<AUTOLOAD>, C<CLONE>,  C<DESTROY> 加，加号，正号 所有的，一切 功能 提到 在，内，穿戴 L<perltie> 和，与，而 L<PerlIO::via>.

=EN The C<BEGIN>, C<UNITCHECK>, C<CHECK>, C<INIT> and C<END> subroutines are not so much subroutines as named special code blocks, of which you can have more than one in a package, and which you can B<not> call explicitly.See L<perlmod/"BEGIN, UNITCHECK, CHECK, INIT and END">

=CN The(？) C<BEGIN>, C<UNITCHECK>, C<CHECK>, C<INIT> 和，与，而 C<END> 子程序 是 不 这样，也一样 许多的，许多 子程序 一样，作为 命名 特别的，专门的 法规，代码，密码 块, 的(表示领属等) 哪个，那个 你，你们 aux，能，会，可以 有，不得不，拿 更多的更，更 比，除，外 一个 在，内，穿戴 a 包裹，打包, 和，与，而 哪个，那个 你，你们 aux，能，会，可以 B<not> 叫，称为，打电话 清晰地.See(？) L<perlmod/"BEGIN, UNITCHECK, CHECK, INIT and END">

=EN =head2 Private Variables via my() X<my> X<variable, lexical> X<lexical> X<lexical variable> X<scope, lexical> X<lexical scope> X<attributes, my>

=CN =head2 Private(？) Variables(？) 经由，取道 我的() X<my> X<variable, lexical> X<lexical> X<lexical variable> X<scope, lexical> X<lexical scope> X<attributes, my>

=EN Synopsis:

=CN Synopsis(？):

=EN     my $foo;            # declare $foo lexically local

=CN     my $foo;            # 宣布，声明 $师父 词法 地方的，当地的

=EN     my (@wid, %get);     # declare list of variables local

=CN     my (@wid, %get);     # 宣布，声明 表，名单，列表 的(表示领属等) 变量 地方的，当地的

=EN     my $foo = "flurp";    # declare $foo lexical, and init it

=CN     my $foo = "flurp";    # 宣布，声明 $师父 词汇, 和，与，而 初始 它

=EN     my @oof = @bar;    # declare @oof lexical, and init it

=CN     my @oof = @bar;    # 宣布，声明 @oof(？) 词汇, 和，与，而 初始 它

=EN     my $x : Foo = $y;    # similar, with an attribute applied

=CN     my $x : Foo = $y;    # 类似的，相象的, 同，一起，用 一个 属于，属性 应用

=EN B<WARNING>: The use of attribute lists on C<my> declarations is still evolving.The current semantics and interface are subject to change. See L<attributes> and L<Attribute::Handlers>.

=CN B<WARNING>: The(？) 使用，用途，利用 的(表示领属等) 属于，属性 列表 在，上，关于 C<my> 声明 是 静止的，仍旧 evolving(？).The(？) 现令的，流 语义 和，与，而 交界，接口 是 题目，学科，主语 向，到 变化，零钱，改变. See(？) L<attributes> 和，与，而 L<Attribute::Handlers>.

=EN The C<my> operator declares the listed variables to be lexically confined to the enclosing block, conditional (C<if/unless/elsif/else>),  loop (C<for/foreach/while/until/continue>), subroutine, C<eval>,  or C<do/require/use>'d file.If more than one value is listed, the list must be placed in parentheses.All listed elements must be legal lvalues.Only alphanumeric identifiers may be lexically scoped--magical built-ins like C<$/> must currently be C<local>ized with C<local> instead.

=CN The(？) C<my> 操作人员，接线员 这 （定冠词）那，这 上市 变量 向，到 是，存在 词法 confined(？) 向，到 （定冠词）那，这 enclosing(？) 大块，街区，障碍物, 有条件的 (C<if/unless/elsif/else>),  环，回路，环绕 (C<for/foreach/while/until/continue>), 子程序, C<eval>,  或者，即，否则 C<do/require/use>'d 档案，纵列，锉刀.If(？) 更多的更，更 比，除，外 一个 价值，评价，估价 是 上市, （定冠词）那，这 表，名单，列表 必须，准是，必须 是，存在 placed(？) 在，内，穿戴 括号.All(？) 上市 元素 必须，准是，必须 是，存在 合法的，法律的 lvalues(？).Only(？) alphanumeric(？) 标识符 可以，也许，祝愿 是，存在 词法 选中--魔法 建造-ins(？) 喜欢，像 C<$/> 必须，准是，必须 当前，广泛地 是，存在 C<local>ized 同，一起，用 C<local> 代替，而是.

=EN Unlike dynamic variables created by the C<local> operator, lexical variables declared with C<my> are totally hidden from the outside world, including any called subroutines.This is true if it's the same subroutine called from itself or elsewhere--every call gets its own copy. X<local>

=CN Unlike(？) 动力的，动态的 变量 创造 在，旁边，按照 （定冠词）那，这 C<local> 操作人员，接线员, 词汇 变量 宣布 同，一起，用 C<my> 是 统统，完全地 隐藏 自，从，来 （定冠词）那，这 外部，在外面 世界，界，世间, 包括 任何，一些 称为 子程序.This(？) 是 真实的，真正的 如果，虽然，是否 它's，（缩）轮船 （定冠词）那，这 同样的 子程序 称为 自，从，来 它自己 或者，即，否则 在别处--每个，所有的 叫，称为，打电话 得到 它的 自己的，拥有 抄写，复制，副本. X<local>

=EN This doesn't mean that a C<my> variable declared in a statically enclosing lexical scope would be invisible.Only dynamic scopes are cut off.For example, the C<bumpx()> function below has access to the lexical $x variable because both the C<my> and the C<sub> occurred at the same scope, presumably file scope.

=CN This(？) 没有't 打算，意指 那那个，那么 a C<my> 可变的，变量 宣布 在，内，穿戴 a 静态 enclosing(？) 词汇 范围 将 是，存在 看不见的.Only(？) 动力的，动态的 范围 是 割，切，削减，切断 去，离开.For(？) 例子，榜样, （定冠词）那，这 C<bumpx()> 作用，集会，函数 在，下面 已经 接近，入口 向，到 （定冠词）那，这 词汇 $x 可变的，变量 因为，由于 双方，两 （定冠词）那，这 C<my> 和，与，而 （定冠词）那，这 C<sub> 发生 在，处于，以 （定冠词）那，这 同样的 范围, 也许，大概 档案，纵列，锉刀 范围.

=EN An C<eval()>, however, can see lexical variables of the scope it is being evaluated in, so long as the names aren't hidden by declarations within the C<eval()> itself.See L<perlref>. X<eval, scope of>

=CN An(？) C<eval()>, 可是，然而, aux，能，会，可以 看见，明白，查看 词汇 变量 的(表示领属等) （定冠词）那，这 范围 它 是 生物，存在 评估 在，内，穿戴, 这样，也一样 长的，长久 一样，作为 （定冠词）那，这 名字 还't 隐藏 在，旁边，按照 声明 在，内 （定冠词）那，这 C<eval()> 它自己.See(？) L<perlref>. X<eval, scope of>

=EN The parameter list to my() may be assigned to if desired, which allows you to initialize your variables.(If no initializer is given for a particular variable, it is created with the undefined value.)  Commonly this is used to name input parameters to a subroutine.Examples:

=CN The(？) 参数，参量 表，名单，列表 向，到 我的() 可以，也许，祝愿 是，存在 assigned(？) 向，到 如果，虽然，是否 desired(？), 哪个，那个 允许 你，你们 向，到 初始化 你的，你们的 变量.(If(？) 不毫不，没有 初始化器 是 给出 给，作，用的 a 特殊的，项目 可变的，变量, 它 是 创造 同，一起，用 （定冠词）那，这 未定义的 价值，评价，估价.)  Commonly(？) 这，这个 是 使用 向，到 姓名，名称，命名 输入，投入 参数 向，到 a 子程序.Examples(？):

=EN     $arg = "fred";      # "global" variable

=CN     $arg = "fred";      # "全世界的，总的" 可变的，变量

=EN     my $arg = shift;  # name doesn't matter

=CN     my $arg = shift;  # 姓名，名称，命名 没有't 事情，物资，毛病

=EN The C<my> is simply a modifier on something you might assign to.So when you do assign to variables in its argument list, C<my> doesn't change whether those variables are viewed as a scalar or an array.So

=CN The(？) C<my> 是 简单地，仅 a 改性剂 在，上，关于 某事，某物 你，你们 或许，可以，力 分配，指定 向，到.So(？) 何时 你，你们 做，干，足够，制作 分配，指定 向，到 变量 在，内，穿戴 它的 争论，论点 表，名单，列表, C<my> 没有't 变化，零钱，改变 是否，还是， 那些 变量 是 viewed(？) 一样，作为 a 标量 或者，即，否则 一个 装扮，排列.So(？)

=EN     my ($foo) = <STDIN>;        # WRONG?

=CN     my ($foo) = <STDIN>;        # WRONG(？)?

=EN both supply a list context to the right-hand side, while

=CN 双方，两 供应，供给 a 表，名单，列表 上下文，语境，环境 向，到 （定冠词）那，这 正确的，右的-手，人手，指针 边，面，侧面，一方, 一会儿，当，时

=EN supplies a scalar context.But the following declares only one variable:

=CN 供应 a 标量 上下文，语境，环境.But(？) （定冠词）那，这 下列的，其次的 这 唯一的，仅仅 一个 可变的，变量:

=EN     my $foo, $bar = 1;            # WRONG

=CN     my $foo, $bar = 1;            # WRONG(？)

=EN That has the same effect as

=CN That(？) 已经 （定冠词）那，这 同样的 后果，效力，导致 一样，作为

=EN The declared variable is not introduced (is not visible) until after the current statement.Thus,

=CN The(？) 宣布 可变的，变量 是 不 介绍 (是 不 看得见的) ，到，为止 在，后 （定冠词）那，这 现令的，流 声明，陈述.Thus(？),

=EN can be used to initialize a new $x with the value of the old $x, and the expression

=CN aux，能，会，可以 是，存在 使用 向，到 初始化 a 新的，重新的 $x 同，一起，用 （定冠词）那，这 价值，评价，估价 的(表示领属等) （定冠词）那，这 老的，，岁的 $x, 和，与，而 （定冠词）那，这 表达，措辞，表情

=EN is false unless the old $x happened to have the value C<123>.

=CN 是 假的，假造的 除非 （定冠词）那，这 老的，，岁的 $x 发生 向，到 有，不得不，拿 （定冠词）那，这 价值，评价，估价 C<123>.

=EN Lexical scopes of control structures are not bounded precisely by the braces that delimit their controlled blocks; control expressions are part of that scope, too.Thus in the loop

=CN Lexical(？) 范围 的(表示领属等) 控制，管理 structures(？) 是 不 bounded(？) 精确地 在，旁边，按照 （定冠词）那，这 牙套 那那个，那么 delimit(？) 他们的，它们的 控制 块; 控制，管理 expressions(？) 是 部分，零件，角色 的(表示领属等) 那那个，那么 范围, 也，非常.Thus(？) 在，内，穿戴 （定冠词）那，这 环，回路，环绕

=EN the scope of $line extends from its declaration throughout the rest of the loop construct (including the C<continue> clause), but not beyond it.Similarly, in the conditional

=CN （定冠词）那，这 范围 的(表示领属等) $行，线条，界线 extends(？) 自，从，来 它的 宣布，宣告 贯穿，全部 （定冠词）那，这 休息，休息，休止 的(表示领属等) （定冠词）那，这 环，回路，环绕 建设，建立 (包括 （定冠词）那，这 C<continue> 条款，从句), 但是，除了 不 在，那边，超出 它.Similarly(？), 在，内，穿戴 （定冠词）那，这 有条件的

=EN the scope of $answer extends from its declaration through the rest of that conditional, including any C<elsif> and C<else> clauses,  but not beyond it.See L<perlsyn/"Simple Statements"> for information on the scope of variables in statements with modifiers.

=CN （定冠词）那，这 范围 的(表示领属等) $答案，答复 extends(？) 自，从，来 它的 宣布，宣告 通过，借助 （定冠词）那，这 休息，休息，休止 的(表示领属等) 那那个，那么 有条件的, 包括 任何，一些 C<elsif> 和，与，而 C<else> clauses(？),  但是，除了 不 在，那边，超出 它.See(？) L<perlsyn/"Simple Statements"> 给，作，用的 通知，情报，资料 在，上，关于 （定冠词）那，这 范围 的(表示领属等) 变量 在，内，穿戴 报表 同，一起，用 修饰.

=EN The C<foreach> loop defaults to scoping its index variable dynamically in the manner of C<local>.However, if the index variable is prefixed with the keyword C<my>, or if there is already a lexical by that name in scope, then a new lexical is created instead.Thus in the loop X<foreach> X<for>

=CN The(？) C<foreach> 环，回路，环绕 违约 向，到 范围界定 它的 索引，标志，指数 可变的，变量 动态 在，内，穿戴 （定冠词）那，这 方法，方式，礼貌 的(表示领属等) C<local>.However(？), 如果，虽然，是否 （定冠词）那，这 索引，标志，指数 可变的，变量 是 前缀 同，一起，用 （定冠词）那，这 关键字 C<my>, 或者，即，否则 如果，虽然，是否 那里，到那里 是 已 a 词汇 在，旁边，按照 那那个，那么 姓名，名称，命名 在，内，穿戴 范围, 当时，然后，那么 a 新的，重新的 词汇 是 创造 代替，而是.Thus(？) 在，内，穿戴 （定冠词）那，这 环，回路，环绕 X<foreach> X<for>

=EN the scope of $i extends to the end of the loop, but not beyond it,  rendering the value of $i inaccessible within C<some_function()>. X<foreach> X<for>

=CN （定冠词）那，这 范围 的(表示领属等) $我 extends(？) 向，到 （定冠词）那，这 结尾，终止，结束 的(表示领属等) （定冠词）那，这 环，回路，环绕, 但是，除了 不 在，那边，超出 它,  渲染 （定冠词）那，这 价值，评价，估价 的(表示领属等) $我 很难得到的 在，内 C<some_function()>. X<foreach> X<for>

=EN Some users may wish to encourage the use of lexically scoped variables. As an aid to catching implicit uses to package variables,  which are always global, if you say

=CN Some(？) 用户 可以，也许，祝愿 希望，祝愿，想要 向，到 鼓舞，鼓励，助长 （定冠词）那，这 使用，用途，利用 的(表示领属等) 词法 选中 变量. As(？) 一个 援助，救护 向，到 catching(？) 隐式 使用 向，到 包裹，打包 变量,  哪个，那个 是 总是，始终 全世界的，总的, 如果，虽然，是否 你，你们 说，发言（权）

=EN then any variable mentioned from there to the end of the enclosing block must either refer to a lexical variable, be predeclared via C<our> or C<use vars>, or else must be fully qualified with the package name. A compilation error results otherwise.An inner block may countermand this with C<no strict 'vars'>.

=CN 当时，然后，那么 任何，一些 可变的，变量 提到 自，从，来 那里，到那里 向，到 （定冠词）那，这 结尾，终止，结束 的(表示领属等) （定冠词）那，这 enclosing(？) 大块，街区，障碍物 必须，准是，必须 二者之一，也 查阅，提及 向，到 a 词汇 可变的，变量, 是，存在 predeclared(？) 经由，取道 C<our> 或者，即，否则 C<use vars>, 或者，即，否则 别的，否则 必须，准是，必须 是，存在 完全，彻底 有资格的 同，一起，用 （定冠词）那，这 包裹，打包 姓名，名称，命名. A 编译 错误，过失 结果 另外的，否则.An(？) 里面的，内心的 大块，街区，障碍物 可以，也许，祝愿 撤回，取消 这，这个 同，一起，用 C<no strict 'vars'>.

=EN A C<my> has both a compile-time and a run-time effect.At compile time, the compiler takes notice of it.The principal usefulness of this is to quiet C<use strict 'vars'>, but it is also essential for generation of closures as detailed in L<perlref>.Actual initialization is delayed until run time, though, so it gets executed at the appropriate time, such as each time through a loop, for example.

=CN A C<my> 已经 双方，两 a 编（书），编辑-时间，时候，次数 和，与，而 a 跑，竞选，行驶-时间，时候，次数 后果，效力，导致.At(？) 编（书），编辑 时间，时候，次数, （定冠词）那，这 编译器 需要 留意，注意，通知 的(表示领属等) 它.The(？) 重要的，主要的 用处，有效性 的(表示领属等) 这，这个 是 向，到 安静的，轻声的 C<use strict 'vars'>, 但是，除了 它 是 也 必需的，本质的 给，作，用的 世代，一代人 的(表示领属等) 瓶盖 一样，作为 详细的，详尽的 在，内，穿戴 L<perlref>.Actual(？) 初始化 是 delayed(？) ，到，为止 跑，竞选，行驶 时间，时候，次数, 虽然，可是, 这样，也一样 它 得到 执行 在，处于，以 （定冠词）那，这 恰当的，拨给 时间，时候，次数, 这样的，如此的 一样，作为 名，每个 时间，时候，次数 通过，借助 a 环，回路，环绕, 给，作，用的 例子，榜样.

=EN Variables declared with C<my> are not part of any package and are therefore never fully qualified with the package name.In particular, you're not allowed to try to make a package variable (or other global) lexical:

=CN Variables(？) 宣布 同，一起，用 C<my> 是 不 部分，零件，角色 的(表示领属等) 任何，一些 包裹，打包 和，与，而 是 因而，所以 从不，永不，未曾 完全，彻底 有资格的 同，一起，用 （定冠词）那，这 包裹，打包 姓名，名称，命名.In(？) 特殊的，项目, 你，你们'读，阅读，朗诵 不 允许 向，到 尝试，审讯，尝试 向，到 做，制造，种类 a 包裹，打包 可变的，变量 (或者，即，否则 其他的，别的 全世界的，总的) 词汇:

=EN     my $pack::var;    # ERROR!  Illegal syntax

=CN     my $pack::var;    # ERROR(？)!  Illegal(？) 语法

=EN In fact, a dynamic variable (also known as package or global variables) are still accessible using the fully qualified C<::> notation even while a lexical of the same name is also visible:

=CN In(？) 事实，真相, a 动力的，动态的 可变的，变量 (也 已知 一样，作为 包裹，打包 或者，即，否则 全世界的，总的 变量) 是 静止的，仍旧 可接近的 使用 （定冠词）那，这 完全，彻底 有资格的 C<::> 符号 平坦的，均匀的 一会儿，当，时 a 词汇 的(表示领属等) （定冠词）那，这 同样的 姓名，名称，命名 是 也 看得见的:

=EN That will print out C<20> and C<10>.

=CN That(？) aux，将，愿，意志 印刷，出版，字体 出外，向外，完 C<20> 和，与，而 C<10>.

=EN You may declare C<my> variables at the outermost scope of a file to hide any such identifiers from the world outside that file.This is similar in spirit to C's static variables when they are used at the file level.To do this with a subroutine requires the use of a closure (an anonymous function that accesses enclosing lexicals). If you want to create a private subroutine that cannot be called from outside that block, it can declare a lexical variable containing an anonymous sub reference:

=CN You(？) 可以，也许，祝愿 宣布，声明 C<my> 变量 在，处于，以 （定冠词）那，这 最外的 范围 的(表示领属等) a 档案，纵列，锉刀 向，到 躲藏，隐瞒，掩盖 任何，一些 这样的，如此的 标识符 自，从，来 （定冠词）那，这 世界，界，世间 外部，在外面 那那个，那么 档案，纵列，锉刀.This(？) 是 类似的，相象的 在，内，穿戴 精神，心灵n，酒精 向，到 C's，（缩）轮船 静止的，静态的 变量 何时 他（她）们，它们 是 使用 在，处于，以 （定冠词）那，这 档案，纵列，锉刀 水平，级，弄平.To(？) 做，干，足够，制作 这，这个 同，一起，用 a 子程序 需要 （定冠词）那，这 使用，用途，利用 的(表示领属等) a 关闭 (一个 匿名 作用，集会，函数 那那个，那么 存取 enclosing(？) lexicals(？)). If(？) 你，你们 想要，通辑，缺乏 向，到 创造，创作，造成 a 私人的，秘密的 子程序 那那个，那么 不能 是，存在 称为 自，从，来 外部，在外面 那那个，那么 大块，街区，障碍物, 它 aux，能，会，可以 宣布，声明 a 词汇 可变的，变量 含有 一个 匿名 子 参考（书），推荐书:

=EN As long as the reference is never returned by any function within the module, no outside module can see the subroutine, because its name is not in any package's symbol table.Remember that it's not I<REALLY> called C<$some_pack::secret_version> or anything; it's just $secret_version,  unqualified and unqualifiable.

=CN As(？) 长的，长久 一样，作为 （定冠词）那，这 参考（书），推荐书 是 从不，永不，未曾 回来 在，旁边，按照 任何，一些 作用，集会，函数 在，内 （定冠词）那，这 模量，模件, 不毫不，没有 外部，在外面 模量，模件 aux，能，会，可以 看见，明白，查看 （定冠词）那，这 子程序, 因为，由于 它的 姓名，名称，命名 是 不 在，内，穿戴 任何，一些 包裹，打包's，（缩）轮船 象征，符号 桌子，表格.Remember(？) 那那个，那么 它's，（缩）轮船 不 I<REALLY> 称为 C<$some_pack::secret_version> 或者，即，否则 无论什么; 它's，（缩）轮船 只，刚才 $secret_version,  unqualified(？) 和，与，而 unqualifiable(？).

=EN This does not work with object methods, however; all object methods have to be in the symbol table of some package to be found.See L<perlref/"Function Templates"> for something of a work-around to this.

=CN This(？) 做 不 劳动，工作，作品 同，一起，用 物体，目的，反对 方法, 可是，然而; 所有的，一切 物体，目的，反对 方法 有，不得不，拿 向，到 是，存在 在，内，穿戴 （定冠词）那，这 象征，符号 桌子，表格 的(表示领属等) 若干，某一 包裹，打包 向，到 是，存在 创办，使有根据.See(？) L<perlref/"Function Templates"> 给，作，用的 某事，某物 的(表示领属等) a 劳动，工作，作品-在周围，大约 向，到 这，这个.

=EN =head2 Persistent Private Variables X<state> X<state variable> X<static> X<variable, persistent> X<variable, static> X<closure>

=CN =head2 Persistent(？) Private(？) Variables(？) X<state> X<state variable> X<static> X<variable, persistent> X<variable, static> X<closure>

=EN There are two ways to build persistent private variables in Perl 5.10. First, you can simply use the C<state> feature.Or, you can use closures,  if you want to stay compatible with releases older than 5.10.

=CN There(？) 是 两 方式 向，到 建造，建设 persistent(？) 私人的，秘密的 变量 在，内，穿戴 Perl(？) 5.10. First(？), 你，你们 aux，能，会，可以 简单地，仅 使用，用途，利用 （定冠词）那，这 C<state> 相貌，特征，特写.Or(？), 你，你们 aux，能，会，可以 使用，用途，利用 瓶盖,  如果，虽然，是否 你，你们 想要，通辑，缺乏 向，到 停留，暂住，保持 可兼容的，一致的 同，一起，用 releases(？) 年长的 比，除，外 5.10.

=EN =head3 Persistent variables via state()

=CN =head3 Persistent(？) 变量 经由，取道 状态，国家，州()

=EN Beginning with perl 5.9.4, you can declare variables with the C<state> keyword in place of C<my>.For that to work, though, you must have enabled that feature beforehand, either by using the C<feature> pragma, or by using C<-E> on one-liners.(see L<feature>)

=CN Beginning(？) 同，一起，用 C<perl(？)> 5.9.4, 你，你们 aux，能，会，可以 宣布，声明 变量 同，一起，用 （定冠词）那，这 C<state> 关键字 在，内，穿戴 地方，位置，放置 的(表示领属等) C<my>.For(？) 那那个，那么 向，到 劳动，工作，作品, 虽然，可是, 你，你们 必须，准是，必须 有，不得不，拿 使 那那个，那么 相貌，特征，特写 事先，预先, 二者之一，也 在，旁边，按照 使用 （定冠词）那，这 C<feature> C<pragma(？)>, 或者，即，否则 在，旁边，按照 使用 C<-E> 在，上，关于 一个-liners(？).(看见，明白，查看 L<feature>)

=EN For example, the following code maintains a private counter, incremented each time the gimme_another() function is called:

=CN For(？) 例子，榜样, （定冠词）那，这 下列的，其次的 法规，代码，密码 maintains(？) a 私人的，秘密的 柜台，相反的, incremented(？) 名，每个 时间，时候，次数 （定冠词）那，这 gimme_another() 作用，集会，函数 是 称为:

=EN Also, since C<$x> is lexical, it can't be reached or modified by any Perl code outside.

=CN Also(？), 自从，既然 C<$x> 是 词汇, 它 aux，能，会，可以't 是，存在 reached(？) 或者，即，否则 改良的，改进的 在，旁边，按照 任何，一些 Perl(？) 法规，代码，密码 外部，在外面.

=EN When combined with variable declaration, simple scalar assignment to C<state> variables (as in C<state $x = 42>) is executed only the first time.When such statements are evaluated subsequent times, the assignment is ignored.The behavior of this sort of assignment to non-scalar variables is undefined.

=CN When(？) combined(？) 同，一起，用 可变的，变量 宣布，宣告, 简单的，朴素的 标量 任务，作业 向，到 C<state> 变量 (一样，作为 在，内，穿戴 C<state $x = 42>) 是 执行 唯一的，仅仅 （定冠词）那，这 第一的，首先 时间，时候，次数.When(？) 这样的，如此的 报表 是 评估 以后的，后起的 次, （定冠词）那，这 任务，作业 是 忽视.The(？) 行为，举止 的(表示领属等) 这，这个 种类，分类，拣 的(表示领属等) 任务，作业 向，到 非-标量 变量 是 未定义的.

=EN =head3 Persistent variables with closures

=CN =head3 Persistent(？) 变量 同，一起，用 瓶盖

=EN Just because a lexical variable is lexically (also called statically) scoped to its enclosing block, C<eval>, or C<do> FILE, this doesn't mean that within a function it works like a C static.It normally works more like a C auto, but with implicit garbage collection.

=CN Just(？) 因为，由于 a 词汇 可变的，变量 是 词法 (也 称为 静态) 选中 向，到 它的 enclosing(？) 大块，街区，障碍物, C<eval>, 或者，即，否则 C<do> FILE(？), 这，这个 没有't 打算，意指 那那个，那么 在，内 a 作用，集会，函数 它 工厂 喜欢，像 a C 静止的，静态的.It(？) 正常地，通常 工厂 更多的更，更 喜欢，像 a C auto(？), 但是，除了 同，一起，用 隐式 垃圾 收集，收藏.

=EN Unlike local variables in C or C++, Perl's lexical variables don't necessarily get recycled just because their scope has exited. If something more permanent is still aware of the lexical, it will stick around.So long as something else references a lexical, that lexical won't be freed--which is as it should be.You wouldn't want memory being free until you were done using it, or kept around once you were done.Automatic garbage collection takes care of this for you.

=CN Unlike(？) 地方的，当地的 变量 在，内，穿戴 C 或者，即，否则 C++, Perl(？)'s，（缩）轮船 词汇 变量 不要't 必然，当然 获得，记住，到达 recycled(？) 只，刚才 因为，由于 他们的，它们的 范围 已经 exited(？). If(？) 某事，某物 更多的更，更 永久性的，持久的 是 静止的，仍旧 知道的，意识到的 的(表示领属等) （定冠词）那，这 词汇, 它 aux，将，愿，意志 枝，杆，手杖，扎 在周围，大约.So(？) 长的，长久 一样，作为 某事，某物 别的，否则 参考 a 词汇, 那那个，那么 词汇 赢得't 是，存在 freed(？)--哪个，那个 是 一样，作为 它 应该，会 是，存在.You(？) 就't 想要，通辑，缺乏 记忆（力），回忆 生物，存在 自由的，空闲的 ，到，为止 你，你们 是 做 使用 它, 或者，即，否则 保持 在周围，大约 一度，一次 你，你们 是 做.Automatic(？) 垃圾 收集，收藏 需要 注意，小心，关心 的(表示领属等) 这，这个 给，作，用的 你，你们.

=EN This means that you can pass back or save away references to lexical variables, whereas to return a pointer to a C auto is a grave error. It also gives us a way to simulate C's function statics.Here's a mechanism for giving a function private variables with both lexical scoping and a static lifetime.If you do want to create something like C's static variables, just enclose the whole function in an extra block,  and put the static variable outside the function but in the block.

=CN This(？) 手段，财力 那那个，那么 你，你们 aux，能，会，可以 经过，传给，关口 背，背后的 或者，即，否则 救，拯救，储蓄 去，远离，在远处 参考 向，到 词汇 变量, 而，却 向，到 回归，归还，归来 a pointer(？) 向，到 a C auto(？) 是 a 严肃的，庄重的 错误，过失. It(？) 也 给 我们(宾格) a 方法，路，方向 向，到 假装，佯伪 C's，（缩）轮船 作用，集会，函数 statics(？).Here(？)'s，（缩）轮船 a 机制，机械装置 给，作，用的 给 a 作用，集会，函数 私人的，秘密的 变量 同，一起，用 双方，两 词汇 范围界定 和，与，而 a 静止的，静态的 一生.If(？) 你，你们 做，干，足够，制作 想要，通辑，缺乏 向，到 创造，创作，造成 某事，某物 喜欢，像 C's，（缩）轮船 静止的，静态的 变量, 只，刚才 围住，圈起，封入 （定冠词）那，这 全部的，全部 作用，集会，函数 在，内，穿戴 一个 额外的，外加的 大块，街区，障碍物,  和，与，而 放置，估价，表达 （定冠词）那，这 静止的，静态的 可变的，变量 外部，在外面 （定冠词）那，这 作用，集会，函数 但是，除了 在，内，穿戴 （定冠词）那，这 大块，街区，障碍物.

=EN     # $secret_val now becomes unreachable by the outside

=CN     # $secret_val 现在，既然 成为 unreachable(？) 在，旁边，按照 （定冠词）那，这 外部，在外面

=EN     # world, but retains its value between calls to gimme_another

=CN     # 世界，界，世间, 但是，除了 retains(？) 它的 价值，评价，估价 在两者之间 电话 向，到 gimme_another

=EN If this function is being sourced in from a separate file via C<require> or C<use>, then this is probably just fine.If it's all in the main program, you'll need to arrange for the C<my> to be executed early, either by putting the whole block above your main program, or more likely, placing merely a C<BEGIN> code block around it to make sure it gets executed before your program starts to run:

=CN If(？) 这，这个 作用，集会，函数 是 生物，存在 sourced(？) 在，内，穿戴 自，从，来 a 分离，分隔，分手 档案，纵列，锉刀 经由，取道 C<require> 或者，即，否则 C<use>, 当时，然后，那么 这，这个 是 或许，大概 只，刚才 好的，精细的.If(？) 它's，（缩）轮船 所有的，一切 在，内，穿戴 （定冠词）那，这 主要的 节目，规划，项目, 你，你们'我 需要，贫困，需要 向，到 整理，安排 给，作，用的 （定冠词）那，这 C<my> 向，到 是，存在 执行 早的，初期的, 二者之一，也 在，旁边，按照 把 （定冠词）那，这 全部的，全部 大块，街区，障碍物 在，之上，高于 你的，你们的 主要的 节目，规划，项目, 或者，即，否则 更多的更，更 可信的，很可能, placing(？) 仅仅，只 a C<BEGIN> 法规，代码，密码 大块，街区，障碍物 在周围，大约 它 向，到 做，制造，种类 有把握的，一定的 它 得到 执行 在，前面 你的，你们的 节目，规划，项目 starts(？) 向，到 跑，竞选，行驶:

=EN See L<perlmod/"BEGIN, UNITCHECK, CHECK, INIT and END"> about the special triggered code blocks, C<BEGIN>, C<UNITCHECK>, C<CHECK>,  C<INIT> and C<END>.

=CN See(？) L<perlmod/"BEGIN, UNITCHECK, CHECK, INIT and END"> 关于，大约 （定冠词）那，这 特别的，专门的 触发 法规，代码，密码 块, C<BEGIN>, C<UNITCHECK>, C<CHECK>,  C<INIT> 和，与，而 C<END>.

=EN If declared at the outermost scope (the file scope), then lexicals work somewhat like C's file statics.They are available to all functions in that same file declared below them, but are inaccessible from outside that file.This strategy is sometimes used in modules to create private variables that the whole module can see.

=CN If(？) 宣布 在，处于，以 （定冠词）那，这 最外的 范围 (（定冠词）那，这 档案，纵列，锉刀 范围), 当时，然后，那么 lexicals(？) 劳动，工作，作品 稍微，有点 喜欢，像 C's，（缩）轮船 档案，纵列，锉刀 statics(？).They(？) 是 可得到的 向，到 所有的，一切 功能 在，内，穿戴 那那个，那么 同样的 档案，纵列，锉刀 宣布 在，下面 他（她）们，它们, 但是，除了 是 很难得到的 自，从，来 外部，在外面 那那个，那么 档案，纵列，锉刀.This(？) 战略，策略，计谋 是 有时，不时 使用 在，内，穿戴 模块 向，到 创造，创作，造成 私人的，秘密的 变量 那那个，那么 （定冠词）那，这 全部的，全部 模量，模件 aux，能，会，可以 看见，明白，查看.

=EN =head2 Temporary Values via local() X<local> X<scope, dynamic> X<dynamic scope> X<variable, local> X<variable, temporary>

=CN =head2 Temporary(？) Values(？) 经由，取道 地方的，当地的() X<local> X<scope, dynamic> X<dynamic scope> X<variable, local> X<variable, temporary>

=EN B<WARNING>: In general, you should be using C<my> instead of C<local>, because it's faster and safer.Exceptions to this include the global punctuation variables, global filehandles and formats, and direct manipulation of the Perl symbol table itself.C<local> is mostly used when the current value of a variable must be visible to called subroutines.

=CN B<WARNING>: In(？) 一般的，总的, 你，你们 应该，会 是，存在 使用 C<my> 代替，而是 的(表示领属等) C<local>, 因为，由于 它's，（缩）轮船 faster(？) 和，与，而 safer(？).Exceptions(？) 向，到 这，这个 包括 （定冠词）那，这 全世界的，总的 准时 变量, 全世界的，总的 filehandles(？) 和，与，而 formats(？), 和，与，而 支配，指挥，对准 操纵，操作 的(表示领属等) （定冠词）那，这 Perl(？) 象征，符号 桌子，表格 它自己.C<local> 是 主要地，大多 使用 何时 （定冠词）那，这 现令的，流 价值，评价，估价 的(表示领属等) a 可变的，变量 必须，准是，必须 是，存在 看得见的 向，到 称为 子程序.

=EN Synopsis:

=CN Synopsis(？):

=EN     # localization of values

=CN     # localization(？) 的(表示领属等) 价值观

=EN     local $foo;            # make $foo dynamically local

=CN     local $foo;            # 做，制造，种类 $师父 动态 地方的，当地的

=EN     local (@wid, %get);        # make list of variables local

=CN     local (@wid, %get);        # 做，制造，种类 表，名单，列表 的(表示领属等) 变量 地方的，当地的

=EN     local $foo = "flurp";    # make $foo dynamic, and init it

=CN     local $foo = "flurp";    # 做，制造，种类 $师父 动力的，动态的, 和，与，而 初始 它

=EN     local @oof = @bar;        # make @oof dynamic, and init it

=CN     local @oof = @bar;        # 做，制造，种类 @oof(？) 动力的，动态的, 和，与，而 初始 它

=EN     local $hash{key} = "val";    # sets a local value for this hash entry

=CN     local $hash{key} = "val";    # 集 a 地方的，当地的 价值，评价，估价 给，作，用的 这，这个 哈希 进入，入口，词条

=EN     delete local $hash{key};    # delete this entry for the current block

=CN     delete local $hash{key};    # 删除 这，这个 进入，入口，词条 给，作，用的 （定冠词）那，这 现令的，流 大块，街区，障碍物

=EN     local ($cond ? $v1 : $v2);    # several types of lvalues support

=CN     local ($cond ? $v1 : $v2);    # 几个 类型 的(表示领属等) lvalues(？) 支持，资助，支援

=EN                 # localization

=CN                 # localization(？)

=EN     # localization of symbols

=CN     # localization(？) 的(表示领属等) symbols(？)

=EN     local *FH;            # localize $FH, @FH, %FH, &FH...

=CN     local *FH;            # localize(？) $FH(？), @FH(？), %FH(？), &FH(？)...

=EN     local *merlyn = *randal;    # now $merlyn is really $randal, plus

=CN     local *merlyn = *randal;    # 现在，既然 $merlyn(？) 是 真正地，果然 $randal(？), 加，加号，正号

=EN                                 #     @merlyn is really @randal, etc

=CN                                 #     @merlyn(？) 是 真正地，果然 @randal(？), (缩)等等

=EN     local *merlyn = 'randal';    # SAME THING: promote 'randal' to *randal

=CN     local *merlyn = 'randal';    # SAME(？) THING(？): 提升，促进，宣传 'randal(？)' 向，到 *randal(？)

=EN     local *merlyn = \$randal;   # just alias $merlyn, not @merlyn etc

=CN     local *merlyn = \$randal;   # 只，刚才 别名 $merlyn(？), 不 @merlyn(？) (缩)等等

=EN A C<local> modifies its listed variables to be "local" to the enclosing block, C<eval>, or C<do FILE>--and to I<any subroutine called from within that block>.A C<local> just gives temporary values to global (meaning package) variables.It does I<not> create a local variable.This is known as dynamic scoping.Lexical scoping is done with C<my>, which works more like C's auto declarations.

=CN A C<local> modifies(？) 它的 上市 变量 向，到 是，存在 "地方的，当地的" 向，到 （定冠词）那，这 enclosing(？) 大块，街区，障碍物, C<eval>, 或者，即，否则 C<do FILE>--和，与，而 向，到 I<any subroutine called from within that block>.A C<local> 只，刚才 给 暂时的，临时的 价值观 向，到 全世界的，总的 (意义，意图 包裹，打包) 变量.It(？) 做 I<not> 创造，创作，造成 a 地方的，当地的 可变的，变量.This(？) 是 已知 一样，作为 动力的，动态的 范围界定.Lexical(？) 范围界定 是 做 同，一起，用 C<my>, 哪个，那个 工厂 更多的更，更 喜欢，像 C's，（缩）轮船 auto(？) 声明.

=EN Some types of lvalues can be localized as well : hash and array elements and slices, conditionals (provided that their result is always localizable), and symbolic references.As for simple variables, this creates new, dynamically scoped values.

=CN Some(？) 类型 的(表示领属等) lvalues(？) aux，能，会，可以 是，存在 localized(？) 一样，作为 井，好，充分 : 哈希 和，与，而 装扮，排列 元素 和，与，而 片, conditionals(？) (只要 那那个，那么 他们的，它们的 结果，效果，后果 是 总是，始终 localizable(？)), 和，与，而 象征 参考.As(？) 给，作，用的 简单的，朴素的 变量, 这，这个 创造 新的，重新的, 动态 选中 价值观.

=EN If more than one variable or expression is given to C<local>, they must be placed in parentheses.This operator works by saving the current values of those variables in its argument list on a hidden stack and restoring them upon exiting the block, subroutine, or eval.This means that called subroutines can also reference the local variable, but not the global one.The argument list may be assigned to if desired, which allows you to initialize your local variables.(If no initializer is given for a particular variable, it is created with an undefined value.)

=CN If(？) 更多的更，更 比，除，外 一个 可变的，变量 或者，即，否则 表达，措辞，表情 是 给出 向，到 C<local>, 他（她）们，它们 必须，准是，必须 是，存在 placed(？) 在，内，穿戴 括号.This(？) 操作人员，接线员 工厂 在，旁边，按照 saving(？) （定冠词）那，这 现令的，流 价值观 的(表示领属等) 那些 变量 在，内，穿戴 它的 争论，论点 表，名单，列表 在，上，关于 a 隐藏 推放，垛 和，与，而 restoring(？) 他（她）们，它们 在，之上 exiting(？) （定冠词）那，这 大块，街区，障碍物, 子程序, 或者，即，否则 eval(？).This(？) 手段，财力 那那个，那么 称为 子程序 aux，能，会，可以 也 参考（书），推荐书 （定冠词）那，这 地方的，当地的 可变的，变量, 但是，除了 不 （定冠词）那，这 全世界的，总的 一个.The(？) 争论，论点 表，名单，列表 可以，也许，祝愿 是，存在 assigned(？) 向，到 如果，虽然，是否 desired(？), 哪个，那个 允许 你，你们 向，到 初始化 你的，你们的 地方的，当地的 变量.(If(？) 不毫不，没有 初始化器 是 给出 给，作，用的 a 特殊的，项目 可变的，变量, 它 是 创造 同，一起，用 一个 未定义的 价值，评价，估价.)

=EN Because C<local> is a run-time operator, it gets executed each time through a loop.Consequently, it's more efficient to localize your variables outside the loop.

=CN Because(？) C<local> 是 a 跑，竞选，行驶-时间，时候，次数 操作人员，接线员, 它 得到 执行 名，每个 时间，时候，次数 通过，借助 a 环，回路，环绕.Consequently(？), 它's，（缩）轮船 更多的更，更 效率高的 向，到 localize(？) 你的，你们的 变量 外部，在外面 （定冠词）那，这 环，回路，环绕.

=EN =head3 Grammatical note on local() X<local, context>

=CN =head3 Grammatical(？) 笔记，注释，便条 在，上，关于 地方的，当地的() X<local, context>

=EN A C<local> is simply a modifier on an lvalue expression.When you assign to a C<local>ized variable, the C<local> doesn't change whether its list is viewed as a scalar or an array.So

=CN A C<local> 是 简单地，仅 a 改性剂 在，上，关于 一个 左值 表达，措辞，表情.When(？) 你，你们 分配，指定 向，到 a C<local>ized 可变的，变量, （定冠词）那，这 C<local> 没有't 变化，零钱，改变 是否，还是， 它的 表，名单，列表 是 viewed(？) 一样，作为 a 标量 或者，即，否则 一个 装扮，排列.So(？)

=EN both supply a list context to the right-hand side, while

=CN 双方，两 供应，供给 a 表，名单，列表 上下文，语境，环境 向，到 （定冠词）那，这 正确的，右的-手，人手，指针 边，面，侧面，一方, 一会儿，当，时

=EN supplies a scalar context.

=CN 供应 a 标量 上下文，语境，环境.

=EN =head3 Localization of special variables X<local, special variable>

=CN =head3 Localization(？) 的(表示领属等) 特别的，专门的 变量 X<local, special variable>

=EN If you localize a special variable, you'll be giving a new value to it,  but its magic won't go away.That means that all side-effects related to this magic still work with the localized value.

=CN If(？) 你，你们 localize(？) a 特别的，专门的 可变的，变量, 你，你们'我 是，存在 给 a 新的，重新的 价值，评价，估价 向，到 它,  但是，除了 它的 魔法，魔术，魅力 赢得't 去，进行，打算 去，远离，在远处.That(？) 手段，财力 那那个，那么 所有的，一切 边，面，侧面，一方-效果 与，有关的 向，到 这，这个 魔法，魔术，魅力 静止的，仍旧 劳动，工作，作品 同，一起，用 （定冠词）那，这 localized(？) 价值，评价，估价.

=EN This feature allows code like this to work :

=CN This(？) 相貌，特征，特写 允许 法规，代码，密码 喜欢，像 这，这个 向，到 劳动，工作，作品 :

=EN     # Read the whole contents of FILE in $slurp

=CN     # Read(？) （定冠词）那，这 全部的，全部 内容 的(表示领属等) FILE(？) 在，内，穿戴 $slurp(？)

=EN Note, however, that this restricts localization of some values ; for example, the following statement dies, as of perl 5.9.0, with an error I<Modification of a read-only value attempted>, because the $1 variable is magical and read-only :

=CN Note(？), 可是，然而, 那那个，那么 这，这个 制约 localization(？) 的(表示领属等) 若干，某一 价值观 ; 给，作，用的 例子，榜样, （定冠词）那，这 下列的，其次的 声明，陈述 dies(？), 一样，作为 的(表示领属等) C<perl(？)> 5.9.0, 同，一起，用 一个 错误，过失 I<Modification of a read-only value attempted>, 因为，由于 （定冠词）那，这 $1 可变的，变量 是 魔法 和，与，而 读-唯一的，仅仅 :

=EN One exception is the default scalar variable: starting with perl 5.14 C<local($_)> will always strip all magic from $_, to make it possible to safely reuse $_ in a subroutine.

=CN One(？) 除外，例外 是 （定冠词）那，这 不履行，不负责 标量 可变的，变量: 出发，开始 同，一起，用 C<perl(？)> 5.14 C<local($_)> aux，将，愿，意志 总是，始终 剥，窄条 所有的，一切 魔法，魔术，魅力 自，从，来 $_, 向，到 做，制造，种类 它 可能的 向，到 安全地，平安地 重用 $_ 在，内，穿戴 a 子程序.

=EN B<WARNING>: Localization of tied arrays and hashes does not currently work as described. This will be fixed in a future release of Perl; in the meantime, avoid code that relies on any particular behaviour of localising tied arrays or hashes (localising individual elements is still okay). See L<perl58delta/"Localising Tied Arrays and Hashes Is Broken"> for more details. X<local, tie>

=CN B<WARNING>: Localization(？) 的(表示领属等) 绑 阵列 和，与，而 破解 做 不 当前，广泛地 劳动，工作，作品 一样，作为 描述. This(？) aux，将，愿，意志 是，存在 固定的，已确定的 在，内，穿戴 a 将来，前途 释放，透露，发行 的(表示领属等) Perl(？); 在，内，穿戴 （定冠词）那，这 同时，在这期间, 避免，逃避 法规，代码，密码 那那个，那么 relies(？) 在，上，关于 任何，一些 特殊的，项目 behaviour(？) 的(表示领属等) localising(？) 绑 阵列 或者，即，否则 破解 (localising(？) 个人的，各自的 元素 是 静止的，仍旧 好吧). See(？) L<perl58delta/"Localising Tied Arrays and Hashes Is Broken"> 给，作，用的 更多的更，更 细节. X<local, tie>

=EN =head3 Localization of globs X<local, glob> X<glob>

=CN =head3 Localization(？) 的(表示领属等) globs(？) X<local, glob> X<glob>

=EN The construct

=CN The(？) 建设，建立

=EN creates a whole new symbol table entry for the glob C<name> in the current package.That means that all variables in its glob slot ($name,  @name, %name, &name, and the C<name> filehandle) are dynamically reset.

=CN 创造 a 全部的，全部 新的，重新的 象征，符号 桌子，表格 进入，入口，词条 给，作，用的 （定冠词）那，这 glob(？) C<name> 在，内，穿戴 （定冠词）那，这 现令的，流 包裹，打包.That(？) 手段，财力 那那个，那么 所有的，一切 变量 在，内，穿戴 它的 glob(？) 槽 ($姓名，名称，命名,  @姓名，名称，命名, %姓名，名称，命名, &姓名，名称，命名, 和，与，而 （定冠词）那，这 C<name> filehandle(？)) 是 动态 reset(？).

=EN This implies, among other things, that any magic eventually carried by those variables is locally lost.In other words, saying C<local */> will not have any effect on the internal value of the input record separator.

=CN This(？) 意味着, 在，之中 其他的，别的 事情, 那那个，那么 任何，一些 魔法，魔术，魅力 最终，终于 carried(？) 在，旁边，按照 那些 变量 是 局部 失去的.In(？) 其他的，别的 的话, 说 C<local */> aux，将，愿，意志 不 有，不得不，拿 任何，一些 后果，效力，导致 在，上，关于 （定冠词）那，这 内部的，国内的 价值，评价，估价 的(表示领属等) （定冠词）那，这 输入，投入 记录，录音，记录 分离器.

=EN =head3 Localization of elements of composite types X<local, composite type element> X<local, array element> X<local, hash element>

=CN =head3 Localization(？) 的(表示领属等) 元素 的(表示领属等) 合成的，组合的 类型 X<local, composite type element> X<local, array element> X<local, hash element>

=EN It's also worth taking a moment to explain what happens when you C<local>ize a member of a composite type (i.e.an array or hash element). In this case, the element is C<local>ized I<by name>.This means that when the scope of the C<local()> ends, the saved value will be restored to the hash element whose key was named in the C<local()>, or the array element whose index was named in the C<local()>.If that element was deleted while the C<local()> was in effect (e.g.by a C<delete()> from a hash or a C<shift()> of an array), it will spring back into existence, possibly extending an array and filling in the skipped elements with C<undef>.For instance, if you say

=CN It(？)'s，（缩）轮船 也 价值，值的 以 a 时刻，瞬间 向，到 解释，说明 什么，什么的 发生 何时 你，你们 C<local>ize a 成员，会员 的(表示领属等) a 合成的，组合的 类型，典型，打字 (我.g，（缩）例如.一个 装扮，排列 或者，即，否则 哈希 成分，元素). In(？) 这，这个 事实，案例，箱子, （定冠词）那，这 成分，元素 是 C<local>ized I<by name>.This(？) 手段，财力 那那个，那么 何时 （定冠词）那，这 范围 的(表示领属等) （定冠词）那，这 C<local()> 结束, （定冠词）那，这 saved(？) 价值，评价，估价 aux，将，愿，意志 是，存在 restored(？) 向，到 （定冠词）那，这 哈希 成分，元素 谁的 钥匙，关键，答案 是 命名 在，内，穿戴 （定冠词）那，这 C<local()>, 或者，即，否则 （定冠词）那，这 装扮，排列 成分，元素 谁的 索引，标志，指数 是 命名 在，内，穿戴 （定冠词）那，这 C<local()>.If(？) 那那个，那么 成分，元素 是 deleted(？) 一会儿，当，时 （定冠词）那，这 C<local()> 是 在，内，穿戴 后果，效力，导致 (g，（缩）例如.g.在，旁边，按照 a C<delete()> 自，从，来 a 哈希 或者，即，否则 a C<shift()> 的(表示领属等) 一个 装扮，排列), 它 aux，将，愿，意志 跳跃，萌芽，春季 背，背后的 到，里面，，成 存在，生存, 可能，或许 extending(？) 一个 装扮，排列 和，与，而 充填物，馅 在，内，穿戴 （定冠词）那，这 skipped(？) 元素 同，一起，用 C<undef>.For(？) 例子, 如果，虽然，是否 你，你们 说，发言（权）

=EN Perl will print

=CN Perl(？) aux，将，愿，意志 印刷，出版，字体

=EN The behavior of local() on non-existent members of composite types is subject to change in future.

=CN The(？) 行为，举止 的(表示领属等) 地方的，当地的() 在，上，关于 非-存在 members(？) 的(表示领属等) 合成的，组合的 类型 是 题目，学科，主语 向，到 变化，零钱，改变 在，内，穿戴 将来，前途.

=EN =head3 Localized deletion of elements of composite types X<delete> X<local, composite type element> X<local, array element> X<local, hash element>

=CN =head3 Localized(？) 删除 的(表示领属等) 元素 的(表示领属等) 合成的，组合的 类型 X<delete> X<local, composite type element> X<local, array element> X<local, hash element>

=EN You can use the C<delete local $array[$idx]> and C<delete local $hash{key}> constructs to delete a composite type entry for the current block and restore it when it ends.They return the array/hash value before the localization,  which means that they are respectively equivalent to

=CN You(？) aux，能，会，可以 使用，用途，利用 （定冠词）那，这 C<delete local $array[$idx]> 和，与，而 C<delete local $hash{key}> 构建 向，到 删除 a 合成的，组合的 类型，典型，打字 进入，入口，词条 给，作，用的 （定冠词）那，这 现令的，流 大块，街区，障碍物 和，与，而 恢复，复原，归还 它 何时 它 结束.They(？) 回归，归还，归来 （定冠词）那，这 装扮，排列/哈希 价值，评价，估价 在，前面 （定冠词）那，这 localization(？),  哪个，那个 手段，财力 那那个，那么 他（她）们，它们 是 各自，分别地 相等的，等值的 向，到

=EN and

=CN 和，与，而

=EN except that for those the C<local> is scoped to the C<do> block.Slices are also accepted.

=CN 除，外，除外 那那个，那么 给，作，用的 那些 （定冠词）那，这 C<local> 是 选中 向，到 （定冠词）那，这 C<do> 大块，街区，障碍物.Slices(？) 是 也 accepted(？).

=EN      # $a is [ 7, 8, 9 ]

=CN      # $a 是 [ 7, 8, 9 ]

=EN      # %hash is (b => 1)

=CN      # %哈希 是 (b => 1)

=EN       # @nums is (7, 9)

=CN       # @nums(？) 是 (7, 9)

=EN       # $a is [ undef, 8 ]

=CN       # $a 是 [ C<undef(？)>, 8 ]

=EN       $a[0] = 999; # will be erased when the scope ends

=CN       $a[0] = 999; # aux，将，愿，意志 是，存在 erased(？) 何时 （定冠词）那，这 范围 结束

=EN      # $a is back to [ 7, 8, 9 ]

=CN      # $a 是 背，背后的 向，到 [ 7, 8, 9 ]

=EN     # %hash is back to its original state

=CN     # %哈希 是 背，背后的 向，到 它的 原始的，原物 状态，国家，州

=EN =head2 Lvalue subroutines X<lvalue> X<subroutine, lvalue>

=CN =head2 Lvalue(？) 子程序 X<lvalue> X<subroutine, lvalue>

=EN B<WARNING>: Lvalue subroutines are still experimental and the implementation may change in future versions of Perl.

=CN B<WARNING>: Lvalue(？) 子程序 是 静止的，仍旧 实验的 和，与，而 （定冠词）那，这 实行，执行 可以，也许，祝愿 变化，零钱，改变 在，内，穿戴 将来，前途 版本 的(表示领属等) Perl(？).

=EN It is possible to return a modifiable value from a subroutine. To do this, you have to declare the subroutine to return an lvalue.

=CN It(？) 是 可能的 向，到 回归，归还，归来 a modifiable(？) 价值，评价，估价 自，从，来 a 子程序. To(？) 做，干，足够，制作 这，这个, 你，你们 有，不得不，拿 向，到 宣布，声明 （定冠词）那，这 子程序 向，到 回归，归还，归来 一个 左值.

=EN     # return $val; this doesn't work, don't say "return"

=CN     # 回归，归还，归来 $val(？); 这，这个 没有't 劳动，工作，作品, 不要't 说，发言（权） "回归，归还，归来"

=EN     canmod() = 5;   # assigns to $val

=CN     canmod() = 5;   # assigns(？) 向，到 $val(？)

=EN     nomod()  = 5;   # ERROR

=CN     nomod()  = 5;   # ERROR(？)

=EN The scalar/list context for the subroutine and for the right-hand side of assignment is determined as if the subroutine call is replaced by a scalar.For example, consider:

=CN The(？) 标量/表，名单，列表 上下文，语境，环境 给，作，用的 （定冠词）那，这 子程序 和，与，而 给，作，用的 （定冠词）那，这 正确的，右的-手，人手，指针 边，面，侧面，一方 的(表示领属等) 任务，作业 是 确定 一样，作为 如果，虽然，是否 （定冠词）那，这 子程序 叫，称为，打电话 是 取代 在，旁边，按照 a 标量.For(？) 例子，榜样, 考虑，以为，体谅:

=EN Both subroutines here are called in a scalar context, while in:

=CN Both(？) 子程序 这里，在这里 是 称为 在，内，穿戴 a 标量 上下文，语境，环境, 一会儿，当，时 在，内，穿戴:

=EN and in:

=CN 和，与，而 在，内，穿戴:

=EN all the subroutines are called in a list context.

=CN 所有的，一切 （定冠词）那，这 子程序 是 称为 在，内，穿戴 a 表，名单，列表 上下文，语境，环境.

=EN =over 4

=CN =over 4

=EN =item Lvalue subroutines are EXPERIMENTAL

=CN =item Lvalue(？) 子程序 是 EXPERIMENTAL(？)

=EN They appear to be convenient, but there are several reasons to be circumspect.

=CN They(？) 出现，好象 向，到 是，存在 便利的，方便的, 但是，除了 那里，到那里 是 几个 原因 向，到 是，存在 circumspect(？).

=EN You can't use the return keyword, you must pass out the value before falling out of subroutine scope.(see comment in example above).This is usually not a problem, but it disallows an explicit return out of a deeply nested loop, which is sometimes a nice way out.

=CN You(？) aux，能，会，可以't 使用，用途，利用 （定冠词）那，这 回归，归还，归来 关键字, 你，你们 必须，准是，必须 经过，传给，关口 出外，向外，完 （定冠词）那，这 价值，评价，估价 在，前面 下降 出外，向外，完 的(表示领属等) 子程序 范围.(看见，明白，查看 评论 在，内，穿戴 例子，榜样 在，之上，高于).This(？) 是 通常，平常 不 a 课题，难题，问题, 但是，除了 它 disallows(？) 一个 清楚的，明晰的 回归，归还，归来 出外，向外，完 的(表示领属等) a 深深的，深切地 嵌套的 环，回路，环绕, 哪个，那个 是 有时，不时 a 令人愉快的 方法，路，方向 出外，向外，完.

=EN They violate encapsulation.A normal mutator can check the supplied argument before setting the attribute it is protecting, an lvalue subroutine never gets that chance.Consider;

=CN They(？) 违犯，违背 封装.A 正常的，标准的 mutator(？) aux，能，会，可以 检验，核对，支票 （定冠词）那，这 提供 争论，论点 在，前面 安置，背景，环境 （定冠词）那，这 属于，属性 它 是 protecting(？), 一个 左值 子程序 从不，永不，未曾 得到 那那个，那么 机会，可能性.Consider(？);

=EN     my $some_array_ref = [];    # protected by mutators ??

=CN     my $some_array_ref = [];    # protected(？) 在，旁边，按照 mutators(？) ??

=EN     sub set_arr {         # normal mutator

=CN     sub set_arr {         # 正常的，标准的 mutator(？)

=EN     sub set_arr_lv : lvalue {    # lvalue mutator

=CN     sub set_arr_lv : lvalue {    # 左值 mutator(？)

=EN     # set_arr_lv cannot stop this !

=CN     # set_arr_lv 不能 停止，终止，停止 这，这个 !

=EN =back

=CN =back

=EN =head2 Passing Symbol Table Entries (typeglobs) X<typeglob> X<*>

=CN =head2 Passing(？) Symbol(？) Table(？) Entries(？) (typeglobs(？)) X<typeglob> X<*>

=EN B<WARNING>: The mechanism described in this section was originally the only way to simulate pass-by-reference in older versions of Perl.While it still works fine in modern versions, the new reference mechanism is generally easier to work with.See below.

=CN B<WARNING>: The(？) 机制，机械装置 描述 在，内，穿戴 这，这个 部分，区域 是 原来，当初 （定冠词）那，这 唯一的，仅仅 方法，路，方向 向，到 假装，佯伪 经过，传给，关口-在，旁边，按照-参考（书），推荐书 在，内，穿戴 年长的 版本 的(表示领属等) Perl(？).While(？) 它 静止的，仍旧 工厂 好的，精细的 在，内，穿戴 现代的，时髦的 版本, （定冠词）那，这 新的，重新的 参考（书），推荐书 机制，机械装置 是 通常，大概 容易 向，到 劳动，工作，作品 同，一起，用.See(？) 在，下面.

=EN Sometimes you don't want to pass the value of an array to a subroutine but rather the name of it, so that the subroutine can modify the global copy of it rather than working with a local copy.In perl you can refer to all objects of a particular name by prefixing the name with a star: C<*foo>.This is often known as a "typeglob", because the star on the front can be thought of as a wildcard match for all the funny prefix characters on variables and subroutines and such.

=CN Sometimes(？) 你，你们 不要't 想要，通辑，缺乏 向，到 经过，传给，关口 （定冠词）那，这 价值，评价，估价 的(表示领属等) 一个 装扮，排列 向，到 a 子程序 但是，除了 相当，颇，宁愿 （定冠词）那，这 姓名，名称，命名 的(表示领属等) 它, 这样，也一样 那那个，那么 （定冠词）那，这 子程序 aux，能，会，可以 修改，减轻，修饰 （定冠词）那，这 全世界的，总的 抄写，复制，副本 的(表示领属等) 它 相当，颇，宁愿 比，除，外 工作 同，一起，用 a 地方的，当地的 抄写，复制，副本.In(？) C<perl(？)> 你，你们 aux，能，会，可以 查阅，提及 向，到 所有的，一切 对象 的(表示领属等) a 特殊的，项目 姓名，名称，命名 在，旁边，按照 prefixing(？) （定冠词）那，这 姓名，名称，命名 同，一起，用 a 星，主演: C<*foo>.This(？) 是 经常，常常 已知 一样，作为 a "typeglob(？)", 因为，由于 （定冠词）那，这 星，主演 在，上，关于 （定冠词）那，这 正面，前线，面对 aux，能，会，可以 是，存在 想法，思想，关怀 的(表示领属等) 一样，作为 a 通配符 火柴，对手，比赛 给，作，用的 所有的，一切 （定冠词）那，这 有趣的，好笑的 前缀 人物 在，上，关于 变量 和，与，而 子程序 和，与，而 这样的，如此的.

=EN When evaluated, the typeglob produces a scalar value that represents all the objects of that name, including any filehandle, format, or subroutine.When assigned to, it causes the name mentioned to refer to whatever C<*> value was assigned to it.Example:

=CN When(？) 评估, （定冠词）那，这 typeglob(？) 生产 a 标量 价值，评价，估价 那那个，那么 代表 所有的，一切 （定冠词）那，这 对象 的(表示领属等) 那那个，那么 姓名，名称，命名, 包括 任何，一些 filehandle(？), 格式，样式, 或者，即，否则 子程序.When(？) assigned(？) 向，到, 它 causes(？) （定冠词）那，这 姓名，名称，命名 提到 向，到 查阅，提及 向，到 无论什么 C<*> 价值，评价，估价 是 assigned(？) 向，到 它.Example(？):

=EN Scalars are already passed by reference, so you can modify scalar arguments without using this mechanism by referring explicitly to C<$_[0]> etc.You can modify all the elements of an array by passing all the elements as scalars, but you have to use the C<*> mechanism (or the equivalent reference mechanism) to C<push>, C<pop>, or change the size of an array.It will certainly be faster to pass the typeglob (or reference).

=CN Scalars(？) 是 已 通过 在，旁边，按照 参考（书），推荐书, 这样，也一样 你，你们 aux，能，会，可以 修改，减轻，修饰 标量 争论 没有，在，外部 使用 这，这个 机制，机械装置 在，旁边，按照 referring(？) 清晰地 向，到 C<$_[0]> (缩)等等.You(？) aux，能，会，可以 修改，减轻，修饰 所有的，一切 （定冠词）那，这 元素 的(表示领属等) 一个 装扮，排列 在，旁边，按照 传球 所有的，一切 （定冠词）那，这 元素 一样，作为 scalars(？), 但是，除了 你，你们 有，不得不，拿 向，到 使用，用途，利用 （定冠词）那，这 C<*> 机制，机械装置 (或者，即，否则 （定冠词）那，这 相等的，等值的 参考（书），推荐书 机制，机械装置) 向，到 C<push>, C<pop>, 或者，即，否则 变化，零钱，改变 （定冠词）那，这 大小，规模，尺寸 的(表示领属等) 一个 装扮，排列.It(？) aux，将，愿，意志 一定，当然，行 是，存在 faster(？) 向，到 经过，传给，关口 （定冠词）那，这 typeglob(？) (或者，即，否则 参考（书），推荐书).

=EN Even if you don't want to modify an array, this mechanism is useful for passing multiple arrays in a single LIST, because normally the LIST mechanism will merge all the array values so that you can't extract out the individual arrays.For more on typeglobs, see L<perldata/"Typeglobs and Filehandles">.

=CN Even(？) 如果，虽然，是否 你，你们 不要't 想要，通辑，缺乏 向，到 修改，减轻，修饰 一个 装扮，排列, 这，这个 机制，机械装置 是 有用的，有益的 给，作，用的 传球 复合的，多次方的 阵列 在，内，穿戴 a 单个的，单身的 LIST(？), 因为，由于 正常地，通常 （定冠词）那，这 LIST(？) 机制，机械装置 aux，将，愿，意志 合并 所有的，一切 （定冠词）那，这 装扮，排列 价值观 这样，也一样 那那个，那么 你，你们 aux，能，会，可以't 取出，榨出，摘录 出外，向外，完 （定冠词）那，这 个人的，各自的 阵列.For(？) 更多的更，更 在，上，关于 typeglobs(？), 看见，明白，查看 L<perldata/"Typeglobs and Filehandles">.

=EN =head2 When to Still Use local() X<local> X<variable, local>

=CN =head2 When(？) 向，到 Still(？) Use(？) 地方的，当地的() X<local> X<variable, local>

=EN Despite the existence of C<my>, there are still three places where the C<local> operator still shines.In fact, in these three places, you I<must> use C<local> instead of C<my>.

=CN Despite(？) （定冠词）那，这 存在，生存 的(表示领属等) C<my>, 那里，到那里 是 静止的，仍旧 三 地方 哪里 （定冠词）那，这 C<local> 操作人员，接线员 静止的，仍旧 shines(？).In(？) 事实，真相, 在，内，穿戴 这些 三 地方, 你，你们 I<must> 使用，用途，利用 C<local> 代替，而是 的(表示领属等) C<my>.

=EN =over 4

=CN =over 4

=EN =item 1.

=CN =item 1.

=EN You need to give a global variable a temporary value, especially $_.

=CN You(？) 需要，贫困，需要 向，到 给 a 全世界的，总的 可变的，变量 a 暂时的，临时的 价值，评价，估价, 特别地，专门地 $_.

=EN The global variables, like C<@ARGV> or the punctuation variables, must be C<local>ized with C<local()>.This block reads in F</etc/motd>, and splits it up into chunks separated by lines of equal signs, which are placed in C<@Fields>.

=CN The(？) 全世界的，总的 变量, 喜欢，像 C<@ARGV> 或者，即，否则 （定冠词）那，这 准时 变量, 必须，准是，必须 是，存在 C<local>ized 同，一起，用 C<local()>.This(？) 大块，街区，障碍物 读 在，内，穿戴 F</etc/motd>, 和，与，而 splits(？) 它 向上，起床 到，里面，，成 chunks(？) separated(？) 在，旁边，按照 lines(？) 的(表示领属等) 相等的，胜任的 迹象, 哪个，那个 是 placed(？) 在，内，穿戴 C<@Fields>.

=EN It particular, it's important to C<local>ize $_ in any routine that assigns to it.Look out for implicit assignments in C<while> conditionals.

=CN It(？) 特殊的，项目, 它's，（缩）轮船 重要的，重大的 向，到 C<local>ize $_ 在，内，穿戴 任何，一些 日常事务 那那个，那么 assigns(？) 向，到 它.Look(？) 出外，向外，完 给，作，用的 隐式 assignments(？) 在，内，穿戴 C<while> conditionals(？).

=EN =item 2.

=CN =item 2.

=EN You need to create a local file or directory handle or a local function.

=CN You(？) 需要，贫困，需要 向，到 创造，创作，造成 a 地方的，当地的 档案，纵列，锉刀 或者，即，否则 目录，地址录 处理，对待，把 或者，即，否则 a 地方的，当地的 作用，集会，函数.

=EN A function that needs a filehandle of its own must use C<local()> on a complete typeglob.This can be used to create new symbol table entries:

=CN A 作用，集会，函数 那那个，那么 需要 a filehandle(？) 的(表示领属等) 它的 自己的，拥有 必须，准是，必须 使用，用途，利用 C<local()> 在，上，关于 a 完成，结束 typeglob(？).This(？) aux，能，会，可以 是，存在 使用 向，到 创造，创作，造成 新的，重新的 象征，符号 桌子，表格 entries(？):

=EN         local  (*READER, *WRITER);    # not my!

=CN         local  (*READER, *WRITER);    # 不 我的!

=EN See the Symbol module for a way to create anonymous symbol table entries.

=CN See(？) （定冠词）那，这 Symbol(？) 模量，模件 给，作，用的 a 方法，路，方向 向，到 创造，创作，造成 匿名 象征，符号 桌子，表格 entries(？).

=EN Because assignment of a reference to a typeglob creates an alias, this can be used to create what is effectively a local function, or at least,  a local alias.

=CN Because(？) 任务，作业 的(表示领属等) a 参考（书），推荐书 向，到 a typeglob(？) 创造 一个 别名, 这，这个 aux，能，会，可以 是，存在 使用 向，到 创造，创作，造成 什么，什么的 是 有效地 a 地方的，当地的 作用，集会，函数, 或者，即，否则 在，处于，以 最少的,  a 地方的，当地的 别名.

=EN         local *grow = \&shrink; # only until this block exists

=CN         local *grow = \&shrink; # 唯一的，仅仅 ，到，为止 这，这个 大块，街区，障碍物 存在

=EN         grow();                 # really calls shrink()

=CN         grow();                 # 真正地，果然 电话 收缩，畏缩()

=EN     move();            # if move() grow()s, it shrink()s too

=CN     move();            # 如果，虽然，是否 移动，推动，搬家() 增长，成长，种植()s，（缩）轮船, 它 收缩，畏缩()s，（缩）轮船 也，非常

=EN     grow();            # get the real grow() again

=CN     grow();            # 获得，记住，到达 （定冠词）那，这 真的，纯粹的 增长，成长，种植() 再，又

=EN See L<perlref/"Function Templates"> for more about manipulating functions by name in this way.

=CN See(？) L<perlref/"Function Templates"> 给，作，用的 更多的更，更 关于，大约 manipulating(？) 功能 在，旁边，按照 姓名，名称，命名 在，内，穿戴 这，这个 方法，路，方向.

=EN =item 3.

=CN =item 3.

=EN You want to temporarily change just one element of an array or hash.

=CN You(？) 想要，通辑，缺乏 向，到 temporarily(？) 变化，零钱，改变 只，刚才 一个 成分，元素 的(表示领属等) 一个 装扮，排列 或者，即，否则 哈希.

=EN You can C<local>ize just one element of an aggregate.Usually this is done on dynamics:

=CN You(？) aux，能，会，可以 C<local>ize 只，刚才 一个 成分，元素 的(表示领属等) 一个 合计(的).Usually(？) 这，这个 是 做 在，上，关于 dynamics(？):

=EN     funct();                # uninterruptible

=CN     funct();                # uninterruptible(？)

=EN     # interruptibility automatically restored here

=CN     # interruptibility(？) automatically(？) restored(？) 这里，在这里

=EN But it also works on lexically declared aggregates.Prior to 5.005,  this operation could on occasion misbehave.

=CN But(？) 它 也 工厂 在，上，关于 词法 宣布 aggregates(？).Prior(？) 向，到 5.005,  这，这个 操作，生效，手术 能 在，上，关于 场合，盛事，机会 misbehave(？).

=EN =back

=CN =back

=EN =head2 Pass by Reference X<pass by reference> X<pass-by-reference> X<reference>

=CN =head2 Pass(？) 在，旁边，按照 Reference(？) X<pass by reference> X<pass-by-reference> X<reference>

=EN If you want to pass more than one array or hash into a function--or return them from it--and have them maintain their integrity, then you're going to have to use an explicit pass-by-reference.Before you do that, you need to understand references as detailed in L<perlref>. This section may not make much sense to you otherwise.

=CN If(？) 你，你们 想要，通辑，缺乏 向，到 经过，传给，关口 更多的更，更 比，除，外 一个 装扮，排列 或者，即，否则 哈希 到，里面，，成 a 作用，集会，函数--或者，即，否则 回归，归还，归来 他（她）们，它们 自，从，来 它--和，与，而 有，不得不，拿 他（她）们，它们 维持，保养，坚持 他们的，它们的 完整性，诚实, 当时，然后，那么 你，你们'读，阅读，朗诵 去 向，到 有，不得不，拿 向，到 使用，用途，利用 一个 清楚的，明晰的 经过，传给，关口-在，旁边，按照-参考（书），推荐书.Before(？) 你，你们 做，干，足够，制作 那那个，那么, 你，你们 需要，贫困，需要 向，到 了解，懂，熟悉 参考 一样，作为 详细的，详尽的 在，内，穿戴 L<perlref>. This(？) 部分，区域 可以，也许，祝愿 不 做，制造，种类 许多的，许多 感官，感觉，见识 向，到 你，你们 另外的，否则.

=EN Here are a few simple examples.First, let's pass in several arrays to a function and have it C<pop> all of then, returning a new list of all their former last elements:

=CN Here(？) 是 a 少的，少数 简单的，朴素的 实例.First(？), 让，使's，（缩）轮船 经过，传给，关口 在，内，穿戴 几个 阵列 向，到 a 作用，集会，函数 和，与，而 有，不得不，拿 它 C<pop> 所有的，一切 的(表示领属等) 当时，然后，那么, 返回 a 新的，重新的 表，名单，列表 的(表示领属等) 所有的，一切 他们的，它们的 以前的，前者 最后的，上次 元素:

=EN Here's how you might write a function that returns a list of keys occurring in all the hashes passed to it:

=CN Here(？)'s，（缩）轮船 如何，多么，怎样 你，你们 或许，可以，力 写，写信，写作 a 作用，集会，函数 那那个，那么 返回 a 表，名单，列表 的(表示领属等) 钥匙 occurring(？) 在，内，穿戴 所有的，一切 （定冠词）那，这 破解 通过 向，到 它:

=EN     my ($k, $href, %seen); # locals

=CN     my ($k, $href, %seen); # locals(？)

=EN So far, we're using just the normal list return mechanism. What happens if you want to pass or return a hash?  Well,  if you're using only one of them, or you don't mind them concatenating, then the normal calling convention is ok, although a little expensive.

=CN So(？) 遥远的，远, 我们'读，阅读，朗诵 使用 只，刚才 （定冠词）那，这 正常的，标准的 表，名单，列表 回归，归还，归来 机制，机械装置. What(？) 发生 如果，虽然，是否 你，你们 想要，通辑，缺乏 向，到 经过，传给，关口 或者，即，否则 回归，归还，归来 a 哈希?  Well(？),  如果，虽然，是否 你，你们'读，阅读，朗诵 使用 唯一的，仅仅 一个 的(表示领属等) 他（她）们，它们, 或者，即，否则 你，你们 不要't 头脑，智力，介意 他（她）们，它们 concatenating(？), 当时，然后，那么 （定冠词）那，这 正常的，标准的 打电话 大会，协定，惯例 是 ok(？), 虽然 a 小的，一点，少的 昂贵的，高价的.

=EN Where people get into trouble is here:

=CN Where(？) 人们，人民，人员 获得，记住，到达 到，里面，，成 麻烦 是 这里，在这里:

=EN That syntax simply won't work.It sets just C<@a> or C<%a> and clears the C<@b> or C<%b>.Plus the function didn't get passed into two separate arrays or hashes: it got one long list in C<@_>,  as always.

=CN That(？) 语法 简单地，仅 赢得't 劳动，工作，作品.It(？) 集 只，刚才 C<@a> 或者，即，否则 C<%a> 和，与，而 clears(？) （定冠词）那，这 C<@b> 或者，即，否则 C<%b>.Plus(？) （定冠词）那，这 作用，集会，函数 没有't 获得，记住，到达 通过 到，里面，，成 两 分离，分隔，分手 阵列 或者，即，否则 破解: 它 得到 一个 长的，长久 表，名单，列表 在，内，穿戴 C<@_>,  一样，作为 总是，始终.

=EN If you can arrange for everyone to deal with this through references, it's cleaner code, although not so nice to look at.Here's a function that takes two array references as arguments, returning the two array elements in order of how many elements they have in them:

=CN If(？) 你，你们 aux，能，会，可以 整理，安排 给，作，用的 人人，每人 向，到 处理，交易，买卖 同，一起，用 这，这个 通过，借助 参考, 它's，（缩）轮船 cleaner(？) 法规，代码，密码, 虽然 不 这样，也一样 令人愉快的 向，到 看，看上去，外表 在，处于，以.Here(？)'s，（缩）轮船 a 作用，集会，函数 那那个，那么 需要 两 装扮，排列 参考 一样，作为 争论, 返回 （定冠词）那，这 两 装扮，排列 元素 在，内，穿戴 命令，订货，次序 的(表示领属等) 如何，多么，怎样 许多的，许多 元素 他（她）们，它们 有，不得不，拿 在，内，穿戴 他（她）们，它们:

=EN It turns out that you can actually do this also:

=CN It(？) 转 出外，向外，完 那那个，那么 你，你们 aux，能，会，可以 实际上，居然 做，干，足够，制作 这，这个 也:

=EN Here we're using the typeglobs to do symbol table aliasing.It's a tad subtle, though, and also won't work if you're using C<my> variables, because only globals (even in disguise as C<local>s) are in the symbol table.

=CN Here(？) 我们'读，阅读，朗诵 使用 （定冠词）那，这 typeglobs(？) 向，到 做，干，足够，制作 象征，符号 桌子，表格 走样.It(？)'s，（缩）轮船 a tad(？) 敏锐的，微妙的, 虽然，可是, 和，与，而 也 赢得't 劳动，工作，作品 如果，虽然，是否 你，你们'读，阅读，朗诵 使用 C<my> 变量, 因为，由于 唯一的，仅仅 globals(？) (平坦的，均匀的 在，内，穿戴 伪装，掩饰 一样，作为 C<local>s) 是 在，内，穿戴 （定冠词）那，这 象征，符号 桌子，表格.

=EN If you're passing around filehandles, you could usually just use the bare typeglob, like C<*STDOUT>, but typeglobs references work, too. For example:

=CN If(？) 你，你们'读，阅读，朗诵 传球 在周围，大约 filehandles(？), 你，你们 能 通常，平常 只，刚才 使用，用途，利用 （定冠词）那，这 裸的，直率的 typeglob(？), 喜欢，像 C<*STDOUT>, 但是，除了 typeglobs(？) 参考 劳动，工作，作品, 也，非常. For(？) 例子，榜样:

=EN If you're planning on generating new filehandles, you could do this. Notice to pass back just the bare *FH, not its reference.

=CN If(？) 你，你们'读，阅读，朗诵 planning(？) 在，上，关于 生成 新的，重新的 filehandles(？), 你，你们 能 做，干，足够，制作 这，这个. Notice(？) 向，到 经过，传给，关口 背，背后的 只，刚才 （定冠词）那，这 裸的，直率的 *FH(？), 不 它的 参考（书），推荐书.

=EN =head2 Prototypes X<prototype> X<subroutine, prototype>

=CN =head2 Prototypes(？) X<prototype> X<subroutine, prototype>

=EN Perl supports a very limited kind of compile-time argument checking using function prototyping.If you declare

=CN Perl(？) 支持 a 很，非常 有限的，限定的 种类，仁慈的 的(表示领属等) 编（书），编辑-时间，时候，次数 争论，论点 检查 使用 作用，集会，函数 prototyping(？).If(？) 你，你们 宣布，声明

=EN then C<mypush()> takes arguments exactly like C<push()> does.The function declaration must be visible at compile time.The prototype affects only interpretation of new-style calls to the function,  where new-style is defined as not using the C<&> character.In other words, if you call it like a built-in function, then it behaves like a built-in function.If you call it like an old-fashioned subroutine, then it behaves like an old-fashioned subroutine.It naturally falls out from this rule that prototypes have no influence on subroutine references like C<\&foo> or on indirect subroutine calls like C<&{$subref}> or C<< $subref->() >>.

=CN 当时，然后，那么 C<mypush()> 需要 争论 确切地，正是 喜欢，像 C<push()> 做.The(？) 作用，集会，函数 宣布，宣告 必须，准是，必须 是，存在 看得见的 在，处于，以 编（书），编辑 时间，时候，次数.The(？) 原型 affects(？) 唯一的，仅仅 解释，口译 的(表示领属等) 新的，重新的-风格，时尚，作风 电话 向，到 （定冠词）那，这 作用，集会，函数,  哪里 新的，重新的-风格，时尚，作风 是 定义 一样，作为 不 使用 （定冠词）那，这 C<&> 性格，角色，特牲.In(？) 其他的，别的 的话, 如果，虽然，是否 你，你们 叫，称为，打电话 它 喜欢，像 a 建造-在，内，穿戴 作用，集会，函数, 当时，然后，那么 它 表现 喜欢，像 a 建造-在，内，穿戴 作用，集会，函数.If(？) 你，你们 叫，称为，打电话 它 喜欢，像 一个 老的，，岁的-塑成 子程序, 当时，然后，那么 它 表现 喜欢，像 一个 老的，，岁的-塑成 子程序.It(？) 自然地 瀑布 出外，向外，完 自，从，来 这，这个 法规，常规，统治 那那个，那么 原型 有，不得不，拿 不毫不，没有 影响，势力（范围） 在，上，关于 子程序 参考 喜欢，像 C<\&foo> 或者，即，否则 在，上，关于 间接的，侧面的 子程序 电话 喜欢，像 C<&{$subref}> 或者，即，否则 C<< $subref->() >>.

=EN Method calls are not influenced by prototypes either, because the function to be called is indeterminate at compile time, since the exact code called depends on inheritance.

=CN Method(？) 电话 是 不 influenced(？) 在，旁边，按照 原型 二者之一，也, 因为，由于 （定冠词）那，这 作用，集会，函数 向，到 是，存在 称为 是 indeterminate(？) 在，处于，以 编（书），编辑 时间，时候，次数, 自从，既然 （定冠词）那，这 精确的，精密的 法规，代码，密码 称为 取决于 在，上，关于 继承.

=EN Because the intent of this feature is primarily to let you define subroutines that work like built-in functions, here are prototypes for some other functions that parse almost exactly like the corresponding built-in.

=CN Because(？) （定冠词）那，这 意图，专心的 的(表示领属等) 这，这个 相貌，特征，特写 是 首要地，主要地 向，到 让，使 你，你们 下定义，界定，规定 子程序 那那个，那么 劳动，工作，作品 喜欢，像 建造-在，内，穿戴 功能, 这里，在这里 是 原型 给，作，用的 若干，某一 其他的，别的 功能 那那个，那么 解析 几乎，差不多 确切地，正是 喜欢，像 （定冠词）那，这 相应的，通信的 建造-在，内，穿戴.

=EN Any backslashed prototype character represents an actual argument that must start with that character (optionally preceded by C<my>,  C<our> or C<local>), with the exception of C<$>, which will accept a hash or array element even without a dollar sign, such as C<< my_function()->[0] >>.The value passed as part of C<@_> will be a reference to the actual argument given in the subroutine call,  obtained by applying C<\> to that argument.

=CN Any(？) backslashed(？) 原型 性格，角色，特牲 代表 一个 现实的，实际的 争论，论点 那那个，那么 必须，准是，必须 开始，着手，发动 同，一起，用 那那个，那么 性格，角色，特牲 (选择性地 preceded(？) 在，旁边，按照 C<my>,  C<our> 或者，即，否则 C<local>), 同，一起，用 （定冠词）那，这 除外，例外 的(表示领属等) C<$>, 哪个，那个 aux，将，愿，意志 接受，同意 a 哈希 或者，即，否则 装扮，排列 成分，元素 平坦的，均匀的 没有，在，外部 a 元，美元 告示，迹象，符号, 这样的，如此的 一样，作为 C<< my_function()->[0] >>.The(？) 价值，评价，估价 通过 一样，作为 部分，零件，角色 的(表示领属等) C<@_> aux，将，愿，意志 是，存在 a 参考（书），推荐书 向，到 （定冠词）那，这 现实的，实际的 争论，论点 给出 在，内，穿戴 （定冠词）那，这 子程序 叫，称为，打电话,  obtained(？) 在，旁边，按照 应用 C<\> 向，到 那那个，那么 争论，论点.

=EN You can use the C<\[]> backslash group notation to specify more than one allowed argument type.For example:

=CN You(？) aux，能，会，可以 使用，用途，利用 （定冠词）那，这 C<\[]> backslash(？) 群，组，团体 符号 向，到 详细说明，指定 更多的更，更 比，除，外 一个 允许 争论，论点 类型，典型，打字.For(？) 例子，榜样:

=EN will allow calling myref() as

=CN aux，将，愿，意志 允许，许可 打电话 myref(？)() 一样，作为

=EN and the first argument of myref() will be a reference to a scalar, an array, a hash, a code, or a glob.

=CN 和，与，而 （定冠词）那，这 第一的，首先 争论，论点 的(表示领属等) myref(？)() aux，将，愿，意志 是，存在 a 参考（书），推荐书 向，到 a 标量, 一个 装扮，排列, a 哈希, a 法规，代码，密码, 或者，即，否则 a glob(？).

=EN Unbackslashed prototype characters have special meanings.Any unbackslashed C<@> or C<%> eats all remaining arguments, and forces list context.An argument represented by C<$> forces scalar context.An C<&> requires an anonymous subroutine, which, if passed as the first argument, does not require the C<sub> keyword or a subsequent comma.

=CN Unbackslashed(？) 原型 人物 有，不得不，拿 特别的，专门的 意义.Any(？) unbackslashed(？) C<@> 或者，即，否则 C<%> eats(？) 所有的，一切 remaining(？) 争论, 和，与，而 部队 表，名单，列表 上下文，语境，环境.An(？) 争论，论点 代表 在，旁边，按照 C<$> 部队 标量 上下文，语境，环境.An(？) C<&> 需要 一个 匿名 子程序, 哪个，那个, 如果，虽然，是否 通过 一样，作为 （定冠词）那，这 第一的，首先 争论，论点, 做 不 需要，请求 （定冠词）那，这 C<sub> 关键字 或者，即，否则 a 以后的，后起的 逗号.

=EN A C<*> allows the subroutine to accept a bareword, constant, scalar expression,  typeglob, or a reference to a typeglob in that slot.The value will be available to the subroutine either as a simple scalar, or (in the latter two cases) as a reference to the typeglob.If you wish to always convert such arguments to a typeglob reference, use Symbol::qualify_to_ref() as follows:

=CN A C<*> 允许 （定冠词）那，这 子程序 向，到 接受，同意 a bareword(？), 不变的，恒定的, 标量 表达，措辞，表情,  typeglob(？), 或者，即，否则 a 参考（书），推荐书 向，到 a typeglob(？) 在，内，穿戴 那那个，那么 槽.The(？) 价值，评价，估价 aux，将，愿，意志 是，存在 可得到的 向，到 （定冠词）那，这 子程序 二者之一，也 一样，作为 a 简单的，朴素的 标量, 或者，即，否则 (在，内，穿戴 （定冠词）那，这 后面的，后者的 两 病例) 一样，作为 a 参考（书），推荐书 向，到 （定冠词）那，这 typeglob(？).If(？) 你，你们 希望，祝愿，想要 向，到 总是，始终 转换，改变信仰 这样的，如此的 争论 向，到 a typeglob(？) 参考（书），推荐书, 使用，用途，利用 Symbol(？)::qualify_to_ref() 一样，作为 遵循:

=EN The C<+> prototype is a special alternative to C<$> that will act like C<\[@%]> when given a literal array or hash variable, but will otherwise force scalar context on the argument.This is useful for functions which should accept either a literal array or an array reference as the argument:

=CN The(？) C<+> 原型 是 a 特别的，专门的 两者取一 向，到 C<$> 那那个，那么 aux，将，愿，意志 行为，法令，表演 喜欢，像 C<\[@%]> 何时 给出 a 字面的，不夸张的 装扮，排列 或者，即，否则 哈希 可变的，变量, 但是，除了 aux，将，愿，意志 另外的，否则 力，力量，强迫 标量 上下文，语境，环境 在，上，关于 （定冠词）那，这 争论，论点.This(？) 是 有用的，有益的 给，作，用的 功能 哪个，那个 应该，会 接受，同意 二者之一，也 a 字面的，不夸张的 装扮，排列 或者，即，否则 一个 装扮，排列 参考（书），推荐书 一样，作为 （定冠词）那，这 争论，论点:

=EN When using the C<+> prototype, your function must check that the argument is of an acceptable type.

=CN When(？) 使用 （定冠词）那，这 C<+> 原型, 你的，你们的 作用，集会，函数 必须，准是，必须 检验，核对，支票 那那个，那么 （定冠词）那，这 争论，论点 是 的(表示领属等) 一个 可接受的，合意的 类型，典型，打字.

=EN A semicolon (C<;>) separates mandatory arguments from optional arguments. It is redundant before C<@> or C<%>, which gobble up everything else.

=CN A semicolon(？) (C<;>) separates(？) 强制性 争论 自，从，来 可任选的，随意的 争论. It(？) 是 冗余 在，前面 C<@> 或者，即，否则 C<%>, 哪个，那个 gobble(？) 向上，起床 事事，一切 别的，否则.

=EN As the last character of a prototype, or just before a semicolon, you can use C<_> in place of C<$>: if this argument is not provided, C<$_> will be used instead.

=CN As(？) （定冠词）那，这 最后的，上次 性格，角色，特牲 的(表示领属等) a 原型, 或者，即，否则 只，刚才 在，前面 a semicolon(？), 你，你们 aux，能，会，可以 使用，用途，利用 C<_> 在，内，穿戴 地方，位置，放置 的(表示领属等) C<$>: 如果，虽然，是否 这，这个 争论，论点 是 不 只要, C<$_> aux，将，愿，意志 是，存在 使用 代替，而是.

=EN Note how the last three examples in the table above are treated specially by the parser.C<mygrep()> is parsed as a true list operator, C<myrand()> is parsed as a true unary operator with unary precedence the same as C<rand()>, and C<mytime()> is truly without arguments, just like C<time()>.That is, if you say

=CN Note(？) 如何，多么，怎样 （定冠词）那，这 最后的，上次 三 实例 在，内，穿戴 （定冠词）那，这 桌子，表格 在，之上，高于 是 治疗 特地，专门地 在，旁边，按照 （定冠词）那，这 分析器.C<mygrep()> 是 解析 一样，作为 a 真实的，真正的 表，名单，列表 操作人员，接线员, C<myrand()> 是 解析 一样，作为 a 真实的，真正的 一元 操作人员，接线员 同，一起，用 一元 领先，优先权 （定冠词）那，这 同样的 一样，作为 C<rand()>, 和，与，而 C<mytime()> 是 真正地，确实 没有，在，外部 争论, 只，刚才 喜欢，像 C<time()>.That(？) 是, 如果，虽然，是否 你，你们 说，发言（权）

=EN you'll get C<mytime() + 2>, not C<mytime(2)>, which is how it would be parsed without a prototype.

=CN 你，你们'我 获得，记住，到达 C<mytime() + 2>, 不 C<mytime(2)>, 哪个，那个 是 如何，多么，怎样 它 将 是，存在 解析 没有，在，外部 a 原型.

=EN The interesting thing about C<&> is that you can generate new syntax with it,  provided it's in the initial position: X<&>

=CN The(？) 有趣的 东西，事情 关于，大约 C<&> 是 那那个，那么 你，你们 aux，能，会，可以 产生，发生，生殖 新的，重新的 语法 同，一起，用 它,  只要 它's，（缩）轮船 在，内，穿戴 （定冠词）那，这 最初的 位置，地位，处境: X<&>

=EN That prints C<"unphooey">.(Yes, there are still unresolved issues having to do with visibility of C<@_>.I'm ignoring that question for the moment.(But note that if we make C<@_> lexically scoped, those anonymous subroutines can act like closures...(Gee,  is this sounding a little Lispish?  (Never mind.))))

=CN That(？) prints(？) C<"unphooey">.(Yes(？), 那里，到那里 是 静止的，仍旧 unresolved(？) 问题 有 向，到 做，干，足够，制作 同，一起，用 能见度 的(表示领属等) C<@_>.I'm 忽略 那那个，那么 问题，疑问，询问 给，作，用的 （定冠词）那，这 时刻，瞬间.(But(？) 笔记，注释，便条 那那个，那么 如果，虽然，是否 我们 做，制造，种类 C<@_> 词法 选中, 那些 匿名 子程序 aux，能，会，可以 行为，法令，表演 喜欢，像 瓶盖...(Gee(？),  是 这，这个 sounding(？) a 小的，一点，少的 Lispish(？)?  (Never(？) 头脑，智力，介意.))))

=EN And here's a reimplementation of the Perl C<grep> operator: X<grep>

=CN And(？) 这里，在这里's，（缩）轮船 a reimplementation(？) 的(表示领属等) （定冠词）那，这 Perl(？) C<grep> 操作人员，接线员: X<grep>

=EN Some folks would prefer full alphanumeric prototypes.Alphanumerics have been intentionally left out of prototypes for the express purpose of someday in the future adding named, formal parameters.The current mechanism's main goal is to let module writers provide better diagnostics for module users.Larry feels the notation quite understandable to Perl programmers, and that it will not intrude greatly upon the meat of the module, nor make it harder to read.The line noise is visually encapsulated into a small pill that's easy to swallow.

=CN Some(？) 乡亲 将 较喜欢，宁愿 满的，完全的 alphanumeric(？) 原型.Alphanumerics(？) 有，不得不，拿 被 intentionally(？) 左的，向左 出外，向外，完 的(表示领属等) 原型 给，作，用的 （定冠词）那，这 表达，快递，快车 目的，用途，意图 的(表示领属等) 总有一天 在，内，穿戴 （定冠词）那，这 将来，前途 添加 命名, 形式上的，正式的 参数.The(？) 现令的，流 机制，机械装置's，（缩）轮船 主要的 目标，目的，球门 是 向，到 让，使 模量，模件 作家 供给，提供，准备 更好的，较好 diagnostics(？) 给，作，用的 模量，模件 用户.Larry(？) feels(？) （定冠词）那，这 符号 完全，十分，相当 understandable(？) 向，到 Perl(？) 程序员, 和，与，而 那那个，那么 它 aux，将，愿，意志 不 侵入，强加于 大大地，非常地 在，之上 （定冠词）那，这 肉 的(表示领属等) （定冠词）那，这 模量，模件, 也不，也没 做，制造，种类 它 更难 向，到 读.The(？) 行，线条，界线 噪音，吵嚷声 是 视觉 封装 到，里面，，成 a 小的，不重要的 药片，药丸 那那个，那么's，（缩）轮船 容易的，轻松的 向，到 燕子，吞咽.

=EN If you try to use an alphanumeric sequence in a prototype you will generate an optional warning - "Illegal character in prototype...". Unfortunately earlier versions of Perl allowed the prototype to be used as long as its prefix was a valid prototype.The warning may be upgraded to a fatal error in a future version of Perl once the majority of offending code is fixed.

=CN If(？) 你，你们 尝试，审讯，尝试 向，到 使用，用途，利用 一个 alphanumeric(？) 一连串，顺序 在，内，穿戴 a 原型 你，你们 aux，将，愿，意志 产生，发生，生殖 一个 可任选的，随意的 警告 - "Illegal(？) 性格，角色，特牲 在，内，穿戴 原型...". Unfortunately(？) 早些时候 版本 的(表示领属等) Perl(？) 允许 （定冠词）那，这 原型 向，到 是，存在 使用 一样，作为 长的，长久 一样，作为 它的 前缀 是 a 正当的，有效的 原型.The(？) 警告 可以，也许，祝愿 是，存在 upgraded(？) 向，到 a 致命的 错误，过失 在，内，穿戴 a 将来，前途 译文，译本，看法 的(表示领属等) Perl(？) 一度，一次 （定冠词）那，这 多数，过半数 的(表示领属等) offending(？) 法规，代码，密码 是 固定的，已确定的.

=EN It's probably best to prototype new functions, not retrofit prototyping into older ones.That's because you must be especially careful about silent impositions of differing list versus scalar contexts.For example,  if you decide that a function should take just one parameter, like this:

=CN It(？)'s，（缩）轮船 或许，大概 最好的 向，到 原型 新的，重新的 功能, 不 retrofit(？) prototyping(？) 到，里面，，成 年长的 的.That(？)'s，（缩）轮船 因为，由于 你，你们 必须，准是，必须 是，存在 特别地，专门地 小心的，仔细的 关于，大约 寂静的，沉默的 impositions(？) 的(表示领属等) differing(？) 表，名单，列表 对 标量 contexts(？).For(？) 例子，榜样,  如果，虽然，是否 你，你们 决定，判决 那那个，那么 a 作用，集会，函数 应该，会 拿，带，吃，乘 只，刚才 一个 参数，参量, 喜欢，像 这，这个:

=EN and someone has been calling it with an array or expression returning a list:

=CN 和，与，而 有人，某人 已经 被 打电话 它 同，一起，用 一个 装扮，排列 或者，即，否则 表达，措辞，表情 返回 a 表，名单，列表:

=EN Then you've just supplied an automatic C<scalar> in front of their argument, which can be more than a bit surprising.The old C<@foo> which used to hold one thing doesn't get passed in.Instead,  C<func()> now gets passed in a C<1>; that is, the number of elements in C<@foo>.And the C<split> gets called in scalar context so it starts scribbling on your C<@_> parameter list.Ouch!

=CN Then(？) 你，你们'C<ve(？)> 只，刚才 提供 一个 自动的 C<scalar> 在，内，穿戴 正面，前线，面对 的(表示领属等) 他们的，它们的 争论，论点, 哪个，那个 aux，能，会，可以 是，存在 更多的更，更 比，除，外 a 小片，一点 惊人的.The(？) 老的，，岁的 C<@foo> 哪个，那个 使用 向，到 握住，容纳，控制 一个 东西，事情 没有't 获得，记住，到达 通过 在，内，穿戴.Instead(？),  C<func()> 现在，既然 得到 通过 在，内，穿戴 a C<1>; 那那个，那么 是, （定冠词）那，这 数字，若干，号码 的(表示领属等) 元素 在，内，穿戴 C<@foo>.And(？) （定冠词）那，这 C<split> 得到 称为 在，内，穿戴 标量 上下文，语境，环境 这样，也一样 它 starts(？) scribbling(？) 在，上，关于 你的，你们的 C<@_> 参数，参量 表，名单，列表.Ouch(？)!

=EN This is all very powerful, of course, and should be used only in moderation to make the world a better place.

=CN This(？) 是 所有的，一切 很，非常 有力的，强的, 的(表示领属等) 过程，路线，课程, 和，与，而 应该，会 是，存在 使用 唯一的，仅仅 在，内，穿戴 moderation(？) 向，到 做，制造，种类 （定冠词）那，这 世界，界，世间 a 更好的，较好 地方，位置，放置.

=EN =head2 Constant Functions X<constant>

=CN =head2 Constant(？) Functions(？) X<constant>

=EN Functions with a prototype of C<()> are potential candidates for inlining.If the result after optimization and constant folding is either a constant or a lexically-scoped scalar which has no other references, then it will be used in place of function calls made without C<&>.Calls made using C<&> are never inlined.(See F<constant.pm> for an easy way to declare most constants.)

=CN Functions(？) 同，一起，用 a 原型 的(表示领属等) C<()> 是 潜在的，潜力 候选人 给，作，用的 inlining(？).If(？) （定冠词）那，这 结果，效果，后果 在，后 优化 和，与，而 不变的，恒定的 folding(？) 是 二者之一，也 a 不变的，恒定的 或者，即，否则 a 词法-选中 标量 哪个，那个 已经 不毫不，没有 其他的，别的 参考, 当时，然后，那么 它 aux，将，愿，意志 是，存在 使用 在，内，穿戴 地方，位置，放置 的(表示领属等) 作用，集会，函数 电话 使 没有，在，外部 C<&>.Calls(？) 使 使用 C<&> 是 从不，永不，未曾 inlined(？).(See(？) F<constant.pm> 给，作，用的 一个 容易的，轻松的 方法，路，方向 向，到 宣布，声明 最多的，非常 constants(？).)

=EN The following functions would all be inlined:

=CN The(？) 下列的，其次的 功能 将 所有的，一切 是，存在 inlined(？):

=EN     sub pi ()        { 3.14159 }        # Not exact, but close.

=CN     sub pi ()        { 3.14159 }        # Not(？) 精确的，精密的, 但是，除了 关闭，结束，终结.

=EN     sub PI ()        { 4 * atan2 1, 1 }    # As good as it gets,

=CN     sub PI ()        { 4 * atan2 1, 1 }    # As(？) 好的，善良的 一样，作为 它 得到,

=EN                         # and it's inlined, too!

=CN                         # 和，与，而 它's，（缩）轮船 inlined(？), 也，非常!

=EN Be aware that these will not be inlined; as they contain inner scopes,  the constant folding doesn't reduce them to a single constant:

=CN Be(？) 知道的，意识到的 那那个，那么 这些 aux，将，愿，意志 不 是，存在 inlined(？); 一样，作为 他（她）们，它们 含有，容纳，抑制 里面的，内心的 范围,  （定冠词）那，这 不变的，恒定的 folding(？) 没有't 减少，贬为 他（她）们，它们 向，到 a 单个的，单身的 不变的，恒定的:

=EN If you redefine a subroutine that was eligible for inlining, you'll get a mandatory warning.(You can use this warning to tell whether or not a particular subroutine is considered constant.)  The warning is considered severe enough not to be optional because previously compiled invocations of the function will still be using the old value of the function.If you need to be able to redefine the subroutine, you need to ensure that it isn't inlined, either by dropping the C<()> prototype (which changes calling semantics, so beware) or by thwarting the inlining mechanism in some other way, such as

=CN If(？) 你，你们 重新定义 a 子程序 那那个，那么 是 eligible(？) 给，作，用的 inlining(？), 你，你们'我 获得，记住，到达 a 强制性 警告.(You(？) aux，能，会，可以 使用，用途，利用 这，这个 警告 向，到 告诉，讲，说出 是否，还是， 或者，即，否则 不 a 特殊的，项目 子程序 是 考虑 不变的，恒定的.)  The(？) 警告 是 考虑 严厉的，苛刻的 足够(的) 不 向，到 是，存在 可任选的，随意的 因为，由于 预先，先前 编译 invocations(？) 的(表示领属等) （定冠词）那，这 作用，集会，函数 aux，将，愿，意志 静止的，仍旧 是，存在 使用 （定冠词）那，这 老的，，岁的 价值，评价，估价 的(表示领属等) （定冠词）那，这 作用，集会，函数.If(？) 你，你们 需要，贫困，需要 向，到 是，存在 有能力的，能干的 向，到 重新定义 （定冠词）那，这 子程序, 你，你们 需要，贫困，需要 向，到 保证，担保，保护 那那个，那么 它 不't inlined(？), 二者之一，也 在，旁边，按照 dropping(？) （定冠词）那，这 C<()> 原型 (哪个，那个 变化 打电话 语义, 这样，也一样 当心) 或者，即，否则 在，旁边，按照 thwarting(？) （定冠词）那，这 inlining(？) 机制，机械装置 在，内，穿戴 若干，某一 其他的，别的 方法，路，方向, 这样的，如此的 一样，作为

=EN =head2 Overriding Built-in Functions X<built-in> X<override> X<CORE> X<CORE::GLOBAL>

=CN =head2 Overriding(？) Built(？)-在，内，穿戴 Functions(？) X<built-in> X<override> X<CORE> X<CORE::GLOBAL>

=EN Many built-in functions may be overridden, though this should be tried only occasionally and for good reason.Typically this might be done by a package attempting to emulate missing built-in functionality on a non-Unix system.

=CN Many(？) 建造-在，内，穿戴 功能 可以，也许，祝愿 是，存在 overridden(？), 虽然，可是 这，这个 应该，会 是，存在 tried(？) 唯一的，仅仅 偶而，有时 和，与，而 给，作，用的 好的，善良的 原因，理由，推论.Typically(？) 这，这个 或许，可以，力 是，存在 做 在，旁边，按照 a 包裹，打包 尝试 向，到 模仿 丢失的，缺少的 建造-在，内，穿戴 functionality(？) 在，上，关于 a 非-Unix(？) 系统，体制，制度.

=EN Overriding may be done only by importing the name from a module at compile time--ordinary predeclaration isn't good enough.However, the C<use subs> pragma lets you, in effect, predeclare subs via the import syntax, and these names may then override built-in ones:

=CN Overriding(？) 可以，也许，祝愿 是，存在 做 唯一的，仅仅 在，旁边，按照 importing(？) （定冠词）那，这 姓名，名称，命名 自，从，来 a 模量，模件 在，处于，以 编（书），编辑 时间，时候，次数--普通的，一般的 predeclaration(？) 不't 好的，善良的 足够(的).However(？), （定冠词）那，这 C<use subs> C<pragma(？)> 让 你，你们, 在，内，穿戴 后果，效力，导致, predeclare(？) 替补 经由，取道 （定冠词）那，这 进口，引进，进口货 语法, 和，与，而 这些 名字 可以，也许，祝愿 当时，然后，那么 推翻 建造-在，内，穿戴 的:

=EN To unambiguously refer to the built-in form, precede the built-in name with the special package qualifier C<CORE::>.For example,  saying C<CORE::open()> always refers to the built-in C<open()>, even if the current package has imported some other subroutine called C<&open()> from elsewhere.Even though it looks like a regular function call, it isn't: you can't take a reference to it, such as the incorrect C<\&CORE::open> might appear to produce.

=CN To(？) 明确 查阅，提及 向，到 （定冠词）那，这 建造-在，内，穿戴 形状，类型，表格, 在前，高于 （定冠词）那，这 建造-在，内，穿戴 姓名，名称，命名 同，一起，用 （定冠词）那，这 特别的，专门的 包裹，打包 qualifier(？) C<CORE::>.For(？) 例子，榜样,  说 C<CORE::open()> 总是，始终 指 向，到 （定冠词）那，这 建造-在，内，穿戴 C<open()>, 平坦的，均匀的 如果，虽然，是否 （定冠词）那，这 现令的，流 包裹，打包 已经 imported(？) 若干，某一 其他的，别的 子程序 称为 C<&open()> 自，从，来 在别处.Even(？) 虽然，可是 它 看起来 喜欢，像 a 正常的，有规律的 作用，集会，函数 叫，称为，打电话, 它 不't: 你，你们 aux，能，会，可以't 拿，带，吃，乘 a 参考（书），推荐书 向，到 它, 这样的，如此的 一样，作为 （定冠词）那，这 不正确的 C<\&CORE::open> 或许，可以，力 出现，好象 向，到 生产，制造，创作.

=EN Library modules should not in general export built-in names like C<open> or C<chdir> as part of their default C<@EXPORT> list, because these may sneak into someone else's namespace and change the semantics unexpectedly. Instead, if the module adds that name to C<@EXPORT_OK>, then it's possible for a user to import the name explicitly, but not implicitly. That is, they could say

=CN Library(？) 模块 应该，会 不 在，内，穿戴 一般的，总的 输出，出口 建造-在，内，穿戴 名字 喜欢，像 C<open> 或者，即，否则 C<chdir> 一样，作为 部分，零件，角色 的(表示领属等) 他们的，它们的 不履行，不负责 C<@EXPORT> 表，名单，列表, 因为，由于 这些 可以，也许，祝愿 偷偷地逃走、做 到，里面，，成 有人，某人 别的，否则's，（缩）轮船 命名空间 和，与，而 变化，零钱，改变 （定冠词）那，这 语义 竟然. Instead(？), 如果，虽然，是否 （定冠词）那，这 模量，模件 增加 那那个，那么 姓名，名称，命名 向，到 C<@EXPORT_OK>, 当时，然后，那么 它's，（缩）轮船 可能的 给，作，用的 a 使用者，用户 向，到 进口，引进，进口货 （定冠词）那，这 姓名，名称，命名 清晰地, 但是，除了 不 隐式. That(？) 是, 他（她）们，它们 能 说，发言（权）

=EN and it would import the C<open> override.But if they said

=CN 和，与，而 它 将 进口，引进，进口货 （定冠词）那，这 C<open> 推翻.But(？) 如果，虽然，是否 他（她）们，它们 上述的，该

=EN they would get the default imports without overrides.

=CN 他（她）们，它们 将 获得，记住，到达 （定冠词）那，这 不履行，不负责 imports(？) 没有，在，外部 覆盖.

=EN The foregoing mechanism for overriding built-in is restricted, quite deliberately, to the package that requests the import.There is a second method that is sometimes applicable when you wish to override a built-in everywhere, without regard to namespace boundaries.This is achieved by importing a sub into the special namespace C<CORE::GLOBAL::>.Here is an example that quite brazenly replaces the C<glob> operator with something that understands regular expressions.

=CN The(？) 先行的，上述的 机制，机械装置 给，作，用的 压倒一切的 建造-在，内，穿戴 是 restricted(？), 完全，十分，相当 故意地，从容地, 向，到 （定冠词）那，这 包裹，打包 那那个，那么 请求 （定冠词）那，这 进口，引进，进口货.There(？) 是 a 第二 方法 那那个，那么 是 有时，不时 生动的，适用的 何时 你，你们 希望，祝愿，想要 向，到 推翻 a 建造-在，内，穿戴 处处，到处, 没有，在，外部 认为，尊重，关于 向，到 命名空间 边界.This(？) 是 achieved(？) 在，旁边，按照 importing(？) a 子 到，里面，，成 （定冠词）那，这 特别的，专门的 命名空间 C<CORE::GLOBAL::>.Here(？) 是 一个 例子，榜样 那那个，那么 完全，十分，相当 brazenly(？) replaces(？) （定冠词）那，这 C<glob> 操作人员，接线员 同，一起，用 某事，某物 那那个，那么 understands(？) 正常的，有规律的 expressions(？).

=EN And here's how it could be (ab)used:

=CN And(？) 这里，在这里's，（缩）轮船 如何，多么，怎样 它 能 是，存在 (ab(？))使用:

=EN     #use REGlob 'GLOBAL_glob';        # override glob() in ALL namespaces

=CN     #使用，用途，利用 REGlob(？) 'GLOBAL_glob';        # 推翻 glob(？)() 在，内，穿戴 ALL(？) 命名空间

=EN     use REGlob 'glob';            # override glob() in Foo:: only

=CN     use REGlob 'glob';            # 推翻 glob(？)() 在，内，穿戴 Foo(？):: 唯一的，仅仅

=EN     print for <^[a-z_]+\.pm\$>;        # show all pragmatic modules

=CN     print for <^[a-z_]+\.pm\$>;        # 显示，表明，演出 所有的，一切 pragmatic(？) 模块

=EN The initial comment shows a contrived, even dangerous example. By overriding C<glob> globally, you would be forcing the new (and subversive) behavior for the C<glob> operator for I<every> namespace,  without the complete cognizance or cooperation of the modules that own those namespaces.Naturally, this should be done with extreme caution--if it must be done at all.

=CN The(？) 最初的 评论 shows(？) a contrived(？), 平坦的，均匀的 有危险的 例子，榜样. By(？) 压倒一切的 C<glob> 全球, 你，你们 将 是，存在 迫使 （定冠词）那，这 新的，重新的 (和，与，而 subversive(？)) 行为，举止 给，作，用的 （定冠词）那，这 C<glob> 操作人员，接线员 给，作，用的 I<every> 命名空间,  没有，在，外部 （定冠词）那，这 完成，结束 cognizance(？) 或者，即，否则 合作，协作 的(表示领属等) （定冠词）那，这 模块 那那个，那么 自己的，拥有 那些 命名空间.Naturally(？), 这，这个 应该，会 是，存在 做 同，一起，用 极度的，极端的 谨慎，告诫--如果，虽然，是否 它 必须，准是，必须 是，存在 做 在，处于，以 所有的，一切.

=EN The C<REGlob> example above does not implement all the support needed to cleanly override perl's C<glob> operator.The built-in C<glob> has different behaviors depending on whether it appears in a scalar or list context, but our C<REGlob> doesn't.Indeed, many perl built-in have such context sensitive behaviors, and these must be adequately supported by a properly written override.For a fully functional example of overriding C<glob>, study the implementation of C<File::DosGlob> in the standard library.

=CN The(？) C<REGlob> 例子，榜样 在，之上，高于 做 不 实行，工具 所有的，一切 （定冠词）那，这 支持，资助，支援 需要 向，到 cleanly(？) 推翻 C<perl(？)>'s，（缩）轮船 C<glob> 操作人员，接线员.The(？) 建造-在，内，穿戴 C<glob> 已经 不同的，各种 行为 根据 在，上，关于 是否，还是， 它 appears(？) 在，内，穿戴 a 标量 或者，即，否则 表，名单，列表 上下文，语境，环境, 但是，除了 我们的 C<REGlob> 没有't.Indeed(？), 许多的，许多 C<perl(？)> 建造-在，内，穿戴 有，不得不，拿 这样的，如此的 上下文，语境，环境 敏感的 行为, 和，与，而 这些 必须，准是，必须 是，存在 恰当地 supported(？) 在，旁边，按照 a 合适地 写作的，书面的 推翻.For(？) a 完全，彻底 功能的 例子，榜样 的(表示领属等) 压倒一切的 C<glob>, 学习，研究 （定冠词）那，这 实行，执行 的(表示领属等) C<File::DosGlob> 在，内，穿戴 （定冠词）那，这 标准，标准的 图书馆，藏书.

=EN When you override a built-in, your replacement should be consistent (if possible) with the built-in native syntax.You can achieve this by using a suitable prototype.To get the prototype of an overridable built-in,  use the C<prototype> function with an argument of C<"CORE::builtin_name"> (see L<perlfunc/prototype>).

=CN When(？) 你，你们 推翻 a 建造-在，内，穿戴, 你的，你们的 归回，代替（物） 应该，会 是，存在 始终如一的，符合 (如果，虽然，是否 可能的) 同，一起，用 （定冠词）那，这 建造-在，内，穿戴 本国的，出生地的 语法.You(？) aux，能，会，可以 完成，实现 这，这个 在，旁边，按照 使用 a 合适的，适宜的 原型.To(？) 获得，记住，到达 （定冠词）那，这 原型 的(表示领属等) 一个 overridable(？) 建造-在，内，穿戴,  使用，用途，利用 （定冠词）那，这 C<prototype> 作用，集会，函数 同，一起，用 一个 争论，论点 的(表示领属等) C<"CORE::builtin_name"> (看见，明白，查看 L<perlfunc/prototype>).

=EN Note however that some built-ins can't have their syntax expressed by a prototype (such as C<system> or C<chomp>).If you override them you won't be able to fully mimic their original syntax.

=CN Note(？) 可是，然而 那那个，那么 若干，某一 建造-ins(？) aux，能，会，可以't 有，不得不，拿 他们的，它们的 语法 表达 在，旁边，按照 a 原型 (这样的，如此的 一样，作为 C<system> 或者，即，否则 C<chomp>).If(？) 你，你们 推翻 他（她）们，它们 你，你们 赢得't 是，存在 有能力的，能干的 向，到 完全，彻底 mimic(？) 他们的，它们的 原始的，原物 语法.

=EN The built-ins C<do>, C<require> and C<glob> can also be overridden, but due to special magic, their original syntax is preserved, and you don't have to define a prototype for their replacements.(You can't override the C<do BLOCK> syntax, though).

=CN The(？) 建造-ins(？) C<do>, C<require> 和，与，而 C<glob> aux，能，会，可以 也 是，存在 overridden(？), 但是，除了 到期的，预定的 向，到 特别的，专门的 魔法，魔术，魅力, 他们的，它们的 原始的，原物 语法 是 preserved(？), 和，与，而 你，你们 不要't 有，不得不，拿 向，到 下定义，界定，规定 a 原型 给，作，用的 他们的，它们的 replacements(？).(You(？) aux，能，会，可以't 推翻 （定冠词）那，这 C<do BLOCK> 语法, 虽然，可是).

=EN C<require> has special additional dark magic: if you invoke your C<require> replacement as C<require Foo::Bar>, it will actually receive the argument C<"Foo/Bar.pm"> in @_.See L<perlfunc/require>.

=CN C<require> 已经 特别的，专门的 增加的，附加的 黑暗的，暗处 魔法，魔术，魅力: 如果，虽然，是否 你，你们 调用 你的，你们的 C<require> 归回，代替（物） 一样，作为 C<require Foo::Bar>, 它 aux，将，愿，意志 实际上，居然 收到，接待，接见 （定冠词）那，这 争论，论点 C<"Foo/Bar.pm"> 在，内，穿戴 @_.See(？) L<perlfunc/require>.

=EN And, as you'll have noticed from the previous example, if you override C<glob>, the C<< <*> >> glob operator is overridden as well.

=CN And(？), 一样，作为 你，你们'我 有，不得不，拿 noticed(？) 自，从，来 （定冠词）那，这 早先的，先前的 例子，榜样, 如果，虽然，是否 你，你们 推翻 C<glob>, （定冠词）那，这 C<< <*> >> glob(？) 操作人员，接线员 是 overridden(？) 一样，作为 井，好，充分.

=EN In a similar fashion, overriding the C<readline> function also overrides the equivalent I/O operator C<< <FILEHANDLE> >>.Also, overriding C<readpipe> also overrides the operators C<``> and C<qx//>.

=CN In(？) a 类似的，相象的 方式，时髦，时装, 压倒一切的 （定冠词）那，这 C<readline> 作用，集会，函数 也 覆盖 （定冠词）那，这 相等的，等值的 I/O 操作人员，接线员 C<< <FILEHANDLE> >>.Also(？), 压倒一切的 C<readpipe> 也 覆盖 （定冠词）那，这 运营商 C<``> 和，与，而 C<qx//>.

=EN Finally, some built-ins (e.g.C<exists> or C<grep>) can't be overridden.

=CN Finally(？), 若干，某一 建造-ins(？) (g，（缩）例如.g.C<exists> 或者，即，否则 C<grep>) aux，能，会，可以't 是，存在 overridden(？).

=EN =head2 Autoloading X<autoloading> X<AUTOLOAD>

=CN =head2 Autoloading(？) X<autoloading> X<AUTOLOAD>

=EN If you call a subroutine that is undefined, you would ordinarily get an immediate, fatal error complaining that the subroutine doesn't exist.(Likewise for subroutines being used as methods, when the method doesn't exist in any base class of the class's package.) However, if an C<AUTOLOAD> subroutine is defined in the package or packages used to locate the original subroutine, then that C<AUTOLOAD> subroutine is called with the arguments that would have been passed to the original subroutine.The fully qualified name of the original subroutine magically appears in the global $AUTOLOAD variable of the same package as the C<AUTOLOAD> routine.The name is not passed as an ordinary argument because, er, well, just because, that's why.(As an exception, a method call to a nonexistent C<import> or C<unimport> method is just skipped instead.Also, if the AUTOLOAD subroutine is an XSUB, C<$AUTOLOAD> is not populated; instead, you should call L<< C<SvPVX>E<sol>C<SvCUR>|perlapi >> on the C<CV> for C<AUTOLOAD> to retrieve the method name.)

=CN If(？) 你，你们 叫，称为，打电话 a 子程序 那那个，那么 是 未定义的, 你，你们 将 通常 获得，记住，到达 一个 立即的，最近的, 致命的 错误，过失 complaining(？) 那那个，那么 （定冠词）那，这 子程序 没有't 存在，生存.(Likewise(？) 给，作，用的 子程序 生物，存在 使用 一样，作为 方法, 何时 （定冠词）那，这 方法 没有't 存在，生存 在，内，穿戴 任何，一些 基础，基地，基于 阶级，种类，班级 的(表示领属等) （定冠词）那，这 阶级，种类，班级's，（缩）轮船 包裹，打包.) However(？), 如果，虽然，是否 一个 C<AUTOLOAD> 子程序 是 定义 在，内，穿戴 （定冠词）那，这 包裹，打包 或者，即，否则 包 使用 向，到 找出，确定地点 （定冠词）那，这 原始的，原物 子程序, 当时，然后，那么 那那个，那么 C<AUTOLOAD> 子程序 是 称为 同，一起，用 （定冠词）那，这 争论 那那个，那么 将 有，不得不，拿 被 通过 向，到 （定冠词）那，这 原始的，原物 子程序.The(？) 完全，彻底 有资格的 姓名，名称，命名 的(表示领属等) （定冠词）那，这 原始的，原物 子程序 神奇地 appears(？) 在，内，穿戴 （定冠词）那，这 全世界的，总的 $AUTOLOAD(？) 可变的，变量 的(表示领属等) （定冠词）那，这 同样的 包裹，打包 一样，作为 （定冠词）那，这 C<AUTOLOAD> 日常事务.The(？) 姓名，名称，命名 是 不 通过 一样，作为 一个 普通的，一般的 争论，论点 因为，由于, 呃, 井，好，充分, 只，刚才 因为，由于, 那那个，那么's，（缩）轮船 为什么.(As(？) 一个 除外，例外, a 方法 叫，称为，打电话 向，到 a nonexistent(？) C<import> 或者，即，否则 C<unimport> 方法 是 只，刚才 skipped(？) 代替，而是.Also(？), 如果，虽然，是否 （定冠词）那，这 AUTOLOAD(？) 子程序 是 一个 XSUB(？), C<$AUTOLOAD> 是 不 人口密集的; 代替，而是, 你，你们 应该，会 叫，称为，打电话 L<< C<SvPVX>E<sol>C<SvCUR>|perlapi >> 在，上，关于 （定冠词）那，这 C<CV> 给，作，用的 C<AUTOLOAD> 向，到 retrieve(？) （定冠词）那，这 方法 姓名，名称，命名.)

=EN Many C<AUTOLOAD> routines load in a definition for the requested subroutine using eval(), then execute that subroutine using a special form of goto() that erases the stack frame of the C<AUTOLOAD> routine without a trace.(See the source to the standard module documented in L<AutoLoader>, for example.)  But an C<AUTOLOAD> routine can also just emulate the routine and never define it.For example,  let's pretend that a function that wasn't defined should just invoke C<system> with those arguments.All you'd do is:

=CN Many(？) C<AUTOLOAD> 程序 负载，负担，装载 在，内，穿戴 a 定义，解释 给，作，用的 （定冠词）那，这 requested(？) 子程序 使用 eval(？)(), 当时，然后，那么 执行，实施，处决 那那个，那么 子程序 使用 a 特别的，专门的 形状，类型，表格 的(表示领属等) goto(？)() 那那个，那么 erases(？) （定冠词）那，这 推放，垛 框架，骨骼，构造 的(表示领属等) （定冠词）那，这 C<AUTOLOAD> 日常事务 没有，在，外部 a 痕迹，微量，追踪.(See(？) （定冠词）那，这 来源，出处，源泉 向，到 （定冠词）那，这 标准，标准的 模量，模件 documented(？) 在，内，穿戴 L<AutoLoader>, 给，作，用的 例子，榜样.)  But(？) 一个 C<AUTOLOAD> 日常事务 aux，能，会，可以 也 只，刚才 模仿 （定冠词）那，这 日常事务 和，与，而 从不，永不，未曾 下定义，界定，规定 它.For(？) 例子，榜样,  让，使's，（缩）轮船 假装，佯称 那那个，那么 a 作用，集会，函数 那那个，那么 不是't 定义 应该，会 只，刚才 调用 C<system> 同，一起，用 那些 争论.All(？) 你，你们'd 做，干，足够，制作 是:

=EN In fact, if you predeclare functions you want to call that way, you don't even need parentheses:

=CN In(？) 事实，真相, 如果，虽然，是否 你，你们 predeclare(？) 功能 你，你们 想要，通辑，缺乏 向，到 叫，称为，打电话 那那个，那么 方法，路，方向, 你，你们 不要't 平坦的，均匀的 需要，贫困，需要 括号:

=EN A more complete example of this is the standard Shell module, which can treat undefined subroutine calls as calls to external programs.

=CN A 更多的更，更 完成，结束 例子，榜样 的(表示领属等) 这，这个 是 （定冠词）那，这 标准，标准的 Shell(？) 模量，模件, 哪个，那个 aux，能，会，可以 对待，医治，论述 未定义的 子程序 电话 一样，作为 电话 向，到 外部的，对外的 programs(？).

=EN Mechanisms are available to help modules writers split their modules into autoloadable files.See the standard AutoLoader module described in L<AutoLoader> and in L<AutoSplit>, the standard SelfLoader modules in L<SelfLoader>, and the document on adding C functions to Perl code in L<perlxs>.

=CN Mechanisms(？) 是 可得到的 向，到 帮助，有助于 模块 作家 劈，分割 他们的，它们的 模块 到，里面，，成 autoloadable(？) 文件.See(？) （定冠词）那，这 标准，标准的 AutoLoader(？) 模量，模件 描述 在，内，穿戴 L<AutoLoader> 和，与，而 在，内，穿戴 L<AutoSplit>, （定冠词）那，这 标准，标准的 SelfLoader(？) 模块 在，内，穿戴 L<SelfLoader>, 和，与，而 （定冠词）那，这 文件，公文 在，上，关于 添加 C 功能 向，到 Perl(？) 法规，代码，密码 在，内，穿戴 L<perlxs>.

=EN =head2 Subroutine Attributes X<attribute> X<subroutine, attribute> X<attrs>

=CN =head2 Subroutine(？) Attributes(？) X<attribute> X<subroutine, attribute> X<attrs>

=EN A subroutine declaration or definition may have a list of attributes associated with it.If such an attribute list is present, it is broken up at space or colon boundaries and treated as though a C<use attributes> had been seen.See L<attributes> for details about what attributes are currently supported. Unlike the limitation with the obsolescent C<use attrs>, the C<sub : ATTRLIST> syntax works to associate the attributes with a pre-declaration, and not just with a subroutine definition.

=CN A 子程序 宣布，宣告 或者，即，否则 定义，解释 可以，也许，祝愿 有，不得不，拿 a 表，名单，列表 的(表示领属等) 属性 联合的 同，一起，用 它.If(？) 这样的，如此的 一个 属于，属性 表，名单，列表 是 在场的，现在, 它 是 破碎的，毁坏了的 向上，起床 在，处于，以 空间，太空，空地 或者，即，否则 结肠 边界 和，与，而 治疗 一样，作为 虽然，可是 a C<use attributes> 已经 被 看到.See(？) L<attributes> 给，作，用的 细节 关于，大约 什么，什么的 属性 是 当前，广泛地 supported(？). Unlike(？) （定冠词）那，这 限制，局限 同，一起，用 （定冠词）那，这 obsolescent(？) C<use attrs>, （定冠词）那，这 C<sub : ATTRLIST> 语法 工厂 向，到 联想，adv，副的 （定冠词）那，这 属性 同，一起，用 a pre(？)-宣布，宣告, 和，与，而 不 只，刚才 同，一起，用 a 子程序 定义，解释.

=EN The attributes must be valid as simple identifier names (without any punctuation other than the '_' character).They may have a parameter list appended, which is only checked for whether its parentheses ('(', ')') nest properly.

=CN The(？) 属性 必须，准是，必须 是，存在 正当的，有效的 一样，作为 简单的，朴素的 标识符 名字 (没有，在，外部 任何，一些 准时 其他的，别的 比，除，外 （定冠词）那，这 '_' 性格，角色，特牲).They(？) 可以，也许，祝愿 有，不得不，拿 a 参数，参量 表，名单，列表 appended(？), 哪个，那个 是 唯一的，仅仅 checked(？) 给，作，用的 是否，还是， 它的 括号 ('(', ')') 巢，窝 合适地.

=EN Examples of valid syntax (even though the attributes are unknown):

=CN Examples(？) 的(表示领属等) 正当的，有效的 语法 (平坦的，均匀的 虽然，可是 （定冠词）那，这 属性 是 未知的，未知物):

=EN Examples of invalid syntax:

=CN Examples(？) 的(表示领属等) 伤残的，无效的 语法:

=EN     sub fnord : switch(10, foo(); # ()-string not balanced

=CN     sub fnord : switch(10, foo(); # ()-细绳，弦，一串 不 balanced(？)

=EN     sub snoid : Ugly('(');      # ()-string not balanced

=CN     sub snoid : Ugly('(');      # ()-细绳，弦，一串 不 balanced(？)

=EN     sub xyzzy : 5x5;          # "5x5" not a valid identifier

=CN     sub xyzzy : 5x5;          # "5x5" 不 a 正当的，有效的 标识符

=EN     sub plugh : Y2::north;      # "Y2::north" not a simple identifier

=CN     sub plugh : Y2::north;      # "Y2::北，北方，北的" 不 a 简单的，朴素的 标识符

=EN     sub snurt : foo + bar;      # "+" not a colon or space

=CN     sub snurt : foo + bar;      # "+" 不 a 结肠 或者，即，否则 空间，太空，空地

=EN The attribute list is passed as a list of constant strings to the code which associates them with the subroutine.In particular, the second example of valid syntax above currently looks like this in terms of how it's parsed and invoked:

=CN The(？) 属于，属性 表，名单，列表 是 通过 一样，作为 a 表，名单，列表 的(表示领属等) 不变的，恒定的 字符串 向，到 （定冠词）那，这 法规，代码，密码 哪个，那个 员工 他（她）们，它们 同，一起，用 （定冠词）那，这 子程序.In(？) 特殊的，项目, （定冠词）那，这 第二 例子，榜样 的(表示领属等) 正当的，有效的 语法 在，之上，高于 当前，广泛地 看起来 喜欢，像 这，这个 在，内，穿戴 条款 的(表示领属等) 如何，多么，怎样 它's，（缩）轮船 解析 和，与，而 invoked(？):

=EN For further details on attribute lists and their manipulation,  see L<attributes> and L<Attribute::Handlers>.

=CN For(？) 更远，进一步 细节 在，上，关于 属于，属性 列表 和，与，而 他们的，它们的 操纵，操作,  看见，明白，查看 L<attributes> 和，与，而 L<Attribute::Handlers>.

=EN =head1 SEE ALSO

=CN =head1 引申阅读

