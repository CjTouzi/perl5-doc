3.4. Selecting What to Import
3.4. 选择性地引入函数
Fortunately, we can tell the use operation to limit its actions by specifying a list of subroutine names following the module name, called the import list: 
use File::Basename (‘fileparse’, ‘basename’); 
很幸运，我们可以告诉use操作符，通过只导入需要的子例程来限制它的行为。称为“函数导入清单”，如：
use File::Basename (‘fileparse’, ‘basename’); 
Now the module only gives us those two subroutines and leaves our own dirname alone. Of course, this is awkward to type, so more often we’ll see this written with the quotewords operator: 
use File::Basename qw( fileparse basename ); 
这样的话，模块只会将两个例程导入我们的程序，让我们自己写的dirname留在程序中。 当然，上述的写法输入起来太麻烦，所以一般我们会看如下用引用操作符的写法：
use File::Basename qw( fileparse basename ); 
In fact, even if there’s only one item, we tend to write it with a qw( ) list for consistency and maintenance; often we’ll go back to say "give me another one from here," and it’s simpler if it’s already a qw( ) list. 
实际上， 即便只有一个参数，我们为了维护起来的一致性，也倾向于用qw()这样的形式。因为我们往往过后再回来找到这段代码说：“得在这里再加个参数”，如果我们一开始用qw()来写的话，维护起来会更简单。
We’ve protected the local dirname routine, but what if we still want the functionality provided by File::Basename’s dirname? No problem. We just spell it out with its full package specification: 
my $dirname = File::Basename::dirname($some_path); 
这样我们当然保护了本地的dirname例程，但是，如果我们想用File::Basename模块的dirname提供的功能怎么办？没问题！我们只要打出这个例程的全名就可以了：
my $dirname = File::Basename::dirname($some_path); 
The list of names following use doesn’t change which subroutines are defined in the module’s package (in this case, File::Basename). We can always use the full name regardless of the import list, as in:[*]
my $basename = File::Basename::basename($some_path); 
use 关键字后面的名字列表并不会使模块里(在这个例子中是File::Basename)的子例程的定义有任何改变。我们可以忽略导入清单，直接用全名，像下面一样：
my $basename = File::Basename::basename($some_path); 
[*] You don’t need the ampersand in front of any of these subroutine invocations, because the subroutine name is already known to the compiler following use.
你不必在这些调用的子例程的前面加“＆”符号，因为编译器已经知道子例程的名字了。
In an extreme (but extremely useful) case, we can specify an empty list for the import list, as in: 
use File::Basename (  );              # no import 
my $base = File::Basename::basename($some_path); 
在一种极端的情况（但也极端有用）， 我们可能为导入列表指定一个空列表，就像下面一样：
use File::Basename (  );              # 不导入任何例程 
my $base = File::Basename::basename($some_path); 
An empty list is different from an absent list. An empty list says "don’t give me anything," while an absent list says "give me the defaults." If the module’s author has done her job well, the default will probably be exactly what we want. 
空列表和没有列表的概念是不一样的。空列表的意思是说“不要导入任何子例程”， 而没有列表的意思是说：“请导入缺省的子例程”。 如果模块的作者干得出色的话，他缺省导出的例程正是你想要的。


