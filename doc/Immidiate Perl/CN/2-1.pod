2.1. List Operators
2.1. 列表操作符
You already know about several list operators in Perl, but you may not have thought of them as working with lists. The most common list operator is probably print. We give it one or more arguments, and it puts them together for us.
print ‘Two castaways are ‘, ‘Gilligan’, ‘ and ‘, ‘Skipper’, "\n";
你可能已经知道Perl的一些列表操作符，但并没有想过他们是怎么同列表一起工作的。最常用的列表操作符应该是print了。我们给它一些参数，然后它把他们合在一起显示出来。
print ‘Two castaways are ‘, ‘Gilligan’, ‘ and ‘, ‘Skipper’, "\n"; 
There are several other list operators that you already know about from Learning Perl. The sort operator puts its input list in order. In their theme song, the castaways don’t come in alphabetical order, but sort can fix that for us.
my @castaways = sort qw(Gilligan Skipper Ginger Professor Mary-Ann);
在Learning Perl这本书里,你可能知道了另外一些列表操作符。如sort操作符将输入的列表按顺序列出。在Gilligan’s Island的主题歌中的那些求生者没有按字母次序出场，sort可以为我们修正这一点。
my @castaways = sort qw(Gilligan Skipper Ginger Professor Mary-Ann); 
The reverse operator returns a list in the opposite order.
my @castaways = reverse qw(Gilligan Skipper Ginger Professor Mary-Ann);
reverse操作符返回反向排序的列表。
my @castaways = reverse qw(Gilligan Skipper Ginger Professor Mary-Ann); 
Perl has many other operators that work with lists, and, once you get used to them, you’ll find yourself typing less and expressing your intent more clearly.
Perl 还有其它与列表打交道的操作符。而且一旦你使用他们，你会发现这些语句会使你表达得更清楚，写更少的代码。
2.1.1. List Filtering with grep
2.1.1. 用grep操作符来过滤列表
The grep operator takes a list of values and a "testing expression." It takes one item after another in the list and places it into the $_ variable. It then evaluates the testing expression in a scalar context. If the expression evaluates to a true value, grep passes $_ on to the output list.
my @lunch_choices = grep &is_edible($_), @gilligans_posessions.
grep操作符取一个列表和一个“测试表达式”。它一个一个地从列表中把元素取出来放到$_变量中，并在标量环境中,用“测试表达式”来检验这个值。如果检验出来是个“真”值，grep会把$_变量送到输出列表中。
my @lunch_choices = grep &is_edible($_), @gilligans_posessions. 
In a list context, the grep operator returns a list of all such selected items. In a scalar context, grep returns the number of selected items.
my @results = grep EXPR, @input_list;
my $count = grep EXPR, @input_list;
在一个列表上下文中，grep操作符会返回所有被选出元素的列表。而在一个标量上下文中，grep返回被选出元素的个数。
my @results = grep EXPR, @input_list; 
my $count   = grep EXPR, @input_list; 
Here, EXPR stands in for any scalar expression that should refer to $_ (explicitly or implicitly). For example, to find all the numbers greater than 10, in our grep expression we check if $_ is greater than 10.
my @input_numbers = (1, 2, 4, 8, 16, 32, 64);
my @bigger_than_10 = grep $_ > 10, @input_numbers;
在下面的例子中，EXPR代表一个返回标量的表达式，它引用$_变量（显式或隐式的）。比如找出大于10的数，EXPR表达式来处理$_是否大于10。
my @input_numbers = (1, 2, 4, 8, 16, 32, 64); 
my @bigger_than_10 = grep $_ > 10, @input_numbers; 
The result is just 16, 32, and 64. This uses an explicit reference to $_. Here’s an example of an implicit reference to $_ from the pattern match operator:
my @end_in_4 = grep /4$/, @input_numbers;
输出结果当然是：16,32 和64。上例中显式地引用了变量$_。 下面有个隐式引用变量$_的例子，在正则表达式中隐式引用了变量$_:
my @end_in_4 = grep /4$/, @input_numbers; 
And now we get just 4 and 64.
现在我们得到的输出是4和64。
While the grep is running, it shadows any existing value in $_, which is to say that grep borrows the use of this variable but puts the original value back when it’s done. The variable $_ isn’t a mere copy of the data item, though; it is an alias for the actual data element, similar to the control variable in a foreach loop.
当grep工作的时候，它是从$_变量中把值"借"出来用。就是说grep把$_的值"借"过来用一下，用完后再把原值放回$_变量中。所以$_变量仅仅是拷贝一下值而己。是实际数据元素的一个别名。就像foreach loop中的控制变量。
If the testing expression is complex, we can hide it in a subroutine:
my @odd_digit_sum = grep digit_sum_is_odd($_), @input_numbers;
sub digit_sum_is_odd {
my $input = shift;
my @digits = split //, $input; # Assume no nondigit characters
my $sum;
$sum += $_ for @digits;
return $sum % 2;
}
如果检验表达式太复杂，我们可以把检验代码隐藏到一个子例程里去：
my @odd_digit_sum = grep digit_sum_is_odd($_), @input_numbers; 
sub digit_sum_is_odd { 
        my $input = shift; 
        my @digits = split //, $input;  # Assume no nondigit characters 
        my $sum; 
        $sum += $_ for @digits; 
        return $sum % 2; 
} 
Now we get back the list of 1, 16, and 32. These numbers have a digit sum with a remainder of "1" in the last line of the subroutine, which counts as true.
对于这个例子，我们得到的输出是1，16和32。程序把这些数据的数位加起来后，因为最后一行返回的余数都是"1"，所以返回值为"真"。
The syntax comes in two forms, though: we just showed you the expression form, and now here’s the block form. Rather than define an explicit subroutine that we’d use for only a single test, we can put the body of a subroutine directly in line in the grep operator, using the block forms:[*]
所以，grep语法有两种形式：前面秀给你们看的表达式形式和下面要展示给你们看的代码块形式。因为代码只用一次，我们现在不把代码放到子例程中，而是以代码块的形式直接放在grep语法里，所谓的块形式：[*]
[*] In the block form of grep, there’s no comma between the block and the input list. In the expression form of grep, there must be a comma between the expression and the list.
[*] 在grep的块形式中，代码块和输入数组中间是没有逗号的。而在grep的表达式形式中，表达式和输入数组中间必须要有一个逗号。区别如下：
my @results = grep {
block;
of;
code;
} @input_list;
my $count = grep {
block;
of;
code;
} @input_list;
Just like the expression form, grep temporarily places each element of the input list into $_. Next, it evaluates the entire block of code. The last evaluated expression in the block is the testing expression. (And like all testing expressions, it’s evaluated in a scalar context.) Because it’s a full block, we can introduce variables that are scoped to the block. Let’s rewrite that last example to use the block form:
my @odd_digit_sum = grep {
my $input = $_;
my @digits = split //, $input; # Assume no nondigit characters
my $sum;
$sum += $_ for @digits;
$sum % 2;
} @input_numbers;
同grep的表达式形式一样，grep临时把输入数组中每个元素放到$_中去，然后，它用代码块来处理这个值。代码块里最后一个表达式来检验值。就像所有的测试表达式一样，在标量上下文来检验值。因为是完整的块，所以我们可以在其中用以块为范围的变量。我们来用块形式重写上面的例子：
my @odd_digit_sum = grep { 
  my $input = $_; 
  my @digits = split //, $input;   # Assume no nondigit characters 
  my $sum; 
  $sum += $_ for @digits; 
  $sum % 2; 
} @input_numbers; 
Note the two changes: the input value comes in via $_ rather than an argument list, and we removed the keyword return. In fact, we would have been wrong to keep the return because we’re no longer in a separate subroutine: just a block of code.[*] Of course, we can optimize a few things out of that routine since we don’t need the intermediate variables:
[*] The return would have exited the subroutine that contains this entire section of code. And yes, some of us have been bitten by that mistake in real, live coding on the first draft.
my @odd_digit_sum = grep {
my $sum;
$sum += $_ for split //;
$sum % 2;
} @input_numbers;
注意与用子例程的方法有两个地方的变化：输入值是通过变量$_,而不是输入参数列表，而且在代码块形式中我们去掉了return关键字。实际上如果我们保留return的话是会出错的，因为我们不是在用一个子例程，仅仅是一个代码块。[*]当然，这个例子我们还可以优化一下，去掉中间变量：
[*] 保留return的结果会导致Perl从包含这个代码块的子例程中退出。当然，我们中有些人在最初编程的时候就深受其苦。
my @odd_digit_sum = grep { 
  my $sum; 
  $sum += $_ for split //; 
  $sum % 2; 
} @input_numbers; 
Feel free to crank up the explicitness if it helps you and your coworkers understand and maintain the code. That’s the main thing that matters.
如果显式使用中间变量能使代码让你和你的同事更易理解和维护代码的话，尽管用它。好代码才是主要的。
2.1.2. Transforming Lists with map
2.1.2. 用map作列表的转换
The map operator has a very similar syntax to the grep operator and shares a lot of the same operational steps. For example, it temporarily places items from a list into $_ one at a time, and the syntax allows both the expression block forms.
map操作符的语法同grep操作符非常相像，他们有相同的操作步骤。例如它们都是把输入列表中的元素临时地放到$_变量中去，而且他们的语法中都有表达式形式和代码块形式。
However, the testing expression becomes a mapping expression. The map operator evaluates the expression in a list context (not a scalar context like grep). Each evaluation of the expression gives a portion of the many results. The overall result is the list concatenation of all individual results. In a scalar context, map returns the number of elements that are returned in a list context. But map should rarely, if ever, be used in anything but a list context.)
然而，grep中的测试表达式在map中变成了映射表达式。map操作符在列表环境中为表达式求值（而不是像grep那样在标量环境下求值）。每次表达式求值都成为整个输出结果的一部分。为各个元素求值结果连在一起成为完整全部的输出。在标量环境下，map返回在输入列表里多少个元素被处理。但是map应该总是用在列表环境下，很少用在标量环境下。
Let’s start with a simple example:
my @input_numbers = (1, 2, 4, 8, 16, 32, 64);
my @result = map $_ + 100, @input_numbers;
我们由一个简单的例子开始：
my @input_numbers = (1, 2, 4, 8, 16, 32, 64); 
my @result = map $_ + 100,  @input_numbers; 
For each of the seven items map places into $_, we get a single output result: the number that is 100 greater than the input number. So the value of @result is 101, 102, 104, 108, 116, 132, and 164.
对七个元素中的每一个，map将它放到变量$_中，然后我们获得单个输出结果：得到各自大于100的数值。所以@result的值是： 101, 102, 104, 108, 116, 132, and 164. 
But we’re not limited to having only one output for each input. Let’s see what happens when each input produces two output items:
my @result = map { $_, 3 * $_ } @input_numbers;
但我们不应该止步于为每个输入仅有一个输出结果。让我们看看为每个输入产生两个输出：
my @result = map { $_, 3 * $_ } @input_numbers; 
Now there are two items for each input item: 1, 3, 2, 6, 4, 12, 8, 24, 16, 48, 32, 96, 64, and 192. We can store those pairs in a hash, if we need a hash showing what number is three times a small power of two:
my %hash = @result;
现在为每个输入项都产生两个输出：1, 3, 2, 6, 4, 12, 8, 24, 16, 48, 32, 96, 64, and 192. 如果需要一个散列展示一个数和它的三倍值的数值对，我们可以将结果成对放到一个散列里面。
my %hash = @result; 
Or, without using the intermediate array from the map:
my %hash = map { $_, 3 * $_ } @input_numbers;
或者，在map中不用中间的数组变量：
my %hash = map { $_, 3 * $_ } @input_numbers; 
You can see that map is pretty versatile; we can produce any number of output items for each input item. And we don’t always need to produce the same number of output items. Let’s see what happens when we break apart the digits:
my @result = map { split //, $_ } @input_numbers;
这里我们可以看到map是非常多才多艺的；我们可以为每个输入元素产生任何数量的输出。而且我们不一定总是为每一个元素产生相同的输出数量。让我们来看一个例子，它把一个数字折成数位。
my @result = map { split //, $_ } @input_numbers; 
The inline block of code splits each number into its individual digits. For 1, 2, 4, and 8, we get a single result. For 16, 32, and 64, we get two results per number. When map concatenates the results lists, we end up with 1, 2, 4, 8, 1, 6, 3, 2, 6, and 4.
内联的代码块把每个数值拆分为数位。对于1，2，4和8，我们得到单个输出。对于16，32，和64，我们为每个数值得到两个输出。当然我把结果连接起来，我们最终得到1, 2, 4, 8, 1, 6, 3, 2, 6, 和4。
If a particular invocation results in an empty list, map concatenates that empty result into the larger list, contributing nothing to the list. We can use this feature to select and reject items. For example, suppose we want only the split digits of numbers ending in 4:
my @result = map {
my @digits = split //, $_;
if ($digits[-1] = = 4) {
@digits;
} else {
( );
}
} @input_numbers;
如果一个特别的调用返回一个空的列表，map会把空列表连接起来到一个大的列表中，然后扔掉。我们可以利用这个特点选择和丢弃结果。例如，可能我们要以4结尾的数值：
my @result = map { 
        my @digits = split //, $_; 
        if ($digits[-1] =  = 4) { 
          @digits; 
        } else { 
          (  ); 
        } 
} @input_numbers; 
If the last digit is 4, we return the digits themselves by evaluating @digits (which is in list context). If the last digit is not 4, we return an empty list, effectively removing results for that particular item. Thus, we can always use a map in place of a grep, but not vice versa.
如果结尾数字为4，我们返回拆分开的数位（在列表环境）。如果最后个数字不是4，我们则返回一个空的列表，有效地去除了不要的输出。所以，我们总是可以用map来替换grep，但相反则不成。
Of course, everything we can do with map and grep, we can also do with explicit foreach loops. But then again, we can also code in assembler or by toggling bits into a front panel.[*] The point is that proper application of grep and map can help reduce the complexity of the program, allowing us to concentrate on high-level issues rather than details.
当然，所有map和grep能做的事，我们也可以显式的用foreach loop来实现。但是，再说一次，我们也可以用汇编或在打卡带来实现同样的编程[*]。要点是正确的运用grep和map可以帮你降低程序的复杂度，让我们可以把注意力集中在高层次的问题上，而不是在细节上纠缠。
[*] If you’re old enough to remember those front panels.
[*] 如果你还记得那些打孔带的符号。
————————-
Gilligan’s Island centered around a group of people who where stranded on an uncharted deserted island somewhere in the Pacific Ocean. They all were on a boat tour, which found itself in the middle of a storm leading them to crash on an island! Those stranded include, Gilligan, the Skipper, a millionaire (Thurston Howell III) and his wife (Lovey Howell), a movie star (Ginger Grant), a professor (known as "The Professor"), and Mary Ann. Gilligan was the first mate on the boat, the SS Minnow. Most episodes dealt with the castaways trying to get off the island, but their attempts seemed to always be foiled by Gilligan.
＜Gilligan的岛＞是CBS 1965年到1967年播放的一部喜剧。这部喜剧以一群荒岛求生者为中心展开故事。这些人因为船只搁浅而登陆到一个在地图上也没有标注的太平洋上的荒岛上。他们原本是乘小船出来旅行的，结果在风暴中迷航而来到这个小岛。这些人中包括Gilligan,船长，一个百万富翁（Thurston Howell三世）和他的太太（Lovey Howell），一个电影明星（Ginger Grant）,一个教授和Mary Ann。Gilligan是船上的大副。大多数情节是写他们如何弃岛求生，不过他们的努力总是因为Gillian的失误而失败。


