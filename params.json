{"name":"Perldoc-cn","tagline":"Perldoc Help Chinese Planning","body":"# TITLE\r\n\r\nSynopsis 5: Regexes and Rules\r\n\r\n# VERSION\r\n\r\n    Created: 24 Jun 2002\r\n\r\n    Last Modified: 22 Jul 2014\r\n    Version: 176\r\n\r\nThis document summarizes Apocalypse 5, which is about the new regex\r\nsyntax.  We now try to call them `regex` rather than \"regular\r\nexpressions\" because they haven't been regular expressions for a\r\nlong time, and we think the popular term \"regex\" is in the process of\r\nbecoming a technical term with a precise meaning of: \"something you do\r\npattern matching with, kinda like a regular expression\".  On the other\r\nhand, one of the purposes of the redesign is to make portions of\r\nour patterns more amenable to analysis under traditional regular\r\nexpression and parser semantics, and that involves making careful\r\ndistinctions between which parts of our patterns and grammars are\r\nto be treated as declarative, and which parts as procedural.\r\n\r\nIn any case, when referring to recursive patterns within a grammar,\r\nthe terms `rule` and `token` are generally preferred over `regex`.\r\n\r\n# Overview\r\n\r\nIn essence, Perl-6 natively implements Parsing Expression Grammars (PEGs)\r\nas an extension of regular expression notation. PEGs require that you\r\nprovide a \"pecking order\" for ambiguous parses. Perl-6's pecking order\r\nis determined by a multi-level tie-breaking test:\r\n\r\n    1) Longest token matching: food\\s+ beats foo by 2 or more positions\r\n    2) Longest literal prefix: food\\w* beats foo\\w* by 1 position\r\n    3) Declaration from most-derived grammar beats less-derived\r\n    4) Within a given compilation unit, earlier declaration wins\r\n    5) (Conjectural) Declaration with least number of 'uses' wins\r\n\r\nNote that tiebreaker #5 can occur only when a grammar is monkey-patched\r\nfrom another compilation unit.  Like #3, it privileges local declarations\r\nover distant ones.\r\n\r\nIn addition to this pecking order, if any rule chosen under the pecking\r\nbacktracks, the next best rule is chosen.  That is, the pecking order\r\ndetermines a candidate list; just because one candidate is chosen does not\r\nmean the rest are thrown away.  They may, however, be explicitly thrown away\r\nby an appropriate backtracking control (sometimes called a \"cut\" operator,\r\nbut Perl 6 has several of them, depending on how much you want to cut).\r\n\r\n# New match result and capture variables\r\n\r\nThe underlying match object is now available via the `$/`\r\nvariable, which is implicitly lexically scoped. All user access to the\r\nmost recent match is through this variable, even when\r\nit doesn't look like it.  The individual capture variables (such as `$0`,\r\nC<$1>, etc.) are just elements of `$/`.\r\n\r\nBy the way, unlike in Perl 5, the numbered capture variables now\r\nstart at `$0` instead of C<$1>.  See below.\r\n\r\nIn order to detect accidental use of Perl 5's unrelated `$/`\r\nvariable, Perl 6's `$/` variable may not be assigned to directly.\r\n\r\n    $/ = $x;   # \"Unsupported use of $/ variable as input record separator\"\r\n    $/ := $x;  # OK, binding\r\n    $/ RR= $x; # OK, metaoperator\r\n    ($/) = $x; # OK, list assignment\r\n\r\n# Unchanged syntactic features\r\n\r\nThe following regex features use the same syntax as in Perl 5:\r\n\r\nCapturing: (...)\r\n\r\nRepetition quantifiers: *, +, and ?\r\n\r\nAlternatives:  |\r\n\r\nBackslash escape:  \\\r\n\r\nMinimal matching suffix: ??,  *?,  +?\r\n\r\nWhile the syntax of `|` does not change, the default semantics do\r\nchange slightly.  We are attempting to concoct a pleasing mixture\r\nof declarative and procedural matching so that we can have the\r\nbest of both.  In short, you need not write your own tokener for\r\na grammar because Perl will write one for you.  See the section\r\nbelow on \"Longest-token matching\".\r\n\r\n# Simplified lexical parsing of patterns\r\n\r\nUnlike traditional regular expressions, Perl 6 does not require\r\nyou to memorize an arbitrary list of metacharacters.  Instead it\r\nclassifies characters by a simple rule.  All glyphs (graphemes)\r\nwhose base characters are either the underscore (`_`) or have\r\na Unicode classification beginning with 'L' (i.e. letters) or 'N'\r\n(i.e. numbers) are always literal (i.e. self-matching) in regexes. They\r\nmust be escaped with a `\\` to make them metasyntactic (in which\r\ncase that single alphanumeric character is itself metasyntactic,\r\nbut any immediately following alphanumeric character is not).\r\n\r\nAll other glyphs--including whitespace--are exactly the opposite:\r\nthey are always considered metasyntactic (i.e. non-self-matching) and\r\nmust be escaped or quoted to make them literal.  As is traditional,\r\nthey may be individually escaped with `\\`, but in Perl 6 they may\r\nbe also quoted as follows.\r\n\r\nSequences of one or more glyphs of either type (i.e. any glyphs at all)\r\nmay be made literal by placing them inside single quotes.  (Double\r\nquotes are also allowed, with the same interpolative semantics as\r\nthe current language in which the regex is lexically embedded.)\r\nQuotes create a quantifiable atom, so while\r\n\r\n    moose*\r\n\r\nquantifies only the 'e' and matches \"mooseee\", saying\r\n\r\n    'moose'*\r\n\r\nquantifies the whole string and would match \"moosemoose\".\r\n\r\nHere is a table that summarizes the distinctions:\r\n\r\n                 Alphanumerics        Non-alphanumerics         Mixed\r\n\r\n Literal glyphs   a    1    _        \\*  \\$  \\.   \\\\   \\'       K\\-9\\!\r\n Metasyntax      \\a   \\1   \\_         *   $   .    \\    '      \\K-\\9!\r\n Quoted glyphs   'a'  '1'  '_'       '*' '$' '.' '\\\\' '\\''     'K-9!'\r\n\r\nIn other words, identifier glyphs are literal (or metasyntactic when\r\nescaped), non-identifier glyphs are metasyntactic (or literal when\r\nescaped), and single quotes make everything inside them literal.\r\n\r\nNote, however, that not all non-identifier glyphs are currently\r\nmeaningful as metasyntax in Perl 6 regexes (e.g. `\\1` C<\\_> C<->\r\nC<!>). It is more accurate to say that all unescaped non-identifier\r\nglyphs are `potential` metasyntax, and reserved for future use.\r\nIf you use such a sequence, a helpful compile-time error is issued\r\nindicating that you either need to quote the sequence or define a new\r\noperator to recognize it.\r\n\r\nThe semicolon character is specifically reserved as a non-meaningful\r\nmetacharacter; if an unquoted semicolon is seen, the compiler will\r\ncomplain that the regex is missing its terminator.\r\n\r\n# Modifiers\r\n\r\nThe extended syntax (C</x>) is no longer required...it's the default.\r\n(In fact, it's pretty much mandatory--the only way to get back to\r\nthe old syntax is with the C<:Perl5>/C<:P5> modifier.)\r\n\r\nThere are no `/s` or `/m` modifiers (changes to the meta-characters\r\nreplace them - see below).\r\n\r\nThere is no `/e` evaluation modifier on substitutions; instead use:\r\n\r\n     s/pattern/{ doit() }/\r\n\r\nor:\r\n\r\n     s[pattern] = doit()\r\n\r\nInstead of `/ee` say:\r\n\r\n     s/pattern/{ EVAL doit() }/\r\n\r\nor:\r\n\r\n     s[pattern] = doit().EVAL\r\n\r\nModifiers are now placed as adverbs at the `start` of a match/substitution:\r\n\r\n     m:g:i/\\s* (\\w*) \\s* ,?/;\r\n\r\nEvery modifier must start with its own colon.  The delimiter must be\r\nseparated from the final modifier by whitespace if it would otherwise be taken\r\nas an argument to the preceding modifier (which is true if and only if\r\nthe next character is a left parenthesis.)\r\n\r\nThe single-character modifiers also have longer versions:\r\n\r\n         :i        :ignorecase\r\n         :m        :ignoremark\r\n         :g        :global\r\n         :r        :ratchet\r\n\r\nThe `:i` (or C<:ignorecase>) modifier causes case distinctions to be\r\nignored in its lexical scope, but not in its dynamic scope.  That is,\r\nsubrules always use their own case settings.  The amount of case folding\r\ndepends on the current context.  In byte and codepoint mode, level 1 case folding\r\nis required (as defined in TR18 section 2.4).  In grapheme mode level 2 is\r\nrequired.\r\n\r\nThe `:ii` (or `:samecase`) variant may be used on a substitution to change the\r\nsubstituted string to the same case pattern as the matched string.  It implies\r\nthe same pattern semantics as `:i` above, so it is not necessary to\r\nput both `:i` and `:ii`.\r\n\r\nIf the pattern is matched without the `:sigspace` modifier, case\r\ninfo is carried across on a character by character basis.  If the\r\nright string is longer than the left one, the case of the final\r\ncharacter is replicated.  Titlecase is carried across if possible\r\nregardless of whether the resulting letter is at the beginning of\r\na word or not; if there is no titlecase character available, the\r\ncorresponding uppercase character is used.  (This policy can be\r\nmodified within a lexical scope by a language-dependent Unicode\r\ndeclaration to substitute titlecase according to the orthographic\r\nrules of the specified language.)  Characters that carry no case\r\ninformation leave their corresponding replacement character unchanged.\r\n\r\nIf the pattern is matched with `:sigspace`, then a slightly smarter\r\nalgorithm is used which attempts to determine if there is a uniform\r\ncapitalization policy over each matched word, and applies the same\r\npolicy to each replacement word.  If there doesn't seem to be a uniform\r\npolicy on the left, the policy for each word is carried over word by\r\nword, with the last pattern word replicated if necessary.  If a word\r\ndoes not appear to have a recognizable policy, the replacement word\r\nis translated character for character as in the non-sigspace case.\r\nRecognized policies include:\r\n\r\n    lc()\r\n    uc()\r\n    tc()\r\n    tclc()\r\n    tcuc()\r\n\r\nIn any case, only the officially matched string part of the pattern\r\nmatch counts, so any sort of lookahead or contextual matching is not\r\nincluded in the analysis.\r\n\r\nThe `:m` (or C<:ignoremark>) modifier scopes exactly like C<:ignorecase>\r\nexcept that it ignores marks (accents and such) instead of case.  It is equivalent\r\nto taking each grapheme (in both target and pattern), converting\r\nboth to NFD (maximally decomposed) and then comparing the two base\r\ncharacters (Unicode non-mark characters) while ignoring any trailing\r\nmark characters.  The mark characters are ignored only for the purpose\r\nof determining the truth of the assertion; the actual text matched\r\nincludes all ignored characters, including any that follow the final\r\nbase character.\r\n\r\nThe `:mm` (or C<:samemark>) variant may be used on a substitution to change the\r\nsubstituted string to the same mark/accent pattern as the matched string.\r\nIt implies the same pattern semantics as `:m` above, so it is not necessary\r\nto put both `:m` and `:mm`.\r\n\r\nMark info is carried across on a character by character basis.  If\r\nthe right string is longer than the left one, the remaining characters\r\nare substituted without any modification.  (Note that NFD/NFC distinctions\r\nare usually immaterial, since Perl encapsulates that in grapheme mode.)\r\nUnder `:sigspace` the preceding rules are applied word by word.\r\n\r\nThe `:c` (or C<:continue>) modifier causes the pattern to continue\r\nscanning from the specified position (defaulting to C<($/ ?? $/.to !! 0)>):\r\n\r\n     m:c($p)/ pattern /     # start scanning at position $p\r\n\r\nNote that this does not automatically anchor the pattern to the starting\r\nlocation.  (Use `:p` for that.)  The pattern you supply to `split`\r\nhas an implicit `:c` modifier.\r\n\r\nString positions are of type `StrPos` and should generally be treated\r\nas opaque.\r\n\r\nThe `:p` (or C<:pos>) modifier causes the pattern to try to match only at\r\nthe specified string position:\r\n\r\n     m:pos($p)/ pattern /  # match at position $p\r\n\r\nIf the argument is omitted, it defaults to C<($/ ?? $/.to !! 0)>.  (Unlike in\r\nPerl 5, the string itself has no clue where its last match ended.)\r\nAll subrule matches are implicitly passed their starting position.\r\nLikewise, the pattern you supply to a Perl macro's C<is parsed>\r\ntrait has an implicit `:p` modifier.\r\n\r\nNote that\r\n\r\n     m:c($p)/pattern/\r\n\r\nis roughly equivalent to\r\n\r\n     m:p($p)/.*? <( pattern )> /\r\n\r\nAll of `:g`, C<:ov>, `:nth`, and C<:x> are incompatible with `:p` and\r\nwill fail, recommending use of `:c` instead.  The C<:ex> modifier is allowed\r\nbut will produce only matches at that position.\r\n\r\nThe new `:s` (`:sigspace`) modifier causes certain whitespace sequences\r\nto be considered \"significant\"; they are replaced by a whitespace\r\nmatching rule, C<< <.ws> >>.  Only whitespace sequences immediately following a\r\nmatching construct (atom, quantified atom, or assertion) are eligible.\r\nHence, initial whitespace is ignored at the front of\r\nany regex, to make it easy to write rules that can participate in longest-token-matching\r\nalternations.  That is,\r\n\r\n     m:s/ next cmd '=' <condition>/\r\n\r\nis the same as:\r\n\r\n     m/ next <.ws> cmd <.ws> '=' <.ws> <condition>/\r\n\r\nwhich is effectively the same as:\r\n\r\n     m/ next \\s+ cmd \\s* '=' \\s* <condition>/\r\n\r\nBut in the case of\r\n\r\n     m:s{(a|\\*) (b|\\+)}\r\n\r\nor equivalently,\r\n\r\n     m { (a|\\*) <.ws> (b|\\+) }\r\n\r\nC<< <.ws> >> can't decide what to do until it sees the data.\r\nIt still does the right thing.  If not, define your own C<< ws >>\r\nand `:sigspace` will use that.\r\n\r\nWhitespace is ignored not just at the front of any rule that might\r\nparticipate in longest-token matching, but in the front of any\r\nalternative within an explicit alternation as well, for the same\r\nreason.  If you want to match sigspace before a set of alternatives,\r\nplace your whitespace outside of the brackets containing the alternation.\r\n\r\nWhen you write\r\n\r\n    rule TOP { ^ <stuff> $ }\r\n\r\nthis is the same as\r\n\r\n    token TOP { ^ <.ws> <stuff> <.ws> $ <.ws> }\r\n\r\nbut note that the final C<< <.ws> >> always matches the null string, since `$` asserts end of string.\r\nAlso, if your `TOP` rule does not anchor with C<^>, it might not match initial whitespace.\r\n\r\nSpecifically, the following constructs turn following whitespace into sigspace:\r\n\r\n    any atom or quantified atom\r\n    $foo @bar\r\n    'a' \"$b\"\r\n    ^ $ ^^ $$\r\n    (...) [...] <...> as a whole atoms\r\n    (...)* [...]* <...>* as quantified atoms\r\n    <( and )>\r\n    « and » (but don't use « that way!)\r\n\r\nand these do not:\r\n\r\n    opening ( or [\r\n    | or ||\r\n    & or &&\r\n    ** % or %%\r\n    :foo declarations, including :my and :sigspace itself\r\n    {...}\r\n\r\nWhen we say sigspace can follow either an atom or a quantified atom, we\r\nmean that it can come between an atom and its quantifier:\r\n\r\n    ms/ <atom> * /      # means / [<atom><.ws>]* /\r\n\r\n(If each atom matches whitespace, then it doesn't need to match after the\r\nquantifier.)\r\n\r\nIn general you don't need to use `:sigspace` within grammars because\r\nthe parser rules automatically handle whitespace policy for you.\r\nIn this context, whitespace often includes comments, depending on\r\nhow the grammar chooses to define its whitespace rule.  Although the\r\ndefault C<< <.ws> >> subrule recognizes no comment construct, any\r\ngrammar is free to override the rule.  The C<< <.ws> >> rule is not\r\nintended to mean the same thing everywhere.\r\n\r\nIt's also possible to pass an argument to `:sigspace` specifying\r\na completely different subrule to apply.  This can be any rule, it\r\ndoesn't have to match whitespace.  When discussing this modifier, it is\r\nimportant to distinguish the significant whitespace in the pattern from\r\nthe \"whitespace\" being matched, so we'll call the pattern's whitespace\r\n`sigspace`, and generally reserve `whitespace` to indicate whatever\r\nC<< <.ws> >> matches in the current grammar. The correspondence\r\nbetween sigspace and whitespace is primarily metaphorical, which is\r\nwhy the correspondence is both useful and (potentially) confusing.\r\n\r\nThe `:ss` (or `:samespace`) variant may be used on substitutions to\r\ndo smart space mapping in addition to smart space matching.  (That is,\r\n`:ss` implies `:s`.)  For each sigspace-induced call to C<< <ws> >>\r\non the left, the matched whitespace is copied over to the corresponding\r\nslot on the right, as represented by a single whitespace character\r\nin the replacement string wherever space replacement is desired.\r\nIf there are more whitespace slots on the right than the left, those\r\nrighthand characters remain themselves.  If there are not enough\r\nwhitespace slots on the right to map all the available whitespace\r\nslots from the match, the algorithm tries to minimize information\r\nloss by randomly splicing \"common\" whitespace characters out of the\r\nlist of whitespace.  From least valuable to most, the pecking order is:\r\n\r\n    spaces\r\n    tabs\r\n    all other horizontal whitespace, including Unicode\r\n    newlines (including crlf as a unit)\r\n    all other vertical whitespace, including Unicode\r\n\r\nThe primary intent of these rules is to minimize format disruption\r\nwhen substitution happens across line boundaries and such.  There is,\r\nof course, no guarantee that the result will be exactly what a human would\r\ndo.\r\n\r\nThe `:s` modifier is considered sufficiently important that\r\nmatch variants are defined for them:\r\n\r\n    ms/match some words/                        # same as m:sigspace\r\n    ss/match some words/replace those words/    # same as s:samespace\r\n\r\nNote that `ss///` is defined in terms of `:ss`, so:\r\n\r\n    $_ = \"a b\\nc\\td\";\r\n    ss/b c d/x y z/;\r\n\r\nends up with a value of \"C<a x\\ny\\tz>\".\r\n\r\nNew modifiers specify Unicode level:\r\n\r\n     m:bytes  / .**2 /       # match two bytes\r\n     m:codes  / .**2 /       # match two codepoints\r\n     m:graphs / .**2 /       # match two language-independent graphemes\r\n     m:chars  / .**2 /       # match two characters at current max level\r\n\r\nThere are corresponding pragmas to default to these levels.  Note that\r\nthe C<:chars> modifier is always redundant because dot always matches\r\ncharacters at the highest level allowed in scope.  This highest level\r\nmay be identical to one of the other three levels, or it may be more\r\nspecific than C<:graphs> when a particular language's character rules\r\nare in use.  Note that you may not specify language-dependent character\r\nprocessing without specifying `which` language you're depending on.\r\n[Conjecture: the C<:chars> modifier could take an argument specifying\r\nwhich language's rules to use for this match.]\r\n\r\nThe new C<:Perl5>/C<:P5> modifier allows Perl 5 regex syntax to be\r\nused instead.  (It does not go so far as to allow you to put your\r\nmodifiers at the end.)  For instance,\r\n\r\n     m:P5/(?mi)^(?:[a-z]|\\d){1,2}(?=\\s)/\r\n\r\nis equivalent to the Perl 6 syntax:\r\n\r\n    m/ :i ^^ [ <[a..z]> || \\d ] ** 1..2 <?before \\s> /\r\n\r\nAny integer modifier specifies a count. What kind of count is\r\ndetermined by the character that follows.\r\n\r\nIf followed by an `x`, it means repetition.  Use C<:x(4)> for the\r\ngeneral form.  So\r\n\r\n     s:4x [ (<.ident>) '=' (\\N+) $$] = \"$0 => $1\";\r\n\r\nis the same as:\r\n\r\n     s:x(4) [ (<.ident>) '=' (\\N+) $$] = \"$0 => $1\";\r\n\r\nwhich is almost the same as:\r\n\r\n     s:c[ (<.ident>) '=' (\\N+) $$] = \"$0 => $1\" for 1..4;\r\n\r\nexcept that the string is unchanged unless all four matches are found.\r\nHowever, ranges are allowed, so you can say C<:x(1..4)> to change anywhere\r\nfrom one to four matches.\r\n\r\nIf the number is followed by an `st`, `nd`, `rd`, or `th`, it means\r\nfind the `N`th occurrence.  Use `:nth(3)` for the general form.  So\r\n\r\n     s:3rd/(\\d+)/@data[$0]/;\r\n\r\nis the same as\r\n\r\n     s:nth(3)/(\\d+)/@data[$0]/;\r\n\r\nwhich is the same as:\r\n\r\n     m/(\\d+)/ && m:c/(\\d+)/ && s:c/(\\d+)/@data[$0]/;\r\n\r\nThe argument to `:nth` is allowed to be a list of integers, but such a list\r\nshould be monotonically increasing.  (Values which are less than or equal to\r\nany previous value will be ignored.)  So:\r\n\r\n    :nth(2,4,6...*)    # return only even matches\r\n    :nth(1,1,*+*...*)  # match only at 1,2,3,5,8,13...\r\n\r\nThis option is no longer required to support smartmatching.  You can grep a list\r\nof integers if you really need that capability:\r\n\r\n    :nth(grep *.oracle, 1..*)\r\n\r\nIf both `:nth` and C<:x> are present, the matching routine looks for submatches\r\nthat match with `:nth`. If the number of post-nth matches is compatible with\r\nthe constraint in C<:x>, the whole match succeeds with the highest possible\r\nnumber of submatches. The combination of `:nth` and C<:x> typically only\r\nmakes sense if `:nth` is not a single scalar.\r\n\r\nWith the new C<:ov> (C<:overlap>) modifier, the current regex will\r\nmatch at all possible character positions (including overlapping)\r\nand return all matches in list context, or a disjunction of matches\r\nin item context.  The first match at any position is returned.\r\nThe matches are guaranteed to be returned in left-to-right order with\r\nrespect to the starting positions.\r\n\r\n     $str = \"abracadabra\";\r\n\r\n     if $str ~~ m:overlap/ a (.*) a / {\r\n         @substrings = slice @();    # bracadabr cadabr dabr br\r\n     }\r\n\r\nWith the new C<:ex> (C<:exhaustive>) modifier, the current regex will\r\nmatch every possible way (including overlapping) and return a list of\r\nall matches.\r\n\r\nThe matches are guaranteed to be returned in left-to-right order with\r\nrespect to the starting positions.  The order within each starting\r\nposition is not guaranteed and may depend on the nature of both the\r\npattern and the matching engine.  (Conjecture: or we could enforce\r\nbacktracking engine semantics.  Or we could guarantee no order at all\r\nunless the pattern starts with \"::\" or some such to suppress DFAish\r\nsolutions.)\r\n\r\n     $str = \"abracadabra\";\r\n\r\n     if $str ~~ m:exhaustive/ a (.*?) a / {\r\n         say \"@()\";    # br brac bracad bracadabr c cad cadabr d dabr br\r\n     }\r\n\r\nNote that the C<~~> above can return as soon as the first match is found,\r\nand the rest of the matches may be performed lazily by C<@()>.\r\n\r\nThe new C<:rw> modifier causes this regex to `claim` the current\r\nstring for modification rather than assuming copy-on-write semantics.\r\nAll the captures in `$/` become lvalues into the string, such\r\nthat if you modify, say, C<$1>, the original string is modified in\r\nthat location, and the positions of all the other fields modified\r\naccordingly (whatever that means).  In the absence of this modifier\r\n(especially if it isn't implemented yet, or is never implemented),\r\nall pieces of `$/` are considered copy-on-write, if not read-only.\r\n\r\n[Conjecture: this should really associate a pattern with a string variable,\r\nnot a (presumably immutable) string value.]\r\n\r\nThe new C<:r> or C<:ratchet> modifier causes this regex to not backtrack by default.\r\n(Generally you do not use this modifier directly, since it's implied by\r\n`token` and `rule` declarations.)  The effect of this modifier is\r\nto imply a `:` after every atom, including but not limited to\r\n`*`, C<+>, and `?` quantifiers, as well as alternations.  Explicit\r\nbacktracking modifiers on quantified atoms, such as `**`, will override this.\r\n(Note: for portions of patterns subject to longest-token analysis, a `:`\r\nis ignored in any case, since there will be no backtracking necessary.)\r\n\r\nThe `:i`, `:m`, C<:r>, `:s`, `:dba`, C<:Perl5>, and Unicode-level modifiers can be\r\nplaced inside the regex (and are lexically scoped):\r\n\r\n     m/:s alignment '=' [:i left|right|cent[er|re]] /\r\n\r\nAs with modifiers outside, only parentheses are recognized as valid\r\nbrackets for args to the adverb.  In particular:\r\n\r\n    m/:foo[xxx]/        Parses as :foo [xxx]\r\n    m/:foo{xxx}/        Parses as :foo {xxx}\r\n    m/:foo<xxx>/        Parses as :foo <xxx>\r\n\r\nUser-defined modifiers will be possible:\r\n\r\n         m:fuzzy/pattern/;\r\n\r\nUser-defined modifiers can also take arguments, but only in parentheses:\r\n\r\n         m:fuzzy('bare')/pattern/;\r\n\r\nTo use parens for your delimiters you have to separate:\r\n\r\n         m:fuzzy (pattern);\r\n\r\nor you'll end up with:\r\n\r\n         m:fuzzy(fuzzyargs); pattern ;\r\n\r\nAny grammar regex is really just a kind of method, and you may\r\ndeclare variables in such a routine using a colon followed by any\r\nscope declarator parsed by the Perl 6 grammar, including `my`,\r\n`our`, `state`, and `constant`.  (As quasi declarators, `temp`\r\nand `let` are also recognized.)  A single statement (up through\r\na terminating semicolon or line-final closing brace) is parsed as normal Perl-6 code:\r\n\r\n    token prove-nondeterministic-parsing {\r\n        :my $threshold = rand;\r\n        'maybe' \\s+ <it($threshold)>\r\n    }\r\n\r\nSuch declarations do not terminate longest-token-matching,\r\nso an otherwise useless declaration may be used as a peg\r\nto hang side effects on without changing how the subsequent\r\npattern matches:\r\n\r\n    rule breaker {\r\n        :state $ = say \"got here at least once\";\r\n        ...\r\n    }\r\n\r\n=head2 Allowed modifiers\r\n\r\nSome modifiers are allowed in all possible places where modifiers can occur,\r\nbut not all of them.\r\n\r\nIn general, a modifier that affects the compilation of a regex (like `:i`)\r\nmust be known at compile time. A modifier that affects only the calling\r\nbehaviour, and not the regex itself (eg. C<:pos>, C<:overlap>, C<:x(4)>) may\r\nonly appear on constructs that involve a call (like `m//` and `s///`), and\r\nnot on C<rx//>. Finally overlapping is disallowed on substitutions, while\r\nadverbs that affect modifications (eg. `:samecase`) are only allowed on\r\nsubstitutions.\r\n\r\nThese principle result in the following rules:\r\n\r\nThe C<:ignorecase>, C<:ignoremark>, `:sigspace`, C<:ratchet> and C<:Perl5>\r\nmodifiers and their short forms are allowed everywhere: inside a regex,\r\nand on `m//`, C<rx//> and `s///` constructs. An implementation may require\r\nthat their value is known at compile time, and give a compile-time error\r\nmessage if that is not the case.\r\n\r\n    rx:i/ hello /           # OK\r\n    rx:i(1) /hello/         # OK\r\n    my $i = 1;\r\n    rx:i($i) /hello/        # may error out at compile time\r\n\r\nThe `:samecase`, `:samespace` and C<:samemark> modifiers (and their short\r\nforms) are only allowed on substitutions (`s///` and C<s[] = ...>).\r\n\r\nThe C<:overlap> and C<:exhaustive> modifiers (and their short forms) are only\r\nallowed on matches (ie `m//`), not on substitutions or regex quotes.\r\n\r\nThe C<:pos>, C<:continue>, C<:x> and `:nth` modifiers and their aliases are\r\nonly allowed on constructs that involve immediate calls, eg. `m//` and `s///`\r\n(but not on C<rx//>).\r\n\r\nThe `:dba` adverb is only allowed inside a regex.\r\n\r\n# Changed metacharacters\r\n\r\nA dot `.` now matches `any` character including newline. (The `/s`\r\nmodifier is gone.)\r\n\r\nC<^> and `$` now always match the start/end of a string, like the old\r\nC<\\A> and C<\\z>. (The `/m` modifier is gone.)  On the right side of\r\nan embedded C<~~> or C<!~~> operator they always match the start/end\r\nof the indicated submatch because that submatch is logically being\r\ntreated as a separate string.\r\n\r\nA `$` no longer matches an optional preceding `\\n` so it's necessary\r\nto say C<\\n?$> if that's what you mean.\r\n\r\n`\\n` now matches a logical (platform independent) newline, not just C<\\x0a>.\r\nSee TR18 section 1.6 for a list of logical newlines.\r\n\r\nThe C<\\A>, C<\\Z>, and C<\\z> metacharacters are gone.\r\n\r\n# New metacharacters\r\n\r\nBecause C</x> is default:\r\n\r\nAn unquoted C<#> now always introduces a comment.  If followed\r\nby a backtick and an opening bracket character,\r\nit introduces an embedded comment that terminates with the closing\r\nbracket.  Otherwise the comment terminates at the newline.\r\n\r\nWhitespace is now always metasyntactic, i.e. used only for layout\r\nand not matched literally (but see the `:sigspace` modifier described above).\r\n\r\nC<^^> and `$$` match line beginnings and endings. (The `/m`\r\nmodifier is gone.)  They are both zero-width assertions.  `$$`\r\nmatches before any `\\n` (logical newline), and also at the end of\r\nthe string if the final character was `not` a `\\n`.  C<^^> always\r\nmatches the beginning of the string and after any `\\n` that is not\r\nthe final character in the string.\r\n\r\n`.` matches an `anything`, while C<\\N> matches an I<anything except\r\nwhat `\\n` matches>. (The `/s` modifier is gone.)  In particular, C<\\N> matches\r\nneither carriage return nor line feed.\r\n\r\nThe new `&` metacharacter separates conjunctive terms.  The patterns\r\non either side must match with the same beginning and end point.\r\nNote: if you don't want your two terms to end at the same point,\r\nthen you really want to use a lookahead instead.\r\n\r\nAs with the disjunctions `|` and `||`, conjunctions come in both\r\n`&` and `&&` forms.  The `&` form is considered declarative rather than\r\nprocedural; it allows the compiler and/or the\r\nrun-time system to decide which parts to evaluate first, and it is\r\nerroneous to assume either order happens consistently.  The `&&`\r\nform guarantees left-to-right order, and backtracking makes the right\r\nargument vary faster than the left.  In other words, `&&` and `||` establish\r\nsequence points.  The left side may be backtracked into when backtracking\r\nis allowed into the construct as a whole.\r\n\r\nThe `&` operator is list associative like `|`, but has slightly\r\ntighter precedence.  Likewise `&&` has slightly tighter precedence\r\nthan `||`.  As with the normal junctional and short-circuit operators,\r\n`&` and `|` are both tighter than `&&` and `||`.\r\n\r\nThe C<~~> and C<!~~> operators cause a submatch to be performed on\r\nwhatever was matched by the variable or atom on the left.  String\r\nanchors consider that submatch to be the entire string.  So, for\r\ninstance, you can ask to match any identifier that does not contain\r\nthe word \"moose\":\r\n\r\n    <ident> !~~ 'moose'\r\n\r\nIn contrast\r\n\r\n    <ident> !~~ ^ 'moose' $\r\n\r\nwould allow any identifier (including any identifier containing\r\n\"moose\" as a substring) as long as the identifier as a whole is not\r\nequal to \"moose\". (Note the anchors, which attach the submatch to the\r\nbeginning and end of the identifier as if that were the entire match.)\r\nWhen used as part of a longer match, for clarity it might be good to\r\nuse extra brackets:\r\n\r\n    [ <ident> !~~ ^ 'moose' $ ]\r\n\r\nThe precedence of C<~~> and C<!~~> fits in between the junctional and\r\nsequential versions of the logical operators just as it does in normal\r\nPerl expressions (see S03).  Hence\r\n\r\n    <ident> !~~ 'moose' | 'squirrel'\r\n\r\nparses as\r\n\r\n    <ident> !~~ [ 'moose' | 'squirrel' ]\r\n\r\nwhile\r\n\r\n    <ident> !~~ 'moose' || 'squirrel'\r\n\r\nparses as\r\n\r\n    [ <ident> !~~ 'moose' ] || 'squirrel'\r\n\r\nThe C<~> operator is a helper for matching nested subrules with a\r\nspecific terminator as the goal.  It is designed to be placed between an\r\nopening and closing bracket, like so:\r\n\r\n    '(' ~ ')' <expression>\r\n\r\nHowever, it mostly ignores the left argument, and operates on the next\r\ntwo atoms (which may be quantified).  Its operation on those next\r\ntwo atoms is to \"twiddle\" them so that they are actually matched in\r\nreverse order.  Hence the expression above, at first blush, is merely\r\nshorthand for:\r\n\r\n    '(' <expression> ')'\r\n\r\nBut beyond that, when it rewrites the atoms it also inserts the\r\napparatus that will set up the inner expression to recognize the\r\nterminator, and to produce an appropriate error message if the\r\ninner expression does not terminate on the required closing atom.\r\nSo it really does pay attention to the left bracket as well, and it\r\nactually rewrites our example to something more like:\r\n\r\n    $<OPEN> = '(' <SETGOAL: ')'> <expression> [ $GOAL || <FAILGOAL> ]\r\n\r\nNote that you can use this construct to set up expectations for\r\na closing construct even when there's no opening bracket:\r\n\r\n    <?> ~ ')' \\d+\r\n\r\nHere <?> returns true on the first null string.\r\n\r\nBy default the error message uses the name of the current rule as an\r\nindicator of the abstract goal of the parser at that point.  However,\r\noften this is not terribly informative, especially when rules are named\r\naccording to an internal scheme that will not make sense to the user.\r\nThe C<:dba(\"doing business as\")> adverb may be used to set up a more informative name for\r\nwhat the following code is trying to  parse:\r\n\r\n    token postfix:sym<[ ]> {\r\n        :dba('array subscript')\r\n        '[' ~ ']' <expression>\r\n    }\r\n\r\nThen instead of getting a message like:\r\n\r\n    Unable to parse expression in postfix:sym<[ ]>; couldn't find final ']'\r\n\r\nyou'll get a message like:\r\n\r\n    Unable to parse expression in array subscript; couldn't find final ']'\r\n\r\n(The `:dba` adverb may also be used to give names to alternations\r\nand alternatives, which helps the lexer give better error messages.)\r\n\r\n# Bracket rationalization\r\n\r\n`(...)` still delimits a capturing group. However the ordering of these\r\ngroups is hierarchical rather than linear. See L<Nested subpattern captures>.\r\n\r\n`[...]` is no longer a character class.\r\nIt now delimits a non-capturing group.\r\n\r\nA character class is now specified using C<< <[...]> >>.\r\nSee also L<Extensible metasyntax (C<< <...> >>)>.\r\n\r\n`{...}` is no longer a repetition quantifier.\r\nIt now delimits an embedded closure.  It is always considered\r\nprocedural rather than declarative; it establishes a sequence point\r\nbetween what comes before and what comes after.  (To avoid this\r\nuse the C<< <?{...}> >> assertion syntax instead.)  A closure\r\nwithin a regex establishes its own lexical scope.\r\n\r\nYou can call Perl code as part of a regex match by using a closure.\r\nEmbedded code does not usually affect the match--it is only used\r\nfor side-effects:\r\n\r\n     / (\\S+) { print \"string not blank\\n\"; $text = $0; }\r\n        \\s+  { print \"but does contain whitespace\\n\" }\r\n     /\r\n\r\nAn B<explicit> reduction using the `make` function generates the\r\nI<abstract syntax tree> object (I<abstract object> or `ast` for short)\r\nfor this match:\r\n\r\n        / (\\d) { make $0.sqrt } Remainder /;\r\n\r\nThis has the effect of capturing the square root of the numified\r\nstring, instead of the string.  The `Remainder` part is matched and\r\nreturned as part of the `Match` object but is not returned\r\nas part of the abstract object.  Since the abstract object usually\r\nrepresents the top node of an abstract syntax tree, the abstract object\r\nmay be extracted from the `Match` object by use of the `.made` method.\r\n\r\nA second call to `make` overrides any previous call to `make`.\r\n`make` is also available as a method on each match object.\r\n\r\nWithin a closure, the instantaneous\r\nposition within the search is denoted by the C<$¢.pos> method.\r\nAs with all string positions, you must not treat it\r\nas a number unless you are very careful about which units you are\r\ndealing with.\r\n\r\nThe `Cursor` object can also return the original item that we are\r\nmatching against; this is available from the C<.orig> method.\r\n\r\nThe closure is also guaranteed to start with a `$/` `Match` object\r\nrepresenting the match so far.  However, if the closure does its own\r\ninternal matching, its `$/` variable will be rebound to the result\r\nof `that` match until the end of the embedded closure.  (The match\r\nwill actually continue with the current value of the C<$¢> object after\r\nthe closure.  `$/` and C<$¢> just start out the same in your closure.)\r\n\r\nIt can affect the match if it calls `fail`:\r\n\r\n     / (\\d+) { $0 < 256 or fail } /\r\n\r\nSince closures establish a sequence point, they are guaranteed to be\r\ncalled at the canonical time even if the optimizer could prove that\r\nsomething after them can't match.  (Anything before is fair game,\r\nhowever.  In particular, a closure often serves as the terminator\r\nof a longest-token pattern.)\r\n\r\nThe general repetition specifier is now `**` for greedy matching,\r\nwith a corresponding `**?` for frugal matching.  (All such quantifier\r\nmodifiers now go directly after the `**`.)  Space is allowed on either\r\nside of the complete quantifier, but only the space before the `**` will\r\nbe considered significant under `:sigspace` and match between repetitions.\r\n(Sigspace after the entire construct matches once after the all repetitions\r\nare found.)\r\n\r\nThe next token constrains how many times the pattern on the left must match.\r\n\r\nIf the next thing is an integer, then it is parsed as either as an exact\r\ncount or a range:\r\n\r\n    . ** 42                  # match exactly 42 times\r\n    <item> ** 3..*           # match 3 or more times\r\n\r\nThis form is considered declarational.\r\n\r\nIf you supply a closure, it should return either an `Int` or a `Range` object.\r\n\r\n    'x' ** {$m}              # exact count returned from closure\r\n    <foo> ** {$m..$n}        # range returned from closure\r\n\r\n    / value was (\\d **? {1..6}) with ([ <alpha>\\w* ]**{$m..$n}) /\r\n\r\nIt is illegal to return a list, so this easy mistake fails:\r\n\r\n    / [foo] ** {1,3} /\r\n\r\nThe closure form is always considered procedural, so the item it is\r\nmodifying is never considered part of the longest token.\r\n\r\nFor backwards compatibility with previous versions of Perl-6, if the token\r\nfollowing ** is not a closure or literal integer, it is interpreted as +%\r\nwith a warning:\r\n\r\n   / x ** y /                # same as / x+ % y /\r\n   / x ** $y /               # same as / x [$y x]* /\r\n\r\nNo check is made to see if $y contains an integer or range value.  This\r\ncompatibility feature is not guaranteed to exist forever.\r\n\r\nNegative range values are allowed, but only when modifying a reversible\r\npattern (such as `after` could match).  For example, to search the\r\nsurrounding 200 characters as defined by 'dot', you could say:\r\n\r\n    / . ** -100..100 <element> /\r\n\r\nSimilarly, you can back up 50 characters with:\r\n\r\n    / . ** -50 <element> /\r\n\r\n[Conjecture: A negative quantifier forces the construct to be\r\nconsidered procedural rather than declarational.]\r\n\r\nAny quantified atom may be modified by an additional constraint that\r\nspecifies the separator to look for between repeats of the left side.\r\nThis is indicated by use of a C<%> between the quantifier and\r\nthe separator.  The initial item is iterated only as long as the\r\nseparator is seen between items:\r\n\r\n    <alt>+ % '|'            # repetition controlled by presence of character\r\n    <addend>+ % <addop>     # repetition controlled by presence of subrule\r\n    <item>+ % [ \\!?'==' ]   # repetition controlled by presence of operator\r\n    <file>+%\\h+             # repetition controlled by presence of whitespace\r\n\r\nAny quantifier may be so modified:\r\n\r\n    <a>* % ','              # 0 or more comma-separated elements\r\n    <a>+ % ','              # 1 or more\r\n    <a>? % ','              # 0 or 1 (but ',' never used!?!)\r\n    <a> ** 2..* % ','       # 2 or more\r\n\r\nThe C<%> modifier may only be used on a quantifier; any attempt\r\nto use it on a bare term will result in a parse error (to minimize\r\npossible confusion with any hash notations we choose to support in\r\nPerl 6 regexes).\r\n\r\nA successful match of a C<%> construct generally ends \"in the middle\" at the C<%>,\r\nthat is, after the initial item but before the next separator.\r\nTherefore\r\n\r\n    / <ident>+ % ',' /\r\n\r\ncan match\r\n\r\n    foo\r\n    foo,bar\r\n    foo,bar,baz\r\n\r\nbut never\r\n\r\n    foo,\r\n    foo,bar,\r\n\r\nThe only time such a match doesn't end in the middle is if the left\r\nside can match 0 times (and does so), in which case the whole construct\r\nmatches the null string.\r\n\r\n    '' ~~ / <ident>* % ',' /  # matches because of the *\r\n\r\nIf you wish to allow the match to end after either side, use C<%%> instead.\r\nTherefore\r\n\r\n    / <ident>+ %% ',' /\r\n\r\ncan match any of\r\n\r\n    foo\r\n    foo,\r\n    foo,bar\r\n    foo,bar,\r\n    foo,bar,baz\r\n    foo,bar,baz,\r\n\r\nIf you wish to quantify each match on the left individually, you must place it in brackets:\r\n\r\n    [<a>*]+ % ','\r\n\r\nIt is legal for the separator to be zero-width as long as the pattern on\r\nthe left progresses on each iteration:\r\n\r\n    .+ % <?same>   # match sequence of identical characters\r\n\r\nThe separator never matches independently of the next item; if the\r\nseparator matches but the next item fails, it backtracks all the way\r\nback through the separator.  Likewise, this matching of the separator\r\ndoes not count as \"progress\" under C<:ratchet> semantics unless the\r\nnext item succeeds.\r\n\r\nWhen significant space is used under `:sigspace`,\r\neach matching element enables the immediately following whitespace\r\nto be considered significant.  Space after the C<%> does nothing.  If you write:\r\n\r\n    ms/ <element> +  %  ',' /\r\n      #1        #2 #3 #4  #5\r\n\r\nit ignores whitespace #1 and #4, and rewrites the rest to:\r\n\r\n    / [ <element> <.ws> ]+ % [ ',' <.ws> ] <.ws> /\r\n                    #2               #5      #3\r\n\r\nSince #3 is redundant with #2 (because C<+> requires an element),\r\nit suffices to supply either #2 or #3:\r\n\r\n    ms/ <element>+ % ',' /    # ws after comma and at end\r\n    ms/ <element> +% ',' /    # ws after comma and any element\r\n\r\nSo the first\r\n\r\n    ms/ <element>+ % ',' /    # ws after comma and at end\r\n\r\nis like\r\n\r\n    / <element>[','<.ws><element>]*<.ws> /\r\n\r\nwhile the second\r\n\r\n    ms/ <element> +% ',' /    # ws after comma and any element\r\n\r\nis like\r\n\r\n    / <element><.ws>[','<.ws><element><.ws>]* /\r\n\r\nand\r\n\r\n    ms/ <element>+% ','/\r\n\r\nexcludes all significant whitespace like this:\r\n\r\n    / <element>[','<element>]* /\r\n\r\nNote that with a `*` instead of a C<+>, space #3 would not be\r\nredundant with #2, since if 0 elements are matched, the space\r\nassociated with it (#2) is not matched.  In that case it makes sense\r\nto put space on both sides of the `*`:\r\n\r\n    ms/ <element> * % ',' /\r\n\r\nC<< <...> >> are now extensible metasyntax delimiters or `assertions`\r\n(i.e. they replace Perl 5's crufty `(?...)` syntax).\r\n\r\n# Variable (non-)interpolation\r\n\r\nIn Perl 6 regexes, variables don't interpolate.\r\n\r\nInstead they're passed `raw` to the regex engine, which can then decide\r\nhow to handle them (more on that below).\r\n\r\nThe default way in which the engine handles a string scalar is to match it\r\nas a C<< \"...\" >> literal (i.e. it does not treat the interpolated string\r\nas a subpattern).  In other words, a Perl 6:\r\n\r\n     / $var /\r\n\r\nis like a Perl 5:\r\n\r\n     / \\Q$var\\E /\r\n\r\nTo interpolate a `Regex` object, use C<< <$var> >> instead.\r\n\r\nIf C<$var> is undefined, a warning is issued and the match fails.\r\n\r\nWhen matching against a Stringy type that is not Str, the variable must\r\nbe interpretable as a value of that Stringy type (or a related type\r\nthat can be coerced to that type).  For example, when regex matching a\r\nBuf type, the variable will be matched under the Buf type's semantics,\r\nnot Str semantics.\r\n\r\n[Conjecture: when we allow matching against non-string types, doing a\r\ntype match on the current node will require the syntax of an embedded\r\nsignature, not just a bare variable, so there is no need to account for\r\na variable containing a type object, which is by definition undefined,\r\nand hence fails to match by the above rule.]\r\n\r\nHowever, a variable used as the left side of an alias or submatch\r\noperator is not used for matching.\r\n\r\n    $x = <.ident>\r\n    $0 ~~ <.ident>\r\n\r\nIf you do want to match `$0` again and then use that as the submatch,\r\nyou can force the match using double quotes:\r\n\r\n    \"$0\" ~~ <.ident>\r\n\r\nOn the other hand, it is non-sensical to alias to something that is\r\nnot a variable:\r\n\r\n    \"$0\" = <.ident>     # ERROR\r\n    $0 = <.ident>       # okay\r\n    $x = <.ident>       # okay, temporary capture\r\n    $<x> = <.ident>     # okay, persistent capture\r\n    <x=.ident>          # same thing\r\n\r\nVariables declared in capture aliases are lexically scoped to the\r\nrest of the regex.  You should not confuse this use of C<=> with\r\neither ordinary assignment or ordinary binding.  You should read\r\nthe C<=> more like the pseudoassignment of a declarator than like\r\nnormal assignment.  It's more like the ordinary C<:=> operator,\r\nsince at the level regexes work, strings are immutable, so captures\r\nare really just precomputed substr values.  Nevertheless, when you\r\neventually use the values independently, the substr may be copied,\r\nand then it's more like it was an assignment originally.\r\n\r\nCapture variables of the form C<< $<ident> >> may persist beyond\r\nthe lexical scope; if the match succeeds they are remembered in the\r\n`Match` object's hash, with a key corresponding to the variable name's\r\nidentifier.  Likewise bound numeric variables persist as `$0`, etc.\r\n\r\nYou may capture to existing lexical variables; such variables may\r\nalready be visible from an outer scope, or may be declared within\r\nthe regex via a C<:my> declaration.\r\n\r\n    my $x; / $x = [...] /            # capture to outer lexical $x\r\n    / :my $x; $x = [...] /           # capture to our own lexical $x\r\n\r\nAn interpolated array:\r\n\r\n     / @cmds /\r\n\r\nis matched as if it were an alternation of its literal elements.  Ordinarily it\r\nmatches using junctive semantics:\r\n\r\n     / [ $(@cmds[0]) | $(@cmds[1]) | $(@cmds[2]) | ... ] /\r\n\r\nHowever, if it is a direct member of a `||` list, it uses sequential\r\nmatching semantics, even it's the only member of the list.  Conveniently,\r\nyou can put `||` before the first member of an alternation, hence\r\n\r\n     / || @cmds /\r\n\r\nis equivalent to\r\n\r\n     / [ $(@cmds[0]) || $(@cmds[1]) || $(@cmds[2]) || ... ] /\r\n\r\nOr course, you can also\r\n\r\n     / | @cmds /\r\n\r\nto be clear that you mean junctive semantics.\r\n\r\nNote the usage of $(...) to prevent the subscripts from being parsed as\r\nregex syntax rather than an actual subscript.\r\n\r\nSince C<$x> is interpolated as if you'd said C<\"$x\">, if C<$x> contains\r\na list, it is stringified first.  To get alternation you must use the\r\nC<@$x> or C<@($x)> form to indicate that you're intending the scalar\r\nvariable to be treated as a list.\r\n\r\nAn interpolated array using junctive semantics is declarative\r\n(participates in external longest token matching) only if it's\r\nknown to be constant at the time the regex is compiled.\r\n\r\nAs with a scalar variable, each element is matched as a literal.\r\nAll such values pay attention to the current C<:ignorecase>\r\nand C<:ignoremark> settings.\r\n\r\nWhen you get tired of writing:\r\n\r\n    token sigil { '$' | '@' | '%' | '&' | '::' }\r\n\r\nyou can write:\r\n\r\n    token sigil { < $ @ % & :: > }\r\n\r\nas long as you're careful to put a space after the initial angle so that\r\nit won't be interpreted as a subrule.  With the space it is parsed\r\nlike angle quotes in ordinary Perl 6 and treated as a literal array value.\r\n\r\nAlternatively, if you predeclare a proto regex, you can write multiple\r\nregexes for the same category, differentiated only by the symbol they\r\nmatch.  The symbol is specified as part of the \"long name\".  It may also\r\nbe matched within the rule using C<< <sym> >>, like this:\r\n\r\n    proto token sigil {*}\r\n    multi token sigil:sym<$>  { <sym> }\r\n    multi token sigil:sym<@>  { <sym> }\r\n    multi token sigil:sym<%>  { <sym> }\r\n    multi token sigil:sym<&>  { <sym> }\r\n    multi token sigil:sym<::> { <sym> }\r\n\r\n(The `multi` is optional and generally omitted with a grammar.)\r\n\r\nThis can be viewed as a form of multiple dispatch, except that it's\r\nbased on longest-token matching rather than signature matching.  The\r\nadvantage of writing it this way is that it's easy to add additional\r\nrules to the same category in a derived grammar.  All of them will\r\nbe matched in parallel when you try to match C<< /<sigil>/ >>.\r\n\r\nIf there are formal parameters on multi regex methods, matching\r\nstill proceeds via longest-token rules first.  If that results in a\r\ntie, a normal multiple dispatch is made using the arguments to the\r\nremaining variants, assuming they can be differentiated by type.\r\n\r\nThe `proto` calls into the subdispatcher when it sees a `*` that\r\ncannot be a quantifier and is the only thing in its block.  Therefore\r\nyou can put items before and after the subdispatch by putting\r\nthe `*` into curlies:\r\n\r\n    proto token foo { <prestuff> {*} <poststuff> }\r\n\r\nThis works only in a proto.  See L<S06> for a discussion of the\r\nsemantics of `{*}`.  (Unlike a proto sub, a proto regex\r\nautomatically remembers the return values from `{*}` because\r\nthey are carried along with the match cursor.)\r\n\r\nThe use of a hash variable in patterns is reserved.\r\n\r\nVariable matches are considered declarative if and only if the variable\r\nis known to represent a constant,  Otherwise they are procedural.\r\nNote that role parameters (if readonly) are considered constant\r\ndeclarations for this purpose despite the absence of an explicit\r\n`constant` declarator, since roles themselves are immutable, and\r\nwill presumably be replacing the parameter with a constant value when\r\ncomposed (if the value passed is a constant).  Macros instantiated\r\nwith constants would also make those constants eligible for declarative\r\ntreatment.\r\n\r\n# Extensible metasyntax (C<< <...> >>)\r\n\r\nBoth C<< < >> and C<< > >> are metacharacters, and are usually (but not\r\nalways) used in matched pairs.  (Some combinations of metacharacters\r\nfunction as standalone tokens, and these may include angles.  These are\r\ndescribed below.) Most assertions are considered declarative;\r\nprocedural assertions will be marked as exceptions.\r\n\r\nFor matched pairs, the first character after C<< < >> determines the\r\nnature of the assertion:\r\n\r\nIf the first character is whitespace, the angles are treated as an\r\nordinary \"quote words\" array literal.\r\n\r\n    < adam & eve >   # equivalent to [ 'adam' | '&' | 'eve' ]\r\n\r\nNote that the space before the ending > is optional and therefore\r\n< adam & eve> would be acceptable.\r\n\r\nA leading alphabetic character means it's a capturing grammatical\r\nassertion (i.e. a subrule or a named character class - see below):\r\n\r\n     / <sign>? <mantissa> <exponent>? /\r\n\r\nThe first character after the identifier determines the treatment of\r\nthe rest of the text before the closing angle.  The underlying semantics\r\nis that of a function or method call, so if the first character is\r\na left parenthesis, it really is a call to either a method or function:\r\n\r\n    <foo('bar')>\r\n\r\nIf the first character after the identifier is an C<=>, then the identifier\r\nis taken as an alias for what follows.  In particular,\r\n\r\n    <foo=bar>\r\n\r\nis just shorthand for\r\n\r\n    $<foo> = <bar>\r\n\r\nNote that this aliasing does not modify the original C<< <bar> >>\r\ncapture.  To rename an inherited method capture without using the\r\noriginal name, use the dot form described below on the capture you\r\nwish to suppress.  That is,\r\n\r\n    <foo=.bar>\r\n\r\ndesugars to:\r\n\r\n    $<foo> = <.bar>\r\n\r\nLikewise, to rename a lexically scoped regex explicitly, use the `&`\r\nform described below.  That is,\r\n\r\n    <foo=&bar>\r\n\r\ndesugars to:\r\n\r\n    $<foo> = <&bar>\r\n\r\nMultiple aliases are allowed, so\r\n\r\n    <foo=pub=bar>\r\n\r\nis short for\r\n\r\n    $<foo> = $<pub> = <bar>\r\n\r\nSimilarly, you can alias other assertion, e.g.:\r\n\r\n    <foo=[abc]>    # a character class, same as $<foo>=<[abc]>\r\n    <foo=:Letter>  # a unicode property, same as $<foo>=:Letter>\r\n    <foo=:!Letter> # a negated unicode property lookup\r\n\r\nIf the first character after the identifier is whitespace, the\r\nsubsequent text (following any whitespace) is passed as a regex, so:\r\n\r\n    <foo bar>\r\n\r\nis more or less equivalent to\r\n\r\n    <foo(/bar/)>\r\n\r\nTo pass a regex with leading whitespace you must use the parenthesized form.\r\n\r\nIf the first character is a colon followed by whitespace, the rest\r\nof the text is taken as a list of arguments to the method, just as\r\nin ordinary Perl syntax.  So these mean the same thing:\r\n\r\n    <foo('foo', $bar, 42)>\r\n    <foo: 'foo', $bar, 42>\r\n\r\nNo other characters are allowed after the initial identifier.\r\n\r\nSubrule matches are considered declarative to the extent that\r\nthe front of the subrule is itself considered declarative.  If a\r\nsubrule contains a sequence point, then so does the subrule match.\r\nLongest-token matching does not proceed past such a subrule, for\r\ninstance.\r\n\r\nThis form always gives preference to a lexically scoped regex declaration,\r\ndispatching directly to it as if it were function.  If there is no such\r\nlexical regex (or lexical method) in scope, the call is dispatched to the\r\ncurrent grammar, assuming there is one. That is, if there is a\r\nC<my regex foo> visible from the current lexical scope, then\r\n\r\n    <foo(1,2,3)>\r\n\r\nmeans the same as\r\n\r\n    <foo=&foo(1,2,3)>\r\n\r\nHowever, if there is no such lexically scoped regex (and note that within\r\na grammar, regexes are installed as methods which have no lexical alias\r\nby default), then the call is dispatched as a normal method on the current\r\n`Cursor` (which will fail if you're not currently within a grammar).  So\r\nin that case:\r\n\r\n    <foo(1,2,3)>\r\n\r\nmeans the same as:\r\n\r\n    <foo=.foo(1,2,3)>\r\n\r\nA call to C<< <foo> >> will fail if there is neither any lexically\r\nscoped routine of that name it can call, nor any method of that name\r\nthat be reached via method dispatch.  (The decision of which dispatcher\r\nto use is made at compile time, not at run time; the method call is not\r\na fallback mechanism.)\r\n\r\nA leading `.` explicitly calls a method as a subrule; the fact\r\nthat the initial character is not alphanumeric also causes the named\r\nassertion to not capture what it matches (see L<Subrule captures>. For\r\nexample:\r\n\r\n     / <ident>  <ws>  /      # $/<ident> and $/<ws> both captured\r\n     / <.ident> <ws>  /      # only $/<ws> captured\r\n     / <.ident> <.ws> /      # nothing captured\r\n\r\nThe assertion is otherwise parsed identically to an assertion beginning with\r\nan identifier, provided the next thing after the dot is an identifier.  As with\r\nthe identifier form, any extra arguments pertaining to the matching engine\r\nare automatically supplied to the argument list via the implicit `Cursor` invocant.\r\nIf there is no current class/grammar, or the current class is not derived\r\nfrom `Cursor`, the call is likely to fail.\r\n\r\nIf the dot is not followed by an identifier, it is parsed as a \"dotty\"\r\npostfix of some type, such as an indirect method call:\r\n\r\n    <.$indirect(@args)>\r\n\r\nAs with all regex matching, the current match state (some derivative\r\nof `Cursor`) is passed as the first argument, which in this case\r\nis simply the method's invocant.  The method is expected to return\r\na lazy list of new match state objects, or `Nil` if the match fails\r\nentirely.  Ratcheted routines will typically return a list containing only\r\none match.\r\n\r\nWhereas a leading `.` unambiguously calls a method, a leading `&`\r\nunambiguously calls a routine instead.  Such a regex routine must\r\nbe declared (or imported) with `my` or `our` scoping to make its\r\nname visible to the lexical scope, since by default a regex name is\r\ninstalled only into the current class's metaobject instance, just\r\nas with an ordinary method. The routine serves as a kind of private\r\nsubmethod, and is called without any consideration of inheritance.\r\nIt must still take a `Cursor` as its first argument (which it can\r\nthink of as an invocant if it likes), and must return the new match\r\nstate as a cursor object.  Hence,\r\n\r\n     <&foo(1,2,3)>\r\n\r\nis sugar for something like:\r\n\r\n     <.gather { take foo($¢,1,2,3) }>\r\n\r\nwhere C<$¢> represents the current incoming match state, and the\r\nroutine must return `Nil` for failure, or a lazy list of one or\r\nmore match states (`Cursor`-derived objects) for successful matches.\r\n\r\nAs with the `.` form, an explicit `&` suppresses capture.\r\n\r\nNote that all normal `Regex` objects are really such routines in disguise.\r\nWhen you say:\r\n\r\n    rx/stuff/\r\n\r\nyou're really declaring an anonymous method, something like:\r\n\r\n    my $internal = anon regex :: ($¢: ) { stuff }\r\n\r\nand then passing that object off to someone else who will call it\r\nindirectly.  In this case, the method is installed neither into\r\na class nor into a lexical scope, but as long as the value stays\r\nlive somehow, it can still be called indirectly (see below).\r\n\r\nA leading `$` indicates an indirect subrule call.  The variable must\r\ncontain either a `Regex` object (really an anonymous method--see\r\nabove), or a string to be compiled as the regex.  The string is never\r\nmatched literally.\r\n\r\nIf the compilation of the string form fails, the error message is converted\r\nto a warning and the assertion fails.\r\n\r\nThe indirect subrule assertion is not captured.  (No assertion with leading punctuation\r\nis captured by default.)  You may always capture it explicitly, of course:\r\n\r\n    / <name=$rx> /\r\n\r\nAn indirect subrule is always considered procedural, and may not participate\r\nin longest-token matching.\r\n\r\nA leading `::` indicates a symbolic indirect subrule:\r\n\r\n     / <::($somename)> /\r\n\r\nThe variable must contain the name of a subrule.  By the rules of\r\nsingle method dispatch this is first searched for in the current\r\ngrammar and its ancestors.  If this search fails an attempt is made\r\nto dispatch via MMD, in which case it can find subrules defined as\r\nmultis rather than methods.  This form is not captured by default.\r\nIt is always considered procedural, not declarative.\r\n\r\nA leading C<@> matches like a bare array except that each element is\r\ntreated as a subrule (string or `Regex` object) rather than as a literal.\r\nThat is, a string is forced to be compiled as a subrule instead of being\r\nmatched literally.  (There is no difference for a `Regex` object.)\r\n\r\nThis assertion is not automatically captured.\r\n\r\nThe use of a hash as an assertion is reserved.\r\n\r\nA leading `{` indicates code that produces a regex to be interpolated\r\ninto the pattern at that point as a subrule:\r\n\r\n     / (<.ident>)  <{ %cache{$0} //= get_body_for($0) }> /\r\n\r\nThe closure is guaranteed to be run at the canonical time; it declares\r\na sequence point, and is considered to be procedural.\r\n\r\nIn any case of regex interpolation, if the value already happens to be\r\na `Regex` object, it is not recompiled.  If it is a string, the compiled\r\nform is cached with the string so that it is not recompiled next\r\ntime you use it unless the string changes.  (Any external lexical\r\nvariable names must be rebound each time though.)  Subrules may not be\r\ninterpolated with unbalanced bracketing.  An interpolated subrule\r\nkeeps its own inner match results as a single item, so its parentheses never count toward the\r\nouter regexes groupings.  (In other words, parenthesis numbering is always\r\nlexically scoped.)\r\n\r\nA leading `?{` or C<!{> indicates a code assertion:\r\n\r\n     / (\\d**1..3) <?{ $0 < 256 }> /\r\n     / (\\d**1..3) <!{ $0 < 256 }> /\r\n\r\nSimilar to:\r\n\r\n     / (\\d**1..3) { $0 < 256 or fail } /\r\n     / (\\d**1..3) { $0 < 256 and fail } /\r\n\r\nUnlike closures, code assertions are considered declarative; they are\r\nnot guaranteed to be run at the canonical time if the optimizer can\r\nprove something later can't match.  So you can sneak in a call to a\r\nnon-canonical closure that way:\r\n\r\n     token { foo .* <?{ do { say \"Got here!\" } or 1 }> .* bar }\r\n\r\nThe `do` block is unlikely to run unless the string ends with \"`bar`\".\r\n\r\nA leading `[` indicates an enumerated character class.  Ranges\r\nin enumerated character classes are indicated with \"`..`\" rather than \"C<->\".\r\n\r\n     / <[a..z_]>* /\r\n\r\nWhitespace is ignored within square brackets:\r\n\r\n     / <[ a .. z _ ]>* /\r\n\r\nA reversed range is illegal.  In directly compiled code it's a compile-time\r\nerror to say\r\n\r\n    / <[ z .. a ]> /  # Reversed range is not allowed\r\n\r\nIn indirectly compiled code, a similar warning is issued and the assertion fails:\r\n\r\n    $rx = '<[ z .. a ]>';\r\n    / <$rx> /;  # warns and never matches\r\n\r\nA leading C<-> indicates a complemented character class:\r\n\r\n     / <-[a..z_]> <-alpha> /\r\n     / <- [a..z_]> <- alpha> /  # whitespace allowed after -\r\n\r\nThis is essentially the same as using negative lookahead and dot:\r\n\r\n    / <![a..z_]> . <!alpha> . /\r\n\r\nWhitespace is ignored after the initial C<->.\r\n\r\nA leading C<+> may also be supplied to indicate that the following\r\ncharacter class is to be matched in a positive sense.\r\n\r\n     / <+[a..z_]>* /\r\n     / <+[ a..z _ ]>* /\r\n     / <+ [ a .. z _ ] >* /      # whitespace allowed after +\r\n\r\nCharacter classes can be combined (additively or subtractively) within\r\na single set of angle brackets.  Whitespace is ignored. For example:\r\n\r\n     / <[a..z] - [aeiou] + xdigit> /      # consonant or hex digit\r\n\r\nA named character class may be used by itself:\r\n\r\n    <alpha>\r\n\r\nHowever, in order to combine classes you must prefix a named\r\ncharacter class with C<+> or C<->.  Whitespace is required before\r\nany C<-> that would be misparsed as an identifier extender.\r\n\r\nUnicode properties are indicated by use of pair notation in place of a normal\r\nrule name:\r\n\r\n    <:Letter>   # a letter\r\n    <:!Letter>  # a non-letter\r\n\r\nProperties with arguments are passed as the argument to the pair:\r\n\r\n    <:East_Asian_Width<Narrow>>\r\n    <:!Blk<ASCII>>\r\n\r\nThe pair value is smartmatched against the value in the Unicode database.\r\n\r\n    <:Nv(0 ^..^ 1)>     # the char has a proper fractional value\r\n\r\nAs a particular case of smartmatching, TR18 section 2.6 is satisfied\r\nwith a pattern as the argument:\r\n\r\n    <:name(/^LATIN LETTER.*P$/)>\r\n\r\nMultiple of these terms may be combined with pluses and minuses:\r\n\r\n    <+ :HexDigit - :Upper >\r\n\r\nTerms may also be combined using `&` for set intersection, `|`\r\nfor set union, and C<^> for symmetric set difference.  Parens may be\r\nused for grouping.  (Square brackets always quote literal characters\r\n(including backslashed literal forms), and may not be nested, unlike\r\nthe suggested notation in TR18 section 1.3.)  The precedence of\r\nthe operators is the same as the correspondingly named operators in\r\nL<S03/Operator precedence>, even though they have somewhat different\r\nsemantics.\r\n\r\nExtra long characters may be entered by quoting them and including them\r\nvia intersection.  Any quoted characters will be treated as \"longest tokens\"\r\nwhen appropriate.  Here 'll' would be recognized in preference to 'l':\r\n\r\n    / <[ a..z ] | 'ñ' | 'ch' | 'll' | 'rr'>\r\n\r\nNote that a negated character class containing \"long characters\"\r\nalways advances by a single character.\r\n\r\nWhen any character constructor such as `\\c`, C<\\x>, or C<\\o> contains\r\nmultiple values separated by commas, these are treated as \"long characters\".\r\nSo you could add a C<\\c[13,10]> to the list above to match CRLF as a long\r\ncharacter.\r\n\r\nA consequence of this is that the negated form advances by a single\r\nposition (matching as `.` does) when the long character doesn't\r\nmatch as a whole.  Hence, this matches:\r\n\r\n    \"\\c[13,13,10,10]\" ~~ /\\C[13,10]* \\c[13,10] \\C[13,10]/;\r\n\r\nIf you want it to mean \\C13\\C10 instead, then you can just write it that way.\r\n\r\nThe special assertion C<< <.> >> matches any logical grapheme\r\n(including a Unicode combining character sequences):\r\n\r\n     / seekto = <.> /  # Maybe a combined char\r\n\r\nSame as:\r\n\r\n     / seekto = [:graphs .] /\r\n\r\nA leading C<!> indicates a negated meaning (always a zero-width assertion):\r\n\r\n     / <!before _ > /    # We aren't before an _\r\n\r\nNote that C<< <!alpha> >> is different from C<< <-alpha> >>.\r\nC<< /<-alpha>/ >> is a complemented character class equivalent to\r\nC<<< /<!before <alpha>> ./ >>>, whereas C<< <!alpha> >> is a zero-width\r\nassertion equivalent to a C<<< /<!before <alpha>>/ >>> assertion.\r\n\r\nNote also that as a metacharacter C<!> doesn't change the parsing\r\nrules of whatever follows (unlike, say, C<+> or C<->).\r\n\r\nA leading `?` indicates a positive zero-width assertion, and like C<!>\r\nmerely reparses the rest of the assertion recursively as if the `?`\r\nwere not there.  In addition to forcing zero-width, it also suppresses\r\nany named capture:\r\n\r\n    <alpha>     # match a letter and capture to $alpha (eventually $<alpha>)\r\n    <.alpha>    # match a letter, don't capture\r\n    <?alpha>    # match null before a letter, don't capture\r\n\r\nThe special named assertions include:\r\n\r\n     / <?before pattern> /    # lookahead\r\n     / <?after pattern> /     # lookbehind\r\n\r\n     / <?same> /              # true between two identical characters\r\n\r\n     / <.ws> /                # match \"whitespace\":\r\n                              #   \\s+ if it's between two \\w characters,\r\n                              #   \\s* otherwise\r\n\r\n     / <?at($pos)> /          # match only at a particular StrPos\r\n                              # short for <?{ .pos === $pos }>\r\n                              # (considered declarative until $pos changes)\r\n\r\nIt is legal to use any of these assertions as named captures by omitting the\r\npunctuation at the front.  However, capture entails some overhead in both\r\nmemory and computation, so in general you want to suppress that for data\r\nyou aren't interested in preserving.\r\n\r\nThe `after` assertion implements lookbehind by reversing the syntax\r\ntree and looking for things in the opposite order going to the left.\r\nIt is illegal to do lookbehind on a pattern that cannot be reversed.\r\n\r\nNote: the effect of a forward-scanning lookbehind at the top level\r\ncan be achieved with:\r\n\r\n    / .*? prestuff <( mainpat )> /\r\n\r\nA leading `*` indicates that the following pattern allows a\r\npartial match.  It always succeeds after matching as many characters\r\nas possible.  (It is not zero-width unless 0 characters match.)\r\nFor instance, to match a number of abbreviations, you might write\r\nany of:\r\n\r\n    s/ ^ G<*n|enesis>     $ /gen/  or\r\n    s/ ^ Ex<*odus>        $ /ex/   or\r\n    s/ ^ L<*v|eviticus>   $ /lev/  or\r\n    s/ ^ N<*m|umbers>     $ /num/  or\r\n    s/ ^ D<*t|euteronomy> $ /deut/ or\r\n    ...\r\n\r\n    / (<* < foo bar baz > >) /\r\n\r\n    / <short=*@abbrev> / and return %long{$<short>} || $<short>;\r\n\r\nThe pattern is restricted to declarative forms that can be rewritten\r\nas nested optional character matches.  Sequence information\r\nmay not be discarded while making all following characters optional.\r\nThat is, it is not sufficient to rewrite:\r\n\r\n    <*xyz>\r\n\r\nas:\r\n\r\n    x? y? z?            # bad, would allow xz\r\n\r\nInstead, it must be implemented as:\r\n\r\n    [x [y z?]?]?        # allow only x, xy, xyz (and '')\r\n\r\nExplicit quantifiers are allowed on single characters, so this:\r\n\r\n    <* a b+ c | ax*>\r\n\r\nis rewritten as something like:\r\n\r\n    [a [b+ c?]?]? | [a x*]?\r\n\r\nIn the latter example we're assuming the DFA token matcher is going to\r\ngive us the longest match regardless.  It's also possible that quantified\r\nmulti-character sequences can be recursively remapped:\r\n\r\n    <* 'ab'+>     # match a, ab, ababa, etc. (but not aab!)\r\n    ==> [ 'ab'* <*ab> ]\r\n    ==> [ 'ab'* [a b?]? ]\r\n\r\n[Conjecture: depending on how fancy we get, we might (or might not)\r\nbe able to autodetect ambiguities in C<< <*@abbrev> >> and refuse to\r\ngenerate ambiguous abbreviations (although exact match of a shorter\r\nabbrev should always be allowed even if it's the prefix of a longer\r\nabbreviation).  If it is not possible, then the user will have to\r\ncheck for ambiguities after the match. Note also that the array\r\nform is assuming the array doesn't change often.  If it does, the\r\nlongest-token matcher has to be recalculated, which could get\r\nexpensive.]\r\n\r\nA leading C<~~> indicates a recursive call back into some or all of\r\nthe current rule.  An optional argument indicates which subpattern\r\nto re-use, and if provided must resolve to a single subpattern.\r\nIf omitted, the entire pattern is called recursively:\r\n\r\n    <~~>       # call myself recursively\r\n    <~~0>      # match according to $0's pattern\r\n    <~~foo>    # match according to $<foo>'s pattern\r\n\r\nNote that this rematches the pattern associated with the name, not\r\nthe string matched.  So\r\n\r\n    $_ = \"foodbard\"\r\n\r\n    / ( foo | bar ) d $0 /      # fails; doesn't match \"foo\" literally\r\n    / ( foo | bar ) d <$0> /    # fails; doesn't match /foo/ as subrule\r\n    / ( foo | bar ) d <~~0> /   # matches using rule associated with $0\r\n\r\nThe last is equivalent to\r\n\r\n    / ( foo | bar ) d ( foo | bar ) /\r\n\r\nNote that the \"self\" call of\r\n\r\n    / <term> <operator> <~~> /\r\n\r\ncalls back into this anonymous rule as a subrule, and is implicitly\r\nanchored to the end of the operator as any other subrule would be.\r\nDespite the fact that the outer rule scans the string, the inner\r\ncall to it does not.\r\n\r\nNote that a consequence of the previous section is that you also get\r\n\r\n    <!~~>\r\n\r\nfor free, which fails if the current rule would match again at this location.\r\n\r\nA leading `|` indicates some kind of a zero-width boundary. You can refer to\r\nbackslash sequences with this syntax; C<< <|h> >> will match between a `\\h` and\r\na C<\\H>, for instance. Some examples:\r\n\r\n    <|w> word boundary\r\n    <|g> grapheme boundary (always matches in grapheme mode)\r\n    <|c> codepoint boundary (always matches in grapheme/codepoint mode)\r\n\r\nThe following tokens include angles but are not required to balance:\r\n\r\nA C<< <( >> token indicates the start of the match's overall capture, while the\r\ncorresponding C<< )> >> token indicates its endpoint.  When matched,\r\nthese behave as assertions that are always true, but have the side\r\neffect of setting the C<.from> and C<.to> attributes of the match\r\nobject.  That is:\r\n\r\n    / foo <( \\d+ )> bar /\r\n\r\nis equivalent to:\r\n\r\n    / <?after foo> \\d+ <?before bar> /\r\n\r\nexcept that the scan for \"`foo`\" can be done in the forward direction,\r\nwhile a lookbehind assertion would presumably scan for C<\\d+> and then\r\nmatch \"`foo`\" backwards.  The use of C<< <(...)> >> affects only the\r\npositions of the beginning and ending of the match, and anything calculated\r\nbased on those positions.  For instance, after the match above, C<$()> contains\r\nonly the digits matched, and C<$/.to> is pointing to after the digits. Other\r\ncaptures (named or numbered) are unaffected and may be accessed through `$/`.\r\n\r\nWhen used directly within quantifiers (that is, within quantified\r\nsquare brackets), there is only one `Match` object to set\r\nC<.from>/C<.to> on, so the C<< <( >> token always sets C<.from> to\r\nthe leftmost matching position, while C<< )> >> always sets C<.to>\r\nto the rightmost position.  However, the situation is different for\r\ncapturing parentheses.  When used within parentheses (whether or\r\nnot the parens are quantified), the `Match` being generated by each\r\ndynamic capture serves as the target, so each such capturing group\r\nsets its own C<.from>/C<.to>.  Hence, if the group is quantified,\r\neach capture sets its own boundaries independently.\r\n\r\nThese tokens are considered declarative.\r\n\r\nA C<«> or C<<< << >>> token indicates a left word boundary.  A C<»> or\r\nC<<< >> >>> token indicates a right word boundary.  (As separate tokens,\r\nthese need not be balanced.)  Perl 5's `\\b` is replaced by a C<< <|w> >>\r\n\"word boundary\" assertion, while C<\\B> becomes C<< <!|w> >>.  (None of\r\nthese are dependent on the definition of C<< <.ws> >>, but only on the `\\w`\r\ndefinition of \"word\" characters.  Non-space mark characters are ignored in\r\ncalculating word properties of the preceding character.  See TR18 1.4.)\r\n\r\n=head2 Predefined Subrules\r\n\r\nThese are some of the predefined subrules for any grammar or regex:\r\n\r\n ident\r\nX<ident>X<< <ident> >>\r\n\r\nMatch an identifier.\r\n\r\n upper\r\nX<upper>X<< <upper> >>\r\n\r\nMatch a single uppercase character.\r\n\r\n lower\r\nX<lower>X<< <lower> >>\r\n\r\nMatch a single lowercase character.\r\n\r\n alpha\r\nX<alpha>X<< <alpha> >>\r\n\r\nMatch a single alphabetic character, or an underscore.\r\n\r\nTo match Unicode alphabetic characters without the underscore, use\r\nC<< <:alpha> >>.\r\n\r\n digit\r\nX<digit>X<< <digit> >>\r\n\r\nMatch a single digit.\r\n\r\n xdigit\r\nX<xdigit>X<< <xdigit> >>\r\n\r\nMatch a single hexadecimal digit.\r\n\r\n print\r\nX<print>X<< <print> >>\r\n\r\nMatch a single printable character.\r\n\r\n graph\r\nX<graph>X<< <graph> >>\r\n\r\nMatch a single \"graphical\" character.\r\n\r\n cntrl\r\nX<cntrl>X<< <cntrl> >>\r\n\r\nMatch a single \"control\" character (equivalent to the <:Cc> property). A control character is usually one that\r\ndoesn't produce output as such but instead controls the terminal somehow: for\r\nexample newline and backspace are control characters. All characters with ord()\r\nless than 32 are usually classified as control characters (assuming ASCII, the\r\nISO Latin character sets, and Unicode), as is the character with the ord() value\r\nof 127 (DEL).  The characters from 128 to 159 are also control characters.\r\n\r\n punct\r\n\r\nMatch a single punctuation character (that is, any character from the\r\nUnicode General Category \"Punctuation\").\r\n\r\n alnum\r\n\r\nMatch a single alphanumeric character. This is equivalent to <+alpha +digit> .\r\n\r\n wb\r\n\r\nReturns a zero-width match that is true at word boundaries.  A word\r\nboundary is a spot with a \"\\w\" on one side and a \"\\W\" on the other\r\nside (in either order), counting the beginning and end of the string\r\nas matching \"\\W\".\r\n\r\n ww\r\n\r\nMatches between two word characters (zero-width match).\r\n\r\n ws\r\n\r\nMatches required whitespace between two word characters, optional\r\nwhitespace otherwise.  This is roughly equivalent to  C<< <!ww> \\s* >>\r\n(`ws` isn't required to use the `ww` subrule).\r\n\r\n space\r\n\r\nMatch a single whitespace character (same as C< \\s > ).\r\n\r\n blank\r\n\r\nMatch a single \"blank\" character -- in most locales, this corresponds\r\nto space and tab.\r\n\r\n before `pattern`\r\n\r\nPerform lookahead -- i.e., check if we're at a position where\r\n`pattern` matches.  Returns a zero-width `Match` object on\r\nsuccess.\r\n\r\n after `pattern`\r\n\r\nPerform lookbehind -- i.e., check if the string before the\r\ncurrent position matches <pattern> (anchored at the end).\r\nReturns a zero-width `Match` object on success.\r\n\r\n <?>\r\n\r\nMatch a null string, viz., always returns true\r\n\r\n <!>\r\n\r\nInverse of <?>, viz., always returns false.\r\n\r\n# Backslash reform\r\n\r\nMany `\\p` and C<\\P> properties become intrinsic grammar rules such as (C<<\r\n<alpha> >> and C<< <-alpha> >>).  They may be combined using the above-mentioned\r\ncharacter class notation: C<< <[-]+alpha+digit> >>.  Regardless of the\r\nhigher-level character class names, all low-level Unicode properties are always\r\navailable with a prefix of colon, that is, in pair notation within the angle\r\nbrackets.  Hence, C<< <+:Lu+:Lt> >> is equivalent to C<< <+upper+title> >>.\r\n\r\nThe C<\\L...\\E>, C<\\U...\\E>, and C<\\Q...\\E> sequences are gone.  The\r\nsingle-character case modifiers `\\l` and `\\u` are also gone.  In the\r\nrare cases that need them you can use C<< <{ lc $regex }> >>,\r\nC<< <{tc $word}> >>, etc.\r\n\r\nAs mentioned above, the `\\b` and C<\\B> word boundary assertions are gone,\r\nand are replaced with C<< <|w> >> (or <wb>) and C<< <!|w> >> (or <!wb>)\r\nzero-width assertions.\r\n\r\nThe C<\\G> sequence is gone.  Use `:p` instead.  (Note, however,\r\nthat it makes no sense to use `:p` within a pattern, since every\r\ninternal pattern is implicitly anchored to the current position.)\r\nSee the `at` assertion below.\r\n\r\nBackreferences (e.g. `\\1`, `\\2`, etc.) are gone; `$0`, C<$1>, etc. can be\r\nused instead, because variables are no longer interpolated.\r\n\r\nNumeric variables are assumed to change every time and therefore are\r\nconsidered procedural, unlike normal variables.\r\n\r\nNew backslash sequences, `\\h` and C<\\v>, match horizontal and vertical\r\nwhitespace respectively, including Unicode.  Horizontal whitespace is defined\r\nas anything matching `\\s` that doesn't also match C<\\v>.  Vertical whitespace is\r\ndefined as any of:\r\n\r\n    U+000A  LINE FEED (LF)\r\n    U+000B  LINE TABULATION\r\n    U+000C  FORM FEED (FF)\r\n    U+000D  CARRIAGE RETURN (CR)\r\n    U+0085  NEXT LINE (NEL)\r\n    U+2028  LINE SEPARATOR\r\n    U+2029  PARAGRAPH SEPARATOR\r\n\r\nNote that U+000D CARRIAGE RETURN (CR) is considered vertical whitespace despite\r\nthe fact that it only moves the \"carriage\" horizontally.\r\n\r\n`\\s` now matches any Unicode whitespace character.\r\n\r\nThe new backslash sequence C<\\N> matches anything except a logical\r\nnewline; it is the negation of `\\n`.\r\n\r\nOther new capital backslash sequences are also the negations\r\nof their lowercase counterparts:\r\n\r\nC<\\H> matches anything but horizontal whitespace.\r\n\r\nC<\\V> matches anything but vertical whitespace.\r\n\r\nC<\\T> matches anything but a tab.\r\n\r\nC<\\R> matches anything but a return.\r\n\r\nC<\\F> matches anything but a formfeed.\r\n\r\nC<\\E> matches anything but an escape.\r\n\r\nC<\\X...> matches anything but the specified character (specified in\r\nhexadecimal).\r\n\r\nBackslash escapes for literal characters in ordinary strings are allowed in\r\nregexes (`\\a`, C<\\x>, etc.).  However, the exception to this rule is `\\b`,\r\nwhich is disallowed in order to avoid conflict with its former use as a word\r\nboundary assertion.  To match a literal backspace, use `\\c8`, C<\\x8>, or a\r\ndouble-quoted `\\b`.\r\n\r\n=head2 Character class shortcuts\r\n\r\nFor historical and convenience reasons, the following character classes are\r\navailable as backslash sequences:\r\n\r\n   \\d      <digit>    A digit\r\n   \\D      <-digit>   A nondigit\r\n   \\w      <alnum>    A word character\r\n   \\W      <-alnum>   A non-word character\r\n   \\s      <sp>       A whitespace character\r\n   \\S      <-sp>      A non-whitespace character\r\n   \\h                 A horizontal whitespace\r\n   \\H                 A non-horizontal whitespace\r\n   \\v                 A vertical whitespace\r\n   \\V                 A non-vertical whitespace\r\n\r\n# Regexes constitute a first-class language, rather than just being strings\r\n\r\nThe Perl 5 C<qr/pattern/> regex constructor is gone.\r\n\r\nThe Perl 6 equivalents are:\r\n\r\n     regex { pattern }    # always takes {...} as delimiters\r\n     rx    / pattern /    # can take (almost) any chars as delimiters\r\n\r\nYou may not use whitespace or alphanumerics for delimiters.  Space is\r\noptional unless needed to distinguish from modifier arguments or\r\nfunction parens.  So you may use parens as your `rx` delimiters,\r\nbut only if you interpose whitespace:\r\n\r\n     rx ( pattern )      # okay\r\n     rx( 1,2,3 )         # tries to call rx function\r\n\r\n(This is true for all quotelike constructs in Perl 6.)\r\n\r\nThe `rx` form may be used directly as a pattern anywhere a normal `//` match can.\r\nThe `regex` form is really a method definition, and must be used in such a way that\r\nthe grammar class it is to be used in is apparent.\r\n\r\nIf either form needs modifiers, they go before the opening delimiter:\r\n\r\n     $regex = regex :s:i { my name is (.*) };\r\n     $regex = rx:s:i     / my name is (.*) /;    # same thing\r\n\r\nSpace is necessary after the final modifier if you use any\r\nbracketing character for the delimiter.  (Otherwise it would be taken as\r\nan argument to the modifier.)\r\n\r\nYou may not use colons for the delimiter.  Space is allowed between\r\nmodifiers:\r\n\r\n     $regex = rx :s :i / my name is (.*) /;\r\n\r\nThe name of the constructor was changed from `qr` because it's no\r\nlonger an interpolating quote-like operator.  `rx` is short for `regex`,\r\n(not to be confused with regular expressions, except when they are).\r\n\r\nAs the syntax indicates, it is now more closely analogous to a C<sub {...}>\r\nconstructor.  In fact, that analogy runs `very` deep in Perl 6.\r\n\r\nJust as a raw `{...}` is now always a closure (which may still\r\nexecute immediately in certain contexts and be passed as an object\r\nin others), so too a raw `/.../` is now always a `Regex` object (which\r\nmay still match immediately in certain contexts and be passed as an\r\nobject in others).\r\n\r\nSpecifically, a `/.../` matches immediately in a value context (sink,\r\nBoolean, string, or numeric), or when it is an explicit argument of\r\na C<~~>.  Otherwise it's a `Regex` constructor identical to the explicit\r\n`regex` form.  So this:\r\n\r\n     $var = /pattern/;\r\n\r\nno longer does the match and sets C<$var> to the result.\r\nInstead it assigns a `Regex` object to C<$var>.\r\n\r\nThe two cases can always be distinguished using `m{...}` or C<rx{...}>:\r\n\r\n     $match = m{pattern};    # Match regex immediately, assign result\r\n     $regex = rx{pattern};   # Assign regex expression itself\r\n\r\nNote that this means that former magically lazy usages like:\r\n\r\n     @list = split /pattern/, $str;\r\n\r\nare now just consequences of the normal semantics.\r\n\r\nIt's now also possible to set up a user-defined subroutine that acts\r\nlike `grep`:\r\n\r\n     sub my_grep($selector, *@list) {\r\n         given $selector {\r\n             when Regex { ... }\r\n             when Code  { ... }\r\n             when Hash  { ... }\r\n             # etc.\r\n         }\r\n     }\r\n\r\nWhen you call `my_grep`, the first argument is bound in item context,\r\nso passing `{...}` or `/.../` produces a `Code` or `Regex` object,\r\nwhich the switch statement then selects upon.  (Normal `grep` just\r\nlets a smartmatch operator do all the work.)\r\n\r\nJust as `rx` has variants, so does the `regex` declarator.\r\nIn particular, there are two special variants for use in grammars:\r\n`token` and `rule`.\r\n\r\nA token declaration:\r\n\r\n    token ident { [ <alpha> | \\- ] \\w* }\r\n\r\nnever backtracks by default.  That is, it likes to commit to whatever\r\nit has scanned so far.  The above is equivalent to\r\n\r\n    regex ident { [ <alpha>: | \\-: ]: \\w*: }\r\n\r\nbut rather easier to read.  The bare `*`, C<+>, and `?` quantifiers\r\nnever backtrack in a `token`.\r\nIn normal regexes, use\r\n`*:`, C<+:>, or `?:` to prevent any backtracking into the quantifier.\r\nIf you want to explicitly backtrack, append either a `?` or a C<!>\r\nto the quantifier.   The `?` forces frugal matching as usual,\r\nwhile the C<!> forces greedy matching.  The `token` declarator is\r\nreally just short for\r\n\r\n    regex :ratchet { ... }\r\n\r\nThe other is the `rule` declarator, for declaring non-terminal\r\nproductions in a grammar.  Like a `token`, it also does not backtrack\r\nby default.  In addition, a `rule` regex also assumes `:sigspace`.\r\nA `rule` is really short for:\r\n\r\n    regex :ratchet :sigspace { ... }\r\n\r\nThe Perl 5 `?...?` syntax (I<succeed once>) was rarely used and can be\r\nnow emulated more cleanly with a state variable:\r\n\r\n    $result = do { state $x ||= m/ pattern /; }    # only matches first time\r\n\r\nTo reset the pattern, simply say C<$x = 0>.  Though if you want C<$x> visible\r\nyou'd have to avoid using a block:\r\n\r\n    $result = state $x ||= m/ pattern /;\r\n    ...\r\n    $x = 0;\r\n\r\n# Backtracking control\r\n\r\nWithin those portions of a pattern that are considered procedural rather\r\nthan declarative, you may control the backtracking behavior.\r\n\r\nBy default, backtracking is greedy in `rx`, `m`, `s`, and the like.\r\nIt's also greedy in ordinary `regex` declarations.  In `rule`\r\nand `token` declarations, backtracking must be explicit.\r\n\r\nTo force the preceding atom to do frugal backtracking (also sometimes\r\nknown as \"eager matching\" or \"minimal matching\"),\r\nappend a `:?` or `?` to the atom.  If the preceding token is\r\na quantifier, the `:` may be omitted, so `*?` works just as\r\nin Perl 5.\r\n\r\nTo force the preceding atom to do greedy backtracking in a\r\nspot that would default otherwise, append a C<:!> to the atom.\r\nIf the preceding token is a quantifier, the `:` may be omitted.\r\n(Perl 5 has no corresponding construct because backtracking always\r\ndefaults to greedy in Perl 5.)\r\n\r\nTo force the preceding atom to do no backtracking, use a single `:`\r\nwithout a subsequent `?` or C<!>.  Backtracking over a single colon\r\ncauses the regex engine not to retry the preceding atom:\r\n\r\n     ms/ \\( <expr> [ , <expr> ]*: \\) /\r\n\r\n(i.e. there's no point trying fewer C<< <expr> >> matches, if there's\r\nno closing parenthesis on the horizon)\r\n\r\nWhen modifying a quantifier, a C<+> may be used instead of a `:`, in\r\nwhich case the quantifier is often known as a `possessive` quantifier.\r\n\r\n     ms/ \\( <expr> [ , <expr> ]*+ \\) /  # same thing\r\n\r\nTo force all the atoms in an expression not to backtrack by default,\r\nuse C<:ratchet> or `rule` or `token`.\r\n\r\nEvaluating a double colon throws away all saved choice points in the current\r\nL<LTM|/\"Longest-token matching\"> alternation.\r\n\r\n     ms/ [ if :: <expr> <block>\r\n         | for :: <list> <block>\r\n         | loop :: <loop_controls>? <block>\r\n         ]\r\n     /\r\n\r\n(i.e. there's no point trying to match a different keyword if one was\r\nalready found but failed).\r\n\r\nThe `::` also has the effect of hiding any declarative match on the right\r\nfrom \"longest token\" processing by `|`.  Only the left side is evaluated\r\nfor determinacy.\r\n\r\n`::` does nothing if there is no current LTM alternation. \"Current\"\r\nis defined dynamically, not lexically.  A `::` in a subrule will affect\r\nthe enclosing alternation.\r\n\r\nEvaluating a C<< ::> >> throws away all saved choice points in the current\r\ninnermost temporal alternation.  It thus acts as a \"then\".\r\n\r\n    ms/ [\r\n        || <?{ $a == 1 }> ::> <foo>\r\n        || <?{ $a == 2 }> ::> <bar>\r\n        || <?{ $a == 3 }> ::> <baz>\r\n        ]\r\n    /\r\n\r\nNote that you can still back into the \"then\" part of such\r\nan alternation, so you may also need to put `:` after it if you\r\nalso want to disable that.  If an explicit or implicit C<:ratchet>\r\nhas disabled backtracking by supplying an implicit `:`, you need to\r\nput an explicit C<!> after the alternation to enable backing into,\r\nsay, the C<< <foo> >> rule above.\r\n\r\nC<< ::> >> does nothing if there is no current temporal alternation.\r\n\"Current\" is defined dynamically, not lexically.  A C<< ::> >> in a\r\nsubrule will affect the enclosing alternation.\r\n\r\nEvaluating a triple colon throws away all saved choice points since\r\nthe current regex was entered.  Backtracking to (or past) this point\r\nwill fail the rule outright (no matter where in the regex it occurs):\r\n\r\n     regex ident {\r\n           ( [<alpha>|\\-] \\w* ) ::: { fail if %reserved{$0} }\r\n         || \" [<alpha>|\\-] \\w* \"\r\n     }\r\n\r\n     ms/ get <ident>? /\r\n\r\n(i.e. using an unquoted reserved word as an identifier is not permitted)\r\n\r\nEvaluating a C<< <commit> >> assertion throws away all saved choice\r\npoints since the start of the entire match.  Backtracking to (or past)\r\nthis point will fail the entire match, no matter how many subrules\r\ndown it happens:\r\n\r\n     regex subname {\r\n         ([<alpha>|\\-] \\w*) <commit> { fail if %reserved{$0} }\r\n     }\r\n     ms/ sub <subname>? <block> /\r\n\r\n(i.e. using a reserved word as a subroutine name is instantly fatal\r\nto the `surrounding` match as well)\r\n\r\nIf commit is given an argument, it's the name of a calling rule that\r\nshould be committed:\r\n\r\n    <commit('infix')>\r\n\r\nA C<< <cut> >> assertion always matches successfully, and has the\r\nside effect of logically deleting the parts of the string already\r\nmatched.  Whether this actually frees up the memory immediately may\r\ndepend on various interactions among your backreferences, the string\r\nimplementation, and the garbage collector.  In any case, the string\r\nwill report that it has been chopped off on the front.  It's illegal\r\nto use C<< <cut> >> on a string that you do not have write access to.\r\n\r\nAttempting to backtrack past a C<< <cut> >> causes the complete\r\nmatch to fail (like backtracking past a C<< <commit> >>). This is\r\nbecause there's now no preceding text to backtrack into.  This is\r\nuseful for throwing away successfully processed input when matching\r\nfrom an input stream or an iterator of arbitrary length.\r\n\r\n# Regex Routines, Named and Anonymous\r\n\r\nThe analogy between `sub` and `regex` extends much further.\r\n\r\nJust as you can have anonymous subs and named subs...\r\n\r\n...so too you can have anonymous regexes and `named` regexes (and tokens,\r\nand rules):\r\n\r\n     token ident { [<alpha>|\\-] \\w* }\r\n\r\n     # and later...\r\n\r\n     @ids = grep /<ident>/, @strings;\r\n\r\nAs the above example indicates, it's possible to refer to named regexes,\r\nsuch as:\r\n\r\n     regex serial_number { <[A..Z]> \\d**8 }\r\n     token type { alpha | beta | production | deprecated | legacy }\r\n\r\nin other regexes as named assertions:\r\n\r\n     rule identification { [soft|hard]ware <type> <serial_number> }\r\n\r\nThese keyword-declared regexes are officially of type `Method`,\r\nwhich is derived from `Routine`.\r\n\r\nIn general, the anchoring of any subrule call is controlled by its calling context.\r\nWhen a regex, token, or rule method is called as a subrule, the\r\nfront is anchored to the current position (as with `:p`), while\r\nthe end is not anchored, since the calling context will likely wish\r\nto continue parsing.  However, when such a method is smartmatched\r\ndirectly, it is automatically anchored on both ends to the beginning\r\nand end of the string.  Thus, you can do direct pattern matching\r\nby using an anonymous regex routine as a standalone pattern:\r\n\r\n    $string ~~ regex { \\d+ }\r\n    $string ~~ token { \\d+ }\r\n    $string ~~ rule { \\d+ }\r\n\r\nand these are equivalent to\r\n\r\n    $string ~~ m/^ \\d+ $/;\r\n    $string ~~ m/^ \\d+: $/;\r\n    $string ~~ m/^ <.ws> \\d+: <.ws> $/;\r\n\r\nThe basic rule of thumb is that the keyword-defined methods never\r\ndo implicit `.*?`-like scanning, while the `m//` and `s///`\r\nquotelike forms do such scanning in the absence of explicit anchoring.\r\n\r\nThe C<rx//> and `//` forms can go either way: they scan when used\r\ndirectly within a smartmatch or boolean context, but when called\r\nindirectly as a subrule they do not scan.  That is, the object returned\r\nby C<rx//> behaves like `m//` when used directly, but like `regex`\r\n`{}` when used as a subrule:\r\n\r\n    $pattern = rx/foo/;\r\n    $string ~~ $pattern;                  # equivalent to m/foo/;\r\n    $string ~~ /'[' <$pattern> ']'/       # equivalent to /'[foo]'/\r\n\r\n# Nothing is illegal\r\n\r\nThe empty pattern is now illegal.\r\n\r\nTo match the zero-width string, you must use some explicit\r\nrepresentation of the null match:\r\n\r\n    / '' /;\r\n    / <?> /;\r\n\r\nFor example:\r\n\r\n     split /''/, $string\r\n\r\nsplits between characters.  But then, so does this:\r\n\r\n     split '', $string\r\n\r\nLikewise, to match a empty alternative, use something like:\r\n\r\n     /a|b|c|<?>/\r\n     /a|b|c|''/\r\n\r\nThis makes it easier to catch errors like this:\r\n\r\n    /a|b|c|/\r\n\r\nAs a special case, however, the first null alternative in a match like\r\n\r\n     ms/ [\r\n         | if :: <expr> <block>\r\n         | for :: <list> <block>\r\n         | loop :: <loop_controls>? <block>\r\n         ]\r\n     /\r\n\r\nis simply ignored.  Only the first alternative is special that way.\r\nIf you write:\r\n\r\n     ms/ [\r\n             if :: <expr> <block>              |\r\n             for :: <list> <block>             |\r\n             loop :: <loop_controls>? <block>  |\r\n         ]\r\n     /\r\n\r\nit's still an error.\r\n\r\nHowever, it's okay for a non-null syntactic construct to have a degenerate\r\ncase matching the null string:\r\n\r\n     $something = \"\";\r\n     /a|b|c|$something/;\r\n\r\nIn particular, C<< <?> >> always matches the null string successfully,\r\nand C<< <!> >> always fails to match anything.\r\n\r\n# Longest-token matching\r\n\r\nSince \"longest-token matching\" is a long phrase, we will usually refer\r\nto this idea as B<LTM>.  The basic notion is that LTM is how people\r\ntend to parse text in their heads, so the computer ought to try to do\r\nthe same.  And parsing with LTM is all about how the computer decides\r\nwhich alternative of a set of alternatives is going to match.\r\n\r\nInstead of representing temporal alternation as it does in Perl 5, in Perl 6 `|` represents\r\nlogical alternation with declarative longest-token semantics.  (You may\r\nnow use `||` to indicate the old temporal alternation.  That is, `|`\r\nand `||` now work within regex syntax much the same as they do outside\r\nof regex syntax, where they represent junctional and short-circuit OR.\r\nThis includes the fact that `|` has tighter precedence than `||`.)\r\n\r\nHistorically regex processing has proceeded in Perl via a backtracking\r\nNFA algorithm.  This is quite powerful, but many parsers work more\r\nefficiently by processing rules in parallel rather than one after\r\nanother, at least up to a point.  If you look at something like a\r\nyacc grammar, you find a lot of pattern/action declarations where the\r\npatterns are considered in parallel, and eventually the grammar decides\r\nwhich action to fire off.  While the default Perl view of parsing is\r\nessentially top-down (perhaps with a bottom-up \"middle layer\" to handle\r\noperator precedence), it is extremely useful for user understanding\r\nif at least the token processing proceeds deterministically.  So for\r\nregex matching purposes we define token patterns as those patterns\r\nthat can be matched without potential side effects or self-reference.\r\n(Since whitespace often has side effects at line transitions, it\r\nis usually excluded from such patterns, give or take a little\r\nlookahead.)  Basically, Perl automatically derives a lexer\r\nfrom the grammar without you having to write one yourself.\r\n\r\nTo that end, every regex in Perl 6 is required to be able to\r\ndistinguish its \"pure\" patterns from its actions, and return its\r\nlist of initial token patterns (transitively including the token\r\npatterns of any subrule called by the \"pure\" part of that regex, but\r\nnot including any subrule more than once, since that would involve\r\nself reference, which is not allowed in traditional regular\r\nexpressions).  A logical alternation using `|` then takes two or\r\nmore of these lists and dispatches to the alternative that matches\r\nthe longest token prefix.  This may or may not be the alternative\r\nthat comes first lexically.\r\n\r\nHowever, if two alternatives match at the same length, the tie is\r\nbroken first by specificity.  The alternative that starts with the\r\nlongest fixed string wins; that is, an exact match counts as closer\r\nthan a match made using character classes.  If that doesn't work, the tie\r\nis broken by one of two methods.  If the alternatives are in different\r\ngrammars, standard MRO (method resolution order) determines which\r\none to try first.  If the alternatives are in the same grammar file, the\r\ntextually earlier alternative takes precedence.  (If a grammar's rules\r\nare defined in more than one file, the order is undefined, and an explicit\r\nassertion must be used to force failure if the wrong one is tried first.)\r\n\r\nThis longest token prefix corresponds roughly to the notion of \"token\"\r\nin other parsing systems that use a lexer, but in the case of Perl\r\nthis is largely an epiphenomenon derived automatically from the grammar\r\ndefinition.  However, despite being automatically calculated, the set of\r\ntokens can be modified by the user; various\r\nconstructs within a regex declaratively tell the grammar engine that\r\nit is finished with the pattern part and starting in on the side effects,\r\nso by inserting such constructs the user controls what is considered\r\na token and what is not.  The constructs deemed to terminate a token\r\ndeclaration and start the \"action\" part of the pattern include:\r\n\r\nAny :: or ::: backtracking control (but not the : possessive modifier).\r\n\r\nAny atom that is quantified with a frugal match (using the `?` modifier).\r\n\r\nAny `{...}` action, but not an assertion containing a closure.\r\n(The empty closure `{}` is customarily used to explicitly terminate\r\nthe pure part of the pattern.)  The closure form of the general\r\n`**{...}` quantifier also terminates the longest token, but the\r\nclosureless forms of quantifier do not.\r\n\r\nAny sequential control flow operator such as `||` or `&&`.\r\n\r\nAs a consequence of the previous point, and because the standard\r\ngrammar's C<< <ws> >> rule defines whitespace using `||`, the\r\nlongest token is also terminated by any part of the regex or rule\r\nthat `might` match whitespace using that rule, including whitespace\r\nimplicitly matched via `:sigspace`.  (However, token declarations are\r\nspecifically allowed to recognize whitespace within a token by using\r\nsuch lower-level primitives as C<\\h+> or other character classes.)\r\n\r\nSubpatterns (captures) specifically do not terminate the token pattern,\r\nbut may require a reparse of the token to find the location\r\nof the subpatterns.  Likewise assertions may need to be checked out\r\nafter the longest token is determined.  (Alternately, if DFA semantics\r\nare simulated in any of various ways, such as by Thompson NFA, it may\r\nbe possible to know when to fire off the assertions without backchecks.)\r\n\r\nGreedy quantifiers and character classes do not terminate a token pattern.\r\nZero-width assertions such as word boundaries are also okay.\r\n\r\nBecause such assertions can be part of the token, the lexer engine must\r\nbe able to recover from the failure of such an assertion and backtrack\r\nto the next best token candidate, which might be the same length or shorter,\r\nbut can never be longer than the current candidate.\r\n\r\nFor a pattern that contains a positive lookahead assertion such as\r\nC<< <?foo> >> or C<< <?before \\s> >>, the assertion is assumed to be\r\nmore specific than the subsequent pattern, so the lookahead's pattern\r\nis counted as the final part of the longest token; the longest-token\r\nmatcher will be smart enough to treat the extra bit as 0-width, that\r\nis, to rematch any text traversed by the lookahead when (and if)\r\nit continues the match.  (Indeed, if the entire lookahead is pure\r\nenough to participate in LTM, the rematcher may simply optimize away\r\nthe rematching, since the lookahead already matched in the LTM engine.)\r\n\r\nHowever, for a pattern that contains a negative lookahead assertion\r\nsuch as C<< <!foo> >> or C<< <!before \\s> >>, just the opposite is\r\ntrue: the subsequent pattern is assumed to be more specific than\r\nthe assertion's.  So LTM completely ignores negative lookaheads, and\r\ncontinues to look for pure patterns in whatever follows the negative\r\nlookahead.  You might say that positive lookaheads are opaque to LTM,\r\nbut negative lookaheads are transparent to LTM.  As a consequence,\r\nif you wish to write a positive lookahead that is transparent to\r\nLTM, you may indicate this with a double negation: C<< <!!foo> >>.\r\n(The optimizer is free to remove the double negation, but not the\r\ntransparency.)\r\n\r\nOddly enough, the `token` keyword specifically does not determine\r\nthe scope of a token, except insofar as a token pattern usually\r\ndoesn't do much matching of whitespace, and whitespace is the prototypical\r\nway of terminating tokens.\r\n\r\nThe initial token matcher must take into account case sensitivity\r\n(or any other canonicalization primitives) and do the right thing even\r\nwhen propagated up to rules that don't have the same canonicalization.\r\nThat is, they must continue to represent the set of matches that the\r\nlower rule would match.\r\n\r\nThe `||` form has the old short-circuit semantics, and will not\r\nattempt to match its right side unless all possibilities (including\r\nall `|` possibilities) are exhausted on its left.  The first `||`\r\nin a regex makes the token patterns on its left available to the\r\nouter longest-token matcher, but hides any subsequent tests from\r\nlongest-token matching.  Every `||` establishes a new longest-token\r\nmatcher.  That is, if you use `|` on the right side of `||`, that\r\nright side establishes a new top level scope for longest-token processing\r\nfor this subexpression and any called subrules.  The right side's\r\nlongest-token automaton is invisible to the left of the `||` or outside\r\nthe regex containing the `||`.\r\n\r\n# Return values from matches\r\n\r\n=head2 Match objects\r\n\r\nA successful match always returns a `Match` object, which is generally also\r\nput into `$/`, a dynamic lexical declared in the outer\r\nroutine that is calling the regex.  (A named `regex`, `token`,\r\nor `rule` is a routine, and hence declares its own\r\nlexical `$/` variable, which always refers to the most recent\r\nsubmatch within the rule, if any.)  The current match state is\r\nkept in the regex's C<$¢> variable which will eventually get\r\nbound to the user's `$/` variable when the match completes.\r\n\r\nAn unsuccessful match returns `Nil` (and sets `$/` to `Nil` if\r\nthe match would have set it).\r\n\r\nNotionally, a match object contains (among other things) a boolean\r\nsuccess value, an array of ordered submatch objects, and a hash of named\r\nsubmatch objects.  (It also optionally carries an I<abstract object> normally\r\nused to build up an abstract syntax tree,)  To provide convenient\r\naccess to these various values, the match object evaluates differently\r\nin different contexts:\r\n\r\nIn boolean context it evaluates as true or false (i.e. did the match\r\nsucceed?):\r\n\r\n     if /pattern/ {...}\r\n     # or:\r\n     /pattern/; if $/ {...}\r\n\r\nWith C<:global> or C<:overlap> or C<:exhaustive> the boolean is\r\nallowed to return true on the first match.  The `Match` object can\r\nproduce the rest of the results lazily if evaluated in list context.\r\n\r\nIn string context it evaluates to the stringified value of its match,\r\nwhich is usually the entire matched string:\r\n\r\n     print %hash{ \"{$text ~~ /<.ident>/}\" };\r\n     # or equivalently:\r\n     $text ~~ /<.ident>/  &&  print %hash{~$/};\r\n\r\nBut generally you should say C<~$/> if you mean C<~$/>.\r\n\r\nIn numeric context it evaluates to the numeric value of its match,\r\nwhich is usually the entire matched string:\r\n\r\n     $sum += /\\d+/;\r\n     # or equivalently:\r\n     /\\d+/; $sum = $sum + $/;\r\n\r\nWhen used as a scalar, a `Match` object evaluates to itself.\r\n\r\nHowever, sometimes you would like an alternate scalar value to\r\nride along with the match.  The `Match` object itself describes\r\na concrete parse tree, so this extra value is called an `abstract`\r\nobject; it rides along as an attribute of the `Match` object.\r\nThe `.made` method by default returns an undefined value.\r\nC<$()> is a shorthand for C<$($/.made // ~$/)>.\r\n\r\nTherefore C<$()> is usually just the entire match string, but\r\nyou can override that by calling `make` inside a regex:\r\n\r\n    my $moose = $(m[\r\n        <antler> <body>\r\n        { make Moose.new( body => $<body>.attach($<antler>) ) }\r\n        # match succeeds -- ignore the rest of the regex\r\n    ]);\r\n\r\nThis puts the new abstract node into C<$/.made>.  An AST node may be of any\r\ntype.  Using the `make`/`.made` mechanism, it is convenient to build up an\r\nabstract syntax tree of arbitrary node types.\r\n\r\nHowever, the `make` function is not limited to be used for storing AST\r\nnodes and building abstract syntax trees only.  This is just a specific Perl-6\r\ninternal use of this functionality.  Nor does the `make` function impose any\r\nitem or list context onto its argument, so if you say something ambiguously\r\nlisty like\r\n\r\n    make ()\r\n    make @array\r\n    make foo()\r\n\r\nthe value returned from `.made` will interpolate into a list.  To suppress\r\nthis, use one of these:\r\n\r\n    make ().item\r\n    make []\r\n    make $@array\r\n    make [@array]\r\n    make foo().item\r\n    make $(foo())\r\n\r\nor use `.made.item` or a `$` variable on the receiving end.\r\n\r\nThe `.ast` method is a synonym `.made` with no differing behavior. It exists\r\nboth for historical reasons and as a way to indicate to those reading your code\r\na more AST-like use of the `made`/`.make` mechanism.\r\n\r\nYou may also capture a subset of the match using the C<< <(...)> >> construct:\r\n\r\n    \"foo123bar\" ~~ / foo <( \\d+ )> bar /\r\n    say $();    # says 123\r\n\r\nIn this case C<$()> is always a string when doing string\r\nmatching, and a list of one or more elements when doing list matching.\r\nThis construct does not set the `.made` attribute.\r\n\r\nWhen used as an array, a `Match` object pretends to be an array of all\r\nits positional captures.  Hence\r\n\r\n     ($key, $val) = ms/ (\\S+) '=>' (\\S+)/;\r\n\r\ncan also be written:\r\n\r\n     $result = ms/ (\\S+) '=>' (\\S+)/;\r\n     ($key, $val) = @$result;\r\n\r\nTo get a single capture into a string, use a subscript:\r\n\r\n     $mystring = \"{ ms/ (\\S+) '=>' (\\S+)/[0] }\";\r\n\r\nTo get all the captures into a string, use a `zen` slice:\r\n\r\n     $mystring = \"{ ms/ (\\S+) '=>' (\\S+)/[] }\";\r\n\r\nOr cast it into an array:\r\n\r\n     $mystring = \"@( ms/ (\\S+) '=>' (\\S+)/ )\";\r\n\r\nNote that, as a scalar variable, `$/` doesn't automatically flatten\r\nin list context.  Use C<@()> as a shorthand for C<@($/)> to flatten\r\nthe positional captures under list context.  Note that a `Match` object\r\nis allowed to evaluate its match lazily in list context.  Use C<eager @()>\r\nto force an eager match.\r\n\r\nWhen used as a hash, a `Match` object pretends to be a hash of all its named\r\ncaptures.  The keys do not include any sigils, so if you capture to\r\nvariable C<< @<foo> >> its real name is C<$/{'foo'}> or C<< $/<foo> >>.\r\nHowever, you may still refer to it as C<< @<foo> >> anywhere `$/`\r\nis visible.  (But it is erroneous to use the same name for two different\r\ncapture datatypes.)\r\n\r\nNote that, as a scalar variable, `$/` doesn't automatically flatten\r\nin list context.  Use C<%()> as a shorthand for C<%($/)> to flatten as a\r\nhash, or bind it to a variable of the appropriate type.  As with C<@()>,\r\nit's possible for C<%()> to produce its pairs lazily in list context.\r\n\r\nThe numbered captures may be treated as named, so C<< $<0 1 2> >>\r\nis equivalent to C<$/[0,1,2]>.  This allows you to write slices of\r\nintermixed named and numbered captures.\r\n\r\nThe C<.keys>, C<.values> and C<.kv> methods act both on the list and hash\r\npart, with the list part coming first.\r\n\r\n    'abcd' ~~ /(.)(.)**2 <alpha>/;\r\n    say ~$/.keys;           # 0 1 alpha\r\n\r\nIn ordinary code, variables `$0`, C<$1>, etc. are just aliases into\r\nC<$/[0]>, C<$/[1]>, etc.  Hence they will all be undefined if the\r\nlast match failed (unless they were explicitly bound in a closure without\r\nusing the `let` keyword).\r\n\r\n`Match` objects have methods that provide additional information about\r\nthe match. For example:\r\n\r\n     if m/ def <ident> <codeblock> / {\r\n         say \"Found sub def from index $/.from.bytes \",\r\n             \"to index $/.to.bytes\";\r\n     }\r\n\r\nThe currently defined methods are\r\n\r\n    $/.from      # the initial match position\r\n    $/.to        # the final match position\r\n    $/.chars     # $/.to - $/.from\r\n    $/.orig      # the original match string\r\n    $/.Str       # substr($/.orig, $/.from, $/.chars)\r\n    $/.made      # the abstract result associated with this node (from make)\r\n    $/.ast       # same as $/.made\r\n    $/.caps      # sequential captures\r\n    $/.chunks    # sequential tokenization\r\n    $/.prematch  # $/.orig.substr(0, $/.from)\r\n    $/.postmatch # $/.orig.substr($/.to)\r\n\r\nWithin the regex the current match state C<$¢> also provides\r\n\r\n    .pos        # the current match position\r\n\r\nThis last value may correspond to either C<$¢.from> or C<$¢.to> depending\r\non whether the match is proceeding in a forward or backward direction\r\n(the latter case arising inside an C<< <?after ...> >> assertion).\r\n\r\nAs described above, a `Match` in list context returns its positional\r\ncaptures.  However, sometimes you'd rather get a flat list of tokens\r\nin the order they occur in the text.  The `.caps` method returns\r\na list of every capture in order, regardless of how it was otherwise\r\nbound into named or numbered captures.  (Other than order, there is\r\nno new information here; all the elements of the list are the very\r\nsame `Match` objects that bound elsewhere.)  The bindings are actually\r\nreturned as key/value pairs where the key is the name or number under which\r\nthe match object was bound, and the value is the match object itself.\r\n\r\nIn addition to returning those captured `Match` objects, the\r\n`.chunks` method also returns all the interleaved \"noise\" between\r\nthe captures.  As with `.caps`, the list elements are in the order\r\nthey were originally in the text.  The interleaved bits are also\r\nreturned as pairs, where the key is '~' and the value\r\nis a simple `Match` object containing only the string, even if unbound\r\nsubrules such as `.ws` were called to traverse the text in the first\r\nplace.  Calling `.made` on such a `Match` object always returns a `Str`.\r\n\r\nA warning will be issued if either `.caps` or `.chunks` discovers\r\nthat it has overlapping bindings.  In the absence of such overlap,\r\n`.chunks` guarantees to map every part of its matched string (between\r\nC<.from> and C<.to>) to exactly one element of its returned matches,\r\nso coverage is complete.\r\n\r\n[Conjecture: we could also have `.deepcaps` and `.deepchunks` that\r\nrecursively expand any capture containing submatches.  Presumably the\r\nkeys of such returned chunks would indicate the \"pedigree\" of bindings\r\nin the parse tree.]\r\n\r\nAll match attempts--successful or not--against any regex, subrule,\r\nor subpattern (see below) return an object that can be evaluated\r\nas a boolean.  (This object will be either a `Match` or a `Nil`.)\r\nThat is:\r\n\r\n     $match_obj = $str ~~ /pattern/;\r\n     say \"Matched\" if $match_obj;\r\n\r\nThis returned object is also automatically bound to the lexical\r\n`$/` variable of the current surroundings regardless of success. That is:\r\n\r\n     $str ~~ /pattern/;\r\n     say \"Matched\" if $/;\r\n\r\nInside a regex, the C<$¢> variable holds the current regex's incomplete\r\n`Match` object, known as a match state (of type `Cursor`).  Generally this should not\r\nbe modified unless you know how to create and propagate match states.\r\nAll regexes actually return match states even when you think they're\r\nreturning something else, because the match states keep track of\r\nthe successes and failures of the pattern for you.\r\n\r\nFortunately, when you just want to return a different abstract result along with\r\nthe default concrete `Match` object, you may associate your return value with\r\nthe current match state using the `make` function, which works something\r\nlike a `return`, but doesn't clobber the match state:\r\n\r\n    $str ~~ / foo                 # Match 'foo'\r\n               { make 'bar' }     # But pretend we matched 'bar'\r\n             /;\r\n    say $();                      # says 'bar'\r\n\r\nThe value of any `Match` object (such as an abstract object) is available via\r\nthe C<< .made >> method.  Hence these abstract objects can be managed\r\nindependently of the returned cursor objects.\r\n\r\nThe current cursor object must always be derived from `Cursor`, or the\r\nmatch will not work.  However, within that constraint, the actual type\r\nof the current cursor defines which language you are currently parsing.\r\nWhen you enter the top of a grammar, this cursor generally starts out\r\nas an object whose type is the name of the grammar you are in, but the\r\ncurrent language can be modified by various methods as they mutate the\r\ncurrent language by returning cursor objects blessed into a different\r\ntype, which may or may not be derived from the current grammar.\r\n\r\n=head2 Subpattern captures\r\n\r\nAny part of a regex that is enclosed in capturing parentheses is called a\r\n`subpattern`. For example:\r\n\r\n        #               subpattern\r\n        #  _________________/\\___________________\r\n        # |                                      |\r\n        # |       subpattern  subpattern         |\r\n        # |          __/\\__    __/\\__            |\r\n        # |         |      |  |      |           |\r\n      ms/ (I am the (walrus), ( khoo )**2  kachoo) /;\r\n\r\nEach subpattern in a regex produces a `Match` object if it is\r\nsuccessfully matched.\r\n\r\nEach subpattern is either explicitly assigned to a named destination or\r\nimplicitly added to an array of matches.\r\n\r\nFor each subpattern that is not explicitly given a name,\r\nthe subpattern's `Match` object is pushed onto the array inside\r\nthe outer `Match` object belonging to the surrounding scope (known as\r\nits I<parent `Match` object>). The surrounding scope may be either the\r\ninnermost surrounding subpattern (if the subpattern is nested) or else\r\nthe entire regex itself.\r\n\r\nLike all captures, these assignments to the array are hypothetical, and\r\nare undone if the subpattern is backtracked.\r\n\r\nFor example, if the following pattern matched successfully:\r\n\r\n        #                subpat-A\r\n        #  _________________/\\__________________\r\n        # |                                     |\r\n        # |         subpat-B  subpat-C          |\r\n        # |          __/\\__    __/\\__           |\r\n        # |         |      |  |      |          |\r\n      ms/ (I am the (walrus), ( khoo )**2 kachoo) /;\r\n\r\nthen the `Match` objects representing the matches made by I<subpat-B>\r\nand I<subpat-C> would be successively pushed onto the array inside I<subpat-\r\nA>'s `Match` object. Then I<subpat-A>'s `Match` object would itself be\r\npushed onto the array inside the `Match` object for the entire regex\r\n(i.e. onto `$/`'s array).\r\n\r\nAs a result of these semantics, capturing parentheses in Perl 6 are\r\nhierarchical, not linear (see L<Nested subpattern captures>).\r\n\r\n=head2 Accessing captured subpatterns\r\n\r\nThe array elements of a `Match` object are referred to using either the\r\nstandard array access notation (e.g. C<$/[0]>, C<$/[1]>, C<$/[2]>, etc.)\r\nor else via the corresponding lexically scoped numeric aliases (i.e.\r\n`$0`, C<$1>, C<$2>, etc.) So:\r\n\r\n     say \"$/[1] was found between $/[0] and $/[2]\";\r\n\r\nis the same as:\r\n\r\n     say \"$1 was found between $0 and $2\";\r\n\r\nNote that, in Perl 6, the numeric capture variables start from $0, not\r\n$1, with the numbers corresponding to the element's index inside `$/`.\r\n\r\nThe array elements of the regex's `Match` object (i.e. `$/`)\r\nstore individual `Match` objects representing the substrings that were\r\nmatched and captured by the first, second, third, etc. `outermost`\r\n(i.e. unnested) subpatterns. So these elements can be treated like fully\r\nfledged match results. For example:\r\n\r\n     if m/ (\\d\\d\\d\\d)-(\\d\\d)-(\\d\\d) (BCE?|AD|CE)?/ {\r\n           ($yr, $mon, $day) = $/[0..2];\r\n           $era = \"$3\" if $3;                    # stringify/boolify\r\n           @datepos = ( $0.from() .. $2.to() );  # Call Match methods\r\n     }\r\n\r\n=head2 Nested subpattern captures\r\n\r\nSubstrings matched by `nested` subpatterns (i.e. nested capturing\r\nparens) are assigned to the array inside the nested subpattern's parent `Match`\r\nobject, not to the array of `$/`.\r\n\r\nThis behavior is quite different from Perl 5 semantics:\r\n\r\n      # Perl-5...\r\n      #\r\n      # $1---------------------  $4---------  $5------------------\r\n      # |   $2---------------  | |          | | $6----  $7------  |\r\n      # |   |         $3--   | | |          | | |     | |       | |\r\n      # |   |         |   |  | | |          | | |     | |       | |\r\n     m/ ( A (guy|gal|g(\\S+)  ) ) (sees|calls) ( (the|a) (gal|guy) ) /x;\r\n\r\nIn Perl 6, nested parens produce properly nested captures:\r\n\r\n      # Perl-6...\r\n      #\r\n      # $0---------------------  $1---------  $2------------------\r\n      # |   $0[0]------------  | |          | | $2[0]-  $2[1]---  |\r\n      # |   |       $0[0][0] | | |          | | |     | |       | |\r\n      # |   |         |   |  | | |          | | |     | |       | |\r\n     m/ ( A (guy|gal|g(\\S+)  ) ) (sees|calls) ( (the|a) (gal|guy) ) /;\r\n\r\n=head2 Quantified subpattern captures\r\n\r\nIf a subpattern is directly quantified with `?`, it either produces\r\na single `Match` object, or `Nil`.  If a subpattern is directly\r\nquantified using any other quantifier, it never produces a single\r\n`Match` object.  Instead, it produces a list of `Match` objects\r\ncorresponding to the sequence of individual matches made by the\r\nrepeated subpattern.  If we need to distinguish the two categories,\r\n`?` is an I<item quantifier>, while `*`, C<+>, and `**` are called\r\nI<list quantifiers>.\r\n\r\nIf 0 values match, the captured value depends on which quantifier\r\nis used.  If the quantifier is `?`, a `Nil` is captured if it\r\nmatched 0 times.  If the quantifier is `*`, the empty list, `()`,\r\nis captured instead.  (Nothing is captured by the C<+> quantifier\r\nif it matches 0 times, since it causes backtracking, but the capture\r\nvariable should return `Nil` if an attempt is made to use it after\r\nan unsuccessful match.)  A `**` quantifier returns () as `*` does\r\nif it the minimum of its range is 0, and backtracks otherwise.\r\n\r\nNote that C<** 0..1> is always considered a list quantifier, unlike `?`.\r\n\r\nThe rationale for treating `?` as an item quantifier is to make\r\nit consistent with how C<$object.?meth> is defined, and to reduce\r\nthe need for gratuitous `.[0]` subscripts, which is surprising to\r\nmost people.  Now that `Nil` is considered undefined rather than a\r\nsynonym for `()`, it's easy to use C<$0 // \"default\"> or some such\r\nto dereference a capture safely.\r\n\r\nBecause a list-quantified subpattern returns a list of `Match` objects, the\r\ncorresponding array element for the quantified capture will store a\r\n(nested) array rather than a single `Match` object.  For example:\r\n\r\n     if m/ (\\w+) \\: (\\w+ \\s+)* / {\r\n         say \"Key:    $0\";         # Unquantified --> single Match\r\n         say \"Values: @($1)\";      # Quantified   --> array of Match\r\n     }\r\n\r\n=head2 Indirectly quantified subpattern captures\r\n\r\nA subpattern may sometimes be nested inside a quantified non-capturing\r\nstructure:\r\n\r\n      #       non-capturing       quantifier\r\n      #  __________/\\____________  __/\\__\r\n      # |                        ||      |\r\n      # |   $0         $1        ||      |\r\n      # |  _^_      ___^___      ||      |\r\n      # | |   |    |       |     ||      |\r\n     m/ [ (\\w+) \\: (\\w+ \\h*)* \\n ] ** 2..* /\r\n\r\nNon-capturing brackets I<don't> create a separate nested lexical scope,\r\nso the two subpatterns inside them are actually still in the regex's\r\ntop-level scope, hence their top-level designations: `$0` and C<$1>.\r\n\r\nHowever, because the two subpatterns are inside a quantified\r\nstructure, `$0` and C<$1> will each contain an array.\r\nThe elements of that array will be the submatches returned by the\r\ncorresponding subpatterns on each iteration of the non-capturing\r\nparentheses. For example:\r\n\r\n     my $text = \"foo:food fool\\nbar:bard barb\";\r\n\r\n               #   $0--     $1------\r\n               #   |   |    |       |\r\n     $text ~~ m/ [ (\\w+) \\: (\\w+ \\h*)* \\n ] ** 2..* /;\r\n\r\n     # Because they're in a quantified non-capturing block...\r\n     # $0 contains the equivalent of:\r\n     #\r\n     #       [ Match.new(str=>'foo'), Match.new(str=>'bar') ]\r\n     #\r\n     # and $1 contains the equivalent of:\r\n     #\r\n     #       [ Match.new(str=>'food '),\r\n     #         Match.new(str=>'fool' ),\r\n     #         Match.new(str=>'bard '),\r\n     #         Match.new(str=>'barb' ),\r\n     #       ]\r\n\r\nIn contrast, if the outer quantified structure is a `capturing`\r\nstructure (i.e. a subpattern) then it `will` introduce a nested\r\nlexical scope. That outer quantified structure will then\r\nreturn an array of `Match` objects representing the captures\r\nof the inner parens for `every` iteration (as described above). That is:\r\n\r\n     my $text = \"foo:food fool\\nbar:bard barb\";\r\n\r\n               # $0-----------------------\r\n               # |                        |\r\n               # | $0[0]    $0[1]---      |\r\n               # | |   |    |       |     |\r\n     $text ~~ m/ ( (\\w+) \\: (\\w+ \\h*)* \\n ) ** 2..* /;\r\n\r\n     # Because it's in a quantified capturing block,\r\n     # $0 contains the equivalent of:\r\n     #\r\n     #       [ Match.new( str=>\"foo:food fool\\n\",\r\n     #                    arr=>[ Match.new(str=>'foo'),\r\n     #                           [\r\n     #                               Match.new(str=>'food '),\r\n     #                               Match.new(str=>'fool'),\r\n     #                           ]\r\n     #                         ],\r\n     #                  ),\r\n     #         Match.new( str=>'bar:bard barb',\r\n     #                    arr=>[ Match.new(str=>'bar'),\r\n     #                           [\r\n     #                               Match.new(str=>'bard '),\r\n     #                               Match.new(str=>'barb'),\r\n     #                           ]\r\n     #                         ],\r\n     #                  ),\r\n     #       ]\r\n     #\r\n     # and there is no $1\r\n\r\nIn other words, quantified non-capturing parens collect their components\r\ninto handy flattened lists, whereas quantified capturing parens collect\r\ntheir components in a handy hierarchical structure.\r\n\r\nAdditionally, the sublists are kept \"in sync\" with each other, as each empty\r\nmatch, in the case of C<$0[1]> in our example if a `:` is followed by a\r\nnewline character, will have a corresponding Nil in the given list.\r\n\r\n=head2 Subpattern numbering\r\n\r\nThe index of a given subpattern can always be statically determined, but\r\nis not necessarily unique nor always monotonic. The numbering of subpatterns\r\nrestarts in each lexical scope (either a regex, a subpattern, or the\r\nbranch of an alternation).\r\n\r\nIn particular, the index of capturing parentheses restarts after each\r\n`|` or `||` (but not after each `&` or `&&`). Hence:\r\n\r\n                  # $0      $1    $2   $3    $4           $5\r\n     $tune_up = rx/ (\"don't\") (ray) (me) (for) (solar tea), (\"d'oh!\")\r\n                  # $0      $1      $2    $3        $4\r\n                  | (every) (green) (BEM) (devours) (faces)\r\n                  /;\r\n\r\nThis means that if the second alternation matches, the list value of the match will\r\ncontain C<('every', 'green', 'BEM', 'devours', 'faces')> rather than\r\nPerl-5's C<(undef, undef, undef, undef, undef, undef, 'every', 'green', 'BEM',\r\n'devours', 'faces')>.\r\n\r\nNote that it is still possible to mimic the monotonic Perl 5 capture\r\nindexing semantics.  See L<Numbered scalar aliasing> below for details.\r\n\r\n=head2 Subrule captures\r\n\r\nAny call to a named C<< <regex> >> within a pattern is known as a\r\n`subrule`, whether that regex is actually defined as a `regex` or\r\n`token` or `rule` or even an ordinary `method` or `multi`.\r\n\r\nAny bracketed construct that is aliased (see L</Aliasing> below) to a\r\nnamed variable is also a subrule.\r\n\r\nFor example, this regex contains three subrules:\r\n\r\n      # subrule       subrule     subrule\r\n      #  __^__    _______^_____    __^__\r\n      # |     |  |             |  |     |\r\n     m/ <ident>  $<spaces>=(\\s*)  <digit>+ /\r\n\r\nJust like subpatterns, each successfully matched subrule within a regex\r\nproduces a `Match` object. But, unlike subpatterns, that `Match`\r\nobject is not assigned to the array inside its parent `Match` object.\r\nInstead, it is assigned to an entry of the hash inside its parent `Match`\r\nobject. For example:\r\n\r\n      #  .... $/ .....................................\r\n      # :                                             :\r\n      # :              .... $/[0] ..................  :\r\n      # :             :                             : :\r\n      # : $/<ident>   :        $/[0]<ident>         : :\r\n      # :   __^__     :           __^__             : :\r\n      # :  |     |    :          |     |            : :\r\n      ms/  <ident> \\: ( known as <ident> previously ) /\r\n\r\n=head2 Accessing captured subrules\r\n\r\nThe hash entries of a `Match` object can be referred to using any of the\r\nstandard hash access notations (C<$/{'foo'}>, C<< $/<bar> >>, C<$/«baz»>,\r\netc.), or else via corresponding lexically scoped aliases (C<< $<foo> >>,\r\nC<$«bar»>, C<< $<baz> >>, etc.)  So the previous example also implies:\r\n\r\n      #    $<ident>             $0<ident>\r\n      #     __^__                 __^__\r\n      #    |     |               |     |\r\n      ms/  <ident> \\: ( known as <ident> previously ) /\r\n\r\nNote that it makes no difference whether a subrule is angle-bracketed\r\n(C<< <ident> >>) or aliased internally (C<< <ident=.name> >>) or aliased\r\nexternally (C<< $<ident>=(<.alpha>\\w*) >>). The name's the thing.\r\n\r\n=head2 Repeated captures of the same subrule\r\n\r\nIf a subrule appears two (or more) times in any branch of a lexical\r\nscope (i.e. twice within the same subpattern and alternation), or if\r\nthe subrule is list-quantified anywhere within a given scope (that is,\r\nby any quantifier other than `?`), then its corresponding hash entry\r\nis always assigned an array of `Match` objects rather than a single\r\n`Match` object.\r\n\r\nSuccessive matches of the same subrule (whether from separate calls, or\r\nfrom a single quantified repetition) append their individual `Match`\r\nobjects to this array. For example:\r\n\r\n     if ms/ mv <file> <file> / {\r\n         $from = $<file>[0];\r\n         $to   = $<file>[1];\r\n     }\r\n\r\n(Note, for clarity we are ignoring whitespace subtleties here--the\r\nnormal sigspace rules would require space only between alphanumeric\r\ncharacters, which is wrong.  Assume that our file subrule deals\r\nwith whitespace on its own.)\r\n\r\nLikewise, with a quantified subrule:\r\n\r\n     if ms/ mv <file> ** 2 / {\r\n         $from = $<file>[0];\r\n         $to   = $<file>[1];\r\n     }\r\n\r\nAnd with a mixture of both:\r\n\r\n     if ms/ mv <file>+ <file> / {\r\n         $to   = pop @($<file>);\r\n         @from = @($<file>);\r\n     }\r\n\r\nTo avoid name collisions, you may suppress the original name by use\r\nof a leading dot, and then use an alias to give the capture a different name:\r\n\r\n     if ms/ mv <file> <dir=.file> / {\r\n         $from = $<file>;  # Only one subrule named <file>, so scalar\r\n         $to   = $<dir>;   # The Capture Formerly Known As <file>\r\n     }\r\n\r\nLikewise, neither of the following constructions causes C<< <file> >> to\r\nproduce an array of `Match` objects, since none of them has two or more\r\nC<< <file> >> subrules in the same lexical scope:\r\n\r\n     if ms/ (keep) <file> | (toss) <file> / {\r\n         # Each <file> is in a separate alternation, therefore <file>\r\n         # is not repeated in any one scope, hence $<file> is\r\n         # not an Array object...\r\n         $action = $0;\r\n         $target = $<file>;\r\n     }\r\n\r\n     if ms/ <file> \\: (<file>|none) / {\r\n         # Second <file> nested in subpattern which confers a\r\n         # different scope...\r\n         $actual  = $/<file>;\r\n         $virtual = $/[0]<file> if $/[0]<file>;\r\n     }\r\n\r\nOn the other hand, unaliased square brackets don't confer a separate\r\nscope (because they don't have an associated `Match` object). So:\r\n\r\n     if ms/ <file> \\: [<file>|none] / { # Two <file>s in same scope\r\n         $actual  = $/<file>[0];\r\n         $virtual = $/<file>[1] if $/<file>[1];\r\n     }\r\n\r\n=head2 Aliasing\r\n\r\nAliases can be named or numbered. They can be scalar-, array-, or hash-like.\r\nAnd they can be applied to either capturing or non-capturing constructs. The\r\nfollowing sections highlight special features of the semantics of some\r\nof those combinations.\r\n\r\n=head3 Named scalar aliasing to subpatterns\r\n\r\nIf a named scalar alias is applied to a set of `capturing` parens:\r\n\r\n        #         _____/capturing parens\\_____\r\n        #        |                            |\r\n        #        |                            |\r\n      ms/ $<key>=( (<[A..E]>) (\\d**3..6) (X?) ) /;\r\n\r\nthen the outer capturing parens no longer capture into the array of\r\n`$/` as unaliased parens would. Instead the aliased parens capture\r\ninto the hash of `$/`; specifically into the hash element\r\nwhose key is the alias name.\r\n\r\nSo, in the above example, a successful match sets\r\nC<< $<key> >> (i.e. C<< $/<key> >>), but `not` `$0` (i.e. not C<< $/[0] >>).\r\n\r\nMore specifically:\r\n\r\nC<< $/<key> >> will contain the `Match` object that would previously have\r\nbeen placed in C<< $/[0] >>.\r\n\r\nC<< $/<key>[0] >> will contain the A-E letter,\r\n\r\nC<< $/<key>[1] >> will contain the digits,\r\n\r\nC<< $/<key>[2] >> will contain the optional X.\r\n\r\nAnother way to think about this behavior is that aliased parens create\r\na kind of lexically scoped named subrule; that the contents of the\r\nparentheses are treated as if they were part of a separate subrule whose\r\nname is the alias.\r\n\r\n=head3 Named scalar aliases applied to non-capturing brackets\r\n\r\nIf a named scalar alias is applied to a set of I<non-capturing> brackets:\r\n\r\n        #         __/non-capturing brackets\\__\r\n        #        |                            |\r\n        #        |                            |\r\n      ms/ $<key>=[ (<[A..E]>) (\\d**3..6) (X?) ] /;\r\n\r\nthen the corresponding C<< $/<key> >> `Match` object contains only the string\r\nmatched by the non-capturing brackets.\r\n\r\nIn particular, the array of the C<< $/<key> >> entry is empty. That's\r\nbecause square brackets do not create a nested lexical scope, so the\r\nsubpatterns are unnested and hence correspond to $0, $1, and $2, and\r\n`not` to C<< $/<key>[0] >>, C<< $/<key>[1] >>, and C<< $/<key>[2] >>.\r\n\r\nIn other words:\r\n\r\nC<< $/<key> >> will contain the complete substring matched by the square\r\nbrackets (in a `Match` object, as described above),\r\n\r\nC<< $0 >> will contain the A-E letter,\r\n\r\nC<< $1 >> will contain the digits,\r\n\r\nC<< $2 >> will contain the optional X.\r\n\r\n=head3 Named scalar aliasing to subrules\r\n\r\nIf a subrule is aliased, it assigns its `Match` object to the hash\r\nentry whose key is the name of the alias, as well as to the original name.\r\n\r\n     if m/ ID\\: <id=ident> / {\r\n         say \"Identified as $/<id> and $/<ident>\";    # both names defined\r\n     }\r\n\r\nTo suppress the original name, use the dot form:\r\n\r\n     if m/ ID\\: <id=.ident> / {\r\n         say \"Identified as $/<id>\";    # $/<ident> is undefined\r\n     }\r\n\r\nHence aliasing a dotted subrule `changes` the destination of the subrule's `Match`\r\nobject. This is particularly useful for differentiating two or more calls to\r\nthe same subrule in the same scope. For example:\r\n\r\n     if ms/ mv <file>+ <dir=.file> / {\r\n         @from = @($<file>);\r\n         $to   = $<dir>;\r\n     }\r\n\r\n=head3 Numbered scalar aliasing\r\n\r\nIf a numbered alias is used instead of a named alias:\r\n\r\n     m/ $1=(<-[:]>*) \\:  $0=<ident> /   # captures $<ident> too\r\n     m/ $1=(<-[:]>*) \\:  $0=<.ident> /  # doesn't capture $<ident>\r\n\r\nthe behavior is exactly the same as for a named alias (i.e. the various\r\ncases described above), except that the resulting `Match` object is\r\nassigned to the corresponding element of the appropriate array rather\r\nthan to an element of the hash.\r\n\r\nIf any numbered alias is used, the numbering of subsequent unaliased\r\nsubpatterns in the same scope automatically increments from that\r\nalias number (much like enum values increment from the last explicit\r\nvalue). That is:\r\n\r\n      #  --$1---    -$2-    --$6---    -$7-\r\n      # |       |  |    |  |       |  |    |\r\n     m/ $1=(food)  (bard)  $6=(bazd)  (quxd) /;\r\n\r\nThis I<follow-on> behavior is particularly useful for reinstituting\r\nPerl5 semantics for consecutive subpattern numbering in alternations:\r\n\r\n     $tune_up = rx/ (\"don't\") (ray) (me) (for) (solar tea), (\"d'oh!\")\r\n                  | $6 = (every) (green) (BEM) (devours) (faces)\r\n                  #              $7      $8    $9        $10\r\n                  /;\r\n\r\nIt also provides an easy way in Perl 6 to reinstitute the unnested\r\nnumbering semantics of nested Perl 5 subpatterns:\r\n\r\n      # Perl-5...\r\n      #               $1\r\n      #  _____________/\\___________\r\n      # |    $2        $3      $4  |\r\n      # |  __/\\___   __/\\___   /\\  |\r\n      # | |       | |       | |  | |\r\n     m/ ( ( [A-E] ) (\\d{3,6}) (X?) ) /x;\r\n\r\n      # Perl-6...\r\n      #                $0\r\n      #  ______________/\\______________\r\n      # |   $0[0]       $0[1]    $0[2] |\r\n      # |  ___/\\___   ____/\\____   /\\  |\r\n      # | |        | |          | |  | |\r\n     m/ ( (<[A..E]>) (\\d ** 3..6) (X?) ) /;\r\n\r\n      # Perl-6 simulating Perl-5...\r\n      #                 $1\r\n      #  _______________/\\________________\r\n      # |        $2          $3       $4  |\r\n      # |     ___/\\___   ____/\\____   /\\  |\r\n      # |    |        | |          | |  | |\r\n     m/ $1=[ (<[A..E]>) (\\d ** 3..6) (X?) ] /;\r\n\r\nThe non-capturing brackets don't introduce a scope, so the subpatterns within\r\nthem are at regex scope, and hence numbered at the top level. Aliasing the\r\nsquare brackets to C<$1> means that the next subpattern at the same level\r\n(i.e. the C<< (<[A..E]>) >>) is numbered sequentially (i.e. C<$2>), etc.\r\n\r\n=head3 Scalar aliases applied to quantified constructs\r\n\r\nAll of the above semantics apply equally to aliases which are bound to\r\nquantified structures.\r\n\r\nThe only difference is that, if the aliased construct is a subrule or\r\nsubpattern, that quantified subrule or subpattern will have returned a\r\nlist of `Match` objects (as described in L<Quantified subpattern\r\ncaptures> and L<Repeated captures of the same subrule>).\r\nSo the corresponding array element or hash entry for the alias will\r\ncontain an array, instead of a single `Match` object.\r\n\r\nIn other words, aliasing and quantification are completely orthogonal.\r\nFor example:\r\n\r\n     if ms/ mv $0=<.file>+ / {\r\n         # <file>+ returns a list of Match objects,\r\n         # so $0 contains an array of Match objects,\r\n         # one for each successful call to <file>\r\n\r\n         # $/<file> does not exist (it's suppressed by the dot)\r\n     }\r\n\r\n     if m/ mv \\s+ $<from>=(\\S+ \\s+)* / {\r\n         # Quantified subpattern returns a list of Match objects,\r\n         # so $/<from> contains an array of Match\r\n         # objects, one for each successful match of the subpattern\r\n\r\n         # $0 does not exist (it's pre-empted by the alias)\r\n     }\r\n\r\nNote, however, that a set of quantified I<non-capturing> brackets always\r\nreturns a single `Match` object which contains only the complete\r\nsubstring that was matched by the full set of repetitions of the\r\nbrackets (as described in L<Named scalar aliases applied to\r\nnon-capturing brackets>). For example:\r\n\r\n     \"coffee fifo fumble\" ~~ m/ $<effs>=[f <-[f]> ** 1..2 \\s*]+ /;\r\n\r\n     say $<effs>;    # prints \"fee fifo fum\"\r\n\r\n=head3 Array aliasing\r\n\r\nAn alias can also be specified using an array as the alias instead of a scalar.\r\nFor example:\r\n\r\n     m/ mv \\s+ @<from>=[(\\S+) \\s+]* <dir> /;\r\n\r\nUsing the C<< @alias= >> notation instead of a C<< $alias= >>\r\nmandates that the corresponding hash entry or array element `always`\r\nreceives an array of `Match` objects, even if the\r\nconstruct being aliased would normally return a single `Match` object.\r\nThis is useful for creating consistent capture semantics across\r\nstructurally different alternations (by enforcing array captures in all\r\nbranches):\r\n\r\n     ms/ Mr?s? @<names>=<ident> W\\. @<names>=<ident>\r\n        | Mr?s? @<names>=<ident>\r\n        /;\r\n\r\n     # Aliasing to @names means $/<names> is always\r\n     # an Array object, so...\r\n\r\n     say @($/<names>);\r\n\r\nFor convenience and consistency, C<< @<key> >> can also be used outside a\r\nregex, as a shorthand for C<< @( $/<key> ) >>. That is:\r\n\r\n     ms/ Mr?s? @<names>=<ident> W\\. @<names>=<ident>\r\n        | Mr?s? @<names>=<ident>\r\n        /;\r\n\r\n     say @<names>;\r\n\r\nIf an array alias is applied to a quantified pair of non-capturing\r\nbrackets, it captures the substrings matched by each repetition of the\r\nbrackets into separate elements of the corresponding array. That is:\r\n\r\n     ms/ mv $<files>=[ f.. \\s* ]* /; # $/<files> assigned a single\r\n                                     # Match object containing the\r\n                                     # complete substring matched by\r\n                                     # the full set of repetitions\r\n                                     # of the non-capturing brackets\r\n\r\n     ms/ mv @<files>=[ f.. \\s* ]* /; # $/<files> assigned an array,\r\n                                     # each element of which is a\r\n                                     # Match object containing\r\n                                     # the substring matched by Nth\r\n                                     # repetition of the non-\r\n                                     # capturing bracket match\r\n\r\nIf an array alias is applied to a quantified pair of capturing parens\r\n(i.e. to a subpattern), then the corresponding hash or array element is\r\nassigned a list constructed by concatenating the array values of each\r\n`Match` object returned by one repetition of the subpattern. That is,\r\nan array alias on a subpattern flattens and collects all nested\r\nsubpattern captures within the aliased subpattern. For example:\r\n\r\n     if ms/ $<pairs>=( (\\w+) \\: (\\N+) )+ / {\r\n         # Scalar alias, so $/<pairs> is assigned an array\r\n         # of Match objects, each of which has its own array\r\n         # of two subcaptures...\r\n\r\n         for @($<pairs>) -> $pair {\r\n             say \"Key: $pair[0]\";\r\n             say \"Val: $pair[1]\";\r\n         }\r\n     }\r\n\r\n     if ms/ @<pairs>=( (\\w+) \\: (\\N+) )+ / {\r\n         # Array alias, so $/<pairs> is assigned an array\r\n         # of Match objects, each of which is flattened out of\r\n         # the two subcaptures within the subpattern\r\n\r\n         for @($<pairs>) -> $key, $val {\r\n             say \"Key: $key\";\r\n             say \"Val: $val\";\r\n         }\r\n     }\r\n\r\nLikewise, if an array alias is applied to a quantified subrule, then the\r\nhash or array element corresponding to the alias is assigned a list\r\ncontaining the array values of each `Match` object returned by each\r\nrepetition of the subrule, all flattened into a single array:\r\n\r\n     rule pair { (\\w+) \\: (\\N+) \\n }\r\n\r\n     if ms/ $<pairs>=<pair>+ / {\r\n         # Scalar alias, so $/<pairs> contains an array of\r\n         # Match objects, each of which is the result of the\r\n         # <pair> subrule call...\r\n\r\n         for @($<pairs>) -> $pair {\r\n             say \"Key: $pair[0]\";\r\n             say \"Val: $pair[1]\";\r\n         }\r\n     }\r\n\r\n     if ms/ mv @<pairs>=<pair>+ / {\r\n         # Array alias, so $/<pairs> contains an array of\r\n         # Match objects, all flattened down from the\r\n         # nested arrays inside the Match objects returned\r\n         # by each match of the <pair> subrule...\r\n\r\n         for @($<pairs>) -> $key, $val {\r\n             say \"Key: $key\";\r\n             say \"Val: $val\";\r\n         }\r\n     }\r\n\r\nIn other words, an array alias is useful to flatten into a single array\r\nany nested captures that might occur within a quantified subpattern or subrule.\r\nWhereas a scalar alias is useful to preserve within a top-level array\r\nthe internal structure of each repetition.\r\n\r\nIt is also possible to use a numbered variable as an array alias.\r\nThe semantics are exactly as described above, with the sole difference\r\nbeing that the resulting array of `Match` objects is assigned into the\r\nappropriate element of the regex's match array rather than to a key of\r\nits match hash. For example:\r\n\r\n     if m/ mv  \\s+  @0=((\\w+) \\s+)+  $1=((\\W+) (\\s*))* / {\r\n         #          |                |\r\n         #          |                |\r\n         #          |                 \\_ Scalar alias, so $1 gets an\r\n         #          |                    array, with each element\r\n         #          |                    a Match object containing\r\n         #          |                    the two nested captures\r\n         #          |\r\n         #           \\___ Array alias, so $0 gets a flattened array of\r\n         #                just the (\\w+) captures from each repetition\r\n\r\n         @from     = @($0);      # Flattened list\r\n\r\n         $to_str   = $1[0][0];   # Nested elems of\r\n         $to_gap   = $1[0][1];   #    unflattened list\r\n     }\r\n\r\nNote again that, outside a regex, C<@0> is simply a shorthand for\r\nC<@($0)>, so the first assignment above could also have been written:\r\n\r\n     @from = @0;\r\n\r\n=head3 Hash aliasing\r\n\r\nAn alias can also be specified using a hash as the alias variable,\r\ninstead of a scalar or an array. For example:\r\n\r\n     m/ mv %<location>=( (<ident>) \\: (\\N+) )+ /;\r\n\r\nA hash alias causes the corresponding hash or array element in the\r\ncurrent scope's `Match` object to be assigned a (nested) Hash object\r\n(rather than an `Array` object or a single `Match` object).\r\n\r\nIf a hash alias is applied to a subrule or subpattern then the first nested\r\nnumeric capture becomes the key of each hash entry and any remaining numeric\r\ncaptures become the values (in an array if there is more than one).\r\n\r\nAs with array aliases it is also possible to use a numbered variable as\r\na hash alias. Once again, the only difference is where the resulting\r\n`Match` object is stored:\r\n\r\n     rule one_to_many {  (\\w+) \\: (\\S+) (\\S+) (\\S+) }\r\n\r\n     if ms/ %0=<one_to_many>+ / {\r\n         # $/[0] contains a hash, in which each key is provided by\r\n         # the first subcapture within `one_to_many`, and each\r\n         # value is an array containing the\r\n         # subrule's second, third, fourth, etc. subcaptures...\r\n\r\n         for %($/[0]) -> $pair {\r\n             say \"One:  $pair.key()\";\r\n             say \"Many: { @($pair.value) }\";\r\n         }\r\n     }\r\n\r\nOutside the regex, C<%0> is a shortcut for C<%($0)>:\r\n\r\n         for %0 -> $pair {\r\n             say \"One:  $pair.key()\";\r\n             say \"Many: @($pair.value)\";\r\n         }\r\n\r\n=head3 External aliasing\r\n\r\nInstead of using internal aliases like:\r\n\r\n     m/ mv  @<files>=<ident>+  $<dir>=<ident> /\r\n\r\nthe name of an ordinary variable can be used as an `external` alias, like so:\r\n\r\n     m/ mv  @OUTER::files=<ident>+  $OUTER::dir=<ident> /\r\n\r\nIn this case, the behavior of each alias is exactly as described in the\r\nprevious sections, except that any resulting capture is bound\r\ndirectly (but still hypothetically) to the variable of the specified\r\nname that must already exist in the scope in which the regex is declared.\r\n\r\n=head2 Capturing from repeated matches\r\n\r\nWhen an entire regex is successfully matched with repetitions\r\n(specified via the C<:x> or `:g` flag) or overlaps (specified via the\r\nC<:ov> or C<:ex> flag), it will usually produce a sequence\r\nof distinct matches.\r\n\r\nA successful match under any of these flags still returns a single\r\n`Match` object in `$/`. However, this object may represent a partial\r\nevaluation of the regex.   Moreover, the values of this match object\r\nare slightly different from those provided by a non-repeated match:\r\n\r\nThe boolean value of `$/` after such matches is true or false, depending on\r\nwhether the pattern matched.\r\n\r\nThe string value is the substring from the start of the first match to\r\nthe end of the last match (`including` any intervening parts of the\r\nstring that the regex skipped over in order to find later matches).\r\n\r\nSubcaptures are returned as a multidimensional list, which the user can\r\nchoose to process in either of two ways.  If you refer to\r\nC<@().flat> (or just use C<@()> in a flat list context), the multidimensionality\r\nis ignored and all the matches are returned flattened (but still lazily).  If\r\nyou refer to C<lol()>, you can get each individual sublist as a `Parcel`\r\nobject. As with any multidimensional list, each sublist can be lazy separately.\r\n\r\nFor example:\r\n\r\n     if $text ~~ ms:g/ (\\S+:) <rocks> / {\r\n         say \"Full match context is: [$/]\";\r\n     }\r\n\r\nBut the list of individual match objects corresponding to each separate\r\nmatch is also available:\r\n\r\n     if $text ~~ ms:g/ (\\S+:) <rocks> / {\r\n         say \"Matched { +lol() } times\";    # Note: forced eager here by +\r\n\r\n         for lol() -> $m {\r\n             say \"Match between $m.from() and $m.to()\";\r\n             say 'Right on, dude!' if $m[0] eq 'Perl';\r\n             say \"Rocks like $m<rocks>\";\r\n         }\r\n     }\r\n\r\n# Grammars\r\n\r\nYour private `ident` rule shouldn't clobber someone else's\r\n`ident` rule.  So some mechanism is needed to confine rules to a namespace.\r\n\r\nIf subs are the model for rules, then modules/classes are the obvious\r\nmodel for aggregating them.  Such collections of rules are generally\r\nknown as `grammars`.\r\n\r\nJust as a class can collect named actions together:\r\n\r\n     class Identity {\r\n         method name { \"Name = $.name\" }\r\n         method age  { \"Age  = $.age\"  }\r\n         method addr { \"Addr = $.addr\" }\r\n\r\n         method desc {\r\n             print &.name(), \"\\n\",\r\n                   &.age(),  \"\\n\",\r\n                   &.addr(), \"\\n\";\r\n         }\r\n\r\n         # etc.\r\n     }\r\n\r\nso too a grammar can collect a set of named rules together:\r\n\r\n     grammar Identity {\r\n         rule name { Name '=' (\\N+) }\r\n         rule age  { Age  '=' (\\d+) }\r\n         rule addr { Addr '=' (\\N+) }\r\n         rule desc {\r\n             <name> \\n\r\n             <age>  \\n\r\n             <addr> \\n\r\n         }\r\n\r\n         # etc.\r\n     }\r\n\r\nLike classes, grammars can inherit:\r\n\r\n     grammar Letter {\r\n         rule text     { <greet> $<body>=<line>+? <close> }\r\n\r\n         rule greet    { [Hi|Hey|Yo] $<to>=\\S+? ',' }\r\n\r\n         rule close    { Later dude ',' $<from>=.+ }\r\n\r\n         token line    { \\N* \\n}\r\n     }\r\n\r\n     grammar FormalLetter is Letter {\r\n\r\n         rule greet { Dear $<to>=\\S+? ',' }\r\n\r\n         rule close { Yours sincerely ',' $<from>=.+ }\r\n\r\n     }\r\n\r\nJust like the methods of a class, the rule definitions of a grammar are\r\ninherited (and polymorphic!). So there's no need to respecify `text`,\r\n`line`, etc.\r\n\r\nPerl 6 will come with at least one grammar predefined:\r\n\r\n     grammar STD {    # Perl's own standard grammar\r\n         rule prog { <statement>* }\r\n         rule statement {\r\n                   | <decl>\r\n                   | <loop>\r\n                   | <label> [<cond>|<sideff>|';']\r\n         }\r\n         rule decl { <sub> | <class> | <use> }\r\n         # etc. etc. etc.\r\n     }\r\n\r\nHence:\r\n\r\n     $parsetree = STD.parse($source_code)\r\n\r\nTo switch to a different grammar in the middle of a regex, you may use the `:lang` adverb.\r\nFor example, to match an expression <expr> from $funnylang that is embedded in curlies, say:\r\n\r\n    token funnylang { '{' [ :lang($funnylang.unbalanced('}')) <expr> ] '}' }\r\n\r\nA string can be matched against a grammar by calling C<.parse>\r\nor C<.parsefile> on the grammar, and optionally pass an `actions`\r\nobject to that grammar:\r\n\r\n    MyGrammar.parse($string, :actions($action-object))\r\n    MyGrammar.parsefile($filename, :actions($action-object))\r\n\r\nThis creates a `Grammar` object, whose type denotes the current language being\r\nparsed, and from which other grammars may be derived as extended languages.\r\nAll grammar objects are derived from `Cursor`, so every grammar object's\r\nvalue embodies the current state of the current match.  This new grammar\r\nobject is then passed as the invocant to the `TOP` method (regex, token,\r\nor rule) of `MyGrammar`. The default rule name to call can be overridden with\r\nthe C<:rule> named argument of the `parse` method. This is useful for unit testing\r\nthe rules of a grammar. As methods, rules can have arguments, so the C<:args> named\r\nargument is used to pass such arguments as a parcel if necessary.\r\n\r\nGrammar objects are considered immutable, so\r\nevery match returns a different match state, and multiple match states may\r\nexist simultaneously.  Each such match state is considered a hypothesis on\r\nhow the pattern will eventually match. A backtrackable choice in pattern\r\nmatching may be easily represented in Perl-6 as a lazy list of match state\r\ncursors; backtracking consists of merely throwing away the front value of\r\nthe list and continuing to match with the next value.  Hence, the management\r\nof these match cursors controls how backtracking works, and falls naturally\r\nout of the lazy list paradigm.\r\n\r\nThe C<.parse> and C<.parsefile> methods anchor to the beginning and ending of the text,\r\nand fail if the end of text is not reached. (The `TOP` rule can check against `$` itself\r\nif it wishes to produce its own error message.)\r\n\r\nIf you wish to parse a portion of a text, then use the C<.subparse> method instead.\r\nYou may pass a C<:pos> argument to start parsing at some position other than 0.\r\nYou may pass a C<:rule> argument to specify which subrule you're wanting to call.\r\nThe final position can be determined by examining the returned `Match` object.\r\n\r\n# Syntactic categories\r\n\r\nFor writing your own backslash and assertion subrules, you may augment\r\n(your copy of) the Regex sublanguage, using the following syntactic\r\ncategories:\r\n\r\n    augment slang Regex {\r\n        token backslash:sym<y> { ... }   # define your own \\y and \\Y\r\n        token assertion:sym<*> { ... }   # define your own <*stuff>\r\n        token metachar:sym<,> { ... }    # define a new metacharacter\r\n\r\n        multi method tweak (:$x) {...}   # define your own :x modifier\r\n    }\r\n\r\n# Pragmas\r\n\r\nVarious pragmas may be used to control various aspects of regex\r\ncompilation and usage not otherwise provided for.  These are tied\r\nto the particular declarator in question:\r\n\r\n    use s :foo;         # control s defaults\r\n    use m :foo;         # control m defaults\r\n    use rx :foo;        # control rx defaults\r\n    use regex :foo;     # control regex defaults\r\n    use token :foo;     # control token defaults\r\n    use rule :foo;      # control rule defaults\r\n\r\n(It is a general policy in Perl 6 that any pragma designed to influence\r\nthe surface behavior of a keyword is identical to the keyword itself, unless\r\nthere is good reason to do otherwise. On the other hand, pragmas designed\r\nto influence deep semantics should not be named identically, though of\r\ncourse some similarity is good.)\r\n\r\n# Transliteration\r\n\r\nThe C<tr///> quote-like operator now also has a method form called\r\nC<trans()>.  Its argument is a list of pairs.  You can use anything that\r\nproduces a pair list:\r\n\r\n     $str.trans( %mapping.pairs );\r\n\r\nUse the C<.=> form to do a translation in place:\r\n\r\n     $str.=trans( %mapping.pairs );\r\n\r\n(Perl 6 does not support the C<y///> form, which was only in `sed` because\r\nthey were running out of single letters.)\r\n\r\nThe two sides of any pair can be strings interpreted as C<tr///> would:\r\n\r\n     $str.=trans( 'A..C' => 'a..c', 'XYZ' => 'xyz' );\r\n\r\nAs a degenerate case, each side can be individual characters:\r\n\r\n     $str.=trans( 'A'=>'a', 'B'=>'b', 'C'=>'c' );\r\n\r\nWhitespace characters are taken literally as characters to be\r\ntranslated from or to.  The `..` range sequence is the only metasyntax\r\nrecognized within a string, though you may of course use backslash\r\ninterpolations in double quotes.  If the right side is too short, the\r\nfinal character is replicated out to the length of the left string.\r\nIf there is no final character because the right side is the null\r\nstring, the result is deletion instead.\r\n\r\nEither or both sides of the pair may also be Array objects:\r\n\r\n     $str.=trans( ['A'..'C'] => ['a'..'c'], <X Y Z> => <x y z> );\r\n\r\nThe array version is the underlying primitive form: the semantics of\r\nthe string form is exactly equivalent to first doing `..` expansion\r\nand then splitting the string into individual characters and then\r\nusing that as an array.\r\n\r\nThe array version can map one-or-more characters to one-or-more\r\ncharacters:\r\n\r\n     $str.=trans( [' ',      '<',    '>',    '&'    ] =>\r\n                  ['&nbsp;', '&lt;', '&gt;', '&amp;' ]);\r\n\r\nIn the case that more than one sequence of input characters matches,\r\nthe longest one wins.  In the case of two identical sequences the\r\nfirst in order wins.\r\n\r\nAs with the string form, missing righthand elements replicate the\r\nfinal element, and a null array results in deletion instead.\r\n\r\nThe recognition done by the string and array forms is very basic.\r\nTo achieve greater power, any recognition element of the left side\r\nmay be specified by a regex that can do character classes, lookahead,\r\netc.\r\n\r\n    $str.=trans( [/ \\h /,   '<',    '>',    '&'    ] =>\r\n                 ['&nbsp;', '&lt;', '&gt;', '&amp;' ]);\r\n\r\n    $str.=trans( / \\s+ / => ' ' );  # squash all whitespace to one space\r\n    $str.=trans( / <-alpha> / => '' );  # delete all non-alpha\r\n\r\nThese submatches are mixed into the overall match in exactly the same way that\r\nthey are mixed into parallel alternation in ordinary regex processing, so\r\nlongest token rules apply across all the possible matches specified to the\r\ntransliteration operator.  Once a match is made and transliterated, the parallel\r\nmatching resumes at the new position following the end of the previous match,\r\neven if it matched multiple characters.\r\n\r\nIf the right side of the arrow is a closure, it is evaluated to\r\ndetermine the replacement value.  If the left side was matched by a\r\nregex, the resulting match object is available within the closure.\r\n\r\n# Substitution\r\n\r\nThere are also method forms of `m//` and `s///`:\r\n\r\n     $str.match(/pat/);\r\n     $str.subst(/pat/, \"replacement\");\r\n     $str.subst(/pat/, {\"replacement\"});\r\n     $str.=subst(/pat/, \"replacement\");\r\n     $str.=subst(/pat/, {\"replacement\"});\r\n\r\nThe `.match` and `.subst` methods support the adverbs of `m//` and\r\n`s///` as named arguments, so you can write\r\n\r\n    $str.match(/pat/, :g)\r\n\r\nas an equivalent to\r\n\r\n    $str.comb(/pat/, :match)\r\n\r\nThere is no syntactic sugar here, so in order to get deferred\r\nevaluation of the replacement you must put it into a closure.  The\r\nsyntactic sugar is provided only by the quotelike forms.  First there\r\nis the standard \"triple quote\" form:\r\n\r\n    s/pattern/replacement/\r\n\r\nOnly non-bracket characters may be used for the \"triple quote\".  The\r\nright side is always evaluated as if it were a double-quoted string\r\nregardless of the quote chosen.\r\n\r\nAs with Perl 5, a bracketing form is also supported, but unlike Perl 5,\r\nPerl 6 uses the brackets `only` around the pattern.  The replacement\r\nis then specified as if it were an ordinary item assignment, with ordinary\r\nquoting rules.  To pick your own quotes on the right just use one of the `q`\r\nforms.  The substitution above is equivalent to:\r\n\r\n    s[pattern] = \"replacement\"\r\n\r\nor\r\n\r\n    s[pattern] = qq[replacement]\r\n\r\nThis is not a normal assignment, since the right side is evaluated each\r\ntime the substitution matches (much like the pseudo-assignment to declarators\r\ncan happen at strange times).  It is therefore treated as a \"thunk\", that is,\r\nit will be called as a chunk of code that creates a dynamic scope but not a\r\nlexical scope.  (You can also think of a thunk as a closure that uses the\r\ncurrent lexical scope parasitically.)  In fact, it makes no sense at all to say\r\n\r\n    s[pattern] = { doit }\r\n\r\nbecause that would try to substitute a closure into the string.\r\n\r\nAny scalar assignment operator may be used; the substitution macro\r\nknows how to turn\r\n\r\n    $target ~~ s:g[pattern] op= expr\r\n\r\ninto something like:\r\n\r\n    $target.=subst(rx[pattern], { $() op expr }, :g)\r\n\r\n(The actual implementation of `s///` must return a `Match` to make\r\nsmartmatch work right.  The rewrite above merely returns the changed string.)\r\n\r\nSo, for example, you can multiply every dollar amount by 2 with:\r\n\r\n    s:g[\\$ <( \\d+ )>] *= 2\r\n\r\n(Of course, the optimizer is free to do something faster than an actual\r\nmethod call.)\r\n\r\nYou'll note from the last example that substitutions only happen on\r\nthe \"official\" string result of the match, that is, the portion of\r\nthe string between the C<$/.from> and C<$/.to> positions.\r\n(Here we set those explicitly using the C<< <(...)> >> pair; otherwise we\r\nwould have had to use lookbehind to match the `$`.)\r\n\r\nPlease note that the `:ii`/`:samecase` and `:mm`/C<:samemark>\r\nswitches are really two different modifiers in one, and when the compiler desugars\r\nthe quote-like forms it distributes semantics to both the pattern\r\nand the replacement.  That is, `:ii` on the replacement implies a `:i` on the\r\npattern, and `:mm` implies `:m`.  The proper method equivalents to:\r\n\r\n    s:ii/foo/bar/\r\n    s:mm/boo/far/\r\n\r\nare not:\r\n\r\n    .subst(/foo/, 'bar', :ii)   # WRONG\r\n    .subst(/boo/, 'far', :mm)   # WRONG\r\n\r\nbut rather:\r\n\r\n    .subst(rx:i/foo/, 'bar', :ii)   # okay\r\n    .subst(rx:m/boo/, 'far', :mm)   # okay\r\n\r\nIt is specifically `not` required of an implementation that it treat\r\nthe regexes as generic with respect to case and mark.  Retroactive\r\nrecompilation is considered harmful.  If an implementation does do lazy\r\ngeneric case and mark semantics, it is erroneous and non-portable\r\nfor a program to depend on it.\r\n\r\nOne other difference between the `s///` and `.subst` forms is that,\r\nwhile `.subst` returns the modified string (and cannot, therefore,\r\nbe used as a smart matcher), the `s///` form always returns either a\r\n`Match` object to indicate to smartmatch that it was successful,\r\nor a `Nil` value to indicate that it was not.\r\n\r\nLikewise, for both `m:g` matches and `s:g` substitutions, there may\r\nbe multiple matches found.  These constructs must still continue to\r\nwork under smartmatching, but since smartmatch recognizes only a few\r\ndistinguished kinds of result values (`True`, `False`, `Match`,\r\n`Nil`, or `Failure`), a `Match` object must be returned to indicate\r\na successful match any time it is desirable to return a list from a\r\nsmartmatcher.  When coerced to a list, all the matches will be returned\r\nas if they were part of a single match.  When coerced to numeric, the\r\nfake `Match` returns the number of matches under `:g`.  (When used\r\nas a boolean, the `Match` always returns `True`, since failure to\r\nmatch is represented by `Nil`, not by a false `Match` object.)\r\n\r\n# Positional matching, fixed width types\r\n\r\nTo anchor to a particular position in the general case you can use\r\nthe C<< <at($pos)> >> assertion to say that the current position\r\nis the same as the position object you supply.  You may set the\r\ncurrent match position via the `:c` and `:p` modifiers.\r\n\r\nHowever, please remember that in Perl 6 string positions are generally\r\n`not` integers, but objects that point to a particular place in\r\nthe string regardless of whether you count by bytes or codepoints or\r\ngraphemes.  If used with an integer, the `at` assertion will assume\r\nyou mean the current lexically scoped Unicode level, on the assumption\r\nthat this integer was somehow generated in this same lexical scope.\r\nIf this is outside the current string's allowed Unicode abstraction levels, an\r\nexception is thrown.  See S02 for more discussion of string positions.\r\n\r\n`Buf` types are based on fixed-width cells and can therefore\r\nhandle integer positions just fine, and treat them as array indices.\r\nIn particular, `buf8` (also known as `buf`) is just an old-school byte string.\r\nMatches against `Buf` types are restricted to ASCII semantics in\r\nthe absence of an `explicit` modifier asking for the array's values\r\nto be treated as some particular encoding such as UTF-32.  (This is\r\nalso true for those compact arrays that are considered isomorphic to\r\n`Buf` types.)  Positions within `Buf` types are always integers,\r\ncounting one per unit cell of the underlying array.  Be aware that\r\n\"from\" and \"to\" positions are reported as being between elements.\r\nIf matching against a compact array C<@foo>, a final position of 42\r\nindicates that C<@foo[42]> was the first element `not` included.\r\n\r\n# Matching against non-strings\r\n\r\nAnything that can be tied to a string can be matched against a\r\nregex. This feature is particularly useful with input streams:\r\n\r\n     my $stream := cat $fh.lines;       # tie scalar to filehandle\r\n\r\n     # and later...\r\n\r\n     $stream ~~ m/pattern/;         # match from stream\r\n\r\nAny non-compact array of mixed strings or objects can be matched\r\nagainst a regex as long as you present them as an object with the `Str`\r\ninterface, which does not preclude the object having other interfaces\r\nsuch as `Array`.  Normally you'd use `cat` to generate such an object:\r\n\r\n    @array.cat ~~ / foo <,> bar <elem>* /;\r\n\r\nThe special C<< <,> >> subrule matches the boundary between elements.\r\nThe C<< <elem> >> assertion matches any individual array element.\r\nIt is the equivalent of the \"dot\" metacharacter for the whole element.\r\n\r\nIf the array elements are strings, they are concatenated virtually into\r\na single logical string.  If the array elements are tokens or other\r\nsuch objects, the objects must provide appropriate methods for the\r\nkinds of subrules to match against.  It is an assertion failure to match\r\na string-matching assertion against an object that doesn't provide\r\na stringified view.  However, pure object lists can be parsed as long as\r\nthe match (including any subrules) restricts itself to assertions like:\r\n\r\n     <.isa(Dog)>\r\n     <.does(Bark)>\r\n     <.can('scratch')>\r\n\r\nIt is permissible to mix objects and strings in an array as long as they're\r\nin different elements.  You may not embed objects in strings, however.\r\nAny object may, of course, pretend to be a string element if it likes,\r\nand so a `Cat` object may be used as a substring with the same restrictions\r\nas in the main string.\r\n\r\nPlease be aware that the warnings on C<.from> and C<.to> returning\r\nopaque objects goes double for matching against an array, where a\r\nparticular position reflects both a position within the array and\r\n(potentially) a position within a string of that array.  Do not\r\nexpect to do math with such values.  Nor should you expect to be\r\nable to extract a substr that crosses element boundaries.\r\n[Conjecture: Or should you?]\r\n\r\nTo match against every element of an array, use a hyper operator:\r\n\r\n     @array».match($regex);\r\n\r\nTo match against any element of the array, it suffices to use ordinary\r\nsmartmatching:\r\n\r\n    @array ~~ $regex;\r\n\r\n# When `$/` is valid\r\n\r\nTo provide implementational freedom, the `$/` variable is not\r\nguaranteed to be defined until the pattern reaches a sequence\r\npoint that requires it (such as completing the match, or calling an\r\nembedded closure, or even evaluating a submatch that requires a Perl\r\nexpression for its argument).  Within regex code, `$/` is officially\r\nundefined, and references to `$0` or other capture variables may\r\nbe compiled to produce the current value without reference to `$/`.\r\nLikewise a reference to `$<foo>` does not necessarily mean\r\n`$/<foo>` within the regex proper.  During the execution of a match,\r\nthe current match state is actually stored in a `$¢` variable\r\nlexically scoped to an appropriate portion of the match, but that is\r\nnot guaranteed to behave the same as the `$/` object, because `$/`\r\nis of type `Match`, while the match state is of a type derived from `Cursor`.\r\n\r\nIn any case this is all transparent to the user for simple matches;\r\nand outside of regex code (and inside closures within the regex)\r\nthe `$/` variable is guaranteed to represent the state of the match\r\nat that point.  That is, normal Perl code can always depend on\r\n`$<foo>` meaning `$/<foo>`, and `$0` meaning `$/[0]>`, whether\r\nthat code is embedded in a closure within the regex or outside the\r\nregex after the match completes.\r\n\r\n# AUTHORS\r\n\r\n    Damian Conway <damian@conway.org>\r\n    Allison Randal <al@shadowed.net>\r\n    Patrick Michaud <pmichaud@pobox.com>\r\n    Larry Wall <larry@wall.org>\r\n    Moritz Lenz <moritz@faui2k3.org>\r\n    Tobias Leich <email@froggs.de>\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}