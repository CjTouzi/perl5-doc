You will not find anything in a footnote that you'll need to understand any of the material we present later.||我们在以后提供给你的材料中不会涉及对这些脚注的理解. 
Now try it out:||然后试试：
So far, nothing unusual has happened. Note, however, that Gilligan has two different behaviors, depending on whether he is addressing the Skipper or someone else.||到现在为止, 一切正常. 然而, 你要注意, Gilligan有两个不同的行为, 这依赖于它是否对Skipper说话, 还是对其它人说. 
You can find the answer to this exercise in "Answer for Chapter 7" in the Appendix.||答案附件找. 
Chapter 5. References and Scoping||第五章 引用和范围
We still have two elements in @_. The first element is the passenger or crew member name, which we use in the error message. The second element is a reference to the correct provisions array, which we use in the grep expression.||我们仍有两个元素在数组@_中. 第一个元素是成员或乘务员的名字, 我们用它来组成出错信息. 第二个元素是指向供应清单数组的引用. 我们把它用在grep表达式中. 
On that last one, we can still drop the arrow between "subscripty kinds of things, " even though one is an array bracket and one is a hash brace.||在最后一个例子中, 我们一样可以去掉"类似下标"间的箭头, 不管箭头是在数组方括号还是散列花括号中间. 
8. 4. 2. Anonymous IO::File Objects||8. 4. 2. 匿名IO:File对象
Write a program that takes a list of filenames on the command line and uses grep to select the ones whose size in bytes is less than 1000. Use map to transform the strings in this list, putting four space characters in front of each and a newline character after. Print the resulting list.||写一个程序从命令行取一个文件清单, 然后用grep把那些文件大小在1000字节以内的文件找出来. 用map把这个清单里的每个字串前加四个空格并在字串后面加上换行符. 然后输出列表结果. 
See, our Learning Perl book was great because it introduced the use of Perl for short and medium programs (which is most of the programming done in Perl, we've observed).||看, 我们的《Learning Perl》写得如此之好, 因为它介绍给你如何用Perl写那些小或中型的程序（据我们观察, 也的确, 大多数Perl程序用这么小的代码量就能很好的完成任务）. 
For each element of the directory, we pass a path consisting of the incoming path followed by the current directory entry, and the data pointer is either undef for a file or a subdirectory hash reference for another directory. We can see the results by running:||对于目录中的每个元素, 我们传一个包含下一项元素的当前路径, 以及一个散列值, 这个值要么是未定义, 表示是文件, 或下一个子目录的散列引用. 我们运行一下, 看下结果：
new undefined variable||新定义的变量
Perl even supports nested eval blocks. The power of an eval block to trap errors extends for as long as it's executing, so it catches errors deep within nested subroutine calls. eval can't trap the most serious of errors, though: the ones in which Perl itself stops running. These include things such as an uncaught signal, running out of memory, and other catastrophes. eval doesn't catch syntax errors, either; because Perl compiles the eval block with the rest of the code, it catches syntax errors at compile time, not at runtime. It doesn't catch warnings either (although Perl does provide a way to intercept warning messages; see $SIG{_ _WARN_ _}).||Perl也支持eval代码块的嵌套. 只要代码执行, eval块总能捕捉错误, 所以它能捕捉嵌套子例程里发生的错误. 尽管如此, eval不能捕捉到非常严重的错误, 这些错误发生时Perl自己会中断执行. 这些错误包括无法捕捉的信号, 内存溢出或其它的灾难. eval同样不能捕捉到语法错误;因为Perl在编译eval及其它代码的时候检查语法错误, 而不是在运行时. 还有, eval也不能捕捉警告. （但是Perl的确提供一个方法来捕捉警告信息;可以查阅一下变量$SIG{__WARN__}）. 
Here, the lib pragma takes one or more arguments and adds them at the beginning of the @INC array, just like unshift did before. [*] It works because it executes at compile time, not runtime. Hence, it's ready in time for the use immediately following.||[*]这样, lib编译提示取一个或多个参数, 并且把他们加入数组@INC开头, 就像前面所说的用unshift的效果一样. 
Write a program that takes in multiple directory names from the command line, then prints out their contents. Use a function that takes a directory handle reference that you made using IO::Dir.||写一个程序, 从命令行读取多个目录名字, 然后打印出他们的目录内容. 用一个取目录句柄引用的函数, 可以在函数中用IO::Dir模块. 
Nothing in either structure tells where the directory is located in the hierarchy. It just represents the contents of some directory.||上面两个例子没有说目录是否是在一个层次结构里面. 它仅仅表示了一个目录里的一些内容. 
The Data::Dumper module defines the Dumper subroutine. This subroutine is similar to the x command in the debugger. We can give Dumper one or more values, and Dumper turns those values into a printable string. The difference between the debugger's x command and Dumper, however, is that the string generated by Dumper is Perl code:||Data::Dumper模块中定义了Dumper子例程. 这个子例子与调试工具中的x命令相似. 我们可以给Dumper子例程一个或多个值, Dumper会以人看得懂的格式返回这些值的内容. 然而, Dumper与调试工具中x命令的不同是Dumper输出的是Perl 代码：
We can still maintain the old interface if we use a setter and getter, because they can perform the translations without the user knowing about it. We can also add new interfaces now to enable the direct setting and getting of the RGB triple:||我们可以在维护旧的接口时一样可以用设置和取值程序, 因为在用户不知道具体细节的情况下他们可以自动转换. 我们也可以添加新的方法来直接改ＲＧＢ三色数字：
Why mention it here? Well, even Perl programmers sometimes copy an algorithm from another programming language. There's nothing inherently wrong with doing this, although it would be better to decide why the original author used a "loopy" data structure and then recode the algorithm to use Perl's strengths. Perhaps you should use a hash instead, or perhaps the data should go into an array that will be sorted later.||那为什么要在这儿提这些呢？ 是这样的, 因为有些Perl程序员有时也会从其它程序语言中把算法拷贝过来. 这样做当然不会继承错误, 尽管考虑一下原来作者用"循环"数据结构是为什么, 然后用Perl的强项来处理这什算法. 可能你要用个散列, 或用数组, 然后以后进行排序. 
We can write a bit of code to check for the Skipper's supplies:||我们来写段代码来检查船长的装备. 
We run a few queries against this data. Who brought fewer than five items?||我们做一个查询：谁只带了不多于五件装备在身？
Fortunately, we can tell the use operation to limit its actions by specifying a list of subroutine names following the module name, called the import list:||很幸运, 我们可以告诉use操作符, 通过只导入需要的子例程来限制它的行为. 称为"函数导入清单", 如：
We can do this a number of ways. One of the easiest is to invoke Perl with a -d switch on the command line:||我们可以有多种方法来执行测试. 其中一种最简单的是以-d开关在命令行执行Perl解释器：
Backing up for a minute, if we found a Build. PL file instead of a Makefile. PL, the process is the same. These distributions use Module::Build to build and install code. Since Module::Build is not a core Perl module, [*] we have to install it before we can install the distribution that needs it.||不过, 等一下, 如果我们找到了Build. PL文件, 而不是Makefile. PL, 那我们可以用它, 过程是一样的. 这种发布用了Module::Build模块来建立和安装包. 因为Module::Build并非Perl的核心模块（至少现在还不是）, 所以我们使用时先要安装一下. 
The value between the open and closing curly braces is an eight-element list. The eight-element list becomes a four-element anonymous hash (four key/value pairs). Perl takes a reference to this hash and returns as a single scalar value, which we assign to the scalar variable. Thus, we can rewrite the roster creation as:||被花括号括起来的是八个元素的列表. 八个元素的列表也就变成了四个元素的匿名数组（四个键／值对）. Perl会取这个散列的引用, 并返回一个标量值, 并送给一个标量变量. 所以我们可以改写程序如下：
Returning the two subroutine references from the creating subroutine does not invoke them. The references are just data at that point. It is not until we invoke them as a callback or an explicit subroutine dereferencing that they actually do their duty.||在返回这两个匿名子程序引用时, 并不执行他们. 这时仅仅返回程序引用而已. 真正调用是在他们作为回调程序被执行或还原后被执行时. 
This process is called autovivification. Any nonexistent variable, or a variable containing undef, which we dereference while looking for a variable location (technically called an lvalue context), is automatically stuffed with the appropriate reference to an empty item, and Perl allows the operation to proceed.||这样的处理叫做：自生成. 任何一个不存在的变量, 或个存有undef的变量, 当被用来查找一个变量的时候（技术上被称为左值环境）, 会自动被适当的生成空项引用, Perl然后再让处理继续. 
Now, in addition to searching the standard directories and the current directory, Perl searches the Skipper's personal Perl library. In fact, Perl searches in that directory first, since it is the first one in @INC. By using unshift rather than push, Perl resolves any conflict in names between the Skipper's private files and the system-installed files, with the Skipper's file-taking precedence.||现在, 除了搜索标准目录和当前目录, Perl还搜索Skipper的个人Perl模块库. 实际上, Perl首先就会查这个目录, 因为这条会排在数组@INC最前面. 因为使用的是unshift而不是push, Perl会将取Skipper的文件放在优先位置, 以此解决Skipper的私有文件与系统安装的文件之间可能的冲突. 
Notice how we've created two different variables now, since there are two parameters to Dumper. The element $VAR1 corresponds to a reference to @data1, while $VAR2 corresponds to a reference to @data2. The debugger shows the values similarly:||注意我们是怎么创建了两个不同的变量, 因为传给了Dumper两个参数. 元素$VAR1对应对@data1的引用, 而$VAR2对应对@data2的引用. 调试工作对值的展示类似：
8. 6. 2. Exercise 2 [30 min]||8. 6. 2. 练习 2 [30 分钟]
This isn't the best solution, however. We still have to keep the @ISA and the initial search package in sync (changes in one must be considered for changes in the other). Worse, if Mouse had multiple entries in @ISA, we wouldn't necessarily know which one had actually defined speak.||然而, 这也并非最终的解决方法. 我们还是要使@ISA和初始包同步（改了一个句就必须考虑另一个）. 更糟的是, 如果在@ISA中Mouse类有多个条目, 我们不知道哪个实际上定义了speak. 
3. 4. Selecting What to Import||3. 4. 选择性地引入函数
Ahh. As ugly as this is, it works. Using this syntax, start with Animal to find speak and use all of Animal's inheritance chain if not found immediately. The first parameter is $class (because we're using an arrow again), so the found speak method gets Mouse as its first entry and eventually works its way back to Mouse::sound for the details.||啊. 虽然丑陋, 但是能用啊. 用这个语法, 如果没有立即找到方法, 就会从继承链中去找方法. 第一个参数是$class（因为我们再次使用了箭头）, 所以找到的speak方法象是Mouse的第一个条目, 回到Mouse::sound. 
[*] Although all examples in this book should be valid Perl code, some examples in this chapter will break the rules enforced by use strict to make them easier to understand. By the end of the chapter, though, we'll show how to make strict-compliant code again.||[*] 尽管书中所有的例子都是有效的Perl程序, 但是有些章节的例子会打破由strict定义的规则, 来使其看上去易懂. 在章节的结尾, 我们会展示如用strict兼容的例子. 
We can dereference a hash reference to get back to the original data. The strategy is similar to dereferencing an array reference. We write the hash syntax as we would have without references and then replace the name of the hash with a pair of curly braces surrounding the thing holding the reference. For example, to pick a particular value for a given key, we do this:||我们也能还原一个对散列的引用, 得到它原来的数据. 其方法与还原一个数组引用相同. 就是当作没有引用这回事一样, 在散列引用变量的名字外面再加一对花括号. 比如, 我们要取散列中一个给定键的特定值, 我们像这样写：
The current package is lexically scoped, similar to the scope of my variables, narrowed to the innermost-enclosing brace pair or file in which we introduced the package.||当前的包是词法范围的, 像my声明的变量一样, 范围限制在大括号的最里层或我们引入包的文件范围之内. 
For every missing provision, we push that provision onto an array, forcing the passenger to consider the item:||对于每个遗忘的的装备, 我们把它放到另一个数组里, 要求乘客关注这些装备：
9. 8. Displaying Recursively Defined Data||9. 8. 显示嵌套数据
This calls the class method catfile of the File::Spec class, which builds a path appropriate for the local operating system and returns a single string. [] This is similar in syntax to the nearly two dozen other operations provided by File::Spec.||上例就是调用了File::Spec类中的一个叫catfile的类方法. 这个方法使用本地操作系统的目录分隔符建立合适的路径字患并返回单个字串[+]. 对于File::Spec提供的其它方法, 调用的语法都是相似的. 
While the previous examples showed closure variables being modified, closure variables are also useful to provide initial or lasting input to the subroutine. For example, let us write a subroutine to create a File::Find callback that prints files exceeding a certain size:||上一章的例子展示了闭包中变量如何被修改的, 而闭包变量还可以被用来初始化变量或给匿名子程序提供参数输入（类似静态局部变量）. 比如, 我们来写一个子程序来创建File::Find回调, 打印出所有超过一定大小的文件名：
The search path is a list of elements in the special @INC array, as we briefly discussed in Chapter 3. By default, the array contains the current directory and a half-dozen or so directories specified by the person who compiled Perl. Typing perl -V on the command line shows what these directories are, in the last dozen lines of the output. Also, the following command displays just the @INC directories:[*]||查寻目录是在一个特别的数组@INC中的列表中一系列的元素, 就象我们在第三章讲过的一样. 缺省时, 数组包括当前目录和一些由编译Perl的用户指定的目录. 在命令行输入Perl -V 可以在最后几行显示出这些目录. 用如下的命令也可以显示@INC所包括的目录[*]
Note the addition of the @missing array. If we find any items missing during the scan, we push them into @missing. If there's anything there at the end of the scan, we add it to the original provision list.||注意我们另外增加了一个@missing数组. 如果我们在扫描数组的时候发现有遗忘的装备, 我们就把它放到@missing数组里. 在扫描结束后, 如果发现@missing里有内容, 我们就把这个数组加在供应清单后面. 
The Professor has to read a logfile that looks like:||教授必须读如下的日志：
Actually, $tv_horse points to the object, but, in common terms, we nearly always deal with objects by references to those objects. Hence, it's simpler to say that $tv_horse is the horse, not "the thing that $tv_horse references. "||[+]实际上, $tv_horse指向一个对象, 但是, 在常用的术语来说, 我们几乎总是用引用与对象打交道来处理对象的. 之后, 我们就可以简单地说$tv_horse就是马, 而不是"$tv_horse引用的那个东西"
[*] These directories were set when the administrator installed Perl, and we can see them with perl -V.||[*]这些目录由管理员安装Perl时建立, 我们可以用perl -V看到是哪些目录. 
[*] My friends call that the "ASCIIbetical" ordering. Normally, modern Perl doesn't use ASCII; instead, it uses a default sort order, depending on the current locale and character set. See the perllocale (not perllocal!) manpage.||[*] 我朋友把这叫做"按ASCII表顺序"排序. 通常来说, 当前的Perl已经不用ASCII字符表了; 它依照当前的缺省字符集的排序顺序来进行排序. 具体可以查看perllocale(不是perllocal!)文档页. 
This works because the output of each setter is the original object, becoming the object for the next method call. Implementing this is, again, relatively easy:||这样的代码是可行的, 因为每个设置方法都是原始对象, 成为下个方法调用对象. 还可以这样：
Here, EXPR stands in for any scalar expression that should refer to $_ (explicitly or implicitly). For example, to find all the numbers greater than 10, in our grep expression we check if $_ is greater than 10.||在下面的例子中, EXPR代表一个返回标量的表达式, 它引用$_变量（显式或隐式的）. 比如找出大于10的数, EXPR表达式来处理$_是否大于10. 
(We've sent Fred, Barney, Betty, and Wilma home, though. A new cast of characters will take the starring roles. )||（尽管我们把Fred, Barney, Betty和wilma送回家了, 但我们让一些新的明星来担纲表演. ）
Although a naked block worked nicely to define the callback, having a subroutine return that subroutine reference instead might be more useful:||尽管定义回调时用裸块的话, 会工作得很好, 但是如果让子程序返回一个对子程序的引用的做法更加有用：
When this subroutine executes, Perl creates a fifth reference to the data and copies it into @_ for the subroutine. The subroutine is free to create additional copies of that reference, which Perl notes as needed. Typically, when the subroutine returns, Perl discards all such references automatically, and you're back to four references again.||当这个子程序执行的时候, Perl会创建指向这个数组的第五个引用, 并将其拷贝到这个子程序的特殊变量@_中. 子程序可以很自由的为那个引用创建更多的拷贝, 而Perl则会适时的关注. 一般来说, 当子程序返回的时候, Perl会自动扔掉所有这些子程序创建的引用, 这样你又回到了4个引用. 
4. 1. Performing the Same Task on Many Arrays||4. 1. 用多个数组来完成一个简单任务
The anonymous hash constructor always evaluates its contents in a list context and then constructs a hash from key/value pairs, just as if we had assigned that list to a named hash. Perl returns a reference to that hash as a single value that fits wherever a scalar fits.||匿名散列构造器总是把内容放在列表环境, 并把他们以键／值对的形式输出, 就像我们分配那个列表给命名散列一样. Perl返回一个那个散列的引用, 并将其作为标量值, 并适合任何标量合适的地方. 
Ah, now it's getting interesting. A new entry in the top-level hash has a key of thurston. howell. hut, and a new hash reference, autovivified initially to an empty hash.||哈, 有趣的事发生了. 顶层散列的一个键：thurston. howell. hut添加了一个新的条目, 于是一个新的散列引用自生成为一个空的散列. 
We can also allow it as an implicitly named package variable:||我们也允许它作为一个隐含命名的包变量：
For example, the File::Find module exports a find subroutine that can efficiently walk through a given filesystem hierarchy in a fairly portable way. In its simplest form, we give the find subroutine two parameters: a starting directory and "what to do" for each file or directory name found recursively below that starting directory. The "what to do" is specified as a subroutine reference:||举个例子来说, File::Find模块导出一个find子程序, 它被用来以非常可移植的方式高效地遍历给定文件系统的层次结构. 在这个简单的例子中, 我们传给find子程序两个参数：一个表示目录搜索开始点的字串, 另一个是对子程序引用. 这子程序会对从给定的起始目录开始, 通过递归搜索的方法, 找到其下的每个文件或目录, 并对它们"干些什么"：
Here's some code to try; it should list only items that were last modified on the most recent Monday, although you could easily change it to work with a different day. (You don't have to type all of this code. This program should be available as the file named ex6-1. plx in the downloadable files, available on the O'Reilly web site. )||这里有一些代码; 它应该列出那些在最近的周一之后修改过的文件, 当然, 你可以容易的修改它来适应不同的日期. （你不必写出所有的代码. 这个程序应该可以在O'Reilly网站下载, 名字叫ex6-1. plx）
The Skipper must edit each program that uses his private libraries to include those lines from the previous section. If that seems like too much editing, he can instead set the PERL5LIB environment variable to the directory name. For example, in the C shell, he'd use the line:||Skipper必须编辑每个程序里以使用他的私有库来导入前面的那些代码. 如果这样编辑太麻烦了, 他可以设置PERL5LIB环境变量, 加上库文件目录. 比如, 在C shell中, 他可以用下面这行：
At this point, we need to put something inside a BEGIN block or perhaps rely on yet another compile-time operation: setting a constant with use constant:||这个时候, 你就需要把它放在BEGIN块中, 或依赖另一个编译期操作：设置一个常量：
2. 1. 2. Transforming Lists with map||2. 1. 2. 用map作列表的转换
12. 14. Restricting a Method to Class-Only or Instance-Only||12. 14. 将方法限制成类的或对象实例的
2. 4. 1. Exercise 1 [15 min]||2. 4. 1. 习题 1 [15 分钟]
CPAN is the result of many volunteers working together, many of whom were originally operating their own little (or big) Perl FTP sites back before that Web thing came along. They coordinated their efforts on the perl-packrats mailing list in late 1993 and decided that disk space was getting cheap enough that the same information should be replicated on all sites rather than having specialization on each site. The idea took about a year to ferment, and Jarkko Hietaniemi established the Finnish FTP site as the CPAN mothership from which all other mirrors could draw their daily or hourly updates.||CPAN是众多志愿者协同工作的产物. 志愿者中的许多人用他们自己的FTP站点来维持前台的CPAN Web页面. 直到1993年底, 他们还是用perl-packrats邮件列表来协调他们的工作. 之后, 因为磁盘空间越来越便宜, 所以相同信息可以在所有的站点复制, 而不必放在专门的站点上. 这种想法酝酿了一年左右, 以Jarkko Hietaniemi(芬兰人, 详见：http://users. tkk. fi/jhi/jarkko. html. 中文名：沙雅可, 日文名：奴稗谷笑)在芬兰建立的FTP站点为母站, 其它的镜相站点可以以此来进行及时的更新. 
and we'll get:||这样, 我们就得到：
In case you didn't catch our warning before, we'll say it again: be very careful with this form of eval. If you can find another way to do what you need, try that first. We'll use it later, in Chapter 10 to load code from an external file, but then we'll also show you a much better way to do that too.||万一你还没有注意我们的警告, 我们在这里重申：要非常小心这种形式的eval用法. 如果你有其它的方法来替代eval用法, 那就试试其它方法. 我们在后来第10章会用到这种办法从外部文件中载入代码, 但我们同样会向你展示出更好的替代方案. 
Which one is correct? It depends. If we are writing a class that simply adds to the parent class behavior, it's best to simply pass along arguments we haven't dealt with. However, if we want precise control over the parent class's behavior, we should determine the argument list explicitly and pass it.||哪个方法是对的？ 这要按情况看. 如果我们写一个类, 只加到父类的行为, 那么最好就是把我们没能处理的参数传给他. 然而, 如果我们要精确控制父类的行为, 我们应该明确决定参数列表, 并传给它. 
While a system administrator might add a setting of PERL5LIB to a system-wide startup script, most people frown on that. The purpose of PERL5LIB is to enable non-administrators to extend Perl to recognize additional directories. If a system administrator wants additional directories, he merely needs to recompile and reinstall Perl.||当一个系统管理员把PERL5LIB作为系统范围的设置, 大多数人可能为此而不悦. PERL5LIB的目录是使非管理员来扩展Perl搜索目录. 如果一个系统管理员要添加目录, 它仅仅需要重编译和重装Perl. 
At this point, we have four different ways to access the data contained in @skipper:||现在, 我们有四种途径来访问保存在@skipper中的数据：
In other words, an initially empty array becomes an array of three elements.||换句话说, 一个初始化的空的数组成为一个有三个元素的数组. 
The IO::File module subclasses IO::Handle to work with files. It comes with the standard Perl distribution, so you should already have it. There are a variety of ways to create an IO::File object.||IO::File模块是IO::Handle模块的子类, 用来同文件打交道. 它是随标准Perl一起发布的, 所以你应该已经有这些模块了. 可以用多种方法来创建一个IO::File对象. 
However, this is a bit more verbose than it needs to be. We could simply return the boolean expression rather than a separate 1 or 0:||然而, 这样的处理还是比较繁索. 我们可以简单的返回布尔表达式, 而不是1或0：
7. 6. Closure Variables as Inputs||7. 6. 作为输入参数的闭包变量
You'll learn the basics of packaging your code as a distribution and providing unit tests for that distribution, both for development and for verifying that your code works in the ultimate end environment.||在本书中你会学到把你的代码如何打包成一个发布版本, 并对其在开发环境中进行单元测试或在最终运行环境进行代码验证. 
Modify the code from this chapter so that each source machine's portion of the output shows the total number of bytes from that machine. List the source machines in order from most to least data transferred. Within each group, list the destination machines in order from most to least data transferred to that target from the source machine.||修改一下这章的那段程序, 使每个源主机显示所有从它那里输出的字节数. 以字节数从大到小排. 对于每一组中, 以所有目标主机, 也以传输到此目标主机的字节数以大到小排. 
[*] In classrooms, we've seen that too much indirection (or not enough indirection) tends to contribute to the most common mistakes made when working with references.||[*] 在教学中, 我们经常会看到在使用引用时犯的直接（或不那么直接）的错误. 
An important aspect of working in teams is having a release cycle and tests for unit and integration testing.||在团队中工作中的一个重要的方面是在一个发布周期中的单元测试和集成测试. 
In this subroutine, $a and $b are still two elements from the list of things to be sorted. When we're sorting numbers, $a and $b are numbers; when we're sorting references, $a and $b are references. We dereference them to get to the corresponding array itself, and pick out item 1 from the array (the monkey's pineapple value). Because $b appears to the left of $a, it'll be a descending sort as well. (We want a descending sort because the Professor wants the first name on the list to be the person who uses the most pineapples. )||在这个子程序中, $a和$b列表中要排序的两个元素. 当我们对数字进行排序的时候, $a和$b是数字. 当我们对引用进行排序时, $a和$b就是引用. 我们将他们还原成相应的数组, 并且将他们的第二个元素取出来（猴子报告的菠萝数目）. 因为$b排在$a之前, 所以, 它是一个由大到小的降序排列. （我们需要降底是因为教授要有菠萝持有最多的那个人）
Now we can say:||这样我们就可以这样写：
Immediately after we declare the @skipper array, we have one reference to the five-element list. After $ref is initialized, we'll have two, down to the end of the block. When the block ends, the @skipper name disappears. However, this was only one of the two ways to access the data! Thus, the five-element list is still in memory, and $ref still points to that data.||在我们声明@skipper数组之后, 我们有了一个指向这个五个元素的列表的引用. 在$ref被初始化后, 到块结束的地方, 我们会有两个引用. 到块结束, @skipper名子消失了. 然而, 这不过是仅仅访问数据的一个途径而已！ 这样, 这个五个元素的列表依旧在内存里, 而且$ref变量仍然指向这块数据. 
Certainly, Perl establishes the declaration of the $LIB_DIR variable at compile time (so we won't get an error with use strict, although the actual use lib should complain), but the actual assignment of the /home/gilligan/lib/ value doesn't happen until runtime. Oops, too late again!||当然, Perl声明$LIB_DIR变量的确是在编译期（所以我们用use strict也不会收到出错信息, 尽管实际use lib时会报错）, 但给变量赋上'/home/gilligan/lib'这个值却直到运行时才发生, 真是的, 又晚了一步！
This strategy is attractive because of its simplicity, but it also has disadvantages. It complicates the actions of the getter, which is called frequently. It also makes it difficult to search through our code to find the setters of a particular parameter, which are often more important than the getters. We've been burned in the past when a setter became a getter because another function returned more parameters than expected after an upgrade.||这种方案具有吸引力是因为其简洁, 但这也有其缺点. 它混淆了频繁的取值的动作. 它也使通过我们的代码来找用特殊参数的设置器变得困难, 而这往往比取值重要. 在以往, 因为一个设置器因为在升级后另一个函数返回多个值而变成了取值器的情况造成的麻烦就很多. <似乎应该反过来－－译者>
Yes, a map within a map. The outer map selects one person at a time. We save this name in $person, and then we extract the item list from the hash. The inner map walks over this item list, executing the expression to construct an anonymous array reference for each item. The anonymous array contains the person's name and the provision item.||是的, 一个map套一个map. 外圈的map一次拣选一个乘客名字. 我们把这个名字放在变量$person中, 然后我们从散列中抽取装备列表. 而内层的map遍历装备清单, 执行一个表达式来为每个装备构建一个匿名数组引用. 每个匿名数组含有乘客的名字和他所带的装备名. 
9. 1. Review of Sorting||9. 1. 再来看一下排序
Now that you've seen the basics of references, let's look at additional ways to manipulate complex data. We'll start by using the debugger to examine complex data structures and then use Data::Dumper to show the data under programmatic control. Next, you'll learn to store and retrieve complex data easily and quickly using Storable, and finally we'll wrap up with a review of grep and map and see how they apply to complex data.||既然你已经知道了引用的基础知识, 那就让我们管理复杂数据结构的其它的方法. 首先, 我们会用测试工具来查看复杂数据结构的内容, 之后我们会介绍Data::Dumper模块, 这样我们就可以在程序中展示数据结构了. 下一步, 我们将会学到用Storable模块把复杂数据结构方便快捷地进行存取. 最后, 我们会回顾一下grep和map, 看他们如何在处理复杂数据结构上来发挥作用. 
Perl complains to us that it can't find the module in @INC and shows us all of the directories it has in that array.||Perl会向我们报怨在@INC中找不到需要的模块, 并且向我们展示数组中包含的所有目录. 
At this point, the five-element list is in an anonymous array, which is a fancy term for an array without a name.||这个时候, 这个五个元素的列表是个匿名数组－－为没有名字的数组起的一个漂亮名字. 
11. 4. Calling a Second Method to Simplify Things||11. 4. 调用第二个方法来简化操作
Now have everyone greet everyone, in a very friendly room:||现在我们可以让大家互相问候了, 在一个十分友好的房间：
Great. The new subroutine works nicely in the current navigation program. However, because he had previously cut and pasted it into a half-dozen other navigation programs, those other programs will still annoy the Skipper with extraneous turning messages.||不错. 新的子程序工作得很好. 然而, 因为前期他已经用拷贝粘贴的办法把这个程序贴在导航程序里很多地方, 其它程序仍旧出现令Skipper不胜其烦的超量输出信息. 
8. 4. 3. IO::Scalar||8. 4. 3. IO::Scalar
And for the other passengers, we repeat as needed. Although this code meets the initial requirements, we've got two problems to deal with:||对于另外两个乘客, 我们可以如法泡制. 尽管以上代码符合最初的要求, 我们还是要有两个问题要解决：
A subroutine reference is often used for a callback. A callback defines what to do when a subroutine reaches a particular place in an algorithm.||一个对子程序的引用, 经常被用来做回调. 一个回调定义了在一个算法中当子程序运行到了一个特定地点时, 程序应该做什么. 
Here's the data we'll use to test it:||下面是我们要测试的数据：
The method arrow can be used on instances, as well as names of packages (classes). Let's get the sound that $tv_horse makes:||方法箭头可以用在实例上, 就像用在包名上（类）一样. 让我们用$tv_horse发声：
Let's print a crew roster:||接下来, 我们打印一下船员的花名册：
In every place the previous sort expression returned -1, this expression returns +1, and vice versa. Thus, the sort is in the opposite order, and so it doesn't need a reverse. It's also easy to remember because if $a is to the left of $b, we get out the lower items first, just like a and b would be in the resulting list.||在前例中, 表达式原来返回－1的, 现在返回＋1, 相反也是一样. 所以, 排序出来的结果是反向排序, 所以也不要reverse关键字了. 这样也容易记得, 因为如果$a是在$b左边, 我们得到从小到大的排序, 就像a和b在结果列表中一样. 
However, we cannot drop the braces if the value within the braces is not a simple scalar variable. For example, for @{$_[1]} from that last subroutine rewrite, we can't remove the braces. That's a single element access to an array, not a scalar variable.||但是, 有一点, 如果大括号里的内容不是简单的标量变量的话, 我们就不能把大括号去掉. 比如, 对于前面最后一个改写过的子例程中的@{$_[1]}, 我们不能把大括号去掉. 因为那是个正访问数组的元素, 而不是一个简单的标量变量. 
which constructs an argument list of:||创建一个参数列表：
Now we can use it to construct the larger list:||现在, 我们可以用它来构建一个更大的列表：
and attempts to invoke:||尝试调用：
If that weren't already simple enough, there's one more rule: if the arrow ends up between "subscripty kinds of things, " such as square brackets, we can also drop the arrow. $all_with_names[2]->[1]->[0] becomes $all_with_names[2][1][0]. Now it's looking even easier on the eyes.||如果你觉得还不够简洁的话？那我们还有条规则：如果箭头是在"类似于下标"中间的话, 那么箭头也可以省去. $all_with_names[2]->[1]->[0]变成了$all_with_names[2][1][0]. 现在样子看上去更简洁了. 
The $read_fh doesn't have to be connected to a file, either. It might also be connected to a socket, a scalar variable, an external command's output, [*] or anything else we can dream up.||而且$read_fh并不一定非要连上文件. 它可以连上一个套接字, 一个标量变量, 一个外部命令的输出, [*] 或者任何其它你想得出来的东西. 
Sometimes the Skipper runs a ship into an island, but sometimes the collision involved is just a couple of names in a Perl program. Suppose that the Skipper has added all his cool and useful routines to navigation. pm and that Gilligan has incorporated the library into his own navigation package, head_toward_island:||有时候Sipper要把船开进一个小岛, 但有时程序里会发生一对名字发生冲突的情况. 假定Skipper把他的所有的有用和酷的子程序加到navigation. pm中, 而Gilligan已经导入他自己的导航程序包, head_toward_island:
Current heading is 234.||当前航向是：234. 
Just as croak is provided as the alternate form of die, Carp also provides carp as a replacement for warn. Each tells the user which line of code called the code that caused the problem. Instead of using die or warn in your modules, use the Carp functions instead. Your users will thank you for it.||croak提供了die函数的替代方案, Carp模块同样提供carp来替代warn的方案. 它们都指出出问题的调用函数所在的行号. 我们可以在代码中用die和warn一样用Carp模块中的函数. 你的用户会因此感谢你的. 
Now we have a list of names, ordered by their pineapple counts, and the monkey's off our backs, all in three easy steps.||这样我们就有一个名字的列表, 并以他们所持菠萝的数目由大到小排列, 仅仅用三步, 也可以把猴子轻松放下. 
Just like the expression form, grep temporarily places each element of the input list into $_. Next, it evaluates the entire block of code. The last evaluated expression in the block is the testing expression. (And like all testing expressions, it's evaluated in a scalar context. ) Because it's a full block, we can introduce variables that are scoped to the block. Let's rewrite that last example to use the block form:||同grep的表达式形式一样, grep临时把输入数组中每个元素放到$_中去, 然后, 它用代码块来处理这个值. 代码块里最后一个表达式来检验值. 就像所有的测试表达式一样, 在标量上下文来检验值. 因为是完整的块, 所以我们可以在其中用以块为范围的变量. 我们来用块形式重写上面的例子：
We pass the 1024 parameter into the print_bigger_than, which then gets shifted into the $minimum_size lexical variable. Because we access this variable within the subroutine referenced by the return value of the print_bigger_than variable, it becomes a closure variable, with a value that persists for the duration of that subroutine reference. Again, invoking this subroutine multiple times creates distinct "locked-in" values for $minimum_size, each bound to its corresponding subroutine reference.||我们把1024作为参数传给子程序print_bigger_than, 这个子程序将其传给词法变量$minimum_size. 因为我们在匿名子程序中引用这个变量, 然后再返回匿名子程序的引用, 所以这成为一个闭包变量, 只要匿名子程序引用它, 它的值就一直保持着. 同样, 多次调用这个程序会为$minimum_size锁定不同的值, 每个都和他们各自的匿名子程序引用绑定. 
8. 5. 1. IO::Dir||8. 5. 1. IO::Dir
Of course, we didn't actually need that scalar temporary, either. We can put a scalar reference to an array as part of a larger list:||甚至, 我们也根本不要那个临时标量. 我们可以直接把临时标量替换成数组引用, 作为一个更大列表的一部份：
12. 13. Getters That Double as Setters||12. 13. 既是设置器也是取值器
as if we had written the basename and dirname subroutines ourselves, or (nearly) as if they were built-in Perl functions. These routines pick out the filename and the directory parts of a pathname. For example, if $some_full_path were D:\Projects\Island Rescue\plan7. rtf (presumably, the program is running on a Windows machine), then $basename would be plan 7. rtf and the $dirname would be D:\Projects\Island Rescue.||就象我们曾经在我们自己代码里写过basename和dirname这两个子例程一样, 或者他们就像是Perl的内置函数似的. 这些例程的功能是从一个路径名中抽出文件名和目录名. 比如, 如果变量$some_full_path的内容是D:\Projects\Island Rescue\plan7. rtf(我们假定是在Windows环境下), 那么$basename的内容将会是plan7. rtf而$dirname的内容将会是D:\Projects\Island Rescue. 
7. 5. Returning a Subroutine from a Subroutine||7. 5. 从子程序中返回一个子程序
To solve either or both of these problems, we need pass by reference rather than pass by value. And that's just what the doctor (or Professor) ordered.||要解决这些问题, 我们需要传引用而不是传值给子例程. 这就是医生（或教授）要求的. 
4. 6. Nested Data Structures||4. 6. 数据结构嵌套
If the Skipper calls this on. cshrc, he'll get back an undef value, indicating that a file was seen.||如果Skipper调用这个时找到. cshrc, 我们返回未定义值, 表示看到一个文件. 
The base cases in this recursive algorithm are the files and symbolic links. This algorithm wouldn't correctly traverse the filesystem if it followed symbolic links to directories as if they were true (hard) links, since it could end up in a circular loop if the symlink pointed to a directory that contained the symlink. [*] It would also fail to correctly traverse a malformed filesystem that is, one in which the directories form a ring rather than a tree structure, say. Although malformed filesystems may not often be an issue, recursive algorithms in general are vulnerable to errors in the structure of the recursive data.||这个递归算法中的基础情况是文件和符号链接. 如果文件系统中的符号链接指向目录, 好像是真的（硬）连接, 这个算法不能正确遍历文件系统. 因为如果符号链接指向一个包含着符号链接的目录的话, 它会最终走向一个循环. ［＊］ 在遍历一个错误格式的文件系统时也会出错. 所谓错误格式的文件系统是指, 目录形成一个循环结构, 而不是树形结构. 尽管错误格式的文件不一定成为问题, 递归算法一般来说在遇到循环数据结构时会有麻烦. 
Now the Skipper can safely update and maintain one copy of the common subroutines without having to copy and recopy all the fixes and extensions into the many separate navigation programs he creates and uses. Figure 10-1 illustrates how the Skipper can use his common library.||这样, Skipper可能安全的修改一处拷贝, 而不必把这些修改和扩展拷贝到所有其它他创建和使用的导航程序中. 图10-1展示了Skipper如何使用他的通用程序库. 
10. 4. Using require||10. 4. 使用 require
The resulting list is 1, 16, 2, 32, 4, 8. Why didn't sort order these properly? It treats each item as a string and sorts them in string order. Any string that begins with 3 sorts before any string that begins with 4.||排序的结果是：1, 16, 2, 32, 4, 8. 为什么不能按正确的顺序排序呢？ 是因为是把它们按字串对待, 以字串的顺序进行排序. 任何以3开头的训是排在以4开头的字串之前. 
At this point, $provisions{"The Skipper"} doesn't exist, but we're trying to use it as an array reference. To resolve the situation, Perl automatically inserts a reference to a new empty anonymous array into the variable and continues the operation. In this case, the reference to the newly created empty array is dereferenced, and we push the blue shirt to the provisions list.||在这时候, $provisions{"The Skipper"}并不存在, 但我们正在把它作为一个数组引用来处理. 为了解决这种情况, Perl自动为我们创建一个指向家的匿名数组的引用来继续操作. 在此例中, 新的指向空数组的引用被创建, 并被还原, 我们再把蓝衬衫放进去, 生成了一个装备清单. 
[*] There are more efficient ways to check list membership for large lists, but for a few items, this is probably the easiest way to do so with just a few lines of code.||[*]如果列表很大, 我们有更有效率的办法. 但是对于这样的小case, 现在了了数行的办法更简便. 
10. 10. Exercises||10. 10. 练习
7. 2. Anonymous Subroutines||7. 2. 匿名子程序
Almost every Perl module comes with documentation, and even though we might not know how all of the behind-the-scenes magic works, we really don't have to worry about that stuff if we know how to use the interface. That's why the interface is there, after all: to hide the details.||几乎所有的Perl模块都带有文档说明. 所以尽管我们可能不知道那些模块背后的戏法是怎么变的, 如果我们知道如何使用接口, 我们就不必去担心那些细节. 这就是在这里介绍接口的原因, 毕竟：它屏蔽了复杂性. 
4. 5. Modifying the Array||4. 5. 修改数组
4. 9. Exercises||4. 9. 练习
[] We can use File::Spec::Functions if we want a functional interface.||[+] 如果我们想要专门的接口的话, 可以用use File::Spec::Functions的办法. 
The debugger shows each line of code before it executes it. That means that, at this point, we're about to invoke the autovivification, and we've got our keys established. The s command single-steps the program, while the x command dumps a list of values in a nice format. We can see that $source, $destination, and $bytes are correct, and now it's time to||测试工具会在程序的每一行被执行之前, 显示该语句. 这个意思就是说, 在此时, 我们将会调用一个自生成, 建立我们的索引键. 's' 表示单步执行, 而'x'表示以适当的格式输出值的列表. 这样我们就可以看到$source, $destination和$bytes这些变量是正确的, 且现在正更新数据：
You may start to notice a lot of repeated code here and think that we should refactor that into a common subroutine that we can reuse (and you'd be right):||你可能开始注意到有些重复代码, 开始想法把它重构一下, 整合到一个通用的子例程里以便重用（你做得对！）：
In this case, $_ is the name of a person. We take that name, look up the array reference of the provisions for that person, dereference that in a scalar context to get the count of provisions, and then compare it to 5. And wouldn't you know it; the only name is Gilligan.||在此例中, $_变量是乘客的名字. 我们用那人名, 在放装备的数组引用中查那个人, 然后在标量环境下还原那数组, 得出装备数量, 再以此与5比较. 而且你不知道, 这个乘客就是Gilligan. (译者注：奇怪, 明明有两个符合条件：Gilligan和Professor)
As long as someone understands that and is a partial evaluator and that print returns true when everything is okay, this is a fine replacement. Remember the Perl motto: "There's more than one way to do it" (although not all of them are equally nice or legitimate).||如果你懂得and是个部分求值的短路操作, 只要一切OK就返回true, 这就是个不错的替代. 记住Perl的信条："条条大路通罗马"（尽管不一定在所有的情况下都合情合理）. 
The sort block must return a coded value to indicate the sort order. If $a comes before $b in our desired sorting order, it should return -1; it should return +1 if $b comes before $a; if the order doesn't matter, it should return 0. The order might not matter, for example, if it's a case-insensitive sort comparing "FRED" to "Fred", or if it's a numeric sort comparing 42 to 42. [*]||排序代码块必须返回一个代码值来指明排序的次序. 如果我们希望$a在$b前, 我们应该返回-1;反之, $b排在$a前, 它应该返回+1;如果次序并不重要, 则应该返回0. 所谓次序不重要的意思是, 比如, 如果是大小写不敏感的排序, "FRED"和"Fred", 或者如果数值比较的话, 42和42. ［＊］
6. 8. 2. Exercise 2 [5 min]||6. 8. 2. 练习2 ［5分钟］
8. 5. Directory Handle References||8. 5. 目录句柄引用
11. 1. If We Could Talk to the Animals...||11. 1. 如果能与动物对话… …
5. 9. Exercises||5. 9. 练习
Another way to visualize a complex data structure rapidly is to dump it. A particularly nice dumping package is included in the Perl core distribution, called Data::Dumper. Let's replace the last half of the byte-counting program with a simple call to Data::Dumper:||另外一个我们可以快速查看复杂数据结构的方法是用dump模块打印出来. 这个特别好用的dump模块已被收纳在Perl的核心发布中, 唤作：Data::Dumper. 让我们改写前面那个字节计数的程序的后半部份, 这次用Data:Dumper模块：
One purpose of OOP is to enable the maintainer of Animal or Horse to make reasonably independent changes to the implementation of the methods and still have the exported interface work properly. To see why accessing the hash directly violates this, let's say that Animal no longer uses a simple color name for the color, but instead changes to use a computed RGB triple to store the color (holding it as an arrayref). In this example, we use a fictional (at the time of this writing) Color::Conversions module to change the format of the color data behind the scenes:||面向对象设计的目标之一就是要让Animal或Horse的代码维护者在进行合理独立的改动方法的实现的时候, 使接口仍然可以工作. 要看为什么直接访问散列就破坏了封装, 让我们打个比方, 如果我们不用简单的颜色名字来代表颜色, 而是用ＲＧＢ三色数字来代表颜色（用一个数组引用来代表）. 在这个例子中, 我们用一个假想的（写这本书的时候）Color::Conversions模块来改幕后的色彩格式：
For the next step, we sort the arrayrefs, ordering them by the monkey-returned value:||为了下一步, 我们把数组引用排序, 以猴子报告的数值为序：
9. 9. Exercises||9. 9. 练习
5. 6. Creating an Anonymous Hash||5. 6. 创建匿名散列
Give the Animal class the ability to get and set the name and color. Be sure that your result works under use strict. Also make sure your get methods work with both a generic animal and a specific animal instance. Test your work with:||给Animal类添加设置和取得名字和颜色的能力. 要保证在use strict下能运行. 而且要保证get方法在类和实例情况下都能工作. 并以以下代码测试：
The data remains alive until we destroy the last reference, even if that reference lives within a larger active data structure. Suppose an array element is itself a reference. Recall the example from Chapter 4:||只要最后一个引用没有被销毁, 数据就一直存在. 甚至引用包含在一个大的数据结构时也是如此. 有可能数组本身的一个元素就是一个引用. 我们回想一下第四章见到过的例子：
Ahh, notice that we have three files, but the fourth entry bin doesn't have undef for a value but rather the hash reference created earlier for the Skipper's personal bin directory. This is how we indicate subdirectories. If the value is undef, it's a plain file; if it's a hash reference, we have a subdirectory, with its own files and subdirectories. Of course, we can have combined these two initializations:||哈, 注意, 我们现在有三个文件, 但是第四个条目bin没有含有未定义值, 而是一个散列引用, 这个引用是先前建立的指向Skipper的个人的bin目录. 这就是我们标识子目录的方法. 如果值不是未定义, 则它是一个文件; 如果是个散列引用, 我们就是指向一个子目录, 其拥有自己的文件和其它子目录. 当然, 我们可以把两者合在一起：
[*] In the block form of grep, there's no comma between the block and the input list. In the expression form of grep, there must be a comma between the expression and the list.||[*] 在grep的块形式中, 代码块和输入数组中间是没有逗号的. 而在grep的表达式形式中, 表达式和输入数组中间必须要有一个逗号. 区别如下：
5. 2. What If That Was the Name?||5. 2. 假若它曾经有一个名字
You can find the answers to these exercises in "Answers for Chapter 3" in the Appendix.||在附录找答案. 
Put another way, a variable or a complex data structure is a repository of values throughout the program. A reference to a subroutine can be thought of as a repository of behavior in a program. The examples in this section show how this works.||换一种说法, 一个变量或者一个复杂数据结构是一个程序中的数据的仓库. 一个对子程序的引用可以被想像成为一个程序动作（方法）的仓库. 本节中的例子可以向你揭示这一点. 
11. 2. Introducing the Method Invocation Arrow||11. 2. 介绍方法调用符
4. 9. 2. Exercise 2 [30 min]||4. 9. 2. 练习 2 [30 分钟]
Package names are like variable names: they consist of alphanumerics and underscores but can't begin with a digit. Also, for reasons explained in the perlmodlib documentation, a package name should begin with a capital letter and not overlap an existing CPAN or core module name. Package names can also have multiple names separated by double colons, such as Minnow::Navigation and Minnow::Food::Storage.||程序包名字与变量名字相同：他们包括字母和数字及下划线, 但是不能以数字开头. 同样, 因为在Perl的perlmodlib文档中说明的理由, 一个程序包名应该以大写开头, 并且不与现存的CPAN或核心的模块名重名. 包名可以以双冒号分隔定义多个名字, 如：Minnow::Navigation及Minnow::Food::Storage. 
The intermediate variables between each of these steps were not necessary, except as input to the next step. We can save ourselves some brainpower by just stacking all the steps together:||每一步当中的中间变量, 除了作为下一步的入, 实际上并不需要他们. 我们可以把这些步骤全都堆在一块儿, 这也节省点力气. 
The book will cover that as well, even if you've never seen objects before.||这本书也介绍了这部分的知道, 尽管你可能重来没有面向对象的概念. 
The Skipper can save disk space (and brain space) by bringing the definition for turn_toward_heading out into a separate file. For example, suppose the Skipper figures out a half-dozen common subroutines related to navigating the Minnow that he seems to use in most or all of the programs he's writing for the task. He can put them in a separate file called navigation. pm, which consists only of the needed subroutines.||Skipper可以把程序turn_toward_heading的定义独立出为另一个文件以节省磁盘空间（也是脑力空间）. 比如, 如果Skipper发现与导航相关的半打通用子程序, 他可能用在大多数或所有的程序中. 他可以把它们放在一个分开的文件叫做navigation. pm中, 只包含有需要的子程序. 
The invocation of:||调用：
Of course, this requires a bit of discipline, because breaking the expected interface of a given subroutine now breaks many programs instead of just one. [] The Skipper needs to give special thought to his design for reusable components and modularity design. We'll presume the Skipper has had some experience at that, but we'll show some more on that in later chapters.||当然, 这样做需要一些约束, 因为如果在给出的子程序中破坏了一个预期的接口, 会影响到许多其它的程序而不只自己一个. [+] Skipper需要对组件的重用性和模块化的设计给予专门的考虑. 我们先假定Skipper有这方面的经验, 但是我们会在以后的章节中展示更多这方面的知识. 
1. 4. What If I'm a Perl Course Instructor?||1. 4. 如果我是讲授Perl课程的指导老师
Most of the time, the array reference we want to dereference is a simple scalar variable, such as @{$items} or ${$items}[1]. In those cases, we can drop the curly braces, unambiguously forming @$items or $$items[1].||一般来说, 还原对数组的引用大多是一个简单的标量变量, 比如：@{$items} 或者 ${$items}[1]. 在那些情况下, 我们可以把大括号去掉, @$items或$$items[1]这样的形式并不会引起歧义. 
We're back to a class method, so the two arguments to Horse::named are "Horse" and "Mr. Ed". The bless operator not only blesses $name, it also returns the reference to $name, so that's fine as a return value. And that's how we build a horse.||参考类方法, 所以有两个参数传给Horse::named, "Horse"和"Mr. Ed". Bless操作符不仅"祝福"了$name, 也返回了$name的引用, 所以返回值是对的. 我们就是这样创建一个horse对象. 
Setting the name of an unnameable generic Horse is probably not a good idea; neither is calling named on an instance. Nothing in the Perl method definition says "this is a class method" or "this is an instance method. " Fortunately, the ref operator lets us throw an exception when called incorrectly. As an example of instance- or class-only methods, consider the following, where we check the argument to see what to do:||给一个无法命名的抽象的"马"起名字多半不是个好主意; 对实例也是一样. 在Perl语言中没有一种方法定义"这是一个类的方法" 或"这是一个对象实例的方法". 好在ref操作符让我们可以在调用出错的时候抛出一个异常. 考虑下面一个仅仅是"实例"或"类"方法的例子, 我们用参数来决定下面一步是什么：
How to run a Perl program on your system||在你的平台如何运行Perl
8. 4. IO::Handle||8. 4. IO::Handle模块
Suppose we wanted to capture information about a filesystem, including the filenames and directory names, and their included contents. Represent a directory as a hash, in which the keys are the names of the entries within the directory, and values are undef for plain files. A sample /bin directory looks like:||我们可能要收集一个文件系统的信息, 包括文件名和目录名, 以及他们的内容. 用一个散列代表目录, 在其中, 键代表条目名字, 其值如果是未定义则代表是一般的文件. 以/bin目录为例：
But look at all that common code. Each speak method has a similar structure: a print operator and a string that contains common text, except for two words. One of OOP's core principles is to minimize common code: if we write it only once, we'll save time. If we test and debug it only once, we'll save more time.||但查看一般代码. 每个speak方法都相似结构：一个打印操作符和一个包含一般文本的字串, 除了两个字不同. OOP的一个核心原则就是把通用的代码最小化：如果我们仅写一次, 我们就节约了时间. 如果我们调试一次就可以了, 我们就节省了更多时间. 
One practical solution to this problem is to change the block in which the static local appears into a BEGIN block:||一种解决方法是把代码放进BEGIN块：
Here we don't need to come up with a temporary name, and we don't need the extra noise of the temporary block. The result of a square-bracketed anonymous array constructor is an array reference, which fits wherever a scalar variable fits.||这里, 我们不必需要提供临时变量名字, 也不要讨厌的临时代码块. 用方括号返回的匿名数组结构就是一个对数组的引用, 并且用在任何标量环境中都合适. 
In the grep, $_ varies from 0 to the highest index of @x. If that element is beyond the end of @y, we automatically select it. Otherwise, we look at the individual corresponding values of the two arrays, selecting only the ones that meet our match.||在grep中, $_由0增长到数组@x的索引最大值. 如果元素超出@y的索引边界, 则自动会选择它. 否则, 我们会比较相应位置的两个元素的大小, 选择符合我们要求的. 
[*] Other than calling on a butcher, that is.||[*] 就是说不要叫屠夫来就可以了. 
Except for. in that list, we probably won't be able to write to any of the other directories unless we're the person responsible for maintaining Perl on our machine, in which case, we should be able to write to all of them. The remaining directories are where Perl searches for system-wide libraries and modules, as we'll see later.||在输出列表中, 除了句点. , 除非我们是负责在这台电脑上维护Perl的人, 我们大概不能写任何其它的目录进去. 在这种情况下, 我们应该能把它们写进去. 象我们后面要看到的, 余下的目录是Perl系统搜索系统库和模块的目录, 象我们后面所看到的. 
Initially, we might gather the data using a simple loop:||起先, 我们用一个简单的循环收集数据：
That's a lot easier to read because it takes up less space on the screen, which can be really handy when you have deeply nested data structures.||这比先前读起来更容易, 因为占用的屏幕比较少, 如果你的数据结构嵌套比较深的话, 就很好用. 
Using the simple syntax introduced in Chapter 11, we have class methods, (multiple) inheritance, overriding, and extending. We've been able to factor out common code and provide a way to reuse implementations with variations. This is at the core of what objects provide, but objects also provide instance data, which we haven't even begun to cover.||应用第11章介绍的简单的语法, 我们就可以创建类方法, （多重）继承、重载和扩展. 我们也可以把代码中共同的部份找出来并用变量代之以重用. 这是面向对象编程的核心概念, 而且对象也提供实例数据, 这点我们还没有开始了解. 
For example, the hash reference might be constructed like so:||比如, 这个散列引用可以是这样的：
All of this means that the file tests, such as -s, automatically report on the just-found item. Although this is convenient, the current directory inside the callback is different from the search's starting directory.||这一切说明对文件的查验, 如-s, 是自动应用在即时找到的那个文件上的. 尽管这很方便, 回调程序里的当前目录还是与搜索目录不同. 
While the code we brought in from a. pm file can have direct executable statements, it's much more common to simply define subroutines that we can load using do.||当代码从一个. pm文件导入的时候可以有直接可执行的语句, 这比用do简单定义子程序更为常用. 
For example, we can iterate over the data for the Skipper, Gilligan, and the Professor by first building a larger data structure holding the entire list of provision lists:||举个例子, 我们首先用个更大点儿的数据结构包含skipper, Gilligan和Professor供应清单的整个列表. 
Each element of the list ends up in $_, so we'll dereference that to pick out the element 0 of that array, which is just the name.||列表中每个元素都是$_, 所以, 我们还原它, 并取出第一个元素, 就是名字. 
The grep in a scalar context returns the number of times the expression $item eq $_ returns true, which is 1 if the item is in the list and 0 if not. [*] If the value is 0, it's false, and we print the message.||grep在标量环境下返回表达式 $item eq $_ 为真时的元素的个数, 如果在列表里就是1否则是0. [*]如果值是0, 则为false, 我们打印出消息. 
12. 6. Making a Method Work with Either Classes or Instances||12. 6. 让一个方法在类和实例都可以使用
Let us add another island inhabitant: Ginger. But rather than define her greeting behavior as a named subroutine, we create an anonymous subroutine:||让我们再添加一个岛上的居民：Ginger. 但是不同于用命名子程序来给她定义行为, 我们可能建立一个匿名子程序：
8. 6. 1. Exercise 1 [20 min]||8. 6. 1. 练习 1 [20 分钟]
6. 4. Storing Complex Data with Storable||6. 4. 用Storable模块存储复杂数据结构
And now we get just 4 and 64.||现在我们得到的输出是4和64. 
Any later data line that contains this same source host and destination host will re-use that same value, adding more bytes to the running total. But each new destination host extends a hash to include a new initially undef byte count, and each new source host uses autovivification to create a destination host hash. In other words, Perl does the right thing, as always.||任何后来的数据行, 如果有相同的源主机和目标主机, 都会重用原来的值, 并加上新读入的值, 再计算出总数. 但是新的目标主机会扩展散列来包括一个新的初始未定义值, 重新计数, 每个新的源主机会用自生成功能建立目标主机散列. 换句话说, Perl 总是做对的事情, 就像它一直表现的那样. 
with the anonymous hash constructor:||如果用匿名散列的话：
Now, since Perl is a mix of procedural, functional, object-oriented, and other sorts of language types, Perl modules come in a variety of different interfaces. We'll employ these modules in slightly different fashions, but as long as we can check the documentation, we shouldn't have a problem.||如今, 因为Perl成了一个过程的、函数的、面向对象和其它各种语言类型的混合体, Perl模块文档开始有不同的接口. 我们会在不同的模块使用稍微不同风格的文档, 但是只要我们可以查文档, 我们就不会有问题. 
The require operator also has two additional features:||require操作符同样有以下两个功能：
Because a use lib pragma will pretty much always have a site-dependent pathname, it is traditional and we encourage you to put it near the top of the file. This makes it easier to find and update when we need to move the file to a new system or when the lib directory's name changes. (Of course, we can eliminate use lib entirely if we can install our modules in standard @INC locations, but that's not always practical. )||因为use lib编译提示总是包含站点相关的路径名, 所以一般来说我们推荐你把它写在文件的开头. 这样当你需要为新系统移动文件, 或库目录名字变化时比较容易更新. （当然, 还有一种办法, 我们压根去掉use lib编译提示, 如果我们可以把我们的模块直接安装在@INC包括的标准路径下, 但这不是总是可行的. ）
Just as we can take a reference to an array, we can also take a reference to a hash. Once again, we use the backslash as the "take a reference to" operator:||就像我们可以取到一个指向一个数组的引用一样, 我们也可以用反斜杠取到一个指向散列的引用：
The syntax comes in two forms, though: we just showed you the expression form, and now here's the block form. Rather than define an explicit subroutine that we'd use for only a single test, we can put the body of a subroutine directly in line in the grep operator, using the block forms:[*]||所以, grep语法有两种形式：前面秀给你们看的表达式形式和下面要展示给你们看的代码块形式. 因为代码只用一次, 我们现在不把代码放到子例程中, 而是以代码块的形式直接放在grep语法里, 所谓的块形式：[*]
Reading this from the inside out, we can think of it like this:||应该按下面的顺序来从里往外读：
Figure 5-1. When the references in a data structure form a loop, Perl's reference-counting system may not be able to recognize and recycle the no-longer-needed memory space||图 5-1. 当一个数据结构中的引用出现循环调用的时候, Perl的引用计数系统可能不能识别出来, 从而不能回收不再需要的内存空间
Some problems that may appear very complex are actually simple once we've seen a solution or two. For example, suppose we want to find the items in a list that have odd digit sums but don't want the items themselves. What we want to know is where they occurred in the original list.||有些问题看上去好像很复杂, 可是一旦你找到解决方案后, 会发现实际上很简单. 比如, 假定我们要在一个列表中把数位加起来是奇数的元素找出来, 但我们不要元素本身, 我们要它们在列表里所在的位置. 
By default, as Perl orders the items, it uses a string comparison. We can specify a new comparison using a sort block that we place between the sort keyword and the list of things to sort. [] Within the sort block, $a and $b stand in for two of the items sort will compare. If we're sorting numbers, then $a and $b will be two numbers from our list.||在缺省时, 当Perl对元素进行排序的时候, 它采用的是字符比较. 我们可以用一个放在sort关键字与要排序的元素列表中间的代码块来指定排序算法. ［＋］ 在排序代码块中, $a和$b代表要比较的两个元素. 如果我们要对数字进行排序, 那么$a和$b会是来自于我们列表中的两个元素. 
Like references, Perl's object architecture was grafted on after a substantial amount of existing pre-Perl 5 code was already in use, so we had to ensure that it wouldn't break existing syntax. Amazingly, the only additional syntax to achieve object nirvana is the method call, introduced shortly. But the meaning of that syntax requires a bit of study, so let's proceed.||如同引用, Perl的对象架构也是从一些现存的前Perl 5已经用的代码移植过来的. 所以我们必须保证不对现有的语法有影响. 令人惊奇的是, 实现向面向对象重生的只用了一个附加的语法, 就是简单引入了方法调用. 但其语不意义需要我们一些研究, 所以让我们开始吧. 
Note that we have just three elements, each of which is a reference to an array that has two elements: the name and its corresponding initial provisions. A picture of that is in Figure 4-1.||注意, 现在我们的结构中有三个元素, 其中每个元素指向另外一个数组, 而那个数组又包含两个元素：名字和相名字相应的初始装备清单. 具体的样子可以看图例4-1:
Now we have an array of references to arrays, each element of which is an IO::File object. Now, let us pump the data from the input files to the output files.||好, 现在我们有了一个保存数组引用的数组, 这个数组中所每个元素都是IO::File对象. 现在, 让我们把输入文件的数据灌入输出文件中去. 
The three basic Perl variable types: scalars, arrays, and hashes||Perl的三种变量类型：标量、数据和散列
Obviously, this will be more interesting if our current directory contains subdirectories.||显然, 如果我们自己的目录里有子目录的话, 那看上去就有趣多了. 
Now we can fix that color for Mr. Ed:||我们可以为Mr. Ed修改一下颜色：
Reference counting as a way to manage memory has been around for a long time. A really long time. The downside of reference counting is that it breaks when the data structure is not a directed graph that is, when some parts of the structure point back in to other parts in a looping way. For example, suppose each of two data structures contains a reference to the other (see Figure 5-1):||用引用计数的办法来管理内存长久以来一直很受欢迎. 的确使用了很长一段时间. 引用计数有一个缺点, 就是在数据结构不是单向引用的时候, 它会有问题. 所谓非单向引用的数据结构就是：这个数据结构中的一些部份引用与其指向的数据存在循环引用. 比如：这两块数据结构中都有互相指向对方的引用（参考图5-1)：
We need a mechanism that tracks which files we've brought in and then brings them in only once. Perl has such an operation, called require. Change the previous code to simply:||我们需要一种机制来跟踪哪些文件我们已经调入了, 而且应该只把它们调入一次. Perl提供了这个功能, 叫作require. 把前面的代码改成如下就可以了：
or the equivalent:||或者等价的：
If we're bringing in the class from outside, via an object-oriented module, we can change:||如果我们要用从外面(通过一个面对对象的模块)带进来的类, 我们可以改成：
All files start as if we had said package main;. [*] Any package directive remains in effect until the next package directive, unless that package directive is inside a curly-braced scope. In that case, Perl remembers the prior package and restores it when that scope ends. Here's an example:||所有的文件都好像以main程序包开始;[*] 所有的包指示字的范围在其声明处开始到下一个包指示字声明的地方结束, 除非那个包指示字在一个大括号范围之内. 在那种情况下, Perl会记住前面的包, 并在其范围结束时恢复它. 这里是个例子. 
2. 3. Dynamic Code with eval||2. 3. 用eval动态编译代码
The map operator has a very similar syntax to the grep operator and shares a lot of the same operational steps. For example, it temporarily places items from a list into $_ one at a time, and the syntax allows both the expression block forms.||map操作符的语法同grep操作符非常相像, 他们有相同的操作步骤. 例如它们都是把输入列表中的元素临时地放到$_变量中去, 而且他们的语法中都有表达式形式和代码块形式. 
If we don't want the default sorting order, we don't need to write an entire sorting algorithm, which is good news since Perl already has a good one of those. But no matter what sorting algorithm we use, at some point we have to look at item A and item B and decide which one comes first. That's the part we'll write: code to handle just two items. Perl will do the rest.||如果我们不想按缺省的排序顺序, 我们不必重写整个排序算法, 好消息是Perl已经有好的方法了来处理这件事情了. 因为不管我们采用什么算法, 从某种程序上说, 这本质是个Ａ和Ｂ谁靠前的问题. 这就是我们要写的那部分代码：处理两个元素的代码. 然后Perl来处理余下的事情. 
12. 15. Exercise||12. 15. 练习
[+] Although we don't go into here, the Module::CoreList module has the lists of which modules came with which versions of Perl, along with other historical data.||[＋] 尽管还没深入到这一步, 还是说一下. 模块Module::CoreList有各个Perl版本所带的模块的列表, 以及其它的历史数据. 
resulting in:||输出结果是：
Now when Gilligan uses this file, he simply adds Navigation:: to the subroutines defined in the library and leaves the Navigation:: prefix off for subroutines he defines on his own:||现在Gilligan导入这个文件, 他只要简单的把在库里引用的子例程前加上Navigation::前缀即可, 而在他自己的同名程序前面不加前缀. 
Using the glob operator, a naive sort of every name in the /bin directory by their relative sizes might be written as:||用glob操作符, 把/bin目录中所有的文件, 以他们的文件大小为序排序, 可能的代码如下：
But, to avoid having "the Llama book" be big and intimidating, we left a lot of information out, deliberately and carefully.||但是, 为了避免"小骆驼书"篇幅太大以至于把初学者吓退, 我们小心谨慎地精简了许多知识. 
This example prints consecutive numbers starting at 1 for the entries below bin, but then continues the numbering when we start entries in lib. The same $count variable is used in both cases. However, if we invoke the create_find_callback_that_counts( ) twice, we get two different $count variables:||下面这个例子从1开始为整个bin目录下的文件计数, 接着前面的数值, 继续为lib目录下所有的文件计数. 在两个程序用同样一个$count变量的值. 然而, 如果我们调用两次create_find_callback_that_counts( ), 我们会得到两个不同的$count变量的值：
One way is to require that the Skipper put an explicit prefix in front of every name defined in the library, say, navigation_. Thus, Gilligan's program ends up looking like:||一种方法是需要Skipper加个显式的前缀在每个他定义的库中的程序名上, 比如, navigation_. 这样, Gilligan的程序看上去是这样的：
The incredibly useful CPAN Search (http://search. cpan. org) will probably become your favorite interface. From that web site, you can search for modules, look at their documentation, browse through their distributions, inspect their CPAN Testers reports, and do many other things.||CPAN Search (http://search. cpan. org)的难以置信的易用性, 一定会成为你最喜欢的搜寻界面. 从那个网页, 你可以搜寻模块、看它的文档、浏览它有哪些版本、查询他们的CPAN测试者的报告以及许多其它事情. 
Inside Horse::name, the @_ array contains just $tv_horse, which the shift stores into $self. It's traditional to shift the first parameter into a variable named $self for instance methods, so stay with that unless you have strong reasons to do otherwise (Perl places no significance on the name $self, however).||在Horse::name中, @_数组只包含了$tv_horse, 并保存到$self中. 一般来说它把第一个参数传到实例方法的$self变量中, 所以保持这个风格, 除非你有十足的理由用其它的风格（然而, Perl对$self并没有特殊的意义）. 
If you come from another OO language background, you might choose $this or $me for the variable name, but you'll probably confuse most other Perl OO hackers.||如果你有其它面向对象语言的背景, 你可能会用$this或$me为变量起名, 不过你可能与其它Perl面向对象的黑客混淆. 
You can find the answers to these exercises in "Answers for Chapter 6" in the Appendix.||在附录中找答案. 
9. 9. 4. Exercise 4 [20 min]||9. 9. 4. 练习4 [20分钟]
Now, what if we want to know Gilligan's first provision? We need to dereference this item one more level, so it's yet another layer of braces: ${${$all_with_names[2]}[1]}[0]. That's a really noisy piece of syntax. Can we shorten that? Yes!||那么, 我们现在要访问Gilligan的第一个装备的话, 会怎么样呢？我们需要把这个引用再还原一下, 所以要加上另一层大括号：${${$all_with_names[2]}[1]}[0]. 这样的语法太麻烦了！我们不能简化一下吗？当然可以！
In an extreme (but extremely useful) case, we can specify an empty list for the import list, as in:||在一种极端的情况（但也极端有用）, 我们可能为导入列表指定一个空列表, 就像下面一样：
the hash slice notation from a reference looks like:||那么散列引用片断的写法看上去如下：
Note that the first parameter here is still the instance, not the name of the class as before. neigh is the return value, which ends up as the earlier $noise variable.||注意这里第一个参数仍旧是实例, 不是像以前一样的类名. "neigh"是输出值, 像以往$noise变量一样. 
Although doing so outside the class is a bad idea, as we'll show later.||[+] 尽管在一个类之外做这事是个糟糕的想法, 这个我们会在后面解说. 
To install a module along with its dependencies, we issue the install command with the name of the module. Now, CPAN. pm handles all the work of downloading, unpacking, building, testing, and installing the module, and it does so recursively for all its dependencies.||要装一个模块和它所依赖的模块, 我们只要发出一个带模块名字的安装命令即可. 如此, CPAN. pm会处理所有下载、解包、编译、测试以及安装模块的工作, 并且它会递归处理所有的依赖关系. 
If the testing expression is complex, we can hide it in a subroutine:||如果检验表达式太复杂, 我们可以把检验代码隐藏到一个子例程里去：
8. 2. The Improved Way||8. 2. 改进的方法
We can even increase the reference count at this point:||此时我们甚至还可以增加引用计数：
As of version 5. 8. 6, Perl recognizes the reverse sort and does it without generating the temporary, intermediate list.||［＋］在5. 8. 6版本中, Perl 识别反向排序, 而且并不产生临时, 中间列表. 
So, with a few calls, we can see an incremented count:||所以, 经过几次调用, 我们可以看到计数增长：
Because it is a slice, remember that those parentheses are mandatory. Don't forget that the working directory inside the callback isn't necessarily the starting directory in which find was called.||因为是片断, 记住上面这段代码中那些小括号是必须要加的. 别忘记回调里的工作目录不一定是find程序调用的起始目录. 
However, if Perl doesn't find Class::method, it examines @Class::ISA (recursively) to locate a package that does indeed contain method and then invokes that version instead.||然而, 如果Perl没有找到Class::method, 它会去查@Class::ISA(以递归的方式)来定位实际包含执行方法的包, 并调用. 
Only the name of the package and the specific sound change. So can we share the definition for speak between the cow and the horse? Yes, with inheritance !||只有包名和声音变了. 那么我们可以把牛和马的speak定义共享吗？ 是的, 用继承！
For each IO::Dir method name, append "dir" and look at the documentation in perlfunc.||[+] 对于每个IO::Dir模块名, 加上"dir" 并用perlfunc查看其文档. 
[*] ISA is actually a linguistic term. Once again, Larry Wall's background as a linguist has come back to influence Perl.||[*] ISA 实际上是一个语言学上的术语. 再提醒一次, Larry Wall的语言学家的背景又在反过来影响了Perl. 
The implementation given earlier returns the newly updated value. Frequently, this is the easiest code to write, and often the fastest to execute.||上面的例子返回新更新的值. 一般来说, 这样写代码是容易, 执行起来也最快. 
10. 1. The Cure for the Common Code||10. 1. 修改通用代码
10. 3. Using do||10. 3. 使用do
Take $root.||取变量$root. 
Chapter 7. Subroutine References||第七章 对子程序的引用
We've created the hash entries through autovivification. Let's see what we've got:||我们已经通过自生成建立了散列条目. 让我们看看我们得到了什么：
In Perl, an instance must be a reference to one of the built-in types. Start with the simplest reference that can hold a horse's name, a scalar reference:[*]||在Perl中, 一个实例必须是一个对内建类的引用. 通过最简单的引用可以保存马的名字, 一个标量引用：[*]
2. 4. 2. Exercise 2 [25 min]||2. 4. 2. 练习 2 [25 分钟]
You've seen how to solve the excessive copying problem with an array reference. Now let's look at modifying the original array.||你已经看到了如何用一个指向数组的引用来解决大量拷贝带来的问题. 现在我们来看看如何修改原始数组. 
But what if we wanted to look at the original list and determine which element of the original list now appears as the first, second, third, and so on, element of the sorted list? For example, Ginger is the second element of the sorted list and was the fourth element of the original list. How do we determine that the second element of the final list was the fourth element of the original list?||但是, 如果我们要看这排序后的列表中各元素在排序前的位置应该如何做呢？ 比如, Ginger排序后是在第二位, 而在原始列表中它是第四位元素. 我们如何确它排序后的第二位元素是排序前的第四位元素呢？
[*] Behind the scenes, Perl is limited by the architecture it's on. It's one of the few places where the hardware shows through.||[*] 在幕后, Perl实际上要被其宿主的操作系统架构所限制. 这是少数硬件环境限制之一. 
As the Professor tries to maintain the community computing facility (built entirely out of bamboo, coconuts, and pineapples, and powered by a certified Perl-hacking monkey), he continues to discover that people are leaving entirely too much data on the single monkey-powered filesystem and decides to print a list of offenders.||因为教授要维护社区的计算设备（全都由竹子, 椰子, 菠萝, 并由一个经过Perl黑客级别认证的猴子来提供支援）, 然后他发现有些人把太多数据给猴子来处理, 所以决定打印出一份罪犯名单. 
5. 8. Autovivification and Hashes||5. 8. 自生成功能与散列
At first, it may look a bit mystifying, but if we walk through the code slowly, we'll see it's always doing the right thing. Test the results of this subroutine by calling it on. (the current directory) and inspecting the result:||一开始, 这看上去好像很搞, 但是, 只要我们慢慢读完这个程序, 我们会发现它总能完成任务. 调用它一下, 看看结果如何. （在当前目录中）检查一下结果：
As the data structures become more complex, it helps to have higher-level constructs deal with common tasks such as selection and transformation. In this regard, Perl's grep and map operators are worth mastering.||随着数据结构越来越复杂, 我们就能有更强的结构来处理那些经常性的拣选和转换的任务. 考虑这些因素, 掌握Perl的grep和map操作符是值得的. 
This is the list the foreach now scans. These are all the sources for transferred bytes seen in this particular logfile. Here's what happens when we step into the inner loop:||这是foreach语句扫描的清单. 这些是所有特定日志文件中传输字节的所有源主机. 下面是当我们单步执行到里层循环时发生的事情：
and then the programmer wonders why it didn't pull in the definitions. Be aware that use lib indeed runs at compile time, so this also doesn't work:||这样程序员会迷惑为什么没有把定义加进去. 还要注意use lib实际上是在编译时执行的, 所以如下代码同样不能工作：
Note the comment about DST. In many parts of the world, on the days when daylight savings time or summer time kicks in and out, the day is no longer 86, 400 seconds long. The program glosses over this issue, but a more pedantic coder might take it into consideration appropriately.||注意关于DST的注释. 在世界上的其它部份, 在夏时制的白天可能有出入, 并不一定是86, 400秒. 这个程序忽略了这个问题, 但是一些更"顶真"的程序员可能会把这种情况适当考虑进去. 
You can find the answers to these exercises in "Answers for Chapter 10" in the Appendix.||答案见附录. 
The semicolon is needed after the eval block because eval is a function (not a control structure, such as if or while). But the block is a true block and may include lexical variables ("my" variables) and any other arbitrary statements. As a function, eval has a return value much like a subroutine's (the last expression evaluated, or a value returned early by the return keyword). Of course, if the code in the block fails, no value is returned; this gives undef in a scalar context, or an empty list in a list context. Thus, another way to calculate an average safely looks like this:||eval块的结束时的分号是必须的, 因为不像 if或者while那样的控制结构, eval实际上是个函数. 但是代码块是真的块, 所以可以包括词法变量（"my" 修饰的变量）和另外其它的断言语句. 因为是个函数, eval有像子例程那样的返回值（最后一个表达式的求值结果, 或者由return语句返回的结果）. 当然, 如果代码块失败则没有值返回;如果在标量环境将返回未定义值, 在列表环境将返回一个空的列表. 因此, 比较安全的求平均值的代码的写法如下：
7. 4. Closures||7. 4. 闭包
When you use the same data from the earlier example, you get this output:||用前面提供的例子, 我们得到这样的输出：
Even though we can't directly examine the list value from inside those parentheses, we can display it:||尽这我们不能直接从括号内部验核列表值, 但我们可以显示它：
You should skip those the first time through and pick them up on a rereading.||在你第一次读本书的时候尽可以略过不看, 在重读的时候可以把它们看看. 
If an error happens while running code inside an eval block, the block is done executing. But even though the code inside the block is finished, Perl continues running the code just after the eval. It's most common after an eval to immediately check $@, which will either be empty (meaning that there was no error) or the dying words Perl had from the code that failed, perhaps something like "divide by zero" or a longer error message.||如果在eval块里代码发生错误, 系统会退出这个块. 但是, 尽管退出块, Perl会继续执行eval块之外的代码. 我们在eval块的后面一般做法是检查一下$@变量, 这个变量要么是空（表示没有出错）或者代码出错时系统返回的"遗言", 多半是"除零错误"之类云云. 
[*] This code seems to have an extra semicolon at the end of the line that assigns to $callback, doesn't it? But remember, the construct sub { ... } is an expression. Its value (a coderef) is assigned to $callback, and there's a semicolon at the end of that statement. It's easy to forget to put the proper punctuation after the closing curly brace of an anonymous subroutine declaration.||[*] 这里的代码好像在行尾给$callback赋值时多出一个分号, 不是吗？ 但是注意, sub { … }创建的是个表达式. 值（一段代码引用）赋给变量$callback, 所以语句后面有分号. 在花括号定义的匿名子程序后面加上适当的标点符号是很容易被遗忘的. 
Ahh! Now that the package name is separated from the subroutine name, we can use a variable package name. This time, we've got something that works even when we enable use strict 'refs'.||哈！既然包名和子程序的名字分开, 我们就可用一个变量包名. 这次, 我们就可以得到我们用use strict 'refs'时也可以工作的东西. 
9. 9. 3. Exercise 3 [10 min]||9. 9. 3. 练习3 ［10分钟]
In the section to set up the subroutines, we create three instances of callback-and-getter pairs. Each callback has a corresponding subroutine to get the results. Next, in the section to gather the data, we call find three times with each corresponding callback subroutine reference. This updates the individual $total_size variables associated with each callback. Finally, in the section to show the data, we call the getter routines to fetch the results.||在创建子程序的程序片断中, 我们创建了回调／求总对的三个实例. 每一个回调程序都有相应的求总程序. 接下来, 在取得文件字节总数的程序片断中, 我们三次用相应的回调匿名子程序的引用调用find程序, 这更新了与这三个回调匿名子程序关联的三个独立的$total_size变量. 最后, 在展示结果的程序片断中, 我们调用返回字节求总的那个匿名子程序来取得结果. 
For Example One, consider an HTML table that has rows containing cellsand some of those cells may also contain entire tables. Example Two could be a visual representation of a filesystem consisting of directories containing files and other directories. Example Three is a company organization chart, which has managers with direct reports, some of whom may be managers themselves. And Example Four is a more complex organization chart, which can contain instances of the HTML tables of Example One, the filesystem representations of Example Two, or even entire organization charts. . . .||举个例子来说, 考虑一下一个含有表行表列的HTML表, 而表里的单位格可能还有其它的表. 例二是个虚拟的文件系统的例子, 一个文件系统中有一些目录, 而在目录中有文件或其它目录. 例子三是公司的组织结构图, 各部经理向他们的上司报告, 而其中有的经理向自己报告. 例子四是更加复杂的组织结构图, 可以包括上述例一的HTML表、例二的文件系统, 或者整个公司的组织结构图表… …
This three-argument form has the added advantage of access to the Perl IO filters. We won't go into too much detail here. [*] The open function's entry in perlfunc is over 400 lines, even though it has its own perldoc tutorial, perlopentut.||这种三参数的形式有可以利用Perl的IO过滤器的优点. 这里我们不涉及太多. [*] 在perlfunc中open函数的条目有400行之多, 尽管在它自己的perldoc教材和perlopentut中也有说明. 
We can refer to the @homeport variable in the main code with its full package specification:||我们可以在主程序中用全名引用@homeport变量：
Another tool, CPANPLUS, is a complete rewrite of CPAN. pm, but it isn't part of the core distribution as we write this.||还有一个工具：CPANPLUS, 是对CPAN. pm完全的重写. 但它不是Perl核心包的一部份, 如下：
By placing some of the code into a separate file, other programmers can reuse the Skipper's routines, and vice versa. If Gilligan writes a routine to drop_anchor( ) and places it in the file drop_anchor. pm, then the Skipper can use Gilligan's code by including his library:||通过将一些代码放到文件中, 其它的程序员可以重用Skipper写的程序, 反过来也一样. 如果Gilligan写了一个程序:drop_dnchor(), 并且将其放到文件drop_anchor. pm中, 这样Skipper就可以通过引入库的办法使用Gilligan的代码：
As you develop your code, you may want to consider if you want to use only core modules, so that you can be sure that anyone with Perl will have that module as long as they have at least the same version as you. [] We'll avoid that debate here, mostly because we love CPAN too much to do without it.||当你在开发你的程序的时候, 你可能要考虑是否你应该仅仅用核心模块. 这样的话你就能保证任何用Perl的人都能执行你的代码, 只要他们的Perl版本同你相同. ［＋］这里我们也不多费口舌了, 主要是因为我们太喜欢CPAN了, 不用它就舍不得. 
At the end of the naked block, the $count variable goes out of scope. However, because it is still referenced by subroutine in $callback, it stays alive as an anonymous scalar variable. [*] When the callback is invoked from find, the value of the variable formerly known as $count is incremented from 1 to 2 to 3, and so on.||在裸块的结尾, 变量$count跑出程序范围. 然而, 因为这个变量仍旧被$callback所指向的匿名子程序引用, 所以此变量作为一个匿名的标量变量仍旧活着. [*] 当find子程序调用回调匿名子程序的时候, 先前被称为$count的这个变量的值继续从１到２到３地增加. 
At this point, @skipper_with_name has two elements, the second of which is an array reference similar to what we passed to the subroutine. Now we group them all:||现在, @skipper_with_name有两个元素, 第二个元素就是指向数组的引用, 就是上例中我们传给子例程的那个. 现在, 我们把它们组织起来：
Now we've added bytes flowing from professor. hut to lovey. howell. hut. The top-level hash hasn't changed, but the second-level hash has added a new entry. Let's continue:||现在我们已经把从professor. hut流向lovey. howell. hut主机的字节数加上了. 顶层的散列没有变化, 而下一级的散列已加上了新的条目. 让我们继续：
Ahh, but what happens if we invoke speak on an instance?||嗯, 但如果我们在实例上调用speak会发生什么呢？
Now we call for the name:||现在调用名字：
[*] The format used by Storable is architecture byte-order dependent by default. Its documentation shows how to create byte-order-independent storage files.||[*]Storable采用的格式是缺省依赖字节顺序的结构. 文档中有说明如果创建不依赖字节顺序的存储文件. 
In a list context, the grep operator returns a list of all such selected items. In a scalar context, grep returns the number of selected items.||在一个列表上下文中, grep操作符会返回所有被选出元素的列表. 而在一个标量上下文中, grep返回被选出元素的个数. 
[] That string might be something like /home/gilligan/web_docs/photos/USS_Minnow. gif on a Unix system. On a Windows system, it would typically use backslashes as directory separators. This module lets us write portable code easily, at least where file specs are concerned.||[+] 返回的的字段结果, 如果在UNIX系统, 那么多半是：/home/gilligan/web_docs/photos/USS_Minnow. gif. 如果在windows系统里, 就会用代表目录分隔符的反斜杠. 这个模块让我们可以写出可移植的代码, 至少在文件描述上是这样的. 
We can then copy the reference or take additional references, and they'll all refer to the same thing and are interchangeable:||我们现在就可以拷贝这个引用或把它传给另外一些引用, 并且, 它们全都指向同一数据, 并且是互相可替换的：
The result should be that the machine that sent the most data will be the first source machine in the list, and the first destination should be the machine to which it sent the most data. The Professor can use this printout to reconfigure the network for efficiency.||其最终的结果就是列出传输最多的源主机, 然后以此源主机为组, 接收最多的目标主机排在最前. 教授可以以此报表来重新安排网络效率. 
Obviously, this can lead to confusing code, so we shouldn't introduce such duplication needlessly. The results are completely predictable, though.||显然, 这段代码会导致混淆, 所以我们不应该搞这种没必要的双重声明. 尽管结果早就会料到. 
while a nonempty directory should appear with nested contents, indented two spaces:||非空的子目录应该用缩进两人空格的方法显示嵌套内容：
We can call out from speak to a helper method called sound. This method provides the constant text for the sound itself:||我们可以从speak调一个方法叫sound. 这个方法提供一个常量做为声音的内容：
To the caller of this subroutine, the return value is identical to the previous version. However, from a maintenance point of view, the reduced clutter of not having all the intermediate names saves screen and brain space.||对于调用它的子程序来说, 现在的返回值对于前一个版本是一样的. 然而, 从代码维护的角度来看, 去掉那些中间名字, 这样降低了复杂性也节省了代码占用屏幕空间. 
8. 3. The Even Better Way||8. 3. 更上一层楼
Does this work for more complicated structures? Yes! Anytime we need an element of a list to be a reference to an array, we can create that reference with an anonymous array constructor. In fact, we can also nest them in our provisions list:||那么在更复杂的结构中, 这个原则还工作吗？当然！只要是需要一个指向数组的引用, 我们就可以创建指向匿名数组的引用. 实际上, 我们还可以嵌套使用：
12. 8. More Interesting Instances||12. 8. 更有趣的实例
and now we'll fix speak to use this:||我们将使用这个设置叫声
3. 6. A More Typical Object-Oriented Module: Math::BigInt||3. 6. 一个更典型的面向对象模块: Math::BigInt
However, suppose we already had a dirname subroutine. We've now overwritten it with the definition provided by File::Basename! If we had turned on warnings, we would have seen a message stating that; but otherwise, Perl really doesn't care.||然而, 假定我们曾经在程序里写过一个同名的dirname函数的话, 那么File::Basename提供的同名函数会把你的覆盖！如果我们打开warnings报警, 我们会看到一条警告信息;否则的话Perl不会关心这种情况. 
That last form is particularly handy when the coderef is in a larger data structure, as you will see in a moment.||最后一种形式特别适用于在一个大数据结构中进行代码引用, 你一会儿就会看到. 
Note that dumping $total_bytes{$source} shows that it was a hash reference. Also, the sort appears not to have done anything, but the output of keys is not necessarily in a sorted order. The next step finds the data:||注意, 打印$total_bytes{$source}显示它是一个散列引用. 这样, sort 看上去好像什么都没做, 输出的键不必以排序输出. 下一步是找数据：
Now the logfile is large, and the coconut-powered computer is not very fast, so he wants to process the input file in one pass and write all output files in parallel. How does he do it?||现在这个日志文件很大, 而计算机又不快, 所以他要一次读入, 并行输出. 他该怎么办呢？
Now that we know more about what the method invocation arrow actually does, we've got an easier way to do the same thing.||即然我们已经知道了箭头调用符是如何工作的, 我们就得到了入门的捷径. 
attempts to invoke the subroutine Class::method as:||会以如下方式调用子程序Class::method :
This routine gives the shortest turn to make from the current heading (returned by the subroutine current_heading( )) to a new heading (given as the first parameter to the subroutine).||这个通用子例程提供从当前航向的最短的转向（从子程序current_heading()返回）到一个新的航向（由第一个参数输入）. 
This is a lot of typing to simply say "the second element should be a reference to an array containing these elements. " We can create such a value directly using the anonymous array constructor, which is yet another use for square brackets:||为了仅仅说明"第二个元素应该是个指向一个包括这些元素的引用", 而编上例中这些代码, 好像太麻烦了. 我们可以创建一个直接使用匿名数组的结构, 即方括号的另一种用法：
We have seen the coderefs in a scalar variable and as an element of a list. Can we put these coderefs into a larger data structure? Certainly. Create a table that maps people to the behavior they exhibit to greet others, and then rewrite that previous example using the table:||我们已经看到了把代码引用作为一个列表中的元素. 那我们是否可以把代码引用放到一个大的数据结构中呢？ 当然可以. 我们可以创建一个表, 来让乘客与其向他们问候动作对应, 我们可以重写之前的例子：
7. 3. Callbacks||7. 3. 回调
Dereference that as an array reference, taking the entire array.||然后把整个数组还原出来. 
[*] Oddly, the variable $more_code is also visible to the evaluated code, not that it is of any use to change that variable during the eval.||［＊］奇怪的是, 变量$morecode同样对于求值代码可见, 不像其它eval求值时会改变变量. 
When we give x a hash reference, it dumps the entire contents of the hash, showing the key/value pairs. If any of the values are also hash references, it dumps those as well, recursively. What we'll see is that the %total_bytes hash has a single key of professor. hut, whose corresponding value is another hash reference. The referenced hash contains a single key of gilligan. crew. hut, with a value of 1250, as expected.||当我们给调试命令x 一个散列引用的时候, 它会把这个散列的所有内容（键／值对）打印出来. 如果其中的值也是指向散列的引用的话, 它同样也会打印, 以此类推. 我们可以看到散列%total_bytes中professor. hut键相对应的值是指向另一个散列的引用. 就像你预期的那样, 这个散列引用内中有单个键：gilligan. crew. hut, 其对应的值为1250. 
If there is a subdirectory, the nested subroutine call uses readdir to extract the contents of that directory and returns a hash reference, which is inserted into the hash structure created by the caller.||如果这其中是个子目录, 则嵌套子程序调用使用readdir抽出目录内容, 并返回一个散列引用, 并由调用者放到散列结构中. 
The previous value (similar to the way umask or the single-argument form of select works)||以前的值（类似于用掩码的方法或选择工作时单值形式的参数）
$count retains its value between calls to count_one( ) or count_so_far( ), but no other section of code can access this $count at all.||在几次调用count_one()或count_so_far(), $count会保留其原来的值, 但程序里其它部份的代码是不能访问$count的. 
Sometimes we find both Makefile. PL and Build. PL in a distribution. What do we do then? We can use either one. Play favorites, if you like.||不过有时候我们在发布的安装包里看到有Makefile. PL也有Build. PL. 我们该用哪一个呢？都可以. 请便. 
The Animal class name is now hardwired into the method selection. This is a mess if someone maintains the code, changing @ISA for Mouse, and doesn't notice Animal there in speak. Thus, this is probably not the right way to go.||现在Animal类名被硬编码用于方法选择. 这对维护代码的人很不方便, 为Mouse改@ISA, 并不会注意到Speak中的Animal类. 所以, 这并非最好的解决方法. 
[*] If we had left the inner brackets off, we'd end up with six items out. That's not very useful, unless we're creating a different hash from them.||[*]如果我们把内层的括号去掉, 我们会最后会得出六个单品. 那不是很常用, 除非为什么建立不同的散列. 
If the index is good, return the resulting array value. If the index is bad, return an empty list, making that item disappear.||如果符合条件, 则返回数组元素. 如果不符合, 则返回一个空列表, 使元素蒸发. 
At this point, we can determine from the inside out exactly what values will result from the list value from inside the parentheses. Let's look at them:||当下, 我们可以由内而外精确地确定括号里的清单的值 得出的结果是什么值. 我们往下看：
5. 9. 2. Exercise 2 [40 min]||5. 9. 2. 练习2 ［40分钟］
However, this is noisy and prone to require far more explanation than you might be comfortable with, especially for the maintenance programmer who has to edit your code later. Let's replace all that clutter with that simple pragma we used before:||不过, 这样做看上去很烦琐, 不容易去解释, 特别是以后向那些维护你代码的同事去解释. 这样, 我们用一个简洁的编译提示来换掉原来用的那些乱七八糟的东西. 
In the %INC hash, as described in the entry for require in the perlfunc documentation.||在%INC散列中, 正如perlfunc文档中require条目所描述的一样. 
Note the two changes: the input value comes in via $_ rather than an argument list, and we removed the keyword return. In fact, we would have been wrong to keep the return because we're no longer in a separate subroutine: just a block of code. [*] Of course, we can optimize a few things out of that routine since we don't need the intermediate variables:||注意与用子例程的方法有两个地方的变化：输入值是通过变量$_, 而不是输入参数列表, 而且在代码块形式中我们去掉了return关键字. 实际上如果我们保留return的话是会出错的, 因为我们不是在用一个子例程, 仅仅是一个代码块. [*]当然, 这个例子我们还可以优化一下, 去掉中间变量：
Such memory is available to Perl for other data later in this program invocation, and generally Perl doesn't give it back to the operating system.||这些被释放的内存会被Perl安排用在程序中之后的其它数据的调用, 一般来说Perl不会把这些内存还给操作系统. 
3. 3. Functional Interfaces||3. 3. 函数接口
Could we have eliminated the two shifts at the beginning of the subroutine? Sure, but we sacrifice clarity:||我们是否可以消除传两个值给子例程？当然可以, 不过这样牺牲了明晰性：
So far, we've used the method arrow syntax:||至此, 我们已经用了方法箭头这个语法：
The other two animals come out similarly:||另外两只动物的代码也一样写：
Then, to keep from having to define one for each additional class, define a backstop method, which serves as the "default default, " directly in Animal:||然后, 为了不用在每个类都作定义, 我们直接在Animal中定义一个缺省的方法. 
3. 9. 1. Handling Module Dependencies||3. 9. 1. 处理模块依赖
If we don't put our IO::File object in a simple scalar variable, some operations require a slightly modified syntax to work. For example, we want to copy every file matched by the glob pattern of *. input to a corresponding file whose suffix is. output, but do it in parallel. First, we open all the files, both inputs and outputs:||如果我们不是把IO::File返回的对象放到一个标量变量中, 那么操作起来需要一些对语法的小小变动. 比如这么一个例子, 我们现在要把所有符合*. input的文件都拷贝到相应的*. output文件中, 但我们要并行的进行拷贝. 首先, 我们打开所有的文件, 包括输入和输出的双方：
Some names are always in package main regardless of the current package: ARGV, ARGVOUT, ENV, INC, SIG, STDERR, STDIN, and STDOUT. We can always refer to @INC and be assured of getting @main::INC. The punctuation mark variables, such as $_, $2, and $!, are either all lexicals or forced into package main, so when we write $., we never get $Navigation::. by mistake.||[+] 有些名字总是在main包里, 而不论当前的包是什么： ARGV, ARGVOUT, ENV, INC, SIG, STDERR, STDIN和STDOUT. 我们可以总是引用@INC而得到@main::INC. 那些标点符号标记的变量名, 如$_, $2, 及$!, 也是要么是词法变量或者强制属于main包, 所以当我们写$. , 我们不必加上$Navigation::而导致错误. 
What if we invoke this new subroutine more than once?||那我们多执行几遍这个新的子程序会怎么样？
Perl gives the subroutine five items in its @_ array initially: the name gilligan and the four items belonging to Gilligan. After the shift, @_ only has the items. Thus, the grep checks each required item against the list.||一开始, Perl给子例程五个元素：一个gilligan名字以及另外属于数组Gilligan的四个元素. shift操作之后, @_仅包括四个元素, 因此, grep用每个出海必备装备来核对这个四个元素的列表. 
Among its many other meanings, the backslash (\) character is also the "take a reference to" operator. When we use it in front of an array name, e. g., \@skipper, the result is a reference to that array. A reference to the array is like a pointer: it points at the array, but it is not the array itself.||相对于其它方法, 反斜杠(\)符号被用来当作"取址"操作符. 比如, 哪我们把它放在一个数组前面时：\@skipper, 其结果就是取这个数组的地址. 引用这个数组就是一个指针：指向这个数组, 但并不是这个数组本身. 
Before the Minnow can leave on an excursion (for example, a three-hour tour), we should check every passenger and crew member to ensure they have all the required trip items in their possession. Let's say that, for maritime safety, every person on-board the Minnow needs to have a life preserver, some sunscreen, a water bottle, and a rain jacket.||在Minnow开始一个旅程之前（比如一个三小时的远足）, 我们应该事先检查一下每个乘客和乘务人员的行李, 保证他们带了旅行所需要的东西. 比如说吧, 水上安全救生装备. 在Minnow船上的每个乘客要生命维持系统, 太阳镜和水瓶以及雨衣. 
This is such a common operation, though, that Perl has a pragma for it. The pragma makes everything happen before runtime, so we'll get what we expect.||因为这个操作太常见了, 所以Perl有一个编译指示字来处理. 编译指示字发生在任何运行时之前, 所以我们可以得到预期的效果. 
12. 7. Adding Parameters to a Method||12. 7. 给方法导入参数
Finally, returning a success status is useful if it's fairly common for an update to fail, rather than an exceptional event. The other variations would have to indicate failure by throwing an exception with die.||最后, 如果程序明显出错, 返回一个返回状态要比一个意外报错要好. 其它的变化会发一个例外并终止程序, 以示程序错误. 
Perl tracks how many ways it can access the data through a mechanism called reference counting. The original name counts as one, and each additional reference that we create (including copies of references) also counts as one. The total number of references to the array of provisions is now four.||Perl跟踪有多少途径在访问数据的机制叫做"引用计数". 原来的名字计数为1, 其它我们创建的每一个引用（包括对引用的拷贝）同样被计数. 就目前的例子, 装备清单数组的目前引用数是4. 
Read up on the Benchmark module, included with Perl. Write a program that will answer the question "How much does using the Schwartzian Transform speed up the task of Exercise 1?"||读一下Perl里的Benchmark模块. 写个程序解决一个问题："用了施瓦茨变换使练习1的任务快了多少？"
We had to use $person here to hold the outer $_ temporarily. Otherwise, we can't refer to both temporary values for the outer map and the inner map.||这里, 我们已经使用$person来保存外圈的$_临时变量. 除此以外, 我们不能同时引用外圈和内圈map的临时变量. 
This is actually the same behavior we've probably been using in Perl all along. Perl creates new variables as needed. Before that statement, $provisions{"The Skipper"} didn't exist, so Perl created it. Then @{ $provisions{"The Skipper"} } didn't exist, so Perl created it as well.||实际上, 我们在使用Perl时, 到处都会有相似的行为. 只要有需要, Perl会自动创建变量. 在这之前, $provisions{"The Skipper"}不存在, 所以Perl就创建它. 后来@{ $provisions{"The Skipper"} }不存在, 所以Perl故伎重演. 
The square brackets take the value within (evaluated in a list context); establish a new, anonymous array initialized to those values; and (here's the important part) return a reference to that array. It's as if we had said:||方括号把内中（相当一在一个列表环境）元素取出来;为这些元素建立一个新的, 匿名的数组;并且（这里很重要）返回一个对这个匿名数组的引用. 就好像我们说过的：
Now we have a proper numeric comparison, so we have a proper numeric sort. Of course, this is far too much typing, so we can use the spaceship operator instead:||目前, 我们对数字进行了合适的比较方法, 所以有了正常的数字排序. 当然, 如此的排序方法还是繁琐, 所以我们可以用一个飞船操作符来代替：
9. 2. Sorting with Indices||9. 2. 用索引排序
This is functionally the same as the original data structure. We're now looking at the two array references within one top-level array. To get something closer to what we saw before, we can be more explicit about the return value:||这在功能上等同于原来的数据结构. 我们现在来看看在一个数组层面上的两个数组引用. 同我们先前看到的比较相近, 我们可以更显式地返回值：
11. 11. 2. Exercise 2 [40 min]||11. 11. 2. 练习 2 [40分钟]
user-defined die?||若打开失败呢？
Since sound already worked with either a class or an instance, we're done!||因此sound方法既可以在类上也可以在实例上运行, 完成了！
[*] Although brian does in "Get More Out of Open, " The Perl Journal, October 31, 2005, http://www. tpj. com/documents/s=9923/tpj1130955178261/bdf_open. htm.||[*] 尽管brian在他的一篇文章《详述Perl的Open函数》有涉及, 发表在2005年10月31号的<Perl Journal>, url:http://www. tpj. com/documents/s=9923/tpj1130955178261/bdf_open. htm
He wants to write a series of files, called gilligan. info, maryann. info, and so on. Each file should contain all the lines that begin with that name. (Names are always delimited by the trailing colon. ) At the end, gilligan. info should start with:||他要写一系列的文件, 名字是：gilligan. info, maryann. info等等, 以此类推. 每个文件必须只有以文件名开始的行. （名字以冒号分隔. ） 其结果, gilligan. info应该是如下样子：
There's also a second form of eval, whose parameter is a string expression instead of a block. It compiles and executes code from a string at runtime. While this is useful and supported, it is also dangerous if any untrustworthy data has gotten into the string. With a few notable exceptions, we recommend you avoid eval on a string. We'll use it a bit later, and you might see it in other people's code, so we'll show you how it works anyway.||eval有另外一种用法, 其参数是作为一个字串表达式, 而不是代码块. 在运行时, 它将字串临时编译成代码并且执行. 这很易用, 但也很危险, 因为有可能会把具有危害性的代码放到字串里. 除了极少数值得一提的例外情况, 我们建议你尽量避免这种用法. 稍后我们会用这种用法, 然后我们就不用这种用法了, 我们只是展示它是怎么工作的. 
In later chapters, we'll show how to set up tests to be used while maintaining reused code.||[+] 在后面的章节中, 我们会展示如何建立测试程序来维护可重用的代码. 
This is a single element of the larger list. This item is a reference to an array with two elements, the first of which is the name string, and the second of which is itself a reference to an empty anonymous array. The array is empty because Mrs. Howell hasn't packed anything for this trip.||这是一个只有一个元素的大列表. 这是一个指向一个具有两个元素的数组的引用, 第一个元素是名字字串, 第二个元素自身是个指向空的匿名数组的引用. 这个数组是空的, 因为Howell先生为他的旅程什么也没有带. 
We can create the filehandle reference with the one-argument form of the constructor. We check the result of the operation by looking for a defined value in the filehandle reference variable.||我们可以用单参数构造器的形式创建文件句柄的引用. 我们可以通过检查返回值是否为空来判断文件句柄引用创建是否成功. 
Thus, an easier-on-the-eyes version of that subroutine might be:||因此, 看上去比较顺眼的写法应该是：
This equality compares the numeric forms of the two references. The numeric form of the reference is the unique memory address of the @skipper internal data structure, unchanging during the life of the variable. If we look at the string form instead, with eq or print, we get a debugging string:||这个等式是以数值形式来比较两个引用的. 引用的数值形式就是@skipper这个内部数据结构在内存中的惟一地址, 且在这个变量的生命周期之内是不变的. 如果我们以字串形式来看的话, 我们会得到如下调试形式的字串：
The Skipper writes many Perl programs to provide navigation for all the common ports of call for the Minnow. He finds himself cutting and pasting a very common routine into each program:||Skipper写了许多Perl程序应Minnow的要求为一般的港口提供导航服务. 他发现自己不停的在各个程序之间复制和粘贴一个通用子例程：
We can reduce the namespace clutter by narrowing down the scope of the various array names. Rather than declaring them within the scope of the subroutine, we can create a temporary block:||我们可以用缩小不同数组名的范围的方法来降低命名空间的繁杂性. 代替在子程序范围内声明变量, 我们可以建立一个临时块：
8. 4. 1. IO::File||8. 4. 1. IO::File
Unlike the File::Basename module, the File::Spec module has a primarily objectoriented interface. We load the module with use, as we did before.||与File::Basename模块不同的是, File::Spec模块接口是被设计成面向对象的. 我们也用use来调入模块, 象往常一样：
What happens when we try to store that blue shirt for the Skipper? While looking at the second line of input, we'll end up with this effect:||那现在, 我们要把蓝衬衣放到Skipper的装备清单时会发生什么呢？ 当查看第二项输入时, 我们结果可以看到如下的效果：
We called the constructor named here so it quickly denotes the constructor's argument as the name for this particular Horse. We can use different constructors with different names for different ways of "giving birth" to the object (such as recording its pedigree or date of birth). However, we'll find that most people use a single constructor named new, with various ways of interpreting the arguments to new. Either style is fine, as long as we document our particular way of giving birth to an object. Most core and CPAN modules use new, with notable exceptions, such as DBI's DBI->connect( ). It's really up to the author.||我们调用构建函数named来快速地把参数作为马的名字. 我们可以用不同名字的构建函数来给对象加上生日（如谱系记录或生日）. 然而, 大多数人喜欢用new来命名构建函数, 并对不同的参数以不同的解释. 只要能太到目的, 两种方法都可以. CPAN上大多数模块用new, 也有些是例外, 比如DBI模块的DBI->connect(). 这根据开发者的习俗. 
For example, a recursive subroutine handling the factorial function, which is one of the simplest recursive functions, might look like:||比如, 下面的一个处理阶乘的递归子程序, 是最简单的递归应用：
How do we access that array reference? Using our rules again, it's ${$all_with_names[2]}[1]. In other words, taking $all_with_names[2], we dereference it in an expression that would be something like $DUMMY[1] as an ordinary array, so we'll place {$all_with_names[2]} in place of DUMMY.||我们如何才能访问那个数组引用呢？用我们的老规矩：${$all_with_names[2]}[1]. 换句话说, 我们在一个表达式中像$DUMMY[1]形式那样把$all_with_names[2]还原成一个一平常的数组, 就是说用{$all_with_names[2]}代替DUMMY的位置. 
Now for the directory part. We need a hash reference, which we declare as a named hash inside the subroutine. For each element of the hash, we call ourselves to populate the value of that hash element. It goes something like this:||现在要对付目录部份了. 我们需要一个散列引用, 我们声明一个命名散列放在子程序中. 为散列中每个元素, 我们调用自己来发布元素值. 程序如下：
The grep operator takes a list of values and a "testing expression. " It takes one item after another in the list and places it into the $_ variable. It then evaluates the testing expression in a scalar context. If the expression evaluates to a true value, grep passes $_ on to the output list.||grep操作符取一个列表和一个"测试表达式". 它一个一个地从列表中把元素取出来放到$_变量中, 并在标量环境中, 用"测试表达式"来检验这个值. 如果检验出来是个"真"值, grep会把$_变量送到输出列表中. 
There is no shortcut form with an arrow (->) for array slices or hash slices, just as there is no shortcut for entire arrays or hashes.||对于数组片断或散列片断没有快捷写法, 就像对整个数组或散列也没有快捷写法一样. 
If you don't have many files in the /bin directory, perhaps because you don't have a Unix machine, change the argument to glob as needed.||如果你发现在/bin中没有文件, 可能是因为你用的不是UNIX系统, 所以可以按需改一下glob的参数. 
The ref function returns true for an instance, which is just a blessed reference, or false for a class, which is just a string. If it returns an undesired value, we use the croak function from the Carp module (which comes in the standard distribution). The croak function places the blame on the caller by making the error message look like it came from the spot where we called the method instead of the spot where we issued the error. The caller will get an error message like this, giving the line number in their code where the wrong method was called:||ref函数对于实例会返回true, 对于被"祝福"的引用也是一样, 如果是类就返回false, 就是个字串. 如果它返回一个我们不要的值, 我们可以用Carp模块（在标准发行版）中的croak函数. croak函数把出错信息看上去好像是调用者发出的一样, 而不是被调用的函数发出. 这样调用者会得到如下的出错信息, 并显示调用者的行号：
What if an instance needs more data? Most interesting instances are made of many items, each of which can, in turn, be a reference or another object. The easiest way to store these items is often in a hash. The keys of the hash serve as the names of parts of the object (also called instance or member variables), and the corresponding values are, well, the values.||如果一个实例需要更多的数据如何？大多数有用的实例是由许多成员组成, 而其中每个成员可以是一个引用或另一个对象. 保存这些成员最简单的办法就是把它们放在一个散列中. 这个散列的键是对象的名字（也被叫作实例或成员变量）, 而且相应的值就是, 值. 
The result will be the indices at which 1, 16, and 32 appear in the list: 0, 4, and 5. We could use these indices in an array slice to get the original values again:||其結果是, 索引位置：0, 4, 5上的值：1, 16, 32符合条件. 我们可以把这些索引放在数组片断里, 然后获得值：
Control structures such as while, if, for, and foreach||控制结构的语法如：while, if, for和foreach
Using a bit mask as the mode allows for more granular control. The IO::File module supplies the constants.||用打开模式掩码可以对文件进行更细致的控制. IO::File模块提供这些掩码的定义. 
For this example, this means we can pick out the array reference for Gilligan with a simple $all_with_names[2]->[1], and Gilligan's first provision with $all_with_names[2]->[1]->[0]. Wow, that's definitely easier on the eyes.||对于我们现在的例子来说, 如果我们要得到对Gilligan数组的引用的话, 我们可以简单写成：$all_with_names[2]->[1], 而指明Gilligan的第一个装备清单的写法是：$all_with_names[2]->[1]->[0]. 哇, 看上去真是好多了. 
which again is unique for this array because it includes the hexadecimal (base 16) representation of the array's unique memory address. The debugging string also notes that this is an array reference. Of course, if we ever see something like this in our output, it almost certainly means we have a bug; users of our program have little interest in hex dumps of storage addresses!||其内容同样是以十六进制表示的（base16）的这个数组惟一内存地址. 调试字串还标明了这个引用指向的是个数组. 当然, 如果我们什么时候看到这样的输出的话, 这多半意味着我们的程序出了bug;我们程序的用户可对十六进制的存储地址可一点兴趣都没有！
We don't always have to know the path ahead of time, either. In the previous examples, we've hardcoded the paths. If we don't know what those will be because we're passing code around to several machines, the FindBin module, which comes with Perl, can help. It finds the full path to the script directory so we can use it to build paths.||我们不一定总是能事先预知目录路径. 在前面的例子中, 我们对路径是硬编码的. 如果我们事先不知道路径是什么, 这有可能是我们在几个机器之前传送代码, Perl自带的FindBin模块可以帮助你. 它会找到脚本所在的目录的全路径, 这样我们可以依此来建立自己的路径. 
Now $average is either the quotient or undef, depending upon whether the operation completed successfully or not.||现在, 根据这个操作执行的成败, 变量$average要么是两数之商要么是个未定义值. 
That works fine and dandy. The subroutines defined in both libraries are available to this program.||这一工作很好很顺利. 子程序在两个库中定义, 使用起来就像在这个程序里一样. 
The arrow has to be between non-subscripty things. Why wouldn't it be between subscripty things? Well, imagine a reference to the array @all_with_names:||那为什么箭头必须在非下标符号间存在呢?好, 如果我们有一个指向数组@all_with_names的引用：
So as not to get dismayed about how "un-OO" the File::Spec module seems since it doesn't have objects, let's look at yet another core module, Math::BigInt, which can handle integers beyond Perl's native reach. [*]||不要因为File::Spec模块没有任何对象, 所以看上去比较像"非面对象的"的模块而失望. 让我们看一下另外一个核心模块, Math::BigInt, 它用来处理超出Perl内置精度的整数值. [*]
The package declaration at the beginning of this file tells Perl to virtually insert Navigation:: in front of most names within the file. Thus, the code above practically says:||在文件的开始的程序包声明, 显式地告诉Perl将Navigation::插入到文件中大多数名字的前面. 这样, 上面的代码实际上在说：
Here's another example: select the elements of @x that are larger than the corresponding value in @y. Again, we'll use the indices of @x as our $_ items:||这里是另一个例子：如果@x中的元素比@y中相应的元素大, 则取出来. 又一次, 我们会用$_来当作@x中的索引序号来用：
12. 15. 1. Exercise [45 min]||12. 15. 1 练习 ［４５分钟］
Rewrite this using the Schwartzian Transform technique.||用施瓦茨变换重写这个程序. 
It puts the directories we specify at the beginning of @INC, just like we did before.||它会把我们指示的目录放到@INC数组的最前面, 正象我们前面做的那样. 
We can copy and pass around references like any other scalar. At any given time, Perl knows the number of references to a particular data item. Perl can also create references to anonymous data structures (structures that do not have explicit names) and create references automatically as needed to fulfill certain kinds of operations. Let's look at copying references and how it affects scoping and memory usage.||我们可以像任何其它标量变量那样拷贝和传递引用. 在任何给定的时间, Perl会知道有多少引用指向一个特定的数据项. Perl也会为匿名数据结构（所谓没有名字的数据结构）创建引用, 以及在为了满足一定的操作自动的创建引用. 让我们来看一下引用的拷贝以及其对范围和内存使用方面的影响. 
In the same way we used indices to solve a few problems with grep and map back in Chapter 2, we can also use indices with sort to get some interesting results. For example, let's sort the list of names from earlier:||在之前的第二章, 我们用grep和map结合索引来解决了一些问题. 我们也可以用排序结合索引来得到一些有趣的结果. 比如说, 让我们对前面的名字列表排序：
However, the testing expression becomes a mapping expression. The map operator evaluates the expression in a list context (not a scalar context like grep). Each evaluation of the expression gives a portion of the many results. The overall result is the list concatenation of all individual results. In a scalar context, map returns the number of elements that are returned in a list context. But map should rarely, if ever, be used in anything but a list context. )||然而, grep中的测试表达式在map中变成了映射表达式. map操作符在列表环境中为表达式求值（而不是像grep那样在标量环境下求值）. 每次表达式求值都成为整个输出结果的一部分. 为各个元素求值结果连在一起成为完整全部的输出. 在标量环境下, map返回在输入列表里多少个元素被处理. 但是map应该总是用在列表环境下, 很少用在标量环境下. 
The variables %gilligan_info and %skipper_info are just temporaries we needed to create the hashes for the final data structure. We can construct the reference directly with the anonymous hash constructor, which is yet another meaning for curly braces, as we'll see. We can replace this:||散列变量%gilligan_info和%skipper_info是为了最终数据结构而建立的临时变量. 下面我们就构造一个对匿名散列的直接引用, 正像我们看到的, 花括号的另一项功能. 替代代码如下：
The Schwartzian Transform has since proven to be a very nice thing to have in our bag of sorting tricks.||施瓦茨变换已经被证明是我们的排序技巧的武器库中非常有效的利器. 
In that last example, had there been any additional parameters to the speak method (like how many times, or in what pitch for singing, for example), the parameters would be ignored by the Mouse::speak method. If we want them to be passed uninterpreted to the parent class, we can add it as a parameter:||在上一个例子中, 没有任何额外的参数给speak方法（如多少次, 或者唱什么调）, 参数将会被Mouse::speak方法忽略. 如果我们要把他们未经解释的传给父类, 我们可以把它作为参数加进去：
Now the BEGIN block compiles and executes at compile time, setting up the proper path for the following use.||这下BEGIN块会在编译时被执行, 在用use调用模块之前设置好适当的路径. 
Contrast the subroutines imported by File::Basename with what another core module has by looking at File::Spec. The File::Spec module is designed to support operations commonly performed on file specifications. (A file specification is usually a file or directory name, but it may be a name of a file that doesn't existin which case, it's not really a filename, is it?)||相比于File::Basename导出的子例程, 在核心模块中有另外一个File::Spec模块也提供类似的功能. File::Spec被设计来支持对文件属性的一般操作. （一个文件属性指文件或目录的名字, 但它可能并不是实际存在的名子, 是这样吗？）
11. 11. Exercises||11. 11. 练习
Or, maybe we just let the variable go out of scope:||或者, 我们可以仅仅让变量跑出范围就可以了：
How can we avoid that? Can we say somehow that a Mouse does everything any other Animal does, but add in the extra comment? Sure!||我们能避免吗？ 我们可以做到一只老鼠能做其它动物能做的, 然后有其自己的特殊的情况吗？当然可以！
Many lines of ordinary code have the potential to terminate a program prematurely if something goes wrong.||有一些代码看上去很平常, 但是却含有潜在的危险, 一旦某种条件不对就会使程序中断, 过早地结束程序. 
Unless you are creating new IO modules, you probably shouldn't use IO::Handle directly. Instead, use some of the handy modules built on top of it. We haven't told you about object-oriented programming (OOP) yet (it's in Chapter 11, so we almost have), but in this case, you just have to follow the example in its documentation.||除非你正在创建新的IO模块, 一般来说你不会直接调用IO::Handle模块. 相反的, 我们可以用一些建立在IO::Handle模块之上更加好用的模块. 我们还没有告诉你有关面向对象编程的知识（在第11章, 所以我们一定会说的）, 但目前情况下, 你只要跟着本书的例子就可以了. 
The Professor has written a subroutine called ask_monkey_about( ), which, given a castaway's name, returns the number of pineapples of storage they use. We have to ask the monkey because he's in charge of the pineapples. An initial naive approach to find the offenders from greatest to least might be something like:||教授写了一个子程序ask_monkey_about(), 这个程序接受一个castaway成员的名字, 然后返回他们用了菠萝总储量中的多少. 我们问猴子是因为他管这事儿. 最初的找出罪犯的程序可以如下的样子：
The spaceship operator returns -1, 0, and +1, according to the rules we laid out. A descending sort is simple in Perl:||飞船操作符按我们前面的算法返回-1, 0或+1. 如果是降序, 在Perl中也很简单 ：［＋］
[*] use lib also unshifts an architecture-dependent library below the requested library, making it more valuable than the explicit counterpart presented earlier.||[*]之所以有效是因为它在编译期间执行而不是在运行时执行. 接下来正是时候立即用use了. 
Thus, SUPER::speak means to look in the current package's @ISA for speak, invoking the first one found if there's more than one. In this case, we look in the one and only base class, Animal, find Animal::speak, and pass it Mouse as its only parameter.||所以, SUPER::speak 表示在当前包的@ISA查找speak, 如果找到多个, 则调用第一个被找到的. 在这个例子中, 我们找到仅有的一个基础类： Aniaml, 找到方法：Animal::speak, 并将其作为参数传给Mouse类. 
[*] To be more accurate, the closure declaration increases the reference count of the referent, as if another reference had been taken explicitly. Just before the end of the naked block, the reference count of $count is two, but after the block has exited, the value still has a reference count of one. Although no other code may access $count, it will still be kept in memory as long as the reference to the sub is available in $callback or elsewhere.||[*] 更准确地说, 闭包的声明增加了引用变量的引用计数, 就像显式地取得了另外一个引用一样. 就在裸块结束之前, 对$count的引用计数为２, 但从块退出之后, 其值的引用仍有一个. 尽管已经没有其它的代码可以访问$count变量了, 但只要$callback中对这个匿名子程序的引用存在（或其它地方有对$count变量的引用）, 其值就一直会被保留. 
The Perl code is fairly understandable; it shows that we have a reference to a hash of three elements, with each value of the hash being a reference to a nested hash. We can evaluate this code and get a hash that's equivalent to the original hash. However, if you're thinking about doing this in order to have a complex data structure persist from one program invocation to the next, please keep reading.||这段Perl代码很容易理解; 它显示我们有一个指向三个元素的散列的引用, 其中每个元素的值则是指向其它散列的引用的嵌套散列. 我们可以求出这代码得出的散列同原来的散列值是等同的. 但是, 如果你考虑通过这个将复杂数据结构保存下来, 并可以由其它的程序调用的话, 别急, 我们往下看就是了. 
10. 10. 1. Exercise 1 [25 min]||10. 10. 1. 练习1 [25分钟]
Everywhere we write ${DUMMY}[$y], we can write DUMMY->[$y] instead. In other words, we can dereference an array reference, picking out a particular element of that array by simply following the expression defining the array reference with an arrow and a square-bracketed subscript.||在任何写成${DUMMY}[$y]样子的地方, 我们都可以用DUMMY->[$y]这种形式代替. 换句话说, 我们可以这样还原一个数组引用： 用定义一个带箭头的数组引用和一个方括号指定下标的形式表达数组里一个特定的元素. 
Why? Because the Animal::speak method expects a class name as its first parameter, not an instance. When we pass in the instance, we'll use a blessed scalar reference as a string, which shows up as we showed it just now similar to a stringified reference, but with the class name in front.||为什么呢?因为Animal::speak方法期一个类名作为它的第一个参数, 而不是一个实例. 当我们传一个实例时, 我们会把"祝福"过的标量引用当作一个字串, 就像我们直接打印一个引用一样, 不过是前面有个类名提示. 
We get a debugging value:||我们会得到一个测试值：
Hmm. That's a bit complex. Let's let them walk into the room one at a time:||呣. 这里有些复杂. 让我们使他们一个个进来. 
Trivia note: 21. 283 degrees north, 157. 842 degrees west is the location of the real-life marina where the opening shot of a famous television series was filmed. Check it out on Google Maps if you don't believe us.||[+] 小注：21. 283度以北, 157. 842度以西是现实生活中一个地点, 上过一个著名的电视节目. 如果你不信, 可以查查Google Maps. 
We can also used a name subroutine that sort invokes for each comparison.||我们同样也可以用命名子程序来每个比较. 
[*] Actually, we can use any negative or positive number in place of -1 and +1, respectively. Recent Perl versions include a default sorting engine that is stable, so zero returns from the sort block cause the relative ordering of $a and $b to reflect their order in the original list. Older versions of Perl didn't guarantee such stability, and a future version might not use a stable sort, so don't rely on it.||［＊］实际上, 我们可以用任一个负值或正值来代替-1和+1. 新近的Perl版本的缺省排序引引擎很稳定, 所以, 如果返回0, 则会使用$a和$b在原来列表里的相对次序. 旧版本的Perl不能保证如此的稳定, 而未来的版本可能不用这种稳定的排序, 所以不能依赖于此. 
9. 4. The Schwartzian Transform||9. 4. 施瓦茨变换
For example, you won't see an explanation in this book that shows how to access the elements of an array or return a value from a subroutine.||比如, 这本书里我们不会再解释如何访问一个数组里一个元素或者从一个子程序里返回一个值. 
However, since this module has an object-oriented interface, [] it doesn't import any subroutines. Instead, the interface tells us to access the functionality of the module using its class methods. The catfile method joins a list of strings with the appropriate directory separator:||然而, 因为这个模块有面向对象的接口[+], 它并不导入任何子例程. 取而代之的是, 接口要我们通过访问类的方法来使用其功能. 如 catfile方法用来把一个字串列表用适当的目录分隔符连接起来：
Chapter 12. Objects with Data||Chapter 12. 带数据的对象
Now, we should get all destinations. The syntax for this is a bit tricky. We want all keys of the hash, resulting from dereferencing the value of the hash element, in the first structure:||好, 现在我们取所有的目标主机. 这里的语法有些"搞". 我们用散列元素还原出来的值作为键来取目标主机, 比如：
If Animal also had an @ISA, Perl would check there too. [] Typically, each @ISA has only one element (multiple elements means multiple inheritance and multiple headaches), so we get a nice tree of inheritance.||如果Animal同样也有一个@ISA数组, Perl也会再去查找. [+] 一般来说, 每个@ISA只有一个元素（多个元素意味着多重继承及多重"头痛"）, 这样我们就可以得到一个清楚的继承树. [+]
We can add and remove references as we wish, and as long as the reference count doesn't hit zero, Perl maintains the array in memory and it is still accessible via any of the other access paths. For example, we might have a temporary reference:||我们可以任意添加和删除引用, 并且, 只要引用计算不减到0, Perl就会在内存中保留这个数组, 并且能通过任何其它的途径来访问这个数组. 比如, 我们可能有一个临时引用：
Because we're going to play nice and always call the getters and setters instead of reaching into the data structure, getters and setters are called frequently. To save a teeny-tiny bit of time, we might see these getters and setters written as:||因为我们打算总以比较良好的方式调用取值器和设置器, 而不直接改变数据结构, 设置器和取值器会被调用得很频繁. 为了节约调用时间, 我们可以看到他们被写成这样：
Besides opening named files, we might want to open an anonymous temporary file. On systems that support this sort of thing, we simply create the new object to get a read-write filehandle.||除了打开命名文件, 我们可能要打开匿名的临时文件. 对于支持这种文件的系统, 我们只要简单地以读写文件名柄建立一个新对象就可以了. 
To make it really useful, what other features should be added to that program? You don't need to implement them!||要让这个程序真正有用, 还要采取其它什么功能？你只要说出来就可以了, 不必真正实现他们！
Now let's walk through this. We've declared @skipper_with_name, the first element of which is the Skipper's name string, and the second element is an array reference, obtained by placing the five provisions into an array and taking a reference to it. So @skipper_with_name is only two elements long, just as before.||来, 我们回顾一下. 我们已经声明了@skipper_with_name, 它的第一个元素是Skipper的名字字串, 第二个元素是一个对数组的引用, 它是由把五个元素放到一个数组, 并且取其引用得到的. 所以, @skipper_with_name数组仅有两个元素长. 
File manipulation such as open, file reading, and -X (file tests)||文件操作的语法：打开、文件操作和-X （文件检测操作）
Chapter 10. Building Larger Programs||第十章 构建更大的程序
Let's look at the code used in Chapter 11 for the Animal classes and Horse classes:||让我们看一下我们在第11章用于表示动物类和马类的代码：
First, we declare the variables for the resulting hash of provisions and the current person. For each line that we read, we determine if it's a person or a provision. If it's a person, we remember the name and create the hash element for that person. The unless exists test ensures that we won't delete someone's provision list if his list is split in two places in the datafile.||首先, 我们定义一个变量来保存结果散列中的乘客及他们的清单. 对于读出的每一行, 我们先判断它是乘客还是装备. 如果是乘客, 我们记下姓名并为那个乘客创建散列元素. unless exists测试来保证在一个乘客的装备在文件中分两块地方放的时候, 我们不会把他的装备清单删掉. 
How do we call the existing check_required_items( ) with this data structure? The following code is easy enough.||那我们如何用这个数据结构来调用现存的check_required_items( )? 下面的代码足够简单：
Suppose we want to modify the original array to force the provisions list to include the mandatory items. Because we have a copy in the subroutine ("pass by value"), any changes we make to @_ aren't reflected automatically in the corresponding provisions array. [*]||假定我们要修改原始数组来强制供应单里加上些硬性规定的物品. 因为我们是拷贝到子例程的（传值）, 任何对数组的改变都不会自动反映到相应的供应单中. [*]
Here's the output from this program:||下面是程序的输出结果：
Because the map and sort operators are right to left, we have to read this construct from the bottom up. Take a list of @castaways, create some arrayrefs by asking the monkey a simple question, sort the list of arrayrefs, and then extract the names from each arrayref. This gives us the list of names in the desired order.||因为map和sort操作是从右到左分析的, 我们读这些结构时应该由下而上的读. 所以顺序是这样的：先取数组 @castaways, 问下小猴一些问题后, 创建一个数组引用, 将数组引用列表排序, 并抽出数组引用中的名字. 这样我们就将名字列表以希望的顺序排序. 
The newly constructed subroutine should call check_required_items for each person in the hash, updating their provisions list to include the required items.||我们新建的那个子程序要调用check_required_items来为散列中每个人更新其必需的装备清单. 
3. 10. Exercises||3. 10. 练习
However, another Perl core module is much better suited for marshaling: Storable. It's better suited because compared to Data::Dumper, Storable produces smaller and faster-to-process files. (The Storable module is standard in recent versions of Perl, but you can always install it from the CPAN if it's missing. )||但是, Perl有另外一个模块更能胜任调制数据的工作：Storable. 之所以更能胜任, 是因为相较于Data::Dumper, Storable产生的文件更小, 能被更快地执行. (Storable模块在最近版本的Perl的标准发布中就有, 但是, 如果你这里没有的话, 可以从CPAN上下载安装. )
If we place this code at the beginning of the program, we declare the variable $count inside the naked block scope, and the two subroutines that reference the variable become closures. However, because they have a name, they will persist beyond the end of the scope (as do all named subroutines). Since the subroutines persist beyond the scope and access variables declared within that scope, they become closures and thus can continue to access $count throughout the lifetime of the program.||如果我们把这短代码放到程序开始, 我们在一个裸块里声明了了变量$count, 然后两个子程序引用这个变量, 于是就成了闭包. 然而, 因为它们都有名字, 并且会保留名字直到块结束（就像所有的命名子程序一样. ） 因为子程序访问声明在范围外的变量, 它们成为闭包并且因此可以在程序的生命周期内继续访问$count. 
named still builds a scalar sheep, so let's fix that as well:||named方法创建标量的sheep对象, 所以让我们来修改一下：
12. 12. Faster Getters and Setters||12. 12. 更快的取值器和设置器
If we reuse the callback, the same variable still has its most recently used value. The initialization occurred in the original subroutine (create_find_callback_that_counts), not the callback (unnamed) subroutine:||如果我们重用回调, 相同的变量仍会保留它最近的值. 初始值是在最初调用子程序的时候创建的（create_find_callback_that_counts）, 并不是回调的匿名子程序中：
2. 1. List Operators||2. 1. 列表操作符
Parse the International Standard Book Number from the back of this book (0596102062). Install the Business::ISBN module from CPAN and use it to extract the country code and the publisher code from the number.||分析一下这本书的国际标准书号（0596102062）. 从CPAN里安装一下Business::ISBN模块, 并且用它来从ISBN数字中抽取国家代码和发行商代码. 
7. 8. 1. Exercise [50 min]||7. 8. 1. 练习 [50分钟]
Obviously, the castaways can't survive on coconuts and pineapples alone. Luckily for them, a barge carrying random farm animals crashed on the island not long after they arrived, and the castaways began farming and raising animals.||显然, castaways船员不可能仅仅靠椰子和菠萝活下来. 幸运的是, 一船满载农场牲畜的驳船在他们来此不久也在小岛搁浅了. 于是船员们开始牧养这些牲畜. 
For example, suppose a subroutine within navigation. pm declares a lexical @homeport variable. Any mention of @homeport will then be the newly introduced lexical variable, but a fully qualified mention of @Navigation::homeport accesses the package variable instead.||举例来说, 假定navigationpm中的一个子例程声明了一个词法变量@homeport. 那么, 任何使用@homeport时, 都是指新引入的词法变量, 但是如果用全名来引用@havigation::homeport将访问的是包变量. 
11. 8. The SUPER Way of Doing Things||11. 8. 用SUPER方法来处理问题
Now the subroutine is defined in the main package, not the Navigation package. This isn't an optimal solution (we'll show better solutions in Chapter 15 when we talk about Exporter), but at least there's nothing sacred or terribly unique about main compared to any other package.||现在, 子程序被定义在main程序包中, 不在navigation包中. 这不是一个好的解决方法（我们会在第15章, 讨论Exporter的时候来说更好的做法）, 但是, 至少目前也没有其它利害的独特方案可以匹分main与其它包. 
Make sure you know the following things:||下面这些知识你应该事先掌握：
10. 2. Inserting Code with eval||10. 2. 用eval插入代码
but gets pretty messy when we want to sort numbers:||可是, 当我们对数字进行排序的时候却是一团糟：
We can use object-oriented interfaces for directory handles too. The IO::Dir module has been part of the standard Perl distribution since 5. 6. It doesn't add interesting new features but wraps the Perl built-in functions.||我们也是用面向对象的接口来处理目录句柄. 从Perl 5. 6开始, IO::Dir模块就是标准发行版的一部份了. 它并没有添加什么新的功能, 无非包装了Perl的内建函数而已. [+]
3. 5. Object-Oriented Interfaces||3. 5. 面向对象的接口
7. 7. Closure Variables as Static Local Variables||7. 7. 闭包变量用作静态局部变量
So far, the examples have glossed over how we've set up the directory structure of where the main code and the included files are located. That's because it "just works" for the simplest case where we have a program and its libraries in the same directory and we run the program from that directory.||到目前为止, 这些例子都忽略了我们如何建立目录结构来安排主要代码和要导入的代码文件应该安放的位置. 那是因为"能工作就行", 用最简单的情形, 我们把程序和它的库放在同一目录, 并就在这个目录里运行程序. 
9. 5. Multi-Level Sort with the Schwartzian Transform||9. 5. 用施瓦茨变换作多层排序
What happens if we want to pass around these filehandles so we could share them with other parts of our code, such as libraries? You've probably seen some tricky looking code that uses a typeglob or a reference to a typeglob.||如果我们要同程序的其它部份, 比如库, 共享这些文件句柄该如何做呢？ 我们大概见过一些讨巧的办法, 用typeglob或一个对typeglob的引用来处理. 
The interface is similar to using Data::Dumper, except we must put everything into one reference. For example, let's store the mutually referencing data structures:||与Storable的接口同使用Data::Dumper十分相似, 除了我们必须把所有东西要放到一个引用中去. 比如, 让我们把存一个互相引用的数据结构：
Like the spaceship operator, we can indicate a string sort with cmp, although this is rarely used alone because it is the default comparison. The cmp operator is most often used in more complex comparisons, as we'll show shortly.||类似于飞船操作符, 我们可以为字串排序用cmp, 尽管其很少单独使用, 因为它是排序方法. 我们以后马上就会讲到, cmp操作符在复杂比较中非常常用. 
This code skeleton has a three-level sort comparison, using three computed values saved in the anonymous array (alongside the original data item to be sorted, which always comes first).||这个代码结构是三层的排序条件, 把三个计算过的值放到一个匿名数组里（还有把原始值放在排过序的列表中第一个位置. ）
The void context trick can be used here too, although with questionable value because we've already established $self.||避免无返回值的方法这里也可以使用, 尽管我们已经建立了$self变量. 
A success/fail code||成功／失败码
Now the Professor feels obligated to respond:||这下轮到教授要作出反映了：
which necessarily results in:||我们所需的输出是：
7. 1. Referencing a Named Subroutine||7. 1. 对命名子程序的引用
How annoying! The Skipper decides to fix this problem by checking for a zero turn value:||真烦人！Skipper决定修正这个0航向的问题：
Now, because name and named were the only methods that referenced the structure of the object, the remaining methods can stay the same, so speak still works as before. This supports another basic rule of OOP: if only the object accesses its internal data, there's less code to change when it's time to modify that structure.||现在, 因为name和named是引用这个对象仅有的方法, 所以其它方法可以不变, 这样speak仍然可以像以前那样使用. 这就支持了面向对象编程的一条基本法则：如果要访问对象内部数据, 那修改结构的时候应该用最少的代码修改. 
This invokes the speak method of the parent class, including all the parameters that we've not yet shifted off of our parameter list.||这句调用父因的方法, 包括所有我们还没有传入的参数列表. 
To load a module, we use the Perl built-in use. We're not going to go into all of the details here, but we'll get to those in Chapters 10 and 15. At the moment, we just want to use the module. Let's start with File::Basename, that same module from the core distribution. To load it into our script, we say:||为了调用一个模块, 我们可以用Perl内置的use语句. 这里我们不打算更深入的了解细节问题, 我们会在第10章和第15章来说这个问题. 目前, 我们只要能调用模块就可以了. 我们就发行版的核心模块中的File::Basename模块开始说吧. 要把它调入我们的脚本, 我们用：
(If it can't find the method, inheritance kicks in, but we'll show that later. ) This means that we get the class name as the first parameter, or the only parameter, if no arguments are given. We can rewrite the Sheep speaking method as:||（如果它找不到方法, 那么继承者会介入, 我们会在以后的章节中展示. ）这意味着我们以类名作为第一个参数, 或者说在没有参数的情况下是仅有的一个参数. 我们可以将其重写为：
Now $tv_horse is a reference to what will be the instance-specific data (the name). The final step in turning this into a real instance involves a special operator called bless:||现在$tv_horse是对一个实例数据（马的名字）的引用. 最后一步就是把它变成一个真实的实例, 这要么一个专门的操作符叫bless:
The only difference here is that we removed the braces around @$items.||与前例惟一的区别就是去掉了大括号：@$items. 
Each exercise has a "minutes to complete" rating. We intend for this rating to hit the midpoint of the bell curve, but don't feel bad if you take significantly longer or shorter. Sometimes it's just a matter of how many times you've faced similar programming tasks in your studies or jobs. Use the numbers merely as a guideline.||每个练习都有限时. 我们打算取一个平均的解题速度, 但是, 如果你用了更长的时间, 也不必但心. 有时候这不过取决于在工作或学习中面对同样问题的次数. 只要把限时当作指导性的就可以了. 
Hint: you can find a file's timestamp (mtime) with code such as:||暗示：你可以用如下代码找到一个文件的时间戳：
8. 6. 3. Exercise 3 [15 min]||8. 6. 3. 练习 3 [15 分钟]
5. 1. More Than One Reference to Data||5. 1. 更多有关对数据进行引用的故事
If we return the previous parameter, we can easily create "set this value temporarily to that" functions:||如果我们返回更改前的值, 我们可以容易地写临时处理程序：
A Perl scalar variable holds a single value. An array holds an ordered list of one or more scalars. A hash holds a collection of scalars as values, keyed by other scalars. Although a scalar can be an arbitrary string, which allows complex data to be encoded into an array or hash, none of the three data types are well suited to complex data interrelationships. This is a job for the reference. Let's look at the importance of references by starting with an example.||一个Perl标量变量保存一个单个值. 一个数组保存一个或多个标量的次序列表. 一个散列保存一个标量作为键值, 另一个标量作为值. 尽管一个标量可以是任意字串, 可以被复杂数据结构用来编入一个数组或一个散列, 但是三种数据类型中没有一个适合用来做复杂数据关系. 这就是引用的工作. 我们由一个例子来探查一下引用的重要性. 
For more efficiency, we can avoid stashing the previous value when in a void context using the wantarray function:||为了效率, 我们可以用wantarray函数在没有返回值的情况下不存以前的值：
The data stays alive until we destroy the last reference:||数据一直会存在, 直到我们销毀最后一个引用：
If the scalar already has a value, this doesn't work because Perl won't stomp on our data.||如果标量已经有值的话, Perl会报错, 因为Perl不会冲掉你的数据：
Now we get back the list of 1, 16, and 32. These numbers have a digit sum with a remainder of "1" in the last line of the subroutine, which counts as true.||对于这个例子, 我们得到的输出是1, 16和32. 程序把这些数据的数位加起来后, 因为最后一行返回的余数都是"1", 所以返回值为"真". 
We can do so by establishing an instance. An instance is generally created by a class, much like a car is created by a car factory. An instance will have associated properties, called instance variables (or member variables, if you come from a C++ or Java background). An instance has a unique identity (like the serial number of a registered horse), shared properties (the color and talents of the horse), and common behavior (e. g., pulling the reins back tells the horse to stop).||我们可以建立一个实例来实现这个功能. 一个实例一般来说根据一个类创建, 就是汽车由汽车工厂生产一样. 一个实例有其关联的属性, 称为实例的变量（或者叫成员变量, 如果你有C++或Java背景的话）. 每个实例有个惟一标识（有些像注册过的赛马的序列号一样）, 共享属性（赛马的毛色与出色的体力）, 和一般的行为（比如拉缰绳告诉马要停下）. 
That's not fun yet. We've got the same number of characters, all constant, no variables. However, the parts are separable now:||不好玩是不是？ 我们得到了相同的输出结果, 都是常量, 没有变量. 然而, 现在被拆开了：
What if we want to send output to more than one place at a time? What if we want to send it to a file and save it in a string at the same time? Using what we know already, we had have to do something like this:||如果我们要一次将结果发送到多个不同的地方, 应该如何做？ 如果我们要把内容发送到一个文件的同时存入一个字串中呢？ 用我们目前所知, 我们大概不得不做如下这些：
Now for the fun part: Perl takes the class in which the instance was blessed, in this case, Horse, and uses it to locate and invoke the method, as if we had said Horse->sound instead of $tv_horse->sound. The purpose of the original blessing is to associate a class with that reference to allow Perl to find the proper method.||现在有趣的地方来了：Perl被祝福的实例中的类, 在这个例子中是Horse, 并用它来定位并调用方法, 就好像我们用的是Horse->sound而不是$tv_horse->sound一样. 最初所谓的"祝福"的目的就是把一个类和它的引用关联起来, 让Perl能找到适当的方法. 
Any syntax error in the required file causes the program to die; thus, the many die $@ if $@ statements are unnecessary.||任何语法错误会导致程序终止; 所以许多 die $@ if $@语句在这里是不需要的. 
But there is more than one way to do it. The spaceship operator is nearsighted; and can't see which one of its parameters comes from $a and which from $b; it sees only which value is to its left and which is to its right. If we reverse the position of $a and $b, the spaceship will sort everything in the opposite order:||但是, 所谓殊途同归. 飞船是近视的; 它不能看到参数中哪个来自$a, 哪个来自$b;它只看哪个值在它的左边, 哪个在右边. 如果$a和$b换了位置, 则飞船操作符则会将其反序排列：
10. 9. Packages and Lexicals||10. 9. 包和词法变量
6. 2. Viewing Complex Data with Data::Dumper||6. 2. 用Data::Dumper模块查看复杂数据
11. 3. The Extra Parameter of Method Invocation||11. 3. 方法调用的额外参数
The first line of this subroutine might have read instead:||子程序的第一行可以用如下行代替：
Of course, we could shorten that a bit so we only have one print statement. We use the foreach control structure to iterate through the filehandle references, store each in $fh in turn, and print to each one.||当然, 我们可以缩短一些, 这样我们可以只用一个打印语句. 我们用foreach控制结构来迭代地使用句柄引用, 用$fn一次换一个, 打印到每个句柄. 
You can find the answer to this exercise in "Answer for Chapter 12" in the Appendix.||答案索引找
Now let's define a common method package called Animal with the definition for speak:||现在, 让我们定义一个共享的方法的包, 叫Animal, 其speak定义如下：
However, the Perl idiom is to do everything in one step. We can declare the variable right in the open statement. It looks funny at first, but after doing it a couple (okay, maybe several) times, you'll get used to it and like it better.||当然, Perl的信条是尽量一步到位. 我们可以在open语句中声明变量. 一开始你可能觉得好笑, 但用了两次（好吧, 多次）之后, 你会习惯并喜欢使用这种方法. 
[*] You can create readable filehandles to external commands with IO::Pipe.||[*] 你可以用IO::Pipe建立一个可读的句柄给外部命令. 
So, is there an even better way?||那么, 还有更好的方法吗？
As of Perl version 5. 8, we can do this directly in Perl without using IO::Scalar.||在Perl 5. 8中, 我们可以直接在Perl中写这样的语句, 而不必引入IO::Scalar:
This requires no changes to the subroutine. The control variable $person will be each of $all_with_names[0], $all_with_names[1], and $all_with_names[2], as the loop progresses. When we dereference $$person[0], we get "Skipper, " "Professor, " and "Gilligan, " respectively. $$person[1] is the corresponding array reference of provisions for that person.||这样对于以前写的子例程不需要做任何改变. 随着循环进程, 控制变量$person将会是$all_with_names[0], $all_with_names[1]和$all_with_names[2]. 当我们还原$$person[0], 我们会得到"Skipper, ""Professor, "和"Gilligan, "相应的, $$persion[1]是各个乘客所对应的装备清单数组. 
Nothing spectacular here: simple subroutines, albeit from separate packages, and called using the full package name. Let's create an entire pasture:||这里没有什么特别的：简单的子程序, 虽然来自不同的包, 但用完整的包名. 让我们来建立整个牧场：
This is a typical data-reduction report generation strategy. [*] Simply create a hash-of-hashrefs (perhaps nested even deeper, as you'll see later), using autovivification to fill in the gaps in the upper data structures as needed, and then walk through the resulting data structure to display the results.||这是一个典型的"消防水带"式的报表生成策略. ［＊］简单地建立一个散列引用的散列（还可以嵌套更深, 后面你就可以看到）, 运用自生成功能, 根据需要填充数据结构, 然后遍历结果数据, 打印输出结果. 
In this case, Perl finds Horse::sound directly (without using inheritance), yielding the final subroutine invocation:||在此例中, Perl直接找到Horse::sound(没有用到继承), 也就是最终的子程序调用：
Let's make a sheep that has a name and a color:||让我们做一个有名有色的绵羊：
To invoke sound, Perl first notes that $tv_horse is a blessed reference, and thus an instance. Perl then constructs an argument list, similar to the way an argument list was constructed when we used the method arrow with a class name. In this case, it'll be just ($tv_horse). (Later we'll show that arguments will take their place following the instance variable, just as with classes. )||为了调用sound方法, Perl首先注意到$tvHorse是一个"被祝福"的引用, 所以是一个对象实例. 于是Perl创建一个参数列表, 有些像当我们用类名加方法箭头那种形式. 在这个例子中, 它就是($tv_horse). （之后我们会展示参数将跟在实例变量后面, 就像跟着类一样. ）
If all of that makes you nervous and wish that none of this stuff existed, that's good. Don't do this anymore! We put it in a section called "The Old Way" because there is a much better way to do it now. Pretend this section never existed and move on to the next one.||如果这一切作法让你大为紧张, 希望没有这种事该多好, 可以. 我们不用作这种事情！就是因为现在有更好的方法, 所以我们把这节叫作"旧的方法". 我们假装没有这节吧, 直接跳到下一节吧. 
Was there anything specific to Horse in that method? No. Therefore, it's also the same recipe for building anything else inherited from Animal, so let's put it there:||对于那个方法中Horse类有其它特殊的吗？ 没有. 因此, 它同样可以继承自Animal类, 所以我们可以把它放到这儿：
In general, where we've seen the bareword filehandle we can substitute the scalar variable filehandle reference.||一般情况下, 所有用裸这字代表文件句柄的地方, 我们都可以用含有文件句柄引用的标量变量代替. 
What happens when these two array names go out of scope? Well, the reference count for the two arrays goes down from two to one, but not zero. And because it's not zero, Perl thinks there might still be a way to get to the data, even though there isn't! Thus, we've created a memory leak. A memory leak in a program causes the program to consume more and more memory over time. Ugh.||那这两个数组跑出范围会发生什么事？ 噢, 这两个数组的引用计数会从2降为1, 但不是0. 正因为没有归到零, Perl会认为仍有引用会指向这些数据, 尽管已经没有了. 所以, 我们已经创建了一个内存泄漏. 一个程序有内存泄漏会导致消耗越来越多的内存, 噢！
Note we use trailing commas on the lists when the element is not immediately next to the closing brace, bracket, or parenthesis. This is a nice style element to adopt because it allows for easy maintenance. We can add or rearrange lines quickly, or comment out lines without destroying the integrity of our list.||注意列表结束时的元素并非马上连着关闭的花括号, 方括号或小括号, 而是以逗号结尾. 这是很好的编程风格, 因为这样做有利于代码维护. 我们可以很方便的添加或重排行, 或者不破坏列表完整性的情况下注释掉代码. 
The result is just 16, 32, and 64. This uses an explicit reference to $_. Here's an example of an implicit reference to $_ from the pattern match operator:||输出结果当然是：16, 32 和64. 上例中显式地引用了变量$_. 下面有个隐式引用变量$_的例子, 在正则表达式中隐式引用了变量$_:
We don't have to create a new directory handle if we decide we want to go through the list again (perhaps later in the program). We can rewind the directory handle to start over:||如果我们要重新查看文件列表的时候（可能在程序的后面）, 我们不必重建句柄. 我们可以用rewind来重用目录句柄：
The list of names following use doesn't change which subroutines are defined in the module's package (in this case, File::Basename). We can always use the full name regardless of the import list, as in:[*]||use 关键字后面的名字列表并不会使模块里(在这个例子中是File::Basename)的子例程的定义有任何改变. 我们可以忽略导入清单, 直接用全名, 像下面一样：
11. 9. What to Do with @_||11. 9. @_的作用
Chapter 12 shows how to distinguish the individual animals by giving them associated properties, called instance variables.||第12章展示如何给出相关的属性来区分不同的动物, 所谓实例变量. 
Here, Mouse has its own speaking routine, so Mouse->speak doesn't immediately invoke Animal->speak. This is known as overriding. We use overriding to shadow the method in the derived class (Mouse) because we have a specialized version of the routine, instead of calling the more general base class's method (in Animal). In fact, we didn't even need to initialize @Mouse::ISA to say that a Mouse was an Animal, because all the methods needed for speak are defined completely with Mouse.||这里, 老鼠有自己的发声程序, 所以Mouse->speak不会立即调用Animal->speak. 这被称为重载. 我们用重载来在继承类（Mouse）中重写方法, 因为我们有个特别版本的子程序来代替原来基础类里更一般化的类方法（在Animal类中）. 实际上, 我们甚至根本不需要初始化@Mouse::ISA来声明Mouse是动物, 因为所有有关发声的方法都已经在Mouse中定义了. 
1. 1. What Should You Know Already?||1. 1. 你应该已经知晓哪些概念？
Because we created both subroutine references from the same scope, they both have access to the same $total_size variable. Even though the variable has gone out of scope before we call either subroutine, they still share the same heritage and can use the variable to communicate the result of the calculation.||因为创建的两个匿名子程序在同一个范围内, 所以他们都访问相同的$total_size变量. 尽管在我们调用任一个匿名子程序之前, 这个变量已经跑出范围, 但他们仍能共享这个变量并且可以用这个变量交换计算结果. 
The bless operator follows the reference to find what variable it points to in this case, the scalar $name. Then it "blesses" that variable, turning $tv_horse into an object a Horse object, in fact. (Imagine that a little sticky-note that says Horse is now attached to $name. )||bless操作符根据引用找到其指的变量, 在这个例子中, 是标量$name. 那么它就"祝福"那个变量, 将$tv_horse转变成一个Horse对象. (想象一个小的标签说那匹马现在与$name关联在一起了. )
Now, in $Bin is the path to the directory that holds our script. If we have our libraries in the same directory, our next line can be:||现在, 变量$Bin中的路径是我们的脚本所在的路径. 如果我们把库放在同一路径, 我们下一行可以是：
4. 4. Getting Our Braces Off||4. 4. 把大括号去掉
This time, $a and $b aren't the elements of the list, but the indices. So instead of comparing $a to $b, we use cmp to compare $input[$a] to $input[$b] as strings. The result of the sort are the indices, in an order defined by the corresponding elements of @input. This prints 0 3 4 2 1, which means that the first element of the sorted list is element 0 of the original list, Gilligan. The second element of the sorted list is element 3 of the original list, which is Ginger, and so on. Now we can rank information rather than just move the names around.||这次, $a和$b并非列表中的元素, 而是索引. 所以, 不是对$a和$b比较, 我们用cmp对$input[$a]和input[$b]所含的字串进行比较. 而排序的结果则是索引, 这索引是按数组@input中的相应的次序进行排列的. 输出是0 3 4 2 1, 这意思是：排序后的首位元素是原来列表的首位元素, Gilligan. 排序后的第二位元素是原始列表的第4个元素, 即Ginger, 以此类推. 现在我们可以不仅仅是把名字移来移去, 而可以做个分级排名的东西了. 
Invoking Animal::speak directly is a mess, however. What if Animal::speak didn't exist before, and it inherited from a class mentioned in @Animal::ISA? For example, suppose the code was:||然而, 调用直接调用Animal::speak是一个错误. 如果Animal::speak事先不存在呢？ 它会从@Animal::ISA继承？如：
If you're on a recent-enough Perl (5. 6 or later), you can use the our declaration to shorten it to:||如果你用的是比较新版本的Perl, 你可以用如下的简短形式：
Until the value of $ref changes, or $ref itself disappears, we can still use all the dereferencing strategies we used prior to when the name of the array disappeared. In fact, it's still a fully functional array that we can shrink or grow just as we do any other Perl array:||直到$ref的值改变, 或者$ref自己消失, 我们依旧可以使用任何我们在前面学到的还原方法, 尽管数组的名字已经不存在了. 实际上, 它仍然是一个不折不扣的数组, 我们可以像对待其它任何Perl数组那样把它拉长和缩小：
We can also use the lib pragma to add to the module search path, although this is not as friendly, since we have to change the code, but also because it might not be the same directory on other machines where we want to run the code.||我们也可以用lib编译提示符来加模块搜寻路径, 尽管这并不友好－－因为这不仅要修改代码, 而且在其它的机器上不一定要相同的目录. 
Autovivification also works for hash references. If we dereference a variable containing undef as if it were a hash reference, a reference to an empty anonymous hash is inserted, and the operation continues.||在散列引用中, 自生成功能也起作用. 如果我们还原一个含有undef的变量, 就好像它是一个散列引用一样, 那么一个指向空的匿名散列的引用就会被插入, 让操作继续下去. 
Gilligan's program will fail in a catastrophic way as soon as he tries to head to port: he'll start steering the ship in circles! The problem is that the Perl compiler first compiles turn_toward_port from Gilligan's main program, then when Perl evaluates the require at runtime, it redefines turn_toward_port as the Skipper's definition. Sure, if Gilligan has warnings enabled, he'll notice something is wrong, but why should he have to count on that?||Gilligan的程序总是在他准备转向岸时就出现灾难：他会使船总是转圈！ 问题在于Perl编译器开始编译Gilligan主程序中的turn_toward_port, 然后当Perl在运行时解析require时, 它以Skipper的定义的turn_toward_port重新定义了这个程序. 当然, 录果Gilligan打开了警告, 他会注意有出错信息, 但他为什要仰赖这个呢？
Passing the array by reference fixes the first of the two problems we mentioned earlier. Now, instead of copying the entire provision list into the @_ array, we get a single element of a reference to that provisions array.||用引用传数组解决了我们上面提到的两个问题中的一个. 即, 相比以前我们拷贝供应清单到@_数组, 现在我们传一个指向供应清单数组的单值. 
The CPANPLUS module also comes with a convenience script, called cpanp. If we give it the i switch and a list of modules, it installs them just like before.||CPANPLUS模块同样有一个方便的脚本, 叫做cpanp. 执行起来用i开关并列出要安装的模块列表, 像如下那样：
By using the reference form, we've decoupled the code and the method of array access from the actual array. Let's see how that changes the rest of this subroutine:||运用引用的形式, 我们已经可以分离数组名字和从实际数组中访问数组的方法. 我们来看看子例程的余下部分：
The Skipper and Gilligan are having a conversation:||Skipper和Gilligan之间有一通对话：
In particular, a reference held in a subroutine's private (lexical) variable goes away at the end of the subroutine.||要指出的是, 在一个子程序的私有（词法）变量保存的一个引用, 会在子程序结束时被释放. 
In the log_message( ) routine, we take the first element off of the argument list and store it in another typeglob. Without going into too many details, a typeglob stores pointers to all the package variables of that name. When we assign one typeglob to another, we create aliases to the same data. We can now access the data, including the details of the filehandle, from another name. Then, when we use that name as a filehandle, Perl knows to look for the filehandle portion of the typeglob. We'd have a much easier time if filehandles had sigils!||在log_message( ) 子程序中, 我们从参数列表中取下第一个元素, 并且存在另一个typeglob中. 不需要详述太多的细节, 一个typeglob存储了包里面所有变量的名字的指针. 当我们把一个typeglob赋值给另一个的时候, 我们就为相同的数据创建了一个别名. 这样我们现在就可以用另外一个名字来访问这块数据的文件句柄了. 如此, 当我们把名字当文件句柄用时, Perl知道在typeglob中找到这个名字的文件句柄部份. 如果文件句柄已经有符号, 那会更容易. 
12. 9. A Horse of a Different Color||12. 9. 一匹有不同色彩的马
Figure 10-2. Once Perl brings in the drop_anchor. pm file, it ignores another attempt to require it||图10-2. 一旦Perl调入drop_anchor. pm文件, 它会忽略其它相同文件的导入
Object-oriented programming (OOP) helps programmers run code sooner and maintain it easier by organizing the code into things that we can name. We need a little more infrastructure to get going with objects, but in the long run, it's worth it.||面向对象编程（ＯＯＰ）帮助程序员把代码到他们可以命名的对象里的办法使代码运行起来更快和维护起来更方便. 我们需要一点功夫来找出对象, 但对于长远来说是值得的. 
In this case, the curly braces have two different meanings. The first pair denotes the expression returning a reference, while the second pair delimits the expression for the hash key.||在上例中, 同样是花括号表达了两个不同的含意. 第一对花括号表示还原一个引用, 而第二个花括号限定散列键. 
This is mostly a style call: in both cases, the first parameter ends up in $new_heading. However, we've seen that removing the items from @_ as they are identified does have some advantages. So, we stick (mostly) with the "shifting" style of argument parsing. Now back to the matter at hand. . . .||这是另一特色的调用：两种情况, 第一个参数都结束于$new_heading. 然而, 正像他们指出的, 从@_提取元素比较方便. 所以, 我们大多数情况下用"shift"风格的参数解析. （？）现在回到我们手头的程序… …
or even:||甚至于：
doesn't work. Why? Because the unshift happens at runtime, long after the use was attempted at compile time. The two statements are lexically adjacent but not temporally adjacent. Just because we wrote them next to each other doesn't mean they execute in that order. We want to change @INC before the use executes. One way to fix this is to add a BEGIN block around the push:||这样做不对, 为什么？因为unshift是在运行时发生的, 远在use来调用模块的编译时之后. 两条语句虽然在词法上紧挨着但并不表示在编辑时间上靠近. 仅仅因为次序上一句挨着另一句并不意味着执行上也按相同的次序. 我们得让@INC在use语句执行之前改变. 一种解决办法是加上BEGIN块：
Note the added @ISA array. We'll get to that in a minute.||注意我们加了@ISA数组. 我们后面会介绍的. 
[*] A famous computing maxim states that "there is no problem so complex that it cannot be solved with appropriate additional layers of indirection. " Of course, with indirection comes obfuscation, so there's got to be a magic middle ground somewhere.||[*] 一条很著名的算法格言指出："没有什么问题太复杂, 而不能被采用适当手段来解决的. " 当然, 用些小手段会使导致程序太难懂, 所以一定有些魔术在里面. 
Using a Schwartzian Transform, read a list of words, and sort them in "dictionary order. " Dictionary order ignores all capitalization and internal punctuation. Hint: the following transformation might be useful:||用施瓦茨变换, 读一列表词, 以"字典顺序"对他们进行排序. 所谓字典顺序忽略大小写和和音节符. 暗示：下列转换可能有用：
The reverse operator returns a list in the opposite order.||reverse操作符返回反向排序的列表. 
First, Perl constructs the argument list. In this case, it's just Cow. Then Perl looks for Cow::speak. That's not there, so Perl checks for the inheritance array @Cow::ISA. It's there and contains the single name Animal.||首先, Perl创建参数列表. 在这个例子中, 就是Cow. 然后Perl找Cow::speak. 当前包没有, 所以Perl就在其祖先数组里找@Cow::ISA. 这里面有Animal包. 
It prints:||输出如下：
[*] This is perhaps different from other OOP languages with which you may be familiar.||[*] 这同你可能熟悉的其它面向对象语言有所不同. 
Maybe you have noticed that, in the previous code, we used $File::Find::name for the item's name. So which name is real, $_ or $File::Find::name? $File::Find::name gives the name relative to the starting directory, but during the callback, the working directory is the one that holds the item just found. For example, suppose that we want find to look for files in the current working directory, so we give it (". ") as the list of directories to search. If we call find when the current working directory is /usr, find looks below that directory. When find locates /usr/bin/perl, the current working directory (during the callback) is /usr/bin. $_ holds perl, and $File::Find::name holds. /bin/perl, which is the name relative to the directory in which you started the search.||刚才你可能已经注意到了, 在前面的代码中, 我们用$File::Find::name来返回文件的名字. 所以现在哪个名字是真实的呢？$_或者$File::Find::name？ $File::Find::name是给出文件自起始搜索目录的相对路径名, 而在回调程序中, 工作目录就是项目所在目录. 比如, 假定我们要在当前目录找些文件, 所以我们给出它（". "）作为要搜索的目录. 如果我们当前目录是/usr, 则程序会往下找这个目录. 然后程序找到/usr/bin/perl, 此时当前目录（在回调程序中）是/usr/bin. 变量$_保存了perl, 而$File::Find::name保存. /bin/perl, 就是相对起始搜索目录的相对路径. 
This task would probably be solved better using iteration rather than recursion, even though the classic definition of factorial is often given as a recursive operation.||这个任务可能用迭代来做比用递归更好, 即使阶乘的经典定义是常常被作为一个递归操作. 
[*] You can read more examples in the Perl Data Structures Cookbook, the perldsc documentation page.||[*] 你可以在《Perl数据结构烹调书》（Perldsc文档页）来接触更多的例子. 
Distinguishing actions by the presence or absence of parameters is not a universal solution. Fortunately, we can create more than one subroutine reference in create_find_callback_that_counts( ):||当然, 用区分参数存在或者不存在的来决定程序行为不是一个通用的解决方案. 还好, 我们可以在create_find_callback_that_counts( )中创建多个子程序. 
11. 11. 1. Exercise 1 [20 min]||11. 11. 1. 练习 1[20 分钟]
That last part looks very repetitive. We can shorten it with a hash slice. Again, if the original syntax is:||上例中最后部份看上去比较重复. 我们可以用散列片断来简化写法. 一样的, 如果散列的语法是这样的：
3. 7. The Comprehensive Perl Archive Network||3. 7. CPAN模块仓库
You can find the answers to these exercises in "Answers for Chapter 11" in the Appendix.||答案附录找. 
2. 4. Exercises||2. 4. 习题
While the data we've processed with references up to this point has been rather fixed structure, sometimes we have to deal with hierarchical data, which is often defined recursively.||我们到现在为止处理的引用都是固定结构的, 可有时候我们要处理一般同递归来定义的层次结构的数据. 
Perl executes that code in the lexical context of the code around it, meaning that it's virtually as if we had typed that code right there. The result of the eval is the last evaluated expression, so we really don't need the entire statement inside the eval.||Perl在词法环境中执行那段代码, 这意味着我们好像在执行的时候输入这些代码的一样. eval的结果就是最后一个表达式求值的值, 所以我们不必在eval中输入整个语句. 
Obviously, we don't want to create and maintain a data structure by changing literals in the program. We should fetch the data by using a subroutine. Write a subroutine that returns undef for a given pathname if the path is a file, or a hash reference of the directory contents if the path is a directory. The base case of looking at a file is the easiest, so let's write that:||显然, 我们不必在程序里用硬编码的形式来构建和维护这个结构. 我们可以用子程序来获取这些数据. 写个子程序, 如果找到的是文件, 则返回未定义值, 如果是目录的话, 则返回一个散列引用. 最基本的查看文件的例子是最简单的, 所以我们可以这样写：
A reference fits wherever a scalar fits. It can go into an element of an array or a hash, or into a plain scalar variable, like this:||标量合适的操作对于引用都一样合适. 它可以是数组或散列中的一个元素, 或简单就是一个标量变量, 像下面所示：
In that last example, we never explicitly called subroutines such as professor_greets( ), we only called them indirectly through the coderef. Thus, we wasted some brain cells to come up with a name for the subroutine used only in one other place, to initialize the data structure. But, just as we can create anonymous hashes and arrays, we can create anonymous subroutines !||在最后那个例子中, 我们并没有显式的调用子程序, 如profressor_greets( ), 我们只是间接通过代码引用来调用它. 所以, 为了初始化一个数据结构, 我们仅仅因为在其它地方使用而给子程序提供名字纯属浪费脑筋. 但是, 就像我们可以建立匿名数组和匿名散列一样, 我们也可能建立一个匿名的子程序！
8. 1. The Old Way||8. 1. 旧的方法
The presence of the parameter in the second line denotes that we are setting the color, while its absence in the third line indicates a getter.||第二行出现的参数表明我们正设置颜色, 如果它缺失, 表示我们调用取值器. 
Now we use the scalar variable in place of the bareword in the line input operator.||现在, 我们就可以在行输入操作符中裸字的位置替换成标量. 
The program from Exercise 2 in Chapter 5 needs to read the entire datafile each time it runs. However, the Professor has a new router logfile each day and doesn't want to keep all that data in one giant file that takes longer and longer to process.||第五章中的练习2中的程序要在每次执行的时候把整个数据文件读进内存. 然而教授每天都会有一个日志文件, 并且也不想让数据文件越来越大, 花很长的时间去执行. 
print it out||输出结果
Note that $person is a name, which we look up in the hash to get to a coderef. Then we dereference that coderef, passing it the name of the person being greeted, and we get the correct behavior, resulting in:||注意, 变量$person是字名, 他们以前在散列中查找代码引用. 然后我们还原那个代码引用, 并传给他要问候的人名, 获得正确的问候行为, 输出结果如下：
[*] Like this.||[*] 喏, 就像这样. 
In the same way that we can create references to filehandles, we can create directory handle references.||用创建对句柄的引用同样的方法, 我可以创建对目录句柄的引用. 
As before, we call the find routine with two parameters: a reference to an anonymous subroutine and the starting directory. When it finds names within that directory (and its subdirectories), it calls the anonymous subroutine.||同以前一样, 我们调用find子程序时传给它两个参数：一个指向匿名子程序的引用和一个起始搜索目录. 在它找到文件在目录中时（或其子目录中时）, 它会调用匿名子程序. 
Without running it, can you see what's wrong with this piece of a program? If you can't see the problem after a minute or two, see whether trying to run it will give you a hint of how to fix it.||先不要运行程序, 看看你能否判断出这程序的哪部份出了问题？如果你看不出来, 就可以运行一相程序, 得到些暗示, 来看是否能修改好：
If Perl did not find Horse::sound, it would walk up the @Horse::ISA list to try to find the method in one of the superclasses, just as for a class method. The only difference between a class method and an instance method is whether the first parameter is an instance (a blessed reference) or a class name (a string). [*]||如果Perl没有找到Horse::sound, 那么它会根据@Horse::ISA列表回溯在父类中查找方法, 就象对类方法的操作一样. 类方法和实例方法的区别是第一个参数是否为实例（一个被祝福过的引用）或一个类名（一个字串）. [*]
Notice how much it simplifies the code. The subroutine definitions are right within the only data structure that references them directly. The result is straightforward:||注意我们简化了多少行代码. 子程序的定义现在直接放在数据结构中. 结果相当直观：
The problem is that Gilligan defined turn_toward_port as meaning "turn toward the port on the island, " while the Skipper defined it as "turn toward the left. " How do we resolve this?||问题在于Gilligan定义的turn_toward_port的作用是"把左舷靠向岛", 而Skipper的定义是"向左转". 如何来解决这个问题呢？
11. 7. Starting the Search from a Different Place||11. 7. 从不同的地方查找
We can take the output of Data::Dumper's Dumper routine, place it into a file, and then load the file to a different program. When we evaluate the code as Perl code, we end up with two package variables, $VAR1 and $VAR2, that are equivalent to the original data. This is called marshaling the data: converting complex data into a form that we can write to a file as a stream of bytes for later reconstruction.||我们可以取Data::Dumper模块中的Dumper子例程的输出, 将其放到一个文件中, 然后, 由另外一个程序把文件调入. 在我们将这输出作为Perl代码来解析的时候, 我们最后可以得到两个包变量：$VAR1和$VAR2, 并且这与原始的数据是一样的. 这个过程就叫作调制数据：将复杂数据结构转换成一个表, 然后我们可以将其作为字节流写到文件中去, 便于以后重建这些数据. 
Obviously, it's easier for Gilligan if the program itself defines the extra libraries. But sometimes just adding a -I fixes things right up. [*] This works even if Gilligan can't edit the Skipper's program. He still has to be able to read it, of course, but Gilligan can use this technique to try a new version of his library with the Skipper's program, for example.||显然, 如果程序自己定义额外的库, 对Gilligan来说更方便. 但有时加一个-I仅是修复一些东西. [*] 这在Gilligan无需编辑Skipper的程序的情况下也能工作. 当然, 它要有读的权限, 但是, 举个例子来说, Gilligan可以用这个技术试一个使用Skipper程序的新版本. 
Dereference it as an array reference, taking the third element of that array (index number 2).||把它先还原成一个指向数组的引用, 取出那个数组中第三个元素（序号为2）
It looks much better with the arrow. Note, however, that no shortcut gets the entire array from an array reference. If we want all of Gilligan's provisions, we say:||看来用箭头比较爽. 不过, 注意, 没有快捷办法从一个数组引用中取出整个数组内容. 比如, 我们要找出Gilligan装备清单的话, 可以这样写：
That is, it'll do as long as we put it near the beginning of the program, before any invocations of count_down( ) or count_remaining( ). Why?||就是说, 只要我们把块放在程序开始, 放在任何 count_donw()或count_remaining()之前就可以. 为什么呢？
Chapter 6. Manipulating Complex Data Structures||第六章 处理复杂数据结构
The kind of subroutine that can access all lexical variables that existed at the time we declared it is called a closure (a term borrowed from the world of mathematics). In Perl terms, a closure is just a subroutine that references a lexical variable that has gone out of scope.||那种能访问所有我们声明的在运行时存在的词法变量的子程序, 我们叫它闭包（一个从数字世界借过一的词）. 在Perl术语中, 一个闭包就是指一种能引用在程序范围之外的词法变量的子程序. 
[*] Have you ever wondered why there is no comma after the filehandle portion of the print? It is really the indirect object notation (which we have not mentioned yet, unless you have read the whole book before you read the footnotes, like we told you to do in the preface!).||[*] 你是否曾经疑惑为什么print语句的文件句柄后面为什么不加逗号？这的确是对象的一种间接标记（这是我们还没有提及的, 除非你已经在读这个脚注前先读完了本书, 就像我们在前言里说的那样！）
To get around that, we break the second argument into two separate arguments.||为了解决这个问题, 我们可以把第两个参数分开：
3. 10. 2. Exercise 2 [35 min]||3. 10. 2. 练习 2 [35 分钟]
The Skipper placed a few common navigation subroutines into navigation. pm. If the Skipper merely inserts:||Skipper把一些导航通用子程序放入navigation. pm后, 如果Skipper只将如下语句：
we can replace it with:||我们可以以此代替：
You can find the answers to these exercises in "Answers for Chapter 4" in the Appendix.||在附录中"第四章的答案"中找答案
While the grep is running, it shadows any existing value in $_, which is to say that grep borrows the use of this variable but puts the original value back when it's done. The variable $_ isn't a mere copy of the data item, though; it is an alias for the actual data element, similar to the control variable in a foreach loop.||当grep工作的时候, 它是从$_变量中把值"借"出来用. 就是说grep把$_的值"借"过来用一下, 用完后再把原值放回$_变量中. 所以$_变量仅仅是拷贝一下值而己. 是实际数据元素的一个别名. 就像foreach loop中的控制变量. 
6. 5. Using the map and grep Operators||6. 5. 使用map和grep操作符
There we have it. This construct invokes the subroutine currently referenced by $ref_to_greeter, passing it the single Gilligan parameter.||就是它了. 这个方法调用了当前$ref_to_greeter变量中保存的那个对子程序的引用, 并给它传了一个字串参数：Gilligan. 
As you can see, various levels of optimization can lead to obfuscation. Be sure to consider where your head will be a month from now when you have to reread your own code. If that's not enough, consider the new person who will take over your job after you have left. [*]||正如你们看到的那样, 不同的优化层次会导致代码明晰性的困惑. 所以写代码的时候要考虑一下一个月后, 当你重读这些代码的时候你会如何理解. 或者, 当你离开这个岗位后, 接替你的人是否会看懂这段代码. 
Hint: use a hash, keyed by the castaway name, holding IO::File objects for each output file. Create them as necessary.||提示： 用一个散列, 键用名字, 值是IO::File对象提供的每个输出文件. 按照需要创建他们. 
5. 9. 1. Exercise 1 [5 min]||5. 9. 1. 练习1 ［5分钟］
If we have the libraries in a directory close to the script directory, we put the right path components together to make it work.||如果我们把库放在脚本目录中的一个目录, 我们只要把正确的路径加上去就可以了, 这样就能工作了. 
Chapter 8. Filehandle References||第八章 引用文件句柄
All we did was replace @_ (the copy of the provisions list) with @{$items}, a dereferencing of the reference to the original provisions array. Now we can call the subroutine a few times, as before:||我们做的仅仅就是把@_(供应清单的拷贝)替换成@{$items}, 对一个引用的还原操作来取得原始的供应清单数组. 现在我们调用子例程次数相比以前少多了. 
This code works fine, but it actually says more than it needs to. Why? Because we can leave out the line that initializes the hash element's value to a reference to an empty array:||这样的代码运行得很好, 但实际上它不需要写那么多. 为什么？ 因为我们可以把初始化指向数据的散列引用的地方去掉：
Like an array reference, when referring to a specific hash element, we can use an arrow form:||像数组引用一样, 当我们要访问一个特定的散列元素的话, 我们可以用箭头形式：
There! Now all the animals are talking, and safely at that, without the use of symbolic coderefs.||如此！ 现在所有的动物都能安全地交谈, 不必使用符号代码引用. 
from the shell prompt.||取自于UNIX shell的提示. 
Closures are "closed" only on lexical variables, since lexical variables eventually go out of scope. Because a package variable (which is a global) never goes out of scope, a closure never closes on a package variable. All subroutines refer to the same single instance of the global variable.||闭包是仅对词法变量跑出程序范围时"关闭". 因为一个包变量（因为是全局）总是在范围之内, 一个闭包不可能"关闭"一个包变量. 对于所有的子程序来说, 他们都引用全局变量的同一个实例. 
In this case, $provisions{"The Professor"} gives an array reference of the provisions brought by the Professor, and $provisions{"Gilligan"}[-1] gives the last item Gilligan thought to bring.||在本例中, $provisions{"The Professor"}给出一个指向数组的引用, 表示教授买的装备清单, 而$provisions{"Gilligan"}[-1]指向Gilligan要带的最后一项东西. 
Because of the second point, most files evaluated for require have a cryptic 1; as their last line of code. This ensures that the last evaluated expression is, in fact, true. Try to carry on this tradition as well.||正因为第二点, 所以大多数给require导入的文件最后求值总有个神秘的1. 这保证了最后的表达式总是1. 努力保持这个传统吧. 
4. 2. Taking a Reference to an Array||4. 2. 建立一个对数组的引用
6. 7. Selecting and Altering Complex Data||6. 7. 拣选和修改复杂数据
[*] Just don't ask us about it. We wrote this book a long time before you got a chance to read it, so we didn't exactly know the details back then.||[*] 不要问我们为什么, 在你有机会读到此书时, 相对我们写书的时间已经是很长久了. 所以我能不能肯定. 
[*] At least not yet. It should be part of Perl 5. 10, though.||[*]尽管它可能成为Perl 5. 10的一部分. （［的确成为Perl 5. 10的一部分：http://perldoc. perl. org/Module/Build. html］）
Perl recycles the memory for the array only when all references (including the name of the array) go away. In this case, Perl only reclaims memory when @skipper and all the references we created to it disappear.||只有这个数组的所有引用（包括数组名）都没有了, Perl才会回收这个数组占用的内存. 在上例中, 只有在@skipper数组及我们所有对它的引用全消失后, Perl才会回收内存. 
And now we see the scalar variable in its place.||现在我们用标量代替：
2. 1. 1. List Filtering with grep||2. 1. 1. 用grep操作符来过滤列表
5. 5. Creating an Anonymous Array Directly||5. 5. 直接建立匿名数组
First, let's use the "take a reference to" operator. It actually needs no introduction because it's that very same backslash as before:||首先, 让我们用"取引用"操作符. 实际上这也不用介绍, 因为它与之前的反斜杠长得非常像：
At this point, you're right to think that example is contrived. Of course we would never make a looped data structure in a real program! Actually, programmers often make these loops as part of doubly linked lists, linked rings, or a number of other data structures. The key is that Perl programmers rarely do so because the most important reasons to use those data structures don't apply in Perl. Most of that deals with managing memory and connecting discontiguous memory blocks, which Perl does for us. If you've used other languages, you may have noticed programming tasks that are comparatively easy in Perl. For example, it's easy to sort a list of items or to add or remove items, even in the middle of the list. Those tasks are difficult in some other languages, and using a looped data structure is a common way to get around the language's limitations.||现在, 你会想例子总是有意设计出来的. 当然, 我们不会在真实的程序中有意设计一个引用循环. 而实际上, 程序员经常在用双向链表、循环列表或其它一些数据结构时创建这些引用循环. 问题是Perl的程序员罕有犯这种错误的, 重要的原因是Perl不太会用到这些数据结构. 大多数处理内存操作及连接内存碎片的操作已经被Perl自动处理了. 如果你曾使用过其它的语言, 你可能会注意到在Perl中的编程相对比较容易. 比如, 对列表中的元素排序或（甚至在列表中间）添加、删除元素都很方便. 同样的任务在其它语言中会很困难, 而用循环数据结构是绕开这些语言限制的常用方法. 
Similar to creating an anonymous array, you can also create an anonymous hash. Consider the crew roster from Chapter 4:||同创建匿名数组类似, 你也可以建立一个匿名散列. 考虑一下第四章的船员注册程序：
Fix up that program to keep the running totals in a datafile so the Professor can simply run it on each day's logs to get the new totals.||修改那个程序, 只要简单的收纳每天教授新产生的日志文件就可以计算数据文件中的即时总数. 
How many different things do these expressions refer to?||下列表达式各表示什么不同的含义：
Inside the Animal::speak method, $class becomes Cow as the first argument is shifted off. When we get to the step of invoking $class->sound while performing the print, it looks for Cow->sound:||在Animal::speak方法里, $class变成Cow, 作为第一个参数传入. 当我们打印时就调用$class->sound, 它会找到Cow->sound:
Chapter 11. Introduction to Objects||第11章 介绍对象
[*] After you make it through this book, you should be able to use Module::CoreList to discover that count for yourself. That's what we did to get those numbers, after all.||[*] 在读完本书之后, 你就能用Module::CoreList模块来自己计算一下共有多少模块. 毕竟, 我们就是用这种方法来得到模块总数. 
Of course, if we want to check on Gilligan and the Professor, we might write the following code:||当然, 如果我们想查一个Gilligan和教授的, 我们可能要写如下的代码：
One part is the declaration of $countdown as a lexical variable. That part is noticed and processed as the program is parsed during the compile phase. The second part is the assignment of 10 to the allocated storage. This is handled as Perl executes the code during the run phase. Unless Perl executes the run phase for this code, the variable has its initial undef value.||一个功能部份是$countdown的声明是作为一个词法变量. 这部份是在程序被编译阶段被解释并处理的. 第二个功能部分是把10赋值给一块分配的内存. 这部份是Perl执行代码时处理的. 除非Perl在运行阶段执行这些代码, 否则变量的初始是未定义值. 
10. 10. 2. Exercise 2 [15 min]||10. 10. 2. 练习2 [15分钟]
The object itself||对象自身
As our first attempt, let's invoke the Animal::speak method directly:||像我们首先尝试的, 当我们直接调用Animal::speak:
That syntax might look funny to you, though, and even if it doesn't look funny to you, it might look odd to the person who has to read your code later. In Perl Best Practices, Damian Conway recommends putting braces around the filehandle portion to explicitly state what you intend. This syntax makes it look more like grep and map with inline blocks.||尽管下面的代码可能你看上去比较搞笑, 或者, 如果你不觉得搞笑, 可能那些后来读到你的代码的人也觉得看上去比较怪异. 在《Perl最佳实践》这本书中, Damian Conway建议在文件句柄部份要加上大括号以显明你的态度. 这样的语法使它看上去更新grep或者map的内嵌块形式. 
[*] Actually, assigning new scalars to elements of @_ after the shift modifies the corresponding variable being passed, but that still wouldn't let us extend the array with additional mandatory provisions.||[*] 实际上, 用shift修改传过来的数组, 把新的标量赋值给数组@_的一个元素是可以的. 但这任不能改变原来的供应单. 
Because we get the instance as the first parameter, we can now access the instance-specific data. In this case, let's add a way to get at the name:||因为我们把实例作为第一个参数, 我们现在可以访问实例自己的数据. 在这个例子中, 让我们添加一个方法来获取一个名字：
Let's add a mouse that can barely be heard:||让我们来加一种少有耳闻的老鼠：
The eval catches the syntax error and puts the message in $@, which we check immediately after calling eval.||eval捕捉语法错误, 然后在我们调用eval后, 在检查$@值时, 把出错信息放到变量$@中. 
The updated parameter (same as what was passed in)||更新过的值（类似于传入的是什么）
Not that any of us have ever done that and wondered why the program took forever. The second time really wasn't our fault anyway, and the third time was just bad luck. That's our story and we're sticking to it.||这并不是说我们任何人都没有碰到过, 并奇怪为什么程序一直运行. 第二次确实不是我们的错, 第三次只是运气不好. 这就是我们的故事而且挥之不去. 
Now, a word from our parser: because blocks and anonymous hash constructors both use curly braces in roughly the same places in the syntax tree, the compiler has to make ad hoc determinations about which of the two you mean. If the compiler ever decides incorrectly, you might need to provide a hint to get what you want. To show the compiler that you want an anonymous hash constructor, put a plus sign before the opening curly brace: +{ ... }. To be sure to get a block of code, just put a semicolon (representing an empty statement) at the beginning of the block: {; ... }.||现在, 下面一些话是从我们的解释器那里来： 因为代码块和匿名散列构造器都用花括号, 在语法树中大致相同的位置, 编译器不得不即时判断你到底是要用哪一个. 如果编译器没法决定, 就需要你给个暗示, 你到底是用哪个. 如果你是要用匿名散列, 那你要在花括号前加一个正号：+{…}. 如果你是用代码块, 则要在花括号后加上分号：{; … }. 
Perl's built-in sort operator sorts text strings in their natural text order, by default. [*] This is fine if we want to sort text strings:||Perl内建的sort排序操作符缺省情况下将文本字串以他们的字符顺序进行排序. [*] 这在我们进行字符排序时没有任何问题：
Demonstrate the Person class by invoking a person with nothing to say, and then demonstrate it a second time by invoking a person with something to say.||用调用Person类, 然后再调用Person类, 并让他说些话. 
Look at the curly-brace dereferencing again. As in our earlier example, the array reference for Gilligan's provision list is ${$all_with_names[2]}[1].||我们再来看一下用大括号的还原过程. 像先前的例子, 我们对Gilligan的装备清单的数组引用是${$all_with_names[2]}[1]. 
Whether we change the value, or the variable itself goes away, Perl notes it as an appropriate reduction in the number of references to the data.||不管是我们改变变量的值, 或者变量跑出范围, Perl会注意到这些, 并且适当的减少对数据的引用计数. 
Figure 10-1. The Skipper uses the navigation. pm file in all his other navigation programs||图10-1. Skipper在他其它所有的导航程序中使用navigation. pm 文件中的程序
3. 8. Installing Modules from CPAN||3. 8. 安装从CPAN下载的模块
Having all horses be brown would be boring. Let's add a method or two to get and set the color:||我们来加一两个方法来设置颜色, 这样让所有出生的马都是棕色. 
This results in:||其输出结果如下：
8. 6. Exercises||8. 6. 练习
12. 4. How to Build a Horse||12. 4. 如何创建Horse类
In each case, $items points to a different array, so the same code applies to different arrays each time we invoke it. This is one of the most important uses of references: decoupling the code from the data structure on which it operates so we can reuse the code more readily.||以上每个例子中, $items指向一个不同的数组. 如此, 同样的代码每次调用的时候可以应用到不同的数组. 这就是引用的一个最重要的用法之一：把代码同其操作的具体数据结构分离开, 这样我们可以重用代码并使其更可读. 
This scenario is arguably better. Most of the time, simply copying the complexly referenced value into a simple scalar is easier on the eyes. In fact, another way to write that loop is to get rid of the ugly if structure:||这样的写法理论上应该很好. 大多数情况下, 简单地把复杂引用的值拷贝到一个标量看上去应该更简单. 实际上, 用另一种方法写这个循环可以把讨厌的if结构去掉：
Now the module only gives us those two subroutines and leaves our own dirname alone. Of course, this is awkward to type, so more often we'll see this written with the quotewords operator:||这样的话, 模块只会将两个例程导入我们的程序, 让我们自己写的dirname留在程序中. 当然, 上述的写法输入起来太麻烦, 所以一般我们会看如下用引用操作符的写法：
10. 7. Packages as Namespace Separators||10. 7. 包名字作为名字空间分隔符
Originally, the mandatory true value was intended as a way for an included file to signal to the invoker that the code was processed successfully and that no error condition existed. However, nearly everyone has adopted the die if ... strategy instead, deeming the "last expression evaluated is false" strategy a mere historic annoyance.||一开始, 强制性的返回真值是给导入文件的一个方法, 给调用者一个信号－－代码被成功处理且没有错误. 然而, 大家都采用die if …的策略, 推定的"最后表达式的计算是错误的"策略只是历史的烦扰. 
[*] O'Reilly Media has a great book to help you be nice to the next guy. Perl Best Practices by Damian Conway has 256 tips on writing more readable and maintainable Perl code.||[*] 奥莱利公司有一大坨的书来帮助你写出好读的代码来应付接替你的家伙. Damian Conway ＜Perl 最佳实践＞列出了有关代码可读性和可维护性的256条锦囊妙计. 
10. 6. The Problem of Namespace Collisions||10. 6. 名字空间冲突的问题
Note that we can't use the more traditional filehandle read or filehandle print operations, because the reading and writing filehandles were not in a simple scalar variable. We can rewrite that loop to see if copying the handles is easier:||注意, 我们不能用更传统的句柄读或者写操作, 因为句柄的读写不能在简单标量变量中. 我们可以通过重写那个循环, 看看拷贝句柄是否更方便：
The key is the person's name, and the value is initially a reference to an empty anonymous array. If the line is a provision, push it to the end of the correct array, using the array reference.||如果把乘客的名字作为键, 值是指向一个空数组的引用. 如果读入的行是装备, 则使用引用数组, 把它推入当前的数组. 
Data::Dumper, like the debugger's x command, handles shared data properly. For example, go back to that "leaking" data from Chapter 5:||Data::Dumper, 同调试工具的命令行 x 命令一样, 处理共享数据属性. 比如, 我们来看看先前第五章遇到的"内存泄漏"的例子：
How do we keep the number of monkey requests to a minimum? Well, we can build a table first. We use a map with seven inputs and seven outputs, turning each castaway item into a separate array reference, with each referenced array consisting of the castaway name and the pineapple count reported by the monkey:||那我们怎么能将询问猴子的次数降为最低呢？ 这样, 我们先建一张表. 我们用一个map和七个输入输出项, 将每个castaway元素做成一个数组引用, 每个数组引用包含两个元素, 一个是成员名字, 一个猴子报告的其所持菠萝的数目：
7. 8. Exercise||7. 8. 练习
A better solution is to tell Perl to search from a different place in the inheritance chain:||一个更好的解决方案是告诉Perl在继承链中从不同的地方去查找. 
Rather than assign the global variable, we can rewrite this without @all_with_names and return the list directly:||与分配一个全局变量不同, 我们还可以重写这个程序, 去掉全局变量@all_with_names, 直接从程序中返回列表：
We'll presume that you've already read Learning Perl, or at least pretend you have, and that you've played enough with Perl to already have those basics down.||我们会假定你已经读过《Learning Perl》, 或假装你已经读过, 或者你已经玩过Perl一段时间, 已经把基础知识拿下. 
All we need to fix this is a way to detect whether the method is called on a class or an instance. The most straightforward way to find out is with the ref operator. This operator returns a string (the class name) when used on a blessed reference, and undef when used on a string (like a class name). We modify the name method first to notice the change:||解决这个问题, 我们所要做的就是查这个方法的调用者是个类还是实例. 最直接的方法是用ref 操作符. 这个操作符在用在一个blessed引用上会返回一个字串（类名）, 而用在一个字串（如类名）时返回的是空值. 我们改下看看：
We're almost done, but what if we just wanted the top names, rather than the names and pineapple counts? We merely need to perform another map to transform the references back to the original data:||我们差不多要完成了, 但如果我们仅仅要名字, 而不要名字和菠萝数呢？ 我们只要做一下另一个map, 把引用变换成原来的数据就可以了：
Here's the trick: we can place any reference to an array in curly braces in place of the name of an array, ending up with a method to access the original array. That is, wherever we write skipper to name the array, we use the reference inside curly braces: { $items }. For example, both of these lines refer to the entire array:||这里有一个小戏法：我们可以用在外面套上大括号的指向数组的引用, 来替换数组的名字, 其结果就是访问原始的数组. 换句话说, 就是我们写sipper数组名字的地方, 可以用大括号包起来的指向数组的引用来代替：{$items}. 举例来说, 下面两行都指向同一数组：
In the pages that follow, you can get "the rest of the story" in the same style as our friendly Llama book.||在后面的学习中, 我们会以《小骆驼书》同样的风格来向你介绍"余下的故事". 
We can use references to acquire, store, and process such hierarchical information. Frequently, the routines to manage the data structures end up as recursive subroutines.||我们可以用引用的办法来获得, 存储以及处理这些层次结构的信息. 一般来说, 处理这些层次结构的子程序最终都是递归程序. 
We can interchange all three references. We can even say they're identical, because, in fact, they are the same thing.||我们可以互换这三个引用. 我们甚至说他们是相同的, 因为, 实际上他们指的是同一地址. 
The bottom line is simply: Perl does the right thing. If we still have a reference to data, we still have the data.||底线很清楚：Perl总是做对的事情. 如果我们依然有指向数据的引用, 我们就仍旧拿着数据. 
[*] Compare this with having to return an array from a C function. We must either return a pointer to a static memory space, making the subroutine nonreentrant, or we must malloc new memory space, requiring the caller to know to free the data. Perl just does the right thing.||[*] 比较一下这与C函数中必须返回一个数组. 我们要么返回一个指向静态内存区域的指针, 使子程序非重入, 或者我们必需分配新内存, 需要调用程序知道释放内存. Perl正好做了对的事情. 
Sometimes we don't want to print to a file and would rather build up the output in a string. Some module interfaces don't give us that option, so we have to make it look like we are printing to a file by using a filehandle. We might also want to build up our content before we write it to a file so we can encrypt it, compress it, or send it as email directly from your program.||有些时候, 我们并不想把内容直接打印到文件, 宁愿把输出送到一个字串中去. 一些模块的接口不提供给我们这个选项, 所以我们不得不利用看上去像打印到文件中去的文件句柄来完成. 我们可能要在把内容写到文件之前先建立好, 这样我们就可以对文件内容进行加密, 压缩或从你的程序中直接把它作为邮件发出去. 
Going back to that drop_anchor. pm library for a second, what if the Skipper wrote a program that needed to "drop anchor" as well as navigate?||我们再回到drop_anchor. pm库, 如果Skipper要写个程序需要"抛锚"和导航呢？
You can find the answers to these exercises in "Answers for Chapter 8" in the Appendix.||答案附录找. 
1. 3. What's with the Exercises?||1. 3. 关于练习
You can find the answers to these exercises in "Answers for Chapter 5" in the Appendix.||附录部份可以找到答案
The require operator keeps track of the files Perl has read. [] Once Perl has processed a file successfully, it simply ignores any further require operations on that same file. This means that even if navigation. pm contains require "drop_anchor. pm", Perl imports the drop_anchor. pm file exactly once, and we'll get no annoying error messages about duplicate subroutine definitions (see Figure 10-2). Most importantly, we'll also save time by not processing the file more than once.||require操作符会在Perl每次读入文件的时候进行跟踪[+] 一旦Perl成功加载了一个文件, 它就会忽略之后require引入相同的文件. 这意味着就算navigation. pm包括require "drop_anchor. pm", Perl只会把drop_anchor. pm引入一次, 我们就不会收到烦人的警告重复定义子程序的消息了（见图10－2）. 更重要的是, 我们同样节省时间, 不必多次加载文件了. 
[*] Extending @INC with either PERL5LIB or I also automatically adds the version and architecture-specific subdirectories of the specified directories. Adding these directories automatically simplifies the task of installing Perl modules that include architecture- or version-sensitive components, such as compiled C code.||[*] 不论是用PERL5LIB环境变量或者I选项来扩展@INC, 自动会把所在目录的下面的子目录全都引入. 自动引入这些目录也简化了安装Perl模块的任务, 如果这些代码是结构化的或对版本敏事情的, 就像编译过的C代码之类. 
It covers what you need to write programs that are 100 to 10, 000 lines long.||本书将会覆盖写从100行到1万行的程序所需要的知识. 
Furthermore, the access to the variable from within the closure ensures that the variable remains alive as long as the subroutine reference is alive. For example, let's number the output files:[*]||更有甚者, 在闭包内部访问变量能保证只要匿名子程序引用存在, 变量的值就能保留. 比如, 让我们对输出文件计数：[*]
Perl comes with many of the popular modules already. Indeed, most of the 50+ MB of the most recent distribution are from modules. In October 1996, Perl 5. 003_07 had 98 modules. Today, at the beginning of 2006, Perl 5. 8. 8 has 359. [*] Indeed, this is one of the advantages of Perl: it already comes with a lot of stuff that you need to make useful and complex programs without doing a lot of work yourself.||Perl发行版已经自带了最受欢迎的模块. 实际上, 最近的发行版中有超过50兆模块. 于1996年十月发布的Perl 5. 003_07有98个模块. 现如今, 2006年的年初发行的Perl 5. 8. 8有359个模块［*］. 这实在是Perl的优点之一：许多有用且复杂的程序用不着你动手, 发行版里已经给你带来了. 
What happens when we invoke Cow->speak now?||现在我们调用Cow->speak会发生什么？
For good measure, we should probably sort both lists to be consistent:||为了好的效率, 我们应该对列表进行排序, 以保持一致性：
5. 7. Autovivification||5. 7. 自生成
The directory handle reference obeys the same rules we laid out before. This only works if the scalar variable does not already have a value, and the handle automatically closes when the variable goes out of scope or we assign it a new value.||对目录句柄引用遵从我们在之前我们说过的规则. 它必须在标量变量没有值的情况下才能工作, 跑出范围或变量被另外赋值时, 句柄自动关闭. 
divide by zero?||若除零呢？
So, in navigation. pm, we can use variables such as:||所以, 在navigation. pm中, 我们可以用下面的变量名：[+]
just as we did in the original program. With Storable, we can store data and retrieve it later. More information on Storable can be found in perldoc Storable, as always.||就像我们在原来的程序里做的那样. 用Storable模块, 我们可以先存后取. 欲得更多有关Storable模块的信息, 可以用perldoc Storable来查, 老招术了：）
First, inside the parentheses, we create a list of two items, each of which is a coderef. The coderefs are then individually dereferenced, invoking the corresponding subroutine and passing it the Professor string.||首先, 在小括号里面, 我们建立一个两个元素的列表, 而且这两个元素各保存一个对代码块的引用. 而每个对代码的引用都各自被还原, 调用相应的子程序并传入"教授"字串. 
3. 10. 1. Exercise 1 [25 min]||3. 10. 1. 练习 1 [25 分钟]
Here we have a base case where $n is less than or equal to 1, which does not invoke the recursive instance, along with a recursive case for $n greater than 1, which calls the routine to handle a portion of the problem (i. e., compute the factorial of the next lower number).||这里的基础例子是变量$n小于或等一1时, 这时就不会调用递归子程序, 而在$n大于1时, 就会调用子程序来处理这部分问题（如, 为下一个更小的数处理阶乘）
6. 1. Using the Debugger to View Complex Data||6. 1. 使用测试工作来查看复杂数据结构
Because we can copy a reference, and passing an argument to a subroutine is really just copying, we can use this code to pass a reference to the array into the subroutine:||因为我们可以拷贝一个引用, 并且作为参数传给一个子例程, 我们可以用如下代码把对数组的引用传给子例程：
From there we go one of two ways (which we'll explain in detail in Chapter 16). If we find a file named Makefile. PL, we run this series of commands to build, test, and finally install the source:||然后我们可以以两种办法安装（我们将会在第16章介绍）. 如果我们找到一个叫makefile. pl的文件, 我们可以运行如下的命令来编译, 测试和最终安装源码：
This is what the modules in Chapter 3 were doing when they imported symbols into our scripts, but we didn't tell you the whole story then. Those modules imported the subroutines and variables into the current package (again, that's main in our scripts, usually). That is, those symbols are only available in that package unless we use the full package specification. We'll get more into how this works later.||这就是在第三章中的那些模块在导入符号到脚本时要做的事情, 但是当时我们没有告诉你整个故事的细节. 这些模块把子例程和变量导入到当前的包（通常, 这是你这个脚本的main包）. 换句话说, 这些符号仅存在于那些包中, 除非你全名引用. 我们会在后面来详述这套机制是如何工作的. 
Welcome to the next step in your understanding of Perl.||欢迎来到认识 Perl 的下一台阶. 
We just saw that if we try to install a module that uses Module::Build, we have to install Module::Build first. That's a mild case of the general dependency headache, and all the coconuts on our castaways' island aren't going to fix it. We might have to install several other modules too, each of which, in turn, depends on even more modules.||我们刚才看到如果我们要安装一个模块, 并且这个模块要引用Module::Build模块的话, 我们要事先装好Module::Build模块. 这就是个稍稍让人头痛的有关一般模块依赖性的例子. 那我们的castaways岛的所有的椰子应该如何处理呢？我们要安装另一些模块, 而这些模块各自又依赖更多的其它不同的模块. 
Perl operators such as grep, map, sort, and print||Perl的操作符：grep, map, sort和print
We've included the top portion of the documentation to show you the most important section (at least, the most important when you're starting). Module documentation typically follows the old Unix manpage format, which starts with a NAME and SYNOPSIS section.||我们在这里列出了文档的一般结构（至少是最重要的部分）. 模块文档是按Unix旧文档格式组织的, 以NAME和SYNOPSIS开始. 
To install into our private directories using Module::Build, we add the install_base parameter. We tell Perl how to find modules the same way we did before.||如果要把Module::Build安装在你自己的目录, 我们可以加上install_base安装参数. 就像我们以前安装Perl时用的参数：
So far, our examples have shown the two-argument form of open, but that actually has a catch: the open mode and the filename both live in the second argument. That means that we have to store two different things in one string, and we have to trust Perl to be able to figure it out.||到目前为此, 我们的例子展示的open都是两个参数的形式, 但实际上有个隐含之处：文件的打开方式是和文件名都放在第二个参数的位置上的. 这意味着我们在一个字串里表达了两种不同的意义, 而且我们不得不相信Perl一定会很好的区分. 
After writing a dozen programs using this routine, the Skipper realizes that the output is excessively chatty when he's already taken the time to steer the proper course (or perhaps simply started drifting in the proper direction). After all, if the current heading is 234 degrees and he needs to turn to 234 degrees, we see:||用这个例程写了一打程序之后, Skipper发现这样用下来, 当他花时间调到正确的航向时, 已经有非常多的输出（或者作简单的在正确的航向漂流）. 毕竟, 如果当前航向是234度, 而他要转234度, 我们会看到：
Here, we dereference the value $not_yet as if it were an array reference. But since it's initially undef, Perl acts as if we had said:||这儿, 我们还原了$not_yet这个值, 好像它原先是一个指向数组的引用一样. 但因为它初始化是undef, Perl的行为好像我们说过的：
10. 5. 1. Extending @INC||10. 5. 1. 括展@INC
Come about to 234 by turning right 0 degrees.||向右转0度, 转向234. 
which results in:||其输出是：
5. 3. Reference Counting and Nested Data Structures||5. 3. 引用计数和数据结构嵌套
Read the list of files in the current directory and convert the names to their full path specification. Don't use the shell or an external program to get the current directory. The File::Spec and Cwd modules, both of which come with Perl, should help. Print each path with four spaces before it and a newline after it, just like you did for Exercise 1 of Chapter 2. Can you reuse part of that answer for this problem?||读当前目录的文件列表并转换成全路径. 不能用shell命令或外部程序读当前目录. Perl的File::Spec和Cwd两个模块对这个程序有帮助. 每个路径条目前加四个空格并每个条目开个新行, 就像第二章的练习一做的那样. 你可以重用原来的程序吗？
Now, when we call Cow->speak, we get a $class of Cow in speak. This, in turn, selects the Cow->sound method, which returns moooo. How different would this be for the Horse?||现在, 当我们调用Cow->speak, 我们会在speak中获得一个Cow的$class. 这样, 选择Cow->sound方法, 返回moooo. 马会怎么样呢？
When we want to print to the filehandle, we use the scalar variable instead of a bareword. Notice that there is still no comma after the filehandle.||当我们要把内容打印到文件句柄的时候, 我们就把标量变量代替以前裸字的位置. 注意文件句柄后面一样没有逗号. 
But boy-oh-boy, is that ugly or what? Luckily, the same reference simplification rules apply. If the value inside the curly braces is a simple scalar variable, we can drop the braces:||不过, 这样子是不是太丑陋了？ 幸运的是同样的简化规则也能应用于对子程序的引用. 如果花括号里是简单的标量变量的话, 花括号可以去掉：
Therefore, $all_with_names[2] will be the array reference for the Gilligan's data. If you dereference it as @{$all_with_names[2]}, you get a two-element array, "Gilligan" and another array reference.||这样, $all_with_names[2]里放的是指向数组的引用, 内中存放的是Gilligan的数据. 如果将其还原, 像这样：@{$all_with_names[2]}, 你就是得到一个有两个元素的数组：Gilligan和另一个数组引用. 
A recursive subroutine has a branch from which it calls itself to handle a portion of the task, and a branch that doesn't call itself to handle the base cases. In Example One above, the base case could be a table cell that is empty. There could also be base cases for empty tables and table rows. In Example Two, base cases would be needed for files, and perhaps for empty directories.||递归子程序有一个分支来调用自己来处理部份任务, 有一个分支处理基础例子. 在上面第一个例子中, 基础例子就是当表格单元空的时候. 同样空行或空表也是基础例子. 在第二人例子中, 基础例子是文件或者空的目录. 
illegal pattern?||若传过来的正则表达式不对呢？
An empty list is different from an absent list. An empty list says "don't give me anything, " while an absent list says "give me the defaults. " If the module's author has done her job well, the default will probably be exactly what we want.||空列表和没有列表的概念是不一样的. 空列表的意思是说"不要导入任何子例程", 而没有列表的意思是说："请导入缺省的子例程". 如果模块的作者干得出色的话, 他缺省导出的例程正是你想要的. 
As before, this module imports nothing. Its entire interface uses class methods, such as new, against the class name to create instances, and then calls instance methods, such as bpow and bstr, against those instances.||如前所述, 这个模块没有导入任何东西. 其全部的接口使用对象的方法, 如用new跟在类名之后, 来建立实例. 然后调用实例的方法, 如跟在实例名字后的bpow和bstr. 
Be sure you don't mangle the data! If the input includes the Professor and the skipper, the output should have them listed in that order, with that capitalization.||注意, 不要把数据搞乱了！ 如果输入是Professor和skipper, 那么输出也应该是这个次序, 同样的大小写. 
We can drop the first brace pair because the only thing within is a simple scalar value, yielding:||因为大括号里是简单的标量变量, 所以我们可以把第一个大括号去掉, 形如：
For example, this works:||比如, 下面在代码是工作的：
The Professor's datafile (mentioned earlier in this chapter) is available as coconet. dat in the files you can download from the O'Reilly web site. There may be comment lines (beginning with a pound sign); be sure to skip them. (That is, your program should skip them. You might find a helpful hint if you read them!)||教授的数据文件（注意早先这章提到的）叫coconet. dat, 保存在O'Reilly的网站上, 你可以下载. 有些行可能被注释了一些行（用前导＃号）;跳过这些行. （就是说, 你的程序可以跳过他们, 不过你阅读这些行还有很有益的！）
We cannot drop the first arrow, however, because that would mean an array @root's third element, an entirely unrelated data structure. Let's compare this to the full curly-brace form again:||然而, 第一个箭头不能舍去, 因为这会表示root数组的第三个元素, 成了一个完全无关的数据结构. 让我们再与它"全包装"的形式再做一个比较：
There. Fixed again. That is, until we need the library to depend on the result of a calculation. (Where will it all end? Somebody stop the madness!) This should handle about 99 percent of our needs.||好, 又解决问题了. 就是说, 直到我们需要的库取决于计算的结果. (要到哪里算是个头啊？停下来吧！)我们99％的需求可以满足了. 
A hash reference prints as a string that looks like HASH(0x1a2b3c), showing the hexadecimal memory address of the hash. That's not very useful to an end user and only barely more usable to the programmer, except as an indication of the lack of appropriate dereferencing.||如果打印一个散列引用, 会得到一个类似于HASH(0x1a2b3c)一样的字串, 显示这个散列在内存中的用十六进制表示的地址. 这个对终端用户来说没有多少用处. 除非表示没有很好还原, 这个对程序员来说也没多大用处. 
Next, we replace the name of the subroutine with curly braces around the thing holding the reference:||下一步, 我们把子程序的名字用引用变量名字外套花括号代替：
The last expression evaluated in the file must return a true value.||文件最后一个求值必须返回真值
[*] It's not that it hasn't been discussed repeatedly by the Perl developers; it's just that nobody has come up with a nice backward-compatible syntax with universal appeal.||这并非没有被Perl开发者重复讨论过;那只不过是没有人能提供一个得到广泛认可的向后兼容的办法. 
Now we've added a second destination to the hash that records information for all bytes originating at ginger. girl. hut. Because that was the final line of data (in this run), a step brings us down to the lower foreach loop:||现在我们已经给源发于ginger. girl. hut. 的主机加了两个目标主机在散列中了. 因为这是数据的最后一行(这次运行中), 单步执行带我们到更底的那一层：
This is implemented as:||实现结果是：
So let's get started. Class begins after you turn the page. . . .||好吧, 开始喽. 翻过此页, 我们的课就马上开始… …
Removing the top of a tree of data generally removes all the data contained within. The exception is when we make additional copies of the references of the nested data. For example, if we copy Gilligan's provisions:||一般来说, 如果删除了一个复杂数据结构的根数据, 会把其包含的子数据全删除. 一个例外就是当我们对其嵌套数据进行了引用. 比如说, 如果我们拷贝了Gilligan的装备：
All that's required is a bit of indirection. [*] First, we have a selection problem, so we use a grep. Let's not grep the values themselves but the index for each item:||要完成这项任务需要一些小手段. [*] 首先, 我们有个拣选的问题, 因此, 我们使用grep. 我们不抓元素值本身, 找它们在列表里的位置. 
That's a bit too much work, though, so brian created the cpan script, which also comes with Perl. We simply list the modules we want to install, and it handles it for us.||如果觉得用上面的方法还烦琐, brian写了个cpan脚本放在Perl的发行包里. 我们只要简单的列出要安装的模块, 由脚本来处理余下的事情. 
11. 5. A Few Notes About @ISA||11. 5. 有关@ISA的一些说明
Here the ?: operator selects either the dereference or a derived string. Now we can use it with either an instance or a class. Note that we changed the first parameter holder to $either to show that it is intentional:||这里?:操作符选择是否是还原或是类字串. 现在不管是实例或者是类我们都可以使用他们. 注意, 我们把第一个参数位改成$either来显示这是有意的：
This magical @ISA variable (pronounced "is a" not "ice-uh") declares that Cow "is a" Animal. [*] Note that it's an array, not a simple single value, because on rare occasions it makes sense to have more than one parent class searched for the missing methods. We'll show more about that later.||这个神奇的@ISA变量（发音是"is a"不是"ice-uh"）声明了Cow"是一个"动物. [*] 注意它是一个数组, 不是一个简单的标量值, 因为在罕有的情况下它可能有多重祖先, 我们将会在下面讨论这个问题. 
Feel free to crank up the explicitness if it helps you and your coworkers understand and maintain the code. That's the main thing that matters.||如果显式使用中间变量能使代码让你和你的同事更易理解和维护代码的话, 尽管用它. 好代码才是主要的. 
At this point, we asked the monkey seven questions in a row, but that's the last time we have to talk to the monkey! We now have everything we need to finish the task.||这次, 我们在一次把把七个问题向猴子问完了, 但这也是最后一次！ 我们现在已经有了要完成任务所有的东西了. 
[*] You don't need the ampersand in front of any of these subroutine invocations, because the subroutine name is already known to the compiler following use.||你不必在这些调用的子例程的前面加"＆"符号, 因为编译器已经知道子例程的名字了. 
Here's the result:||下面是产生的结果：
When we turn on use strict, we'll get complaints on @ISA because it's not a variable containing an explicit package name, nor is it a lexical (my) variable. We can't make it a lexical variable, though: it has to belong to the package to be found by the inheritance mechanism.||当我们打开strict后, 我们会有关于@ISA的警告信息, 因为它既不是一个有明确包名的变量, 也不是一个词法（my声明)的变量. 我们不能把它定义为词法变量, 因为它属于它所继承的那个包. 
Now, with the new named method, we build a Horse:||现在, 用新的named方法, 我们来创建一个Horse:
10. 5. 3. Extending @INC with -I||10. 5. 3. 用 -I 扩展@INC
4. 9. 1. Exercise 1 [5 min]||4. 9. 1. 练习 1 [5 分钟]
You already know about several list operators in Perl, but you may not have thought of them as working with lists. The most common list operator is probably print. We give it one or more arguments, and it puts them together for us.||你可能已经知道Perl的一些列表操作符, 但并没有想过他们是怎么同列表一起工作的. 最常用的列表操作符应该是print了. 我们给它一些参数, 然后它把他们合在一起显示出来. 
[] Actually, it imports them into the current package, but we haven't told you about those yet.||[+]事实上他们被它引入当前的包, 只不过我们没有告诉你这些而已. 
4. 3. Dereferencing the Array Reference||4. 3. 还原一个指向数组的引用
In Bourne-style shells, he'd use something like:||在Bourne类型的shell中, 他可以用类似于如下的行：
And once again, this results in:||同样, 其输出是：
In this case, we are passing both data (the list of starting directories) and behavior as parameters to the find routine.||在此例中, 我们传了两项数据（开始搜索的目录）和给find子程序的行为子程序作为参数. 
A lexical variable (a variable introduced with my) isn't prefixed by the current package because package variables are always global: we can always reference a package variable if we know its full name. A lexical variable is usually temporary and accessible for only a portion of the program. If we declare a lexical variable, then using that name without a package prefix gets the lexical variable. A package prefix ensures that we are accessing a package variable and never a lexical variable.||一个词法变量（以my声明的变量） 不会有当前包名做前缀, 因为包变量已经是全局的了：我们总是可以引用一个包变量, 如果我们知道它的全名. 一个词法变量通常是临时的或只在程序的局部可访问. 如果我们声明一个词法变量, 然后不带包前缀地使用它, 就获得一个词法变量. 一个包前缀保证我们可以访问一个包变量, 而不是词法变量. 
But that's not very nice, especially if we need to keep doing this kind of task repeatedly. Luckily, Perl has several ways to help us out.||不过这不是最漂亮的, 特别是当我们需要重复这些工作的时候. 好在, Perl 有多种途径来帮助我们. 
The Professor modified some files on Monday afternoon, and now he's forgotten which ones they were. This happens all the time. He wants you to make a subroutine called gather_mtime_between, which, given a starting and ending timestamp, returns a pair of coderefs. The first one will be used with File::Find to gather the names of only the items that were modified between those two times; the second one should return the list of items found.||周一中午, 教授修改了一些文件, 不过现在他忘了改了哪些文件. 这种事情老是发生. 他要你写个程序, 叫"gather_mtime_between". 这个程序接受开始和结束时间作为参数, 返回一对代码引用. 第一个会被File::Find模块用来收集那些修改时间在两个时间点之间的文件名;第二个将返回所有文件列表. 
To install a module, we use the i command.||我们用i命令来安装模块：
Throughout this book, we'll try to identify which modules comes with Perl (and in most cases, with which version they started coming with Perl). We'll call these "core modules " or note that they're in "the standard distribution. " If you have Perl, you should have these modules. Since we're using Perl 5. 8. 7 as we write this, we'll assume that's the current version of Perl.||在这本书里, 我们会向你标出哪些模块是Perl自带的（而且在大多数情况下, 会说明是从哪个版本开始收入Perl发行版中的）. 我们把它们称为"核心模块", 或者标注它们是在"标准发行版"中的. 如果你安装了Perl, 那你就可以用这些模块. 因为我们写这本书的时候是用的Perl 5. 8. 7版, 所以我们也假定这是Perl的当前版本. 
The basic structure maps the original list into a list of arrayrefs, computing the expensive function only once for each; sorts those array refs, looking at the cached value of each expensive function invocation;[*] and then extracts the original values back out in the new order. All we have to do is plug in the proper two operations, and we're done. For example, to use the Schwartzian Transform to implement a case-insensitive sort, we could use code like this:[]||基本的结构将原始的列表变成一个数组引用的列表, 为每个成员只计算一次昂贵的计算; 将数组引用排序以缓存中通过前面昂贵的计算得到的结果进行排序［＊］, 然后抽出原始的值, 以前的次序排. 我们所要做的全部工作就是将两个操作合适发安排, 然后事儿就这样成了. 比如, 按照施瓦茨变换来实现一个不区分大小写的排序, 我们可以这样编码：［＋］
The Perl object architecture relies heavily on packages, subroutines, and references, so if you're skipping around in this book, please go back to the beginning. Ready? Here we go.||Perl的对象结构严重依赖于包, 子例程和引用, 所以如果你已经跳过书中的这些章节, 请回到开始的部份好好看完. 准备好了吗？我们开始. 
We set the value of @all_with_names to contain three references. Inside the subroutine we have named arrays with references to arrays first placed into other named arrays. Eventually, the values end up in the global @all_with_names. However, as the subroutine returns, the names for the six arrays disappear. Each array has had one other reference taken to it, making the reference count temporarily two, and then back to one as the name disappears. Because the reference count is not yet zero, the data continues to live on, although it is now referenced only by elements of @all_with_names.||我们用数组@all_with_names的值来放三个引用. 在子程序里, 我们命名了一些数组, 而这些数组指向了事先命名的另外的数组. 最终, 这些值最后放到一个全局的数组@all_with_names中. 然而, 当子程序返回时, 这些六个数组的名字被锁毁. 正因为每个数组都有另外一个引用指向它, 所以导致引用计数临时是2, 但当数组名字销毁后, 计数又回到1. 因为引用计数没有回到零, 数据仍然在, 尽管它向在仅仅被当做数组@all_with_names的元素. 
For a plain file, dump the pathname; for a directory, $data is a hash reference. Let's walk through the keys and dump the values:||对于文件, 我们打印出路径名; 对于目录, 变量$data是一个散列引用. 我们则遍历所有的键, 输出对应的值：
12. 3. Accessing the Instance Data||12. 3. 访问实例数据
On each pass, only the handle pairs that evaluate as true in the grep CONDITION survive. Inside, we take the first element of each pair and try to read from it. If that's successful, write that line to the second element of the pair (the corresponding output handle). If the print is successful, it returns true, which lets grep know that we want to keep that pair. If either the print fails or the getline returns undef, the grep sees the false value as an indication to discard that pair. Discarding the pair automatically closes both filehandles. Cool!||在每个传输过程中, 只有那些通过grep条件测试的句柄对才会留下. 在条件测试中, 我们拿句柄对中第一个元素并读取其中内容. 如果处理成功, 则向句柄对中第二个元素（对应的输出句柄）写行. 如果打印成功, 它返回true, 这样就让grep知道我们要保留那个句柄对. 只要打印失败或取行返回未定义值, grep就会认做false并放弃那个句柄对. 放弃句柄对自动就关闭了输入输出句柄. 太妙了！
If we return the object itself, we can chain settings:||如果想返回对象自身, 我们可以链式设置：
Like Learning Perl, this book relegates some of the more esoteric items out of the way for the first reading and places those items in footnotes.||同《Learning Perl》这本书的做法一样, 我们把那些深奥的概念移掉了, 并把他们做为脚注[*]. 
If every name has a package name inserted in front of it, what about names in the main program? Yes, they are also in a package, called main. It's as if package main; were at the beginning of each file. Thus, to keep Gilligan from having to say Navigation::turn_toward_heading, the navigation. pm file can say:||如果每个名字前面都有包名字, 那么主程序的名字会是什么？是的, 他们同样有包名字, 称作main. 就好象在main这个程序包里面;在每个文件开始的地方. 所以, 要Gilligan避免说Navigation::turn_toward_heading, navigation. pm文件中可以用：
1. 2. What About All Those Footnotes?||1. 2. 那些脚注是怎么回事？
The strategy here for an indirect grep or map is to think of the $_ values as identifying a particular item of interest, such as the key in a hash or the index of an array, and then use that identification within the block or expression to access the actual values.||这里运用grep或者map的技巧是把$_值作为感兴趣的特定元素的标识来用, 比如散列的键或者数组的索引, 然后, 用这些标识, 在块中或者表达式中来访问实际的元素内容. 
Imagine for a moment that the intermediate variables are all part of a subroutine:||想像一下中间变量全是子程序一部份的情况：
To dump the data, we need to know the name of the directory at the top of the tree, because that's not stored within the structure:||为了打印出数据, 我们必须知道顶层目录的名字, 因为它不会存储在嵌套结构中：
We're taking a reference to the subroutine skipper_greets( ). Note that the preceding ampersand is mandatory here, and the lack of trailing parentheses is also intentional. Perl stores the reference to the subroutine (a coderef) within $ref_to_greeter, and, like all other references, it fits nearly anywhere a scalar fits.||我们现在取子程序skipper_greets()的引用. 注意, 前导的&字符在这里是强制必须的, 而其后的小括号也不要加. Perl会把对这个子程序的引用放到变量$ref_to_greeter中, 而且, 同对其它的引用一样, 它适合于任何可以使用标量的地方. 
Normally we want to ensure that this happens before anything else, so we can wrap it in a BEGIN block. Perl executes the code in the BEGIN block during the compile phase before the require executes at runtime. Otherwise, Perl executes statements in the order that it finds them, and we have to ensure that our unshift shows up before our require.||一般来说, 我们要保证添加搜索目录一定要放在其它事之前, 我们可以把它放进BEGIN块. Perl会在编译阶段执行在BEGIN块中的语句, 而在运行时执行require语句. 除此之外, Perl会以文件中的自然顺序执行语句, 所以我们要保证我们的unshift要出现在我们的require之前. 
Notice the use of local there. A typeglob works with the symbol table, which means it's dealing with package variables. Package variables can't be lexical variables, so we can't use my. Since we don't want to stomp on anything else that might be named FH somewhere else in the script, we must use local to say that the name FH has a temporary value for the duration of the log_message subroutine and that when the subroutine finishes, Perl should restore any previous values to FH as if we were never there.||注意这里local的用法. 一个typeglob同符号表一起工作, 这意味着它处理包变量. 包变量不能是词法变量, 所以我们不能用my. 因为我们不能与程序其它部份的以FH命名的句柄混淆, 我们必须用local告诉Perl这个FH是在log_message子程序中用作临时变量, 用完即丢, Perl会把原来的FH句柄恢复, 好像没有发生过一样. 
9. 9. 1. Exercise 1 [15 min]||9. 9. 1. 练习 1 ［15分钟]
The last step doesn't have a shortcut arrow form. Oh well. [*]||得, 最后一步不必要箭头快捷方式了. 
The benefits of OOP become worthwhile when our program (including all external libraries and modules) exceeds about N lines of code. Unfortunately, nobody can agree on what the value of N is, but for Perl programs, it's arguably around 1, 000 lines of code. If our whole program is only a couple hundred lines of code, using objects is probably overkill.||当程序超过Ｎ行的时候, 面向对象的好处就显露出来了. 不过, 对于这个Ｎ到底是多少, 各有各的持法, 但对于Perl程序来说, 1000行左右代码是比较能被接受的. 如果我们的程序就区区几百行, 用面向对象编程可能就太过了. 
The File::Spec module provides several other methods for dealing with file paths in a portable manner. You can read more about portability issues in the perlport documentation.||File::Spec 模块还提供了许多其它的方法来用可移植的方式处理路径. 你可以通过perlport文档了解更多有关移植方面的专题. 
In fact, even if there's only one item, we tend to write it with a qw( ) list for consistency and maintenance; often we'll go back to say "give me another one from here, " and it's simpler if it's already a qw( ) list.||实际上, 即便只有一个参数, 我们为了维护起来的一致性, 也倾向于用qw()这样的形式. 因为我们往往过后再回来找到这段代码说："得在这里再加个参数", 如果我们一开始用qw()来写的话, 维护起来会更简单. 
Of course, we can shorten this as well, since the entire dereferenced array matches the argument list precisely:||当然, 我们可以把这个过程再简化, 因为整个还原数组与参数清单精确对应：
Immediately after the new empty hash was put in place, a new key/value pair was added, indicating 1250 bytes transferred from thurston. howell. hut to lovey. howell. hut. Let's step some more:||在空散列被加好之后, 马上一个新的键/值对被加上, 标示1250字节从thurston. howell. hut传到lovey. howell. hut. 让我们单步执行, 查看一下：
Building Recursively Defined Data||构建嵌套定义的数据
Behind the scenes, Perl is really using the IO::Handle module to work this magic, so our filehandle scalar is really an object. [*] The IO::Handle package is a base class for input-output things, so it handles a lot more than just files.||在帷幕之后, Perl实际上用调用IO::Handle模块来变这个戏法的, 所以, 我们的文件句柄实际上是一个对象[*]. IO::Handle包是输入输出的基础类, 所以它处理许多不仅仅有关文件的操作. 
We can also perform transformations. For example, turn this hash into a list of array references, with each array containing two items. The first is the original person's name; the second is a reference to an array of the provisions for that person:||我们还可以把数据转换成其它格式. 比如, 将散列转换成一个对数组的引用, 其中每个数组含有两个元素. 第一个元素为乘客名字, 第二个元素则是对这个乘客的装备列表的引用：
The File::Basename module knows what sort of system it's on, and thus its functions figure out how to correctly parse the strings for the different delimiters we might encounter.||File::Basename会自己"感知"它所处的是哪种操作系统, 并且因此针对所遇到的操作系统, 用不同的分隔符来解析字串. 
Part of the work involved rearranging and organizing the separate archives. Places were established for Perl binaries for non-Unix architectures, scripts, and Perl's source code itself. However, the modules portion has come to be the largest and most interesting part of the CPAN.||这个站点的一部份工作是重新编排和组织分离的Perl文档. 建立起放置为非UNIX系统的二进制文件、脚本、和Perl源代码的空间. 然而, CPAN当然最关心的是占空间大部份的Perl模块部分. 
Dereference that as an array reference, taking the second element of that array (index number 1).||用同样的方法取出那个数组第二个元素（序号为1）
Subroutines||子程序
Which way is better? When should we use a reverse sort, and when should we switch $a and $b? Well, in most cases it shouldn't matter much for efficiency, so it's probably best to optimize for clarity and use reverse. For a more complex comparison, however, a single reverse may not be up to the task.||哪种方法更好？ 什么时间我们用reverse来反向排序, 什么时候用交换 $a和$b位置来排序呢？ 好, 大多数情况下, 他们对性能上没有什么差异. 所以可能为了表达清楚, 我们用reverse. 然而, 为了更复杂的的比较, 单个reverse又可能不是最好. 
Although we kept the value in a scalar variable, we could have put that sub { ... } construct directly into the initialization of the greetings hash:||尽管我们可以把代码引用作为标量值保存, 但我们也可以直接把sub {...} 代码块直接放在初始化的greetings散列中：
Some upcoming version of Perl is likely to use garbage collection in addition to, or instead of, referencing counting. [*] Until then, we must be careful not to create circular references or, if we do, break the circle before the variables go out of scope. For example, the following code doesn't leak:||另外, 经后的Perl可能会使用垃圾收集器来代替计数引用. [*] 不过到现在, 我们必须注意不要建立循环引用, 或者, 如果我们做的话, 在变量跑出范围时, 要去掉循环引用. 比如, 下面的代码不会造成内存泄漏：
There are a couple of straightforward ways to handle the declaration and setting of @ISA. The easiest is to just spell out the package name:||有两个简单方法来处理对@ISA的声明和设置. 最简单的方法是指出包名：
Things get a bit more complicated when the libraries aren't in the current directory. In fact, Perl searches for libraries along a library search path, similar to what the shell does with the PATH environment variable. The current directory (represented in Unix by a single dot) is an element of the search path. So, as long as our libraries are in our current working directory, everything is fine.||当库文件不在当前目录的时候, 事件就有些复杂了. 实际上, Perl按库一个库搜索路径来查找库, 有些像UNIX shell用PATH环境变量一样. 当前目录（在Unix里以句点表示）是查寻目录之一. 所以只要我们的库在我们的当前工作目录, 就没问题. 
Now the Professor wants to produce a summary of the source host, the destination host, and the total number of transferred bytes for the day. Tabulating the data is as simple as:||现在, 教授要生成一个有关源主机, 目标主机和总传输字节数的报表. 把数据列表显示出来：
Let's listen to those animals for a moment:||让我们听一下那些动物的叫声：
and we get our desired output.||这样就得到我们需要的输出结果. 
3. 9. Setting the Path at the Right Time||3. 9. 适时地打开路径
Write a program that asks the user to enter a pattern (regular expression). Read this as data from the keyboard; don't get it from the command-line arguments. Report a list of files in some hardcoded directory (such as "/etc" or 'C:\\Windows') whose names match the pattern. Repeat this until the user enters an empty string instead of a pattern. The user should not type the forward slashes that are traditionally used to delimit pattern matches in Perl; the input pattern is delimited by the trailing newline. Ensure that a faulty pattern, such as one with unbalanced parentheses, doesn't crash the program||写一个程序要求用户输入一个正则表达式的模板. 不要以命令行参数形式输入, 要从键盘读取. 然后从一些目录中（可以是硬编码的, 如： "/etc" 或 'C:\\Windows'）中读取符合模板的文件名. 重复这个操作直到用户输入空串. 要屏蔽用户输入的正斜杠("/"), 因为那是Perl里正则表达式的分隔符;输入的模板用换行符为分隔. 要保证不会因为用户输入了一个错误的正则表达式, 如括号不匹配之类的, 而导致程序崩溃. 
Think of use lib as not "use this library" but rather "use this path to find my libraries (and modules). " Too often, we see code written like:||要注意到：use lib不是指"用这个库", 而是指"用这个路径可以找到我的库（以及模块）. " 很多情况下, 我们会看到代码被写成这样：
What if we want to use File::Find to accumulate the total size of all files seen? The callback subroutine cannot take arguments, and the caller discards its result. But that doesn't matter. When dereferenced, a subroutine reference can see all visible lexical variables when the reference to the subroutine is taken. For example:||如果我们要用File::Find来累加所找到的所有文件的大小的话, 应该如何做呢？回调子程序不能有参数, 而调用者也忽略回调子程序返回的结果. 但这没有关系. 在还原后, 一个子程序引用可以看到所有指向子程序的引用的可见词法变量. 例如：
So, if we know the relative path from the script directory, we don't have to hardcode the whole path. This makes the script more portable.||这样, 如果我们知道脚本目录的相对路径, 我们就不必硬编码全路径了. 这使我们的脚本更加易于移植. 
[*] Except lexicals, as we'll show in a moment.||[*] 除了词法变量, 我们会在后面说到. 
Thus, we can replace that final loop with:||因而, 我们可以把最后的循环语句替换成：
then when we remove @all_with_names, we still have one live reference to what was formerly @gilligan, and the data from there downward remain alive.||然后我们删除了@all_with_names, 我们有一个活的引用指向之前的@gilligan, 其下的数据也依然在. 
Recursive algorithms deal with the unlimited complexity of their data by beginning with a base case and building upon that. [*] The base case considers what to do in the simplest case: when the leaf node has no branches, when the array is empty, when the counter is at zero. In fact, it's common to have more than one base case in various branches of a recursive algorithm. A recursive algorithm with no base case is an infinite loop.||递归算法用处理起始的一个基础例子并由此建立的程序来处理无限复杂的数据. [*] 所谓基础例子是指在一个最最简单的情况下如何处理：没有分支的叶子节点, 当数组还是空的情况, 当计数器是零时. 实际上, 在递归算法的不同分支中一般有多个基础例子. 如果递归算法没有基础例子, 程序就会导致无限循环. 
This time, we added a new source, ginger. girl. hut. Notice that the top level hash now has three elements, and each element has a different hash reference value. Let's step some more:||这次, 我们添加了个新的源主机, ginger. girl. hut. 注意顶层散列现在有三个元素了, 每个元素有一个不同的散列引用. 好, 我们继续：
We can also flip it around a bit with the arrow notation:||我们也可以把它转换成带箭头的格式：
This general technique can be convenient if we need to look at our data in more than one way. Perhaps we keep many records in order by a numeric code for efficiency reasons, but we occasionally want to view them in alphabetical order as well. Or maybe the data items themselves are impractical to sort, such as a month's worth of server logs.||这些一般的方法可以使方便地我们以不同的角度来看我们的数据. 可以我们以效率的原因使我们数据以数字顺序排, 但有时我们又要他们以字母顺序排. 或者, 可能这些数据项目自己本身顺序并没有多大意义, 比如一个月的服务器日志的价值. 
8. 4. 4. IO::Tee||8. 4. 4. IO::Tee
The result is a typical day on that tropical island:||输出结果如下, 岛上典型的一天是这样的：
The keys of %provisions are names of the people. For each name, we construct a two-element list of the name and the corresponding provisions array reference. This list is inside an anonymous array constructor, so we get back a reference to a newly created array for each person. Three names in; three references out. [*] Or, let's go a different way. Turn the input hash into a series of references to arrays. Each array will have a person's name and one of the items they brought:||散列%provisions的键是乘客的人名. 对于每个人名, 我们构键一个两个元素的列表, 其中有名字和对应的对装备清单列表的引用. 这个列表是由匿名数组构建的, 这样我们就获得每个乘客新创建数组的引用. 三个名字进去, 三个引用出来, [*] 或者, 让我们变换一种方法. 把输入的散列转换成一系列对数组的引用. 每个数组将有一个乘客的名字和一个由他身带的装备：
Except in regard to @INC, %INC, and missing file handling, which we'll show later.||[+] 这排除了考虑@INC、%INC的情况, 以及丢失文件定位处理, 这个我们在后面的章节会遇到. 
However, now the Skipper decides to modify his navigation. pm library, adding a routine called turn_toward_port that makes a 45-degree turn toward the left (known as "port" in nautical jargon).||然而, 现在Skipper决定修改他的navigation. pm库, 加一个子程序：turn_toward_port, 使船可以以45度角向左舷转向（航海术语, 左舷是靠向岸的舷）. 
Typically, all references to a variable are gone before the variable itself. But what if one of the references outlives the variable name? For example, consider this code:||一般来说, 引用总是比其指向的变量之前被释放. 但是如果引用比其指向的变量活得长会发生什么情况？比如, 考虑下面的情况：
Let's start with a simple example:||让我们开始一个简单的实例：
This chapter looks at how to break up a program into pieces and includes some of the concerns that arise when we put those pieces back together again, or when many people work together on the same program.||这一章我们来看看如何把程序分成一些小的部份, 并且包括那些把小程序组合成一个整体时会发生的问题. 以及多个人协同完成一个项目时分发生的问题. 
When we do this, File::Basename introduces three subroutines, fileparse, basename, and dirname, [*] into our script. [+] From this point forward, we can say:||当我们写上如上的代码后, File::Basename 向你的脚本引入了三个子例程［＋］：fileparse, basename和dirname. [*] 自此之后, 我们就可以用如下语句了：
12. 11. Don't Look Inside the Box||12. 11. 不要往盒子里看
If you do not like that (for the same reasons as regular open), use one of the other calling conventions. The optional second argument is the filehandle mode.||如果不喜欢用这种方式（因为同样原因也不喜欢标准open）, 你可以用另一种调用约定. 可选的第二个参数是文件句柄的打开方式. [+]
This block does not work when you put it after those invocations because there are two functional parts to the first line:||如果把裸块放在那些调用之后的话就不会工作, 因为有两个功能部分牵涉到下面这行：
Don't confuse the square brackets with the parentheses here. They each have their distinct purpose. If we replace the square brackets with parentheses, we end up with a six-element list. If we replace the outer parentheses (on the first and last lines) with square brackets, we construct an anonymous array that's two elements long and then take the reference to that array as the only element of the ultimate @skipper_with_name array. [*] So, in summary, if we have this syntax:||别把这里的方括号和小括号搞混了. 它们各有不同的目的. 如果我们用小括号代替方括号, 我们结果会得到一个六个元素的列表. 如果我们将外圈的（第一行和最后一行）的小括号用方括号代替, 我们就构建了一个两个元素长的匿名数组的引用, 并将其返回给@skipper_with_name数组. [*] 这样, 总之, 如果我们有以下的代码：
The IO::Scalar module uses the magic of tie behind the scenes to give us a filehandle reference that appends to a scalar. This module doesn't come with the standard Perl distribution, so you'll have to install it yourself most likely.||IO::Scalar模块在幕后是使用tie来实现魔法的, 它把一个文件句柄引用给一个标量. 这个模块不在标准的Perl发行版中, 所以你可能必须自己安装它. 
[*] As well as a utility routine, fileparse_set_fstype.||[*] 以及实用例程, fileparse_set_fstype. 
A subroutine does not have to be an anonymous subroutine to be a closure. If a named subroutine accesses lexical variables, and those variables go out of scope, the named subroutine retains a reference to the lexicals, just as you saw with anonymous subroutines. For example, consider two routines that count coconuts for Gilligan:||要做成一个闭包, 并不一定非要搞成匿名子程序. 如果一个命名子程序访问那些跑出范围的词法变量, 其作用就如同你用匿名子程序一样. 比如, 考虑一下两个为Gilligan计算椰子的子程序
In this example, the array @_ contains two elements, one of which is also an array. What if we take a reference to an array that also contains a reference to an array? We end up with a complex data structure, which can be quite useful.||在前例中, 我们的数组@_有两个元素, 其中一个同样是个数组. 如果一个引用所指向的数组中还包含着另外一个指向数组的引用会是什么情况？那就成了非常有用的所谓复杂数据结构. 
10. 5. 2. Extending @INC with PERL5LIB||10. 5. 2. 用PERL5LIB环境变量扩展@INC
3. 1. The Standard Distribution||3. 1. 标准发行版
11. 6. Overriding the Methods||11. 6. 重载方法
The six subroutines (and the three $total_size variables they share) are reference counted. When we modify %subs or it goes out of scope, the values have their reference counts reduced, recycling the contained data. (If that data also references further data, those reference counts are reduced appropriately. )||六个匿名子程序（他们共享了三个$total_size变量）是引用计数的. 当我们修改%subs或者它跑出范围时, 引用计数减少, 重用他们包含的数据. （如果这些数据同样引用其它数据, 那么那些数据的引用计数也相应减少. ）
Most libraries have only one package declaration at the top of the file. Most programs leave the package as the default main package. However it's nice to know that we can temporarily have a different current package.||大多数的库只在一个文件里放一个包, 并且在文件开始的地方声明包名. 大多数的程序就把缺省的main作为包名. 不过知道我们可以临时有个不同的当前包名是不错的. [+]
The synopsis gives us examples of the module's use, and if we can suspend understanding for a bit and follow the example, we can use the module. That is to say, it may be that you're not yet familiar with some of the Perl techniques and syntax in the synopsis, but you can generally just follow the example and make everything work.||synopsis节给我们关于这个模块的用法的例子, 这样我们就可以稍微理解了用法就可以使用这个模块. 就是说, 这可以使你在还没有熟悉Perl技术和语法的情况下, 仅仅看这些例子, 就可以使程序工作起来. 
In C, this is known as a static local variable: a variable that is visible to only a subset of the program's subroutines but persists throughout the life of the program, even between calls to those subroutines.||在C语言里, 这被称作静态本地变量： 一个变量仅仅在程序子程序的一小块代码中可见, 但会在程序的生命周期内保留其值, 甚至在那些子程序的数次调用中也保留值. 
If we use code outside the class that looks at $tv_horse->{Color} directly, this change is no longer possible. It won't work to store a string ('blue') where an arrayref is needed ([0, 0, 255]) or to use an arrayref as a string. This is why OO programming encourages you to call getters and setters, even if they take some time.||如果我们在类的外面直接看$tv_horse->{Color}, 这样的改变是不可能的. 它不能在存数组引用（[0, 0, 255]）的地方存字串（'blue'）或把数组引用当作字串. 这就是为什么面向对象的编程鼓励你用设置器或取值器, 尽管他们可能费些写代码的时间. 
Here, we declare a variable to hold the callback. We cannot declare this variable within the naked block (the block following that is not part of a larger Perl syntax construct), or Perl will recycle it at the end of that block. Next, the lexical $count variable is initialized to 0. We then declare an anonymous subroutine and place its reference into $callback. This subroutine is a closure because it refers to the lexical $count variable.||这儿, 我们定义了一个保存有回调子程序引用的变量. 我们不能在裸块中定义这个变量（其后的块并非Perl语法构建的一部份）, 或者Perl在块结束时会回收它. 之后, 词法变量$count变量会初始化为0. 我们声明一个匿名子程序并把其引用给$callback. 这个子程序就是个闭包, 因它指向词法变量$count. 
In any of these forms, when the scalar variable goes out of scope (or we assign another value to it), Perl closes the file. We don't have to explicitly close the file ourselves.||在以上的各种使用方式中, 只要这个标量变量跑出范围（或者我们赋另一个值给它）, Perl就会自动关闭文件. 我们不必自己显式地关闭文件. 
Because %total_bytes is initially empty, Perl doesn't find the first key of professor. hut, but it establishes an undef value for the dereferencing as a hash reference. (Keep in mind that an implicit arrow is between the two sets of curly braces here. ) Perl sticks a reference to an empty anonymous hash in that element, which it then immediately extends to include the element with a key of gilligan. crew. hut. Its initial value is undef, which acts like a zero when you add 1250 to it, and the result of 1250 is inserted back into the hash.||因为散列%total_bytes初始时是空的, Perl没有找到第一个以professor. hut命名的键, 但它会为了还原而建立一个未定义值作为散列引用. （记住, 这里在花括号间有隐含的箭头. ）Perl会在那个元素里放个指向空值的匿名散列, 这样它可以立即扩展数组, 将把gilligan. crew. hut作为一个元素放入. 它的初始值是未定义值, 与零等同, 而当你把1250与它相加的时候, 其相加的结果1250也放回散列. 
Now our log message ends up in the scalar variable $string_log instead of a file. What if we want to read from our logfile, though? We do the same thing. In this example, we create $scalar_fh just as we did before, then read from it with the line input operator. In our while loop, we'll extract the log messages that contain Gilligan (which is probably most of them, since he's always part of the mess):||现在我们的日志信息不是放在文件中, 而是放在标量变量$string_log中. 那我们如何从我们的日志文件中读呢？ 故伎重演而已. 在这个例子中, 我们象之前一样创建变量$scalar_fh, 然后用用输入操作符从中读行. 在我们的while循环中, 我们从日志信息中抽出包含Gilligan的行（应该有很多吧, 因为他总是纠缠在许多事情中）：
[*] In Perl, there really isn't a difference between a subroutine and a method. They both get an argument list in @_, and we have to make sure we do the right thing.||[*] 在Perl, 实际上子程序和方法没什么差别. 他们都以@_作参数, 我们来决定什么是对的. 
What's this default_color? If named has only the name, we still need to set a color, so we'll have a class-specific initial color. For a sheep, we might define it as white:||那么缺省毛色呢？
This rule also means that it's easy to see where the "missing" braces need to go. When we see $$items[1], a pretty noisy piece of syntax, we can tell that the curly braces must belong around the simple scalar variable, $items. Therefore, $items must be a reference to an array.||这个规则也方便我们知道哪里丢了大括号. 比如我们看到$$items[1]的时候, 知道这会有些语法上的麻烦, 我们会意识到必须在简单标量变量$items周围加上大括号. 如此, $items必须是一个指向数组的引用. 
You can find the answers to these exercises in "Answers for Chapter 2" in the Appendix.||答案在附录中的"第二章的答案"中;
[*] You are using warnings, right? You can enable them with either -w or use warnings;.||[*] 你开启警告是吗？你可以用-w开关, 以及use warnings来开始警告;
whereas both of these refer to the second item of the array:[*]||同样, 下面两行同指这个数组的第二个元素：[*]
By changing the Animal class to the SUPER class in that invocation, we get a search of all our superclasses (classes listed in @ISA) automatically:||在调用时, 把Animal类改成SUPER类, 我们可以自动查到我们的所有的超级类（在@ISA列表中的类）：
9. 3. Sorting Efficiently||9. 3. 更有效率的排序
Note that because we've stopped using the method arrow, we have to include the $class parameter (almost surely the value Mouse) as the first parameter to Animal::speak.||注意, 因为我们已经不用方法箭头, 我们必须用$class参数（当然其值是Mouse）作为Animal::speak的第一个参数. 
This book will also show you how to deal with larger and more complex data structures, such as what we might casually call a "hash of hashes" or an "array of arrays of hashes of arrays. "||这本书也展示了如何处理更大和更复杂的数据结构. 例如我们可能会提到的所谓一个"散列中的散列", 或"数组中的数组中的散列中的数组". 
For example, you'll learn how to work with multiple programmers on the same project.||比如, 你将会学到多外程序员如果在同一项目中一起工作. 
Note that the phrase REUSED_ADDRESS indicates that some parts of the data are actually references we've already seen.||注意, 短语REUSED_ADDRESS标示数据的一些部份实际上已引用了我们已经看到的一些数据. 
Perl has many other operators that work with lists, and, once you get used to them, you'll find yourself typing less and expressing your intent more clearly.||Perl 还有其它与列表打交道的操作符. 而且一旦你使用他们, 你会发现这些语句会使你表达得更清楚, 写更少的代码. 
Installing a simple module from CPAN can be straightforward: we download the module distribution archive, unpack it, and change into its directory. We use wget here, but it doesn't matter which tool you use.||安装从CPAN获得的简单模块可以很直接：先从CPAN下载发布的文档, 解压到一个目录. 下例中我们用wget下载文档, 当然, 你可以用你习惯的工具下载. 
Some of these modules do some of the same things that we can already do with Perl's built-in open (depending on which version of Perl we have), but they can be handy when we want to decide as late as possible which module should handle input or output. Instead of using the built-in open, we use the module interface. To switch the behavior, we simply change the module name. Since we've set up our code to use a module interface, it's not that much work to switch modules.||这些模块做的工作同Perl自带的open相同（这要依赖你使用的Perl的版本）, 但是, 当我们要尽可能晚的决定模块处理输入输出时, 用他们就很顺手. 代替我们使用内建的open, 我们使用模块接口. 我们只要简单的改一下模块的名字, 就可以改变行为. 因为我们已经为使用模块接口建立了代码, 切换模块就不费多少功夫. 
This is an efficient way to do this only if the uppercasing operation is sufficiently expensive, which it might be if our strings tend to be very long or if we have a large enough number of them. For a small number of not-long strings, a simple my @output_data = sort { "\U$a" cmp "\U$b"} @input_data is probably more efficient. If in doubt, benchmark.||这只是在当转换大写是非常昂贵时才是有效的, 或当我们的字串很长或要排的字串很多时. 对于小数量的或不长的字串, 简单的一句：my @output_data = sort { "\U$a" cmp "\U$b"} @input_data 就能解决问题, 足够有效率了. 如果不信, 作基准测试吧. 
Then, for each animal, we can say it inherits from Animal, along with the animal-specific sound:||这样, 对于每个动物, 我们说它继承自Animal, 并有此动物专有的叫声：
Why would we want to do that? Well, in the same way that taking a reference to an array lets you have the same code work on different arrays at different times, taking a reference to a subroutine allows the same code to call different subroutines at different times. Also, references permit complex data structures. A reference to a subroutine allows a subroutine to effectively become part of that complex data structure.||但我们为什么要做那个呢？ 与我们用指向数组的引用来实现用同一代码块在不同时间处理不同数组相同, 我们也可以使用指向子程序的引用实现在不同时间调用不同的子程序. 一样, 引用充许复杂的数据结构. 一个指向子程序的引用使子程序成为复杂数据结构的一部份成为可能. 
Now how do we get to Gilligan's first item?||现在我们如何时取得Gilligan的第一个装备呢？
In the get_provisions_list routine earlier, we created a half dozen array names that we used only so that we could take a reference to them immediately afterward. When the subroutine exited, the array names all went away, but the references remained.||在早前的get_provisions_list子程序中（参考5. 3节）, 我们建立了半打数组, 而且创建的目的仅仅是为了后面马上要给他们建立引用. 当子程序退出的时候, 所有数组名将销毁, 但引用还留着. 
9. 9. 2. Exercise 2 [15 min]||9. 9. 2. 练习2 ［15分钟]
The Perl debugger can display complex data easily. For example, let's single-step through one version of the byte-counting program from Chapter 5:||Perl的测试工具可以方便地显示复杂的数据结构. 例如, 让我们单步执行第五章中我们说过的那个字节计数的程序：
die inside sub?||若在子程序里出错退出程序呢？
We eliminated the reference to @data2 from within @data1, and vice versa. Now the data have only one reference each, which all go to zero references at the end of the block. In fact, we can clear out either one and not the other, and it still works nicely. Chapter 13 shows how to create weak references, which can help with many of these problems.||我们在@data1中对@data2的引用, 相反也一样. 现在两块数据只有一个引用, 在跑出块范围的时候, 引用计数会归零. 实际上, 我们清除任何一个引用就可以了, 程序一样工作得很好. 第13章会展示如何建立弱引用, 可以对这些问题有些帮助. 
[*] An expensive operation is one that takes a relatively long time or a relatively large amount of memory.||［＊］一个昂贵的操作是花相对时间长的操作, 或者相对使用大量内存的操作. 
These are the ANSI C fopen mode strings. You can also use these with the built-in open. Indeed, IO::File uses the built-in open behind the scenes.||[+]这些都是ANSI C 的fopen的文件打开方式的字串. 你在内建的open中也可以使用. 实际上, IO::File在后台也是使用内建的open函数的. 
Suppose navigation. pm itself also pulls in drop_anchor. pm for some common navigation task. Perl reads the file once directly and then again while processing the navigation package. This needlessly redefines drop_anchor( ). Worse than that, if we have warnings enabled, [*] we'll get a warning from Perl that we've redefined the subroutine, even if it's the same definition.||假定navigation. pm自己, 因为一些导航任务而把drop_anchor. pm引进自己的模块里. Perl在处理导航程序包的时候将文件一次直接读入. 在这次重新定义drop_anchor()是不必要的. 更糟的是, 如果我们把警告打开, 我们会从Perl得到一个警告信息, 说我们已经重新定义子程序, 尽管是一模一样的定义. 
Perl reads the code from navigation. pm into the $more_code variable. We then use eval to process that text as Perl code. Any lexical variables in $more_code remain local to the evaluated code. [*] If there's a syntax error, Perl sets the $@ variable and causes the subroutine to die with the appropriate error message.||Perl把navigation. pm程序的代码写入变量$more_code. 我们用eval来让Perl把这段文本以代码来处理. 任何$more_code变量中的词法变量被当作本地变量来求值. ［＊］如果其中有语法错误, Perl会设置$@变量, 并且导致程序以适当的出错信息退出. 
Again, this is more interesting in a directory that has subdirectories, but the output should be similar to:||同样, 如果散列数据有子目录的话, 效果更精彩. 不过输出结果同如下的脚本类似：
To have both Gilligan and the Skipper greet the Professor, we merely need to iterate over all the subroutines:||如果让Gilligan和Skipper向教授问好, 我们只需要迭代调用子程序就可以了：
For example, suppose we have our own directory under /home/gilligan/lib, and we place our own Navigation::SeatOfPants module in /home/gilligan/lib/Navigation/SeatOfPants. pm. When we load our module, Perl won't find it.||举个例子, 假定我们有个目录/home/gilligan/lib, 并且把模块Navigation::SeatOfPants放到这个目录下面的Navigation目录中的SeatOfPants. pm文件中. 但Perl在用如下语句调用我们的模块时是不会找到它的. 
start with 2||起始为 2
There are several other list operators that you already know about from Learning Perl. The sort operator puts its input list in order. In their theme song, the castaways don't come in alphabetical order, but sort can fix that for us.||在Learning Perl这本书里, 你可能知道了另外一些列表操作符. 如sort操作符将输入的列表按顺序列出. 在Gilligan's Island的主题歌中的那些求生者没有按字母次序出场, sort可以为我们修正这一点. 
On our local machine, we can read the module documentation with the perldoc command. We give it the module name we're interested in, and it prints out its documentation.||在我们的本机当中, 我们可以用perldoc命令来调出模块文档. 我们输入我们要查的模块的名字, 然后perldoc打印出文档内容：
However, at some point, we have to compare the number of pineapples that Gilligan has with another castaway as well. For example, suppose the pair is Ginger and Gilligan. We ask the monkey about Ginger, get a number back, and then ask the monkey about Gilligan... again. This will probably annoy the monkey a bit, since we already asked earlier. But we need to ask for each value two, three, or maybe even four times, just to put the seven values into order.||然而, 我们还得把Gilligan手中的持有的菠萝数量与其它castaway成员手中持有的菠萝数目相比较. 比如, 假定我们对比的是Ginger和Gilligan. 我们询问猴子Ginger的情况, 取得菠萝的数目后, 再去问Gilligan的情况, 以此类推. 这可能会让猴烦不胜烦, 因为我们早前已经问过它了. 但我们必须再二再三, 再三再四地为每个值去问, 直到把七个值排顺. 
From its small start of a few mirror machines, CPAN has now grown to over 200 public archives in all corners of the Net, all churning away, updating at least daily, sometimes as frequently as hourly. No matter where we are in the world, we can find a nearby CPAN mirror from which to pull the latest goodies.||从屈指可数的几台镜相服务器开始, CPAN如今已经成长为超过200公共服务器, 至少每天（有时是每小时）刷新一次的网络. 无论你在世界的哪头, 我们总是可以找到最近的CPAN镜相站. 
This can be a problem because it irritates the monkey.||这可能会成为一个问题, 这太刺激猴子了. 
Type in the Animal, Cow, Horse, Sheep, and Mouse class definitions. Make it work with use strict. Use our if you're using a recent enough version of Perl. Your program should ask the user to enter the names of one or more barnyard animals. Create a barnyard with those animals, and have each animal speak once.||输入Animal, Cow, Horse, Sheep, 和Mouse类的定义. 在use strict下可以工作. 如果你的Perl版本很新, 那么你可以用our关键字. 你的程序要问用户输入一个或多个农场动物的名字. 然后以这些动物创建整个农场, 每个动物都有自己的叫声. 
Because of the way the code is written, the setter also returns the updated value. Think about this (and document it) when we write a setter. What does the setter return? Here are some common variations:||根据代码的写法, 设置方法也可以返回更新的值. 当我们写设值代码时我们要考虑, 或者要写下来. 设置代码应该返回什么？下面是一般的答案：
So far, so good. We can check the Skipper and the Professor with just a bit more code:||到目前为止进展顺利. 我们可以检查船长和教授的装备, 只用如下一点代码：
Now @crew is identical to the value it had before, but we no longer need to invent names for the intermediate data structures. As before, the @crew variable contains two elements, each of which is a reference to a hash containing keyword-based information about a particular crew member.||现在@crew里所包含的值同先前是一样的, 但不再需要为中间数据结构起名字了. 就像上一个版本一样, @crew包含两个元素, 每个元素都是一个指向一个包含以键为基础的散列, 表示了船上成员的特殊信息. 
Write a program that prints the date and the day of the week, but allow the user to choose to send the output either to a file, a scalar, or both at the same time. No matter which output channels the user selects, send the output with a single print statement. If the user chooses to send the output to a scalar, at the end of the program print the scalar's value to standard output.||写一个程序打印一周的日期, 但要允许用户选择输出到文件或标量, 或者同时输出. 不论用户如何选择, 都必须用一个打印语句输出. 如果用户选择打印到标量, 那么在程序结束时, 要将其打印到标准输出. 
Now we're adding in some more bytes from professor. hut to lovey. howell. hut, reusing the existing value place. Nothing too exciting there. Let's keep stepping:||现在我们添加更多的字节从professor. hut到lovey. howell. hut, 我们用现存的值. 这儿没有什么新鲜的, 让我们继续：
Here, the expression 0. . $#input_numbers will be a list of indices for the array. Inside the block, $_ is a small integer, from 0 to 6 (seven items total). Now, we don't want to decide whether $_ has an odd digit sum. We want to know whether the array element at that index has an odd digit sum. Instead of using $_ to get the number of interest, use $input_numbers[$_]:||这里, 表达式0. . $#input_numbers会是这个数组的索引号列表. 在代码块里面, $_是个0～6的数字（总共7个元素）. 现在, 我们并不要决定是否$_的数位相加为奇数. 我们要决定的是在这个位置上的元素的数位相加是否为奇数. 所以, 我们感兴趣的不是$_, 而是$input_numbers[$_]:
An instance method with parameters gets invoked with the instance, and then the list of parameters. That first invocation is like:||一个带实例方法把实际作为参数, 然后是参数列表. 调用的样子如下：
Thus, $crew[0] is a hash reference to the information about Gilligan. We can get to Gilligan's name via any one of:||所以啦, $crew[0]的内容是指向Gilligan信息的一个散列的引用. 我们可以通过以下任一种方法取得Gilligan的名字. 
9. 6. Recursively Defined Data||9. 6. 数据的嵌套定义
You might pick up deeper insight into these topics in this book, but we're going to presume you know the basics.||我们可能在本书对这些话题进行深入探讨, 不过我们假定你已经掌握这些概念的基础知识. 
We can use these operators on more complex data. Taking the provisions list from Chapter 5:||我们可以用这些操作符在更复杂的数据结构中. 我们拿第五章的装备清单来看看：
You're probably here either because you want to learn to write programs that are more than 100 lines long or because your boss has told you to do so.||你来到这里的原因可能是你想比100行更长的 Perl 程序, 或者你的老板要你来学. 
The search is recursive, depth-first, and left to right in each @ISA.||[+] 查找是递归的, 在每个@ISA数组中是从上到下, 从左到右. 
That is, the do operator acts as if the code from navigation. pm were incorporated into the current program, although in its own scope block, so that lexicals (my variables) and most directives (such as use strict) from the included file don't leak into the main program.||那就是说, do 操作符的功能就像把navigation. pm中的代码直接引入现当前的程序一样, 尽管在它自己的块范围内, 所以词法变量（my 声明的变量） 和大多数指示字（如use strict）不会流到主程序里去. 
A class is a group of things with similar behaviors and traits. For now, let's say that Class->method invokes subroutine method in package Class. A method is the object-oriented version of the subroutine, so we'll say "method" from now on. [*] That's not completely accurate, but we'll go on one step at a time. Let's use it like so:||一个类是一组具有相同很行为性状的事物的集合. 对于Perl, 我们就认为类->方法就是Class包调用method子程序. 一个方法就是面向对象版本的子程序, 所以从现在开始, 我们会说"方法"[*] 这不是特别准确, 但是第一步. 让我们像下面那样使用：
Gilligan then has his program debugged (perhaps with the aid of a smart person whom we'll call "the Professor"), and everything works well.||Gilligan开始调试自己的程序（可能有一个有个聪明的人在帮他, 我们叫他"教授"）, 一切顺利. 
Walking through this from the outside in, we have a return value of three elements. Each element is an array reference, pointing to an anonymous two-element array. The first element of each array is a name string, while the second element is a reference to an anonymous array of varying lengths naming the provisions all without having to come up with temporary names for any of the intermediate layers.||我们由外而内地看一下上面的代码, 我们返回了三个元素. 每个元素是一个数组引用, 并且是指向有两个元素的匿名数组的引用. 内中每个数组第一个元素是名字字串, 而第一个元素又是一个变长的匿名数组的引用. 而且变长数组包括了所有的装备清单, 并且我们不必再提供临时名字作为中间变量. 
Let's train our animals to eat:||现在让我们训练我们的动物会吃：
For example, to sort those numbers in their proper order, we can use a sort block comparing $a and $b, like so:||举个例子, 以正常的次序对数字进行排序, 我们可以用个排序代码块比较$a和$b, 像这样：
Chapter 4. Introduction to References||第四章 介绍引用
Let's see what happens just after the next assignment:||我们看看下一个赋值会发生什么：
Because we no longer use the method arrow, we get one and only one chance to hit the right method because we're treating it like a regular subroutine with no inheritance magic. We'll look for it in Animal and not find it, and the program aborts.||因为我们不用方法箭头, 我们有一个且只有一个机会命中正确的方法, 因为我们对待它就像是一般的, 没有继承特色的子程序. 我们会在Animal类中找, 没找到它, 程序就停止. 
Now, have the Professor walk into the hut. Both of the Minnow crew greet the newest participant:||现在, 教授到屋子里来了. 这两个Minnow船员都向新来者问候：
into his typical navigation program, it's almost the same as if the eval code were executed right at that point in the program.||放到导航程序里的话, 它几乎同我们用eval把代码插在同一地点的执行结果是相同的. [+]
At this point, the second element of @skipper_with_name is a reference to the array formerly known as @skipper. However, that name is no longer relevant.||上例中, @skipper_with_name第二个元素是个指向先前命令的数组@skipper. 然而, 那个名字现在与程序不再有关系了. 
Then we dereference $self as a scalar reference, yielding Mr. Ed. The result is:||[+] 如果你把$self作为一个标量引用还原, 那么输出Mr. Ed是：
6. 8. Exercises||6. 8. 练习
From the earlier example, we plug in YAML where we had Data::Dumper, and use Dump( ) where we had Dumper( )||同早先的例子一样, 我们在程序中写Data::Dumper的地方替换成ＹＡＭＬ, 在用Dumper()函数的地方, 我们用Dump()函数代替. 
[*] On a Windows machine, use double quotes instead of single quotes on the command line.||[*] 在Windows操作系统的电脑上, 用双引号代替单引号. 
Perl next checks for speak inside Animal instead, as in Animal::speak. That found, Perl invokes that method with the already frozen argument list, as if we had said:||然后Perl就用Animal里的speak来代替了, 就是Animal::speak. 找到后, Perl用已经不变的参数列表来调用, 就像我们这样写的一样：
If we need to sort on more than one criterion, the Schwartzian Transform is still up to the task.||如果我们需要用多个测试条件进行排序, 施瓦茨变换照样可以处理这样的任务. 
If this transform looks like it might be too complex to memorize or come up with from first principles, it might help to look at the flexible and constant parts:||如果你觉得这个技巧太复杂而难以记忆或提供一种简明的办法, 下面这种简化成常量的表达可能更灵活一点：
As with array references, we can use shortcuts to replace the complex curly-braced forms under some circumstances. For example, if the only thing inside the curly braces is a simple scalar variable (as shown in these examples so far), we can drop the curly braces:||在某种环境下, 我们也可以像对数组引用那样, 用快捷方法不用复杂的花括号形式. 比如说, 花括号里仅仅是简单的标量变量的话（就像到现在为止的例子展示的那样）, 我们可以把花括号拿掉：
a Mouse goes squeak!||[但你罕有机会听到它的叫声!]
12. 2. Invoking an Instance Method||12. 2. 调用一个实例方法
10. 8. Scope of a Package Directive||10. 8. 包指示字的范围
To perform an operation on the entire hash, we proceed similarly:||对整个散列操作, 其操作也类似：
We may run into some cases where we can't install modules in the pre-configured directories in @INC. We can change @INC itself before the require, so Perl searches our directories too. The @INC array is an ordinary array, so have the Skipper add a directory below his home directory to the mix:||我们可能碰到这些情况, 即不能（想）在预先配置在@INC中的目录中安装模块. 但我们可以在require之前先改变数组@INC自己, 这样Perl也会去查找我们的目录. 数组@INC就是平常的数组, 所以让Skipper把它主目录加进去：
Each has advantages and disadvantages. For example, if we return the updated parameter, we can use it again for another object:||几种方法各有优缺点. 比如, 如果我们返回更新的值, 我们可以将其用于其它的对象：
Figure 4-1. The array @all_with_names holds a multilevel data structure containing strings and references to arrays||图 4-1. 数组@all_with_name包含一个多层的数据结构, 包括字串和指向另一数组的引用. 
If we constructed all our horses by hand, we'd most likely make mistakes from time to time. Making the "inside guts" of a Horse visible also violates one of the principles of OOP. That's good if we're a veterinarian but not if we just like to own horses. We let the Horse class build a new horse:||如果我们手工创建所有的马, 那我们很可能一次次犯错. 而且暴露Horse内部的信息也违反了面向对象编程的基本原则. 我们不是兽医, 我们只想拥有一匹马而已. 我们用Horse类创建一个新的马：
If eval can't properly compile and run the Perl code we hand it, it sets $@ just like in its block form. In this example, we want to trap any divide-by-zero errors, but we don't divide by anything (another sort of error).||如果eval不能正确编译和执行我们传给它的Perl代码, 它就会像代码块形式的结果一样设置变量$@一个值. 在下例中, 我们想要捕捉任何除零错误, 但我们遇到了另外一种错误－－分母缺失. 
What should you do if you're asked to set the name or color of a generic animal?||要在类层面设置名字或颜色, 你该如何做？
Chapter 4 explored how to take a reference to an array @skipper and place it into a new scalar variable:||在第四章里, 我们了解了如何取一个数组@skipper的引用, 并把它放到一个新建的标量变量中：
If we don't have permission to install modules in the system-wide directories, [*] we can tell Perl to install them under another path by using the PREFIX argument:||如果你因为没有权限而不能在系统级的目录里建立目录, [*]我们可以用PREFIX参数告诉Perl安装在你另外指定的路径：
As we can see with the debugger, we can easily show the data, even structured data, to help us understand our program.||当我们用测试工具看到的, 我们可以方便地查验数据, 甚至是结构化的数据, 来帮助我们理解我们的程序. 
$lost->{Name} has Bo, and $lost->{Color} has white. But we want to make $lost->name access the name, and that's now messed up because it's expecting a scalar reference. Not to worry, because it's pretty easy to fix:||$lost->{Name}里存的是"Bo", $lost->{Color}里放的是white. 但我们要用$lost->name访问name变量, 但是因为要用标量引用, 所以会造成混乱. 别急, 这很容易解决：
There is also inheritance through UNIVERSAL and AUTOLOAD; see the perlobj manpage for the whole story.||同样可以从UNIVERSAL和AUTOLOAD继承;可以查看perlobj手册页来得到它的身世. 
4. 7. Simplifying Nested Element References with Arrows||4. 7. 用箭头号简化嵌套数组引用
Yes, every scalar, array, hash, filehandle, or subroutine now has to have a navigation_ prefix in front of it to guarantee that the names won't collide with any potential users of the library. Obviously, for that old sailor, this ain't gonna float his boat. What do we do instead?||是的, 每个标量, 数组名, 散列, 文件句柄或者子程序现在都必须加上一个navigation_ 前缀, 这样才能保证不与其它的库里潜在的用户发生冲突. 显然, 对于老水手来说, 他是不会干这种事的. 我们能用什么替代方案呢？
But just because something has gone wrong with one part of our code, that doesn't mean that we want everything to crash. Perl uses the eval operator as its error-trapping mechanism.||可是, 不能因为代码的某一片断出错而使我们的整个程序崩溃. Perl用eval操作符来实现捕捉错误的机制. 
6. 3. YAML||6. 3. YAML
Starting with Perl 5. 6, open can create a filehandle reference in a normal scalar variable. Instead of using a bareword for the filehandle name, we use a scalar variable whose value is undef.||从Perl 5. 6版本开始, 可以用一个通常的标量变量打开一个文件句柄. 相比于使用裸字来代表句柄名字, 我们可以用一个含有空值的标量变量代表. 
How do we turn the horse into a hash?[*] Recall that an object is any blessed reference. We can just as easily make it a blessed hash reference as a blessed scalar reference, as long as everything that looks at the reference is changed accordingly.||我们把horse变成一个散列如何？[*] 回想一下, 所谓对象实际上是被"祝福"的引用. 我们可以像"祝福"一个标量引用一样容易的"祝福"一个散列引用, 只要把它们看作引用就可以了. 
12. 1. A Horse Is a Horse, of Course of Courseor Is It?||12. 1. 一匹马属于马类, 各从其类是吗？
2. 2. Trapping Errors with eval||2. 2. 用eval捕捉错误
In the olden days, Perl used barewords for filehandle names. The filehandle is another Perl data type, although people don't talk about it too much since it doesn't get its own special sigil. You've probably already seen a lot of code that uses these bareword filehandles.||在以往的日子里, Perl用裸字来代表文件句柄. 文件句柄是另一种Perl的数据类型, 尽管人们对此讨论不多, 因为它也没有专门的符号标注. 你大概已经许多用裸字文件句柄的代码, 如：
[*] The return would have exited the subroutine that contains this entire section of code. And yes, some of us have been bitten by that mistake in real, live coding on the first draft.||[*] 保留return的结果会导致Perl从包含这个代码块的子例程中退出. 当然, 我们中有些人在最初编程的时候就深受其苦. 
If you're playing along at home, be aware that each new release of the debugger works differently than any other, so your screen probably won't look exactly like ours. Also, if you get stuck at any time, type h for help or look at perldoc perldebug.||如果在你这儿运行的话, 要注意因为测试工具的版本不同, 所以你的屏幕显示可能与我们的不尽相同. 还有, 如果你在测试中遇到了麻烦, 可以输入h键来获得perldoc perldebug提供的在线帮助. 
take 2**1000||算2**1000
The Skipper can set PERL5LIB once and forget about it. However, unless Gilligan has the same PERL5LIB environment variable, his program will fail! While PERL5LIB is useful for personal use, we can't rely on it for programs we intend to share with others. (And we can't make our entire team of programmers add a common PERL5LIB variable. Believe us, we've tried. )||Skipper可以在一次设置PERL5LIB后就把它忘了. 然而, 除非Gilligan使用同样的PERL5LIB环境变量, 它的程序就会失败！ 因为PERL5LIB对个人使用非常有用, 当我们与其它人共享程序时, 我们不能依靠它. （而且我们也不能让我们整个程序员团队的人用一个共同的PERL5LIB变量. 相信我们, 我们试过. ）
Take the arrow invocation and put it back in the barnyard example:||我们用箭头调用来看前面农场的例子：
Now we treat the filehandle reference just like any other scalar. We don't have to do any tricky magic to make it work.||现在我们就可以把文件句柄引用当作标量一样到处使用了. 我们不必不得不搞些怪手法来处理问题. 
That's not all, though. If the first argument to IO::Tee is an input filehandle (the succeeding arguments must be output filehandles), we can use the same teed filehandle to read from input and write to the output. The source and destination channels are different, but we get to treat them as a single filehandle.||呵呵, 还有更绝的. 如果我们给IO::Tee一些参数（第一个为输入句柄, 其后均为输出句柄）, 我们可以用同一个Tee过的句柄来从输入中读和从输出中写. 虽然输出源和输出目的地不同, 但我们可以用同一个句柄来操作. 
Hands-on training gets the job done better. The best way to provide this training is with a series of exercises after every half-hour to hour of presentation. Of course, if you're a speed reader, the end of the chapter may come a bit sooner than a half hour. Slow down, take a breather, and do the exercises!||动口又动手, 学习就是好. 培训最好的途径就是在半小时或一小时之后的讲课后有一系列的练习. 当然, 如果你阅读速度很快的话, 一章大概在半小时之内就可以看完. 那么, 停一停, 不着急, 做一下练习吧. 
As before, Perl closes these files when the scalar variable goes out of scope, but if that is not enough, we do it ourselves explicitly.||在以前, Perl会在这些标量变量跑出范围的时候把文件关闭, 不过, 如果你还不放心, 我们可以显式关闭文件. 
The reference can be copied:||引用可以被复制：
Fortunately, we have tools to help us. The CPAN. pm module has been part of the core distribution since Perl 5. 004. It gives us an interactive module installation shell.||幸而, 我们有工具来助一臂之力. 自从Perl 5. 004版开始, CPAN. pm模块成为核心发布的一部份. 它给我们提供了一个交互式的模块安装环境. 
In this case, we have two separate $count variables, each accessed from within their own callback subroutine.||上面的例子中, 我们有两个分开的$count变量, 各自被他们自己的回调子程序访问. 
Using the final version of check_required_items, write a subroutine check_items_for_all that takes a hash reference as its only parameter, pointing at a hash whose keys are the people aboard the Minnow and whose corresponding values are array references of the things they intend to bring onboard.||运用书中最后那个版本的check_required_items, 写一个子程序check_items_for_all, 把一个散列引用作为惟一参数. 这个散列引用的键是在Minnow船上的所有乘客, 其对应的值是他们各自想带上船的东西. 
Now, instead of a few dozen lines of common subroutines to place in each file, we simply have one subroutine to insert in each file.||现在, 不必在每个文件里的打上几十行通用代码, 我们方便地把一个子程序放到每个文件中. 
The PERL5LIB variable can include multiple directories separated by colons. Perl inserts all specified directories at the beginning of @INC.||PERL5LIB环境变量可以加多个目录, 中间用分号分开. Perl会把所有这些目录加到@INC中. 
5. 4. When Reference Counting Goes Bad||5. 4. 当引用计数出问题了
That's pretty darn compact. Furthermore, use base has the advantage that it's performed at compile time, eliminating a few potential errors from setting @ISA at runtime, like some of the other solutions.||这是非常简短的形式了. 此外, use base有个优点是它是在编译时执行的, 这样消除了在运行时设置@ISA可能发生的潜在错误, 就像先前的一些解决方案那样. 
Chapter 1. Introduction||第一章 引言
In theory, this would be fine. For the first pair of names (Gilligan and Skipper), we ask the monkey "How many pineapples does Gilligan have?" and "How many pineapples does Skipper have?" We get back two values from the monkey and use them to order Gilligan and Skipper in the final list.||按理, 这个程序不错. 对于第一对名字（Gilligan和Skipper), 我们问下猴子："Gilligan有多少菠萝？" 和"Skipper手里有多少菠萝？" 我们从猴子那里得到这个值后, 并以此来将Gilligan和Skipper在最终的列表中排座次. 
The code prints 0 4 3 1 2. This means that Gilligan is position 0 in the output list, Skipper is position 4, Professor is position 2, and so on. The positions here are 0-based, so add 1 to get "human" ordinal values. One way to cheat is to use 1. . @sorted_positions instead of 0. . $#sorted_positions, so a way to dump it all out looks like:||这段代码输出是这样的：0 4 3 1 2. 这就是说Gilligan在输出列表中还是老大, Skipper是在输出列表中倒数第一, 教授是3, 以此类推. 这里的序数是以0为基数的, 所以我们可以加1, 让他看起来像人话. 一种骗术是用1. . @sorted_positions 代替 0. . $#sorted_positions, 所以写出来是这样的：
or equivalently:||下面也一样：
Modify the recursive directory dumping routine so it shows the nested directories through indentation. An empty directory should show up as:||修改一下递归目录打印程序, 让它以缩进的形式显示嵌套子目录. 一个空的目录应该如下显示：
In each case, $class gets the value appropriate for that method. But once again, we have a lot of similar structure. Can we factor out that commonality even further? Yes by calling another method in the same class.||在以上例子中, $class类为那个方法取到适当的值. 可是又一次, 我们又看到许多相似的结构. 我们能不能更进一步, 求出最大公约数呢？有, 只要调用同一个类中的另一个方法就可以了. 
And, just as was promised and delivered in Learning Perl, we'll entertain you along the way with interesting examples and bad puns.||另外, 就像我们在已经出版的《Learning Perl》中保证, 我们会在整个学习过程中用一些有趣的例子和没治的双关语让你的学习旅程充满乐趣. 
Similarly, the Skipper's home directory might also contain a personal bin directory (at something like ~skipper/bin) that contains personal tools:||类似的, Skipper的主目录同样包括一个属于他自己的bin目录（多少象~/skipper/bin）, 其中有些他个人的工具：
This lets us invoke Horse->speak to ripple upward to Animal::speak, calling back to Horse::sound to get the specific sound, and the output of:||这样, 让我们调用Horse->speak从而会找到Animal::speak, 然后会回调Horse::sound来取得特定的声音, 其输出是：
no import||不导入任何例程
Thus, the code that we bring in from separate files permits easy maintenance and interprogrammer cooperation.||所以, 从分开的文件引入代码可以使我们可以更方便地维护和协同编程. 
Chapter 2. Intermediate Foundations||第二章 进阶基础
Why did we stop using the arrow? Well, if we invoke Animal->speak there, the first parameter to the method is "Animal" not "Mouse" and when the time comes for it to call for the sound, it won't have the right class to select the proper methods for this object.||为什么我们不用方法箭头？哦, 如果我们在那里用Animal->speak, 那给方法的第一个参数就是Animal而不是Mouse, 而且当程序调用sound的时候, 它不会选用正确的类. 
11. 10. Where We Are So Far…||11. 10. 我们已经到哪了…
But all Horse objects would have to be absolutely identical. If we add a method, all horses automatically share it. That's great for making horses identical, but how do we capture the properties of an individual horse? For example, suppose we want to give our horse a name. There's got to be a way to keep its name separate from those of other horses.||但是所有的Horse对象都必须完全相同. 如果我们加了一个方法, 则所有的horses对象都自动共享它. 这对于保持对象都有的共性这点很好, 但是如何捕捉到每个horse个体的属性呢？比如说, 假定我们要给我们的马取个名字. 应该有个方法来区分它的名字与其它马的名字. 
6. 6. Applying a Bit of Indirection||6. 6. 搞些小伎俩
Make a program that uses your library and the following code to print out a message, such as Today is dip, sen 15, 2011, meaning that today is a Monday in August. (Hint: the year and month numbers returned by localtime may not be what you'd expect, so you need to check the documentation. )||写个程序使用你的库并用如下代码打印一些信息, 如今天是dip, sen 15, 2011, 表示今天是八月的周一. （暗示：localtime返回的年月数字可能并不一定是你想要的, 所以你要查一下文档. ）
Perl finds modules by looking through the directories in the special Perl array, @INC. The use statement executes at compile time, so it looks at the module search path, @INC, at compile time. That can break our program in hard-to-understand ways unless we take @INC into consideration.||Perl会从一个专门的Perl数组:@INC中包含的目录条目中查找程序调用的模块. use语句会在编译时执行, 所以它会在编译时在@INC数组所包含的路径中查找模块. 所以, 除非我们把@INC的因素考虑进去, 否则我们就很难理解有时我们的程序会莫明其妙地中断. 
You might think that we should just add our module directory to @INC before we call the use. However, even adding:||我们可能会想在调用模块之前, 把路径加进@INC不就成了？然而, 当我们加入如下语句：
Now $items in the subroutine is a reference to the array of @skipper. But how do we get from a reference back into the original array? We dereference the reference, of course.||现在子例程中的$items变量保存的是指向数组@skipper的引用. 但我们如何时把一个引用变回一个原始数组呢？当然, 我们可以还原一个引用. 
To create @_, Perl copies the entire contents of the array to be scanned. This is fine for a few items, but if the array is large, it seems a bit wasteful to copy the data just to pass it into a subroutine.||为了建立数组@_, Perl会拷贝整个数据内容. 对于少量数据还可以, 但如果数组庞大, 这看上去多少有些浪费时间在拷贝数组到子例程. 
If you look at @skipper, you'll see that it consists of two parts: the @ symbol and the name of the array. Similarly, the syntax $skipper[1] consists of the name of the array in the middle and some syntax around the outside to get at the second element of the array (index value 1 is the second element because index values start at 0).||我们看一下@skipper, 你会发现它包括两部份：@符号和数组名. 相似地, 语法$skipper[1]包括当中的数组名和围绕在周围的语法符号表示取这个数组的第二个元素（索引1表示取第二个元素, 因为索引起始值是0）. 
Also, @$items (and its more generic form, @{$items}) works within a double-quoted string. We can't include any whitespace between the @ and the immediately following character, although we can include nearly arbitrary whitespace within the curly braces as if it were normal Perl code.||同样, @$items(或者其更一般的形式:@{$items})在双引号内也可以工作. 尽管我们可以在大括号里加任意空格, 但我们不能在@和后面跟着的字符间加上空格. 
What if we wanted to count down? Something like this will do:||那递减会如何呢？大概应该如此：
10. 5. require and @INC||10. 5. require 和 @INC
If you're a Perl instructor who has decided to use this as your textbook, you should know that each set of exercises is short enough for most students to complete in 45 minutes to an hour, with a little time left over for a break. Some chapters' exercises should be quicker, and some may take longer. That's because once all those little numbers in square brackets were written, we discovered that we didn't know how to add.||如果你是讲授Perl课程的指导老师, 并且决定用此书作为课程讲义, 你应该知道, 对于大多数学生来说, 每组练习45分钟到一小时就足够完成了, 余下留点时间作课间休息. 一些章节可能快些, 有的章节可能要慢些. 标在方框内的限时是死的, 所以一切按实际情况决定. 
The Dumper routine of Data::Dumper displays the output nicely, but what if we don't like the format being used? We can write a routine to display the data. Again, for recursively defined data, a recursive subroutine is usually the key.||用Data::Dumper模块的Dumper程序显示输出是不错, 但如果我们不喜欢它使用的格式怎么办呢？ 我们可以写一个程序来显示数据. 同样, 对于嵌套定义的数据, 我们用递归子程序是关键. 
References are the basis for complex data structures, object-oriented programming (OOP), and fancy subroutine magic. They're the magic that was added between Perl version 4 and version 5 to make it all possible.||引用是复杂数据结构、面向对象编程和令人眩目的子例程魔术的基础. Perl 版本4和版本5加入的一些功能使这些魔术成为可能. 
However, if you think your code might be used by people stuck with Perl 5. 005 or earlier, it's best to avoid our.||当然, 如果你需要你的代码让那些执着于Perl 5. 005或更早的版本的人, 最好避免使用our. 
It's a bit silly to invent a subroutine name to use the name only once, so we can write the previous code using an anonymous subroutine, such as:||在这里, 子程序只使用一次, 为此而起个名字的做法好像有些蠢, 所以我们还可以把子程序做成匿名子程序, 如：
At this point, we have two names for the data in @data1: @data1 itself and @{$data2[3]}, and two names for the data in @data2: @data2 itself and @{$data1[2]}. We've created a loop. In fact, we can access won with an infinite number of names, such as $data1[2][3][2][3][2][3][1].||像这种情况, 我们会有两个名字为@data1中的数据块命名：@data1自身和@{$data2[3]}, 另外有两个名字为@data2中的数据块命名：@data2自身和@{$data1[2]}. 我们创建了一个循环. 实际上我们可以用可怕多的下标来访问这块数据： $data1[2][3][2][3][2][3][1]. 
Clearly, the navigation_turn_toward_heading comes from the navigation. pm file. This is great for Gilligan but awkward for the Skipper, as his file now has longer subroutine names:||这样就明白了, navigation_turn_toward_heading来自于navigation. pm文件. 这对Gilligan是不错, 不过让Skipper很窘, 因为他的程序现在有很长的程序名：
3. 2. Using Modules||3. 2. 使用模块
An anonymous subroutine looks like an ordinary sub declaration, but there's no name (or prototype) between sub and the block that follows. It's also part of a statement, so we need a trailing semicolon or other expression separator after it in most cases.||一个匿名子程序看上去像一个平常的子程序声明, 只是没有名字（或原型声明）在sub关键字和紧随的代码块之间. 这同样是声明的一部份, 所以在大多数情况下, 我们需要结尾的分号, 或者其它的表达式分隔符. 
Whew! That's lot of typing and not very general. If each person's behavior is in a separate named subroutine, and a new person walks in the door, we have to figure out what other subroutines to call. We could certainly do it with enough hard-to-maintain code, but we can simplify the process by adding a bit of indirection, just as we did with arrays and hashes.||咻！这程序写得真费事, 而且一点也不抽象. 如果每个乘客的行为以不同的子程序命名, 而且每个乘客都进来的话, 我们要不得不写多少程序来对付啊. 当然, 我们可以用这样难以维护的代码来处理这件事, 但是, 就像我们在数组和散列上做的那样, 我们只要加一些小技巧, 就可以简化处理过程. 
The Skipper needs a way to write the code in one place and then share it among many programs. And, like most things in Perl, there's more than one way to do it.||Skipper需要一种方法, 只写一篇程序, 然后把它共享给其它程序. 而且, 正像Perl的大多数事物一样, 条条大路通罗马. 
The key is in the last line of that subroutine. We're dereferencing the $items array reference, accessing the original array, and adding the elements from @missing. Without passing by reference, we'd modify only a local copy of the data, which has no effect on the original array.||关键就在于那个子例程的最后一行. 我们把指向数组的引用$items还原成数组, 访问还原后的数组, 并且把@missing数组中的元素加进去. 
As before, we can now avoid the temporary variables and insert the values directly into the top-level list:||同前面一样, 我们还是可以避免使用临时变量, 把散列值直接放到列表里：
12. 5. Inheriting the Constructor||12. 5. 继承构建函数
Once we've processed the file, it's time to display the summary. First, we determine all the sources:||一旦我们处理完文件, 应该是显示总计的时候了. 首先, 我们取源主机：
We might have obtained or set the color outside the class simply by following the hash reference: $tv_horse->{Color}. However, this violates the encapsulation of the object by exposing its internal structure. The object is supposed to be a black box, but we've pried off the hinges and looked inside.||我们可以通过下面的散列引用$tv_horse->{Color}通过类的外部来获取或设置颜色. 然而, 这样就因为暴露了内部结构而违反了对象的封装性. 对象应该是一个黑盒, 而我们已经撬开了绞链, 看到了里边. 
Add a Person class at the same level as Animal, and have both of them inherit from a new class called LivingCreature. Also make the speak method take a parameter of what to say, falling back to the sound (humming for a Person) if no parameter is given. Since this isn't Dr. Dolittle, make sure the animals can't talk. (That is, don't let speak have any parameters for an animal. ) Try not to duplicate any code, but be sure to catch likely errors of usage, such as forgetting to define a sound for an animal.||在Aniaml同一层加上Person类, 而且他们两个都继承自一个新类：LivingCreature. 写一个speak方法, 它取一个参数作为说话内容, 如果没有给参数, 则使用sound（对于Person类来说是humming）. 因为这不是怪医杜立德, 所以要保证动物们不能对话. （就是说speak对于动物来说没有任何参数）不要写重复代码, 但是要保证捕获到相似的错误, 如忘了为某个动物定义叫声. 
We've protected the local dirname routine, but what if we still want the functionality provided by File::Basename's dirname? No problem. We just spell it out with its full package specification:||这样我们当然保护了本地的dirname例程, 但是, 如果我们想用File::Basename模块的dirname提供的功能怎么办？没问题！我们只要打出这个例程的全名就可以了：
This is great, because unless you work 35 hours each day, you'll need some help with larger tasks.||这是很重要的, 因为除非你一天工作35小时, 否则你很难在没有他们帮助下完成更大的任务. 
And then there's the buzzworthy notion of object-oriented programming (OOP), which allows parts of your code (or hopefully code from others) to be reused with minor or major variations within the same program.||另外, 还有一个必须知道的概念是关于什么是面向对象编程, 就是让你部份的代码（特别是可能与其它程序员共用的）能在或多或少的程度上在同一个项目中被重用. 
Before, we would have seen the bareword between the angle brackets:||之前, 我们会看到我们把裸字放在尖括号里：
The file produced by this step is under 100 bytes, which is quite a bit shorter than the equivalent Data::Dumper output. It's also much less readable for humans. It's easy for Storable to read, as you'll soon see. [*] Next, fetch the data, again using the Storable module. The result will be a single array reference. We dump the result to see if it stored the right values:||这步产生的内容小于100字节, 相比同样用Data::Dumper的输出, 那是非常的小. 这同样也更不具可读性. 你不久也会了解, 这样的话更利于Storable模块读这些数据. [*] 下一步, 我们同样用Storable模块读取这些数据. 产生的结果是一个指向单个数组的引用. 我们把读出的结果打印出来, 看看是否存得对：
So far, you have seen references to three main Perl data types: scalars, arrays, and hashes. We can also take a reference to a subroutine (sometimes called a coderef).||目前, 你已经看到了对Perl三种数据类型的引用：标量, 数组和散列. 同样, 我们也可以对一个子程序进行引用（有时候我们把它叫作代码引用）. 
Well, we can apply a bit of indirection. Let's not sort the actual names but rather the indices of each name:||好, 我们可以稍微间接的来做. 我们来为名字的索引排序, 而不是为实际的名字排序. 
Thus, all animals are brown (muddy, perhaps), unless a specific animal class gives a specific override to this method.||这样, 所有的动物都是棕色（土色, 也许吧）, 除非个别动物特别指定了毛色, 对这个方法进行了重载. 
6. 8. 1. Exercise 1 [20 min]||6. 8. 1. 练习1 ［20分钟］
In summary: use what you want, be consistent if you can, but document it nonetheless (and don't change it after you've already released one version).||总结：经过考虑后, 按需要应用, 但无论如何要写下来（而且在发布后不要再改）
Note that the subroutine accesses the $total_size variable. We declare this variable outside the scope of the subroutine but still visible to the subroutine. Thus, even though find invokes the callback subroutine (and would not have direct access to $total_size), the callback subroutine accesses and updates the variable.||注意, 匿名子程序会访问$total_size变量. 我们定义这个变量是在匿名子程序范围之外的, 但是对于匿名子程序来说还是可见的. 所以, 尽管find调用那个回调的匿名子程序（并且不会直接访问$total_size）, 回调的匿名子程序会访问并且更新变量. 
find starts at the current directory (. ) and locates each file or directory. For each item, we call the subroutine what_to_do( ), passing it a few documented values through global variables. In particular, the value of $File::Find::name is the item's full pathname (beginning with the starting directory).||在例子中, find程序开始于当前目录（. ）, 并且向下找到所有的目录和文件. 对于找到的每个项目, 我们会调用那个子程序what_to_do(), 把一些全局变量传进去. 一般来说全局变量:$File::Find::name是项目的全路径名（以开始搜索的目录为起点）
At this point, $tv_horse is an instance of Horse. [] That is, it's a specific horse. The reference is otherwise unchanged and can still be used with traditional dereferencing operators.||这下, $tv_horse现在是Horse的一个实例. [+] 那就是, 它现在是一个不同的马了. 而引用并没有改变什么, 它仍然可以以传统的还原操作符还原. [+]
For example, suppose that "The Skipper" and "sextant" (note the leading whitespace) are at the end of the datafile in order to list an additional data item.||例如, 假定"The skipper"和"sextant"(注意前导空格) 放在文件末尾, 作为增补的项目. 
Here's a trickier one. Who brought a water bottle?||这里有个更搞的, 谁带了水瓶？
While creating temporarily named arrays would work in the simplest cases, creating such names becomes more complicated as the data structures become more detailed. We'd have to keep thinking of names of arrays just so we could forget them shortly thereafter.||临时命名的数组, 在简单环境中还可以工作, 但这些名字在数据结构开始越来越复杂的情况下会变得比较繁琐. 我们应该想到, 正确地处理这些数组的名字, 这样我们可以很快就忘掉它. 
The BEGIN keyword tells the Perl compiler that as soon as this block has been parsed successfully (during the compile phase), jump for a moment to run phase and run the block as well. Presuming the block doesn't cause a fatal error, compilation then continues with the text following the block. The block itself is also discarded, ensuring that the code within is executed precisely once in a program, even if it had appeared syntactically within a loop or subroutine.||BEGIN块会告诉Perl编译器只要这个块被成功解释了（在编译阶段）, 就马上去运行这个块. 假定这个块不会导致致命错误, 编译器就继续下面的块. 块自身也会被丢弃, 保证其中的代码在程序中被精确地只执行一次, 甚至代码在语法上在一个循环或子程序中. 
Another alternative to the pattern of creating two different methods for getting and setting a parameter is to create one method that notes whether or not it gets any additional arguments. If the arguments are absent, it's a get operation; if the arguments are present, it's a set operation. A simple version looks like:||另一种建立设置器和取值器替代方案是用一个方法, 以参数作区分是取值还是设置值. 如果参数缺失, 那么就作取值操作;如果有值, 那就设置值. 简例如下：
More easily, we can skip the step of building the intermediate array by simply returning the items of interest with a map:||更有甚者, 我们可以不用中间数组, 简单地用map返回我们需要的数组:
[*] Note that we added whitespace in these two displays to make the similar parts line up. This whitespace is legal in a program, even though most programs won't use it.||[*] 注意, 为了对齐语法上的各部份, 我们在上面的例子中加了空格. 这些空格在程序上也是合法的, 尽管许多程序不必如此. 
If the name prefix of the last example didn't have to be spelled out on every use, things would work much better. We can improve the situation by using a package:||package Navigation;
Every exercise has its answer in the Appendix. Again, try not to peek; you'll ruin the value of the exercise.||每个练习在附录都有参考答案. 再提醒一下, 作题前别去看, 看了再作题, 学习效果就差了. 
We can also create filehandle references from which we can read. We simply put the right thing in the second argument.||我们同样可以以读的方式创建文件句柄引用. 我们只要简单地在第二个参数放上适当的文件名即可：
More simply, using the "drop arrow" rule, we can use:||很简单, 用"去箭头"规则, 我们可以写成：
We save a bit of typing when we do this, and the code is slightly faster, although probably not enough for us to notice it with everything else that's going on in our program. The $_[0] is just the single element access to the @_ array. Instead of using shift to put the argument into another variable, we can simply use it directly.||写这些代码的时候我们省了点儿时间, 代码执行也快了点儿, 尽管对于这些代码在我们的程序里具体发挥什么作用可能也不太了解. 变量$_[0]是访问@_数组的第一个元素. 相比于把数组的变量放到另一个变量中的作法, 我们简单的直接引用它. 
Before we get started on the meat of the book, we want to introduce some intermediate-level Perl idioms that we use throughout the book. These are the things that typically set apart the beginning and intermediate Perl programmers. Along the way, we'll also introduce you to the cast of characters that we'll use in the examples throughout the book.||在开始深入学习这本书之前, 我们要介绍一些中阶Perl语言的"习惯用语". 我们会在整本书里都用到这些"习语". 对这些"习语"的掌握程度区分了一个程序员对Perl的运用等级是中阶还是初阶. 我们将会在贯穿整本书的例子里向您介绍这些"演员". 
But now, how can we tell Perl to pull in that program snippet from another file? We could do it the hard way, using the string form of eval that we discussed in Chapter 2.||到目前为止, 我们如何告诉Perl从另外一个程序中拉出一块程序代码呢？ 我们可以用硬编码, 第二章所讨论过的用eval的形式来求一个字串的值. 
to just:||或者：
Starting with the list of names again (keys %provisions), we pull up all the packed items first and then use that list in an inner grep to count the number of those items that equal water_bottle. If the count is 0, there's no bottle, so the result is false for the outer grep. If the count is nonzero, we have a bottle, so the result is true for the outer grep. Now we see that the Skipper will be a bit thirsty later, without any relief.||同先前一样, 我们首先取乘客名字（keys %provisions）, 然后取那个乘客所带的所有装备列表, 之后, 在一个内部的grep中计数有多少元素是water_bottle. 如果计数是0, 则表示没有, 所以返回false 给外部grep. 如果计数非零, 表示我们有一个水瓶, 所以返回真给外部grep. 现在我们可以看到Skipper以后会是比较渴的那位, 以后没有任何缓解余地. 
We indent provisions with some whitespace, following a non-indented line with the person's name. Let's construct a hash of provisions. The keys of the hash will be the person's name, and the value will be an array reference to an array containing a list of provisions.||我们把装备用空格缩进表示, 没有缩进的行是旅客名字. 我们来建立一个装备清单. 索引键是旅客名字, 其值是一个指向装备列表的引用. 
12. 10. Getting Our Deposit Back||12. 10. 取回存储
We can kill off each reference by using the variable for something other than a reference to the value of @skipper. For example, we can assign undef to the variable:||我们用给引用赋任何一个与指向@skipper引用无关的其它的变量就可以切断引用关系了. 比如, 我们可以给变量分配一个undef给变量：
For each file within the directory being examined, the response from the recursive call to data_for_path is undef. This populates most elements of the hash. When the reference to the named hash is returned, the reference becomes a reference to an anonymous hash because the name immediately goes out of scope. (The data itself doesn't change, but the number of ways in which we can access the data changes. )||对于目录中的每个文件都会查一下, 从递归调用data_for_path得到的结果就是未定义值. 这就生成了散列中大部份的值. 当一个命名引用返回时, 引用立即跑出程序范围, 所以成为对一个匿名散列的引用. （数据本身并没有改变, 但是我们可以有多种方法来访问数据变化. ）
This chapter looks at optimizing sorting and dealing with recursively defined data.||这一章我们来看看如何优化排序并且如何处理嵌套数据结构. 
Adding a few more castaways is as simple as putting the entry for the greeting behavior into the hash and adding them into the list of people entering the room. We get this scaling of effort because we have preserved the behavior as data over which you can iterate and look up, thanks to your friendly subroutine references.||添加更多的旅客就变成了简单的把问候行为放到散列中, 并把他们加入到进入房间的人名清单中. 我们在效率上得到扩展, 因为我们把程序行为保存为数据, 并通过它可以查找和迭代, 这要感谢友好的子程序引用. 
The instance methods form the Application Programming Interface (API) for an object. Most of the effort involved in designing a good object class goes into the API design, because the API defines how reusable and maintainable the object and its subclasses will be. Don't rush to freeze an API design before you've considered how you (or others) will use the object.||一个实际的方法就是一个对象的应用程序接口（ＡＰＩ）. 一个好的面向对象的设计很大程度上取决于ＡＰＩ设计, 因为ＡＰＩ决定了对象如何被使用和被维护, 以及其子类应该是什么样子的. 不要在还没有考虑好你（或其他人）如何用这个对象前急急忙忙的确定ＡＰＩ设计. 
Here, we create the value that we'll eventually store in @all_with_names as the last expression evaluated in the subroutine. The subroutine returns a three-element list. As long as the named arrays within the subroutine have had at least one reference taken of them, and it is still part of the return value, the data remains alive. [*] If we alter or discard the references in @all_with_names, Perl reduces the reference count for the corresponding arrays. If that means the reference count has become zero (as in this example), Perl also eliminates the arrays themselves. Because the arrays inside @all_with_names also contain a reference (such as the reference to @skipper), Perl reduces that reference count by one. Again, that reduces the reference count to zero, freeing that memory as well, in a cascading effect.||上例中, 我们创建的那个最终保存在@all_with_names中的值是用子程序的最后一个表达式求值得到的. 子程序返回一个三个元素的列表. 只要子程序中的命名数组曾经至少有一个引用指向他们, 他们就仍旧是返回值的一部份, 数据仍旧存在. [*] 如果我们改变或者丢弃@all_with_names中的引用, Perl会减少相应的数组的引用计数. 如果那意味着引用计数降为零（在例中）, Perl一样会把数组销毁. 因为@all_with_names数组中包含的其它数组同样包含一个引用（如对@skipper的引用）, Perl会把那个引用的计数降为1. 一样, 一旦引用计数降为零, Perl会连锁地释放内存. 
Data::Dumper is not the only game on the island, though. Brian Ingerson came up with Yet Another Markup Language (YAML) to provide a more readable (and more compact) dump. It works in the same way as Data::Dumper. We'll see more about YAML when we talk about modules later, so we won't say much about it here.||Data::Dumper并非在Perl中输出数据的惟一玩法. Brian Ingerson提供了Yet Another Markup Language(YAML) 来提供一种更具可读性的（也更节省空间）的输出办法. 同Data::Dumper的作法一样, 我们会在以后大谈特谈ＹＡＭＬ, 所以这里就不费话了. 
Or is it?||或者, 如何才好呢？
Go up one level to the Skipper's home directory, which is likely to contain a few files along with the personal bin directory:||我们往上跑一级, 到Skipper的主目录, 里面有些文件, 并且有他自己的一个bin目录：
We can show a reference to an empty anonymous array using an empty anonymous array constructor. For example, if we add one "Mrs. Howell" to that travel list, as someone who has packed rather light, we'd simply insert:||我们也可以将引用指现空的匿名数组. 比如, 如果我们加一个Mrs. Howell到一个遊客列表, 并且它没带多少装备, 我们可以简单的这样写：
There's only one reason to get back to the original subroutine by dereferencing the coderef: to invoke it. Dereferencing a code reference is similar to dereferencing other references. First, start with the way we would have written it before we heard of references (including the optional ampersand prefix):||还原一个对子程序的引用的惟一目的就是：为了调用它. 还原对代码的引用同还原对其它数据类型的引用是相似的. 首先, 我们可以采用我们在听说引用以前写过的方法来处理（包括前导的&号）
You'll also need to ensure that all your code fits with the other code as you develop it for the final application.||同样, 在协作环境下, 你要保证你开发的所有的代码在最终的应用程序中能很好的同他人的代码配合. 
To make Perl look in that directory for modules, we can set the PERL5LIB environment variable. Perl adds those directories to its module directory search list.||为了让Perl在目录中查找到模块, 我们可以设置PERL5LIB环境变量. Perl会把这些目录加到模块搜寻清单里去. 
Because a hash reference fits wherever a scalar fits, we can create an array of hash references:||因为在标量适合的地方, 散列引用也适合, 所以我们可以创建一个散列引用的数组. 
We've now duplicated some of the code from Animal->speak; this can be a maintenance headache. For example, suppose someone decides that the word goes in the output of the Animal class is a bug. Now the maintainer of that class changes goes to says. Our mice will still say goes, which means the code still has the bug. The problem is that we invoked cut and paste to duplicate code, and in OOP, that's a sin. We should reuse code through inheritance, not by cut and paste.||我们现在已经在Animal->speak重复写了些代码了; 这会引起维护上的问题. 比如, 某人认为Animal类的输出的词不对, 是个错误. 现在代码维护者改变了程序. 而我们的老鼠仍旧说原来的话, 意味着错误仍旧存在. 问题是我们采用剪切和粘贴来复制代码, 在面向对象编程中, 这是不可饶恕的罪过. 我们应该通过继承来重用代码, 而不是靠剪切和粘贴. 
[*] Recursive functions should all have a base, or trivial case, where they don't need to recurse and that all other recursions can eventually reach. That is, unless we have a lot of time on our hands to let the function recurse forever.||[*] 递归程序应该都有一个基础的, 或最简的例子, 这种例子无须再用递归处理了, 而且其它递归可以在此结束. 就是说, 除非我们手上有的是时间让它永无止境地运行下去. 
The modules in CPAN are organized as a symbolic-link tree in hierarchical functional categories, pointing to author directories where the actual files are located. The modules area also contains indices that are generally in easy-to-parse-with-Perl formats, such as the Data::Dumper output for the detailed module index. Of course, these indices are all derived automatically from databases at the master server using other Perl programs. Often, the mirroring of the CPAN from one server to another is done with a now-ancient Perl program called mirror. pl.||按模块的功能编目, CPAN把模块用符号连接组织起来, 指向他们的作者目录－－实际文件所在的地方. 模块还包含以易于Perl分析的格式索引, 如Data::Dumper这样的输出来丰富模块索引的内容. 自然啦, 这一切编目索引都是有主服务器的Perl程序自动从数据库生成的. 一般来说, CPAN中从一个服务器同步到另一个服务器的工作是由mirror. pl这个古老的Perl程序完成的. 
How would we get the total size of all found files from the callback? Earlier, we were able to do this by making $total_size visible. If we stick the definition of $total_size into the subroutine that returns the callback reference, we won't have access to the variable. But we can cheat a bit. For one thing, we can determine that we'll never call the callback subroutine with any parameters, so, if the subroutine receives a parameter, we make it return the total size:||那我们怎么得到所有找到的文件的总的文件大小呢？在前一章的例子中, 我们的作法是让$total_size变量在范围内可见. 如果我们把$total_size的定义放在返回回调引用的子程序里的话, 我们将无法访问这个变量. 但是我们可以耍个小花招. 即我们可以决定, 只要收到任何参数, 我们就不调用回调子程序, 这样的话, 如果子程序收到一个参数, 我们就让它返回总字节数：
Actually, we have the inverse of the rank. We still don't know, for a given name in the original list, which position it occupies in the output list. But with a bit more magic, we can get there as well:||事实上, 我们也有了倒过来的排名. 即, 给定原始的列表, 在排序后他们所占的位置是什么. 当然, 戏法也得上一层楼, 我们可以这样做：
As long as we have pairs, we keep passing the list through the grep structure:||只要还有文件对, 我们就会通过grep结构不断把列表传过来：
That's still a bit too much work. In the foreach, we had to decide which filehandles to include. What if we could just define a group of filehandles that answered to the same name? Well, that's what IO::Tee does for us. Imagine it like a tee connector on a bilge output pipe; when the water gets to the tee, it can flow it two different directions at the same time. When our output gets to IO::Tee, it can go to two (or more) different channels at the same time. That is, IO::Tee multiplexes output. In this example, the castaways log message goes to both the logfile and the scalar variable.||不过, 这个看上去还是有些复杂. 在foreach, 我们还得决定是哪个句柄. 以不能定义一组句柄来回答同样的问题呢？ 哈, 这就是IO::Tee提供的功能. 可以把它想像成舱底连接输出水管儿的T字连接口; 当水灌到T字口的时候, 它会同时向两个不同的方向流. 当我们的数据灌入IO::Tee时, 它会流向两个（或多个）不同管道. 就是说IO::Tee实现了多路输出. 在下面 例子中, 日志同时写入logfile和标量变量. 
We could also use File::Find to find out some other things about files, such as their size. For the callback's convenience, the current working directory is the item's containing directory, and the item's name within that directory is found in $_.||我们还可以用File::Find来查其它一些文件属性, 比如它们的文件大小. 为了回调方便, 当前目录被设为文件所在的目录, 目录中的文件名也放在缺省变量$_中. ：
The Oogaboogoo natives on the island have unusual names for the days and months. Here is some simple but not very well-written code from Gilligan. Fix it up, add a conversion function for the month names, and make the whole thing into a library. For extra credit, add suitable error checking and consider what should be in the documentation.||岛上的土著Oogaboogoo对于日期和月份着不同寻常的名字. 这里有个从Gilligan来的简单但写得不是很好的代码. 修改一下, 给月份名加一个对话函数, 并把这些放到一个库里. 为了更好的可靠性, 添加一个错误检查程序以及文档. 
Nearly every scalar, array, hash, subroutine, and filehandle name[*] is actually prefixed by the current package, unless the name already contains one or more double-colon markers.||几乎所有的标量、数组、散列、子程序及文件句柄名字实际上已经加上了当前的程序包的名字, 除非原来的名字已经包括一个或多个双冒号标记. 
If Gilligan recognizes that one of the Skipper's programs is missing the proper directive, Gilligan can either add the proper PERL5LIB variable or invoke Perl directly with one or more -I options. For example, to invoke the Skipper's get_us_home program, the command line might be something like:||如果Gilligan注意到Skipper的程序丢失了合适的指示字, Gilligan可以通过设置正确的PERL5LIB环境变量, 也可以用Perl的-I 选项. 比如, 要调用Skipper的get_us_home程序, 在命令行可能是：
It's the same process here, just written a bit differently. When we invoke create_find_callback_that_counts( ), we initialize the lexical variable $count to 0. The return value from that subroutine is a reference to an anonymous subroutine that is also a closure because it accesses the $count variable. Even though $count goes out of scope at the end of the create_find_callback_that_counts( ) subroutine, there's still a binding between it and the returned subroutine reference, so the variable stays alive until the subroutine reference is finally discarded.||上面那个程序与之前的程序有同样的功能, 只稍稍做了些改动. 当我们调用create_find_callback_that_counts()的时候, 我们会把词法变量$count置为零. 子程序返回的是一个对匿名子程序的引用, 它同样是一个闭包, 因为这个闭包访问$count变量. 尽管$count在create_find_callback_that_counts( ) 子程序结束后跑出范围, 但仍旧有一个绑定它和返回的子程序引用, 所以, 变量会一直存在, 直到子程序引用最后被丢弃. 
Let's look again at the provisions list. Suppose we were reading the data from a file, in this format:||我们重顾一下装备清单. 假定我们从一个文件中读取这些数据, 格式如下：
We've seen arrays, hashes, and subroutines passed around in references, permitting a level of indirection to solve certain types of problems. We can also store filehandles in references. Let's look at the old problems and the new solutions.||我们已经看到如何通过引用传递数组, 散列和子程序, 并通过一定的手段来解决一定复杂度的问题. 同样, 我们也可以将文件句柄存到引用里. 让我们看如何用新办法来解决老问题. 
The value in $ginger is a coderef, just as if we had defined the following block as a subroutine and then taken a reference to it. When we reach the last statement, we see:||$ginger的值是一个代码引用, 就像我们在其后定义了子程序一样, 然后返回引用给它. 当我们到达最后一行, 我们看到：
Let's see how this works on the first line of data. We'll be executing:||让我们看第一行如何生成的：
You can find the answers to these exercises in "Answers for Chapter 9" in the Appendix.||答案附录找. 
Wow. That symbolic coderef dereferencing there in the body of the loop is pretty nasty. We're counting on no strict 'refs' mode, certainly not recommended for larger programs. [*] And why was that necessary? Because the name of the package seems inseparable from the name of the subroutine we want to invoke within that package.||哇, 在loop中有代码的符号引用还原操作是够糟的. 我们需要指望没有严格的'refs'模式. 当然, 在大型程序中不建议这样. 为什么要这样做？因为包名与我们包里我们要调用的子程序名字是不能分开的. 
Later, in Chapters 10, 17, and 18, we'll use this to optionally load modules. If we can't load the module, Perl normally would stop the program. We'll catch the error and recover on our own when this happens.||在稍后的第10、17和18章中, 我们会用这种办法来调用可选模块. 如果我们调用模块失败, Perl会中止程序. 而我们会捕捉到这种错误, 并由我们自己以我们的办法恢复程序的运行. 
Once you know a little about references, you're on your way to arbitrarily complex data structures.||只要你掌握了一点关于引用的知识, 你就可以在复杂数据结构中自在遨游了. 
4. 8. References to Hashes||4. 8. 指向散列的引用
[*] It's the simplest, but rarely used in real code for reasons we'll show shortly.||[*] 这是最简单的, 但鲜有在实际的代码中使用, 原因我们后面会说到. 
One place this comes in very handy is in a typical data reduction task. For example, let's say the Professor gets an island-area network up and running (perhaps using Coco-Net or maybe Vines) and now wants to track the traffic from host to host. He begins logging the number of bytes transferred to a log file, giving the source host, the destination host, and the number of transferred bytes:||自生成功能一大用处是在那些典型的单向读取的任务（消防水带）. 比如说, 假设教授要建立一个岛间的网络. 现在他要跟踪主机与主机之间的流量. 他现在开始把之间传输的字间记录到日志文件. 记录源主机, 目标主机和传输的字节数：
Chapter 9. Practical Reference Tricks||第九章 实用引用技巧
Here, we go through the operators + - * / and use each of those inside our eval code. In the string we give to eval, we interpolate the value of $operator into the string. The eval executes the code that the string represents and returns the last evaluated expression, which we assign it to $result.||上例中, 我们依次把+ – * /四个操作符用到我们的eval代码块中. 在给eval的字串中, 我们内插了变量$operator的值. eval执行并返回了我们给出字串的值, 并且放到变量$result中. 
This construct is commonly called the Schwartzian Transform, which was named after Randal (but not by Randal), thanks to a Usenet posting he made many years ago.||这个结构一般叫做施瓦茨变换, 它以兰德命名（并不是他本人起的）, 感谢新闻组张贴他的程序使他成名多年. 
[*] Perl doesn't make us create an explicit main( ) loop like C. Perl knows that every script needs one, so it gives it to us for free.||[*] Perl 不会让我们像C那样创建一个显式的main( )循环. Perl清楚每个脚本都需要它, 所以它自动为我们做了这项工作. 
