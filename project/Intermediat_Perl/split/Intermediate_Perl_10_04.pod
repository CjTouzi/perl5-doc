=EN Using require
=CN 使用 I<require>
=EN Suppose navigation. pm itself also pulls in drop_anchor. pm for some common navigation task. Perl reads the file once directly and then again while processing the navigation package. This needlessly redefines drop_anchor( ). Worse than that, if we have warnings enabled, [*] we'll get a warning from Perl that we've redefined the subroutine, even if it's the same definition.
=CN 假定 I<navigation.pm> 自己, 因为一些导航任务而把 I<drop_anchor.pm> 引进自己的模块里 I<.Perl> 在处理导航程序包的时候将文件一次直接读入.在这次重新定义 I<drop_anchor()> 是不必要的.更糟的是, 如果我们把警告打开, 我们会从 I<Perl> 得到一个警告信息, 说我们已经重新定义子程序, 尽管是一模一样的定义。
=EN You are using warnings, right? You can enable them with either -w or use warnings;.
=CN 你开启警告是吗？你可以用 I<-w> 开关, 以及 I<use> I<warnings> 来开始警告;
=EN We need a mechanism that tracks which files we've brought in and then brings them in only once. Perl has such an operation, called require. Change the previous code to simply:
=CN 我们需要一种机制来跟踪哪些文件我们已经调入了, 而且应该只把它们调入一次 I<.Perl> 提供了这个功能, 叫作 I<require.> 把前面的代码改成如下就可以了：
=EN The require operator keeps track of the files Perl has read. [] Once Perl has processed a file successfully, it simply ignores any further require operations on that same file. This means that even if navigation. pm contains require "drop_anchor. pm", Perl imports the drop_anchor. pm file exactly once, and we'll get no annoying error messages about duplicate subroutine definitions (see Figure 10-2). Most importantly, we'll also save time by not processing the file more than once.
=CN I<require> 操作符会在 I<Perl> 每次读入文件的时候进行跟踪[+] 一旦 I<Perl> 成功加载了一个文件, 它就会忽略之后 I<require> 引入相同的文件.这意味着就算 I<navigation.pm> 包括 I<require> I<"drop_anchor.pm"> , I<Perl> 只会把 I<drop_anchor.pm> 引入一次, 我们就不会收到烦人的警告重复定义子程序的消息了（见图 I<10> －2）.更重要的是, 我们同样节省时间, 不必多次加载文件了。
=EN In the %INC hash, as described in the entry for require in the perlfunc documentation.
=CN 在 I<%INC> 散列中, 正如 I<perlfunc> 文档中 I<require> 条目所描述的一样。
=EN Figure 10-2. Once Perl brings in the drop_anchor. pm file, it ignores another attempt to require it
=CN 图 I<10-2.> 一旦 I<Perl> 调入 I<drop_anchor.pm> 文件, 它会忽略其它相同文件的导入
=EN The require operator also has two additional features:
=CN I<require> 操作符同样有以下两个功能：
=EN Any syntax error in the required file causes the program to die; thus, the many die $@ if $@ statements are unnecessary.
=CN 任何语法错误会导致程序终止; 所以许多 I<die> I<$@> I<if> I<$@> 语句在这里是不需要的。
=EN The last expression evaluated in the file must return a true value.
=CN 文件最后一个求值必须返回真值
=EN Because of the second point, most files evaluated for require have a cryptic 1
=CN 正因为第二点, 所以大多数给 I<require> 导入的文件最后求值总有个神秘的1
=EN as their last line of code. This ensures that the last evaluated expression is, in fact, true.
=CN 这保证了最后的表达式总是 I<1.>
=EN Try to carry on this tradition as well.
=CN 努力保持这个传统吧。
=EN Originally, the mandatory true value was intended as a way for an included file to signal to the invoker that the code was processed successfully and that no error condition existed.
=CN 一开始, 强制性的返回真值是给导入文件的一个方法, 给调用者一个信号－－代码被成功处理且没有错误。
=EN However, nearly everyone has adopted the die if ... strategy instead, deeming the "last expression evaluated is false" strategy a mere historic annoyance
=CN 然而, 大家都采用 I<die> I<if...> 的策略, 推定的"最后表达式的计算是错误的"策略只是历史的烦扰
