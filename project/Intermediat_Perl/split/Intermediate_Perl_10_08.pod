=EN Scope of a Package Directive
=CN 包指示字的范围
=EN All files start as if we had said package main;. [*] Any package directive remains in effect until the next package directive, unless that package directive is inside a curly-braced scope. In that case, Perl remembers the prior package and restores it when that scope ends. Here's an example:
=CN 所有的文件都好像以 I<main> 程序包开始;[*] 所有的包指示字的范围在其声明处开始到下一个包指示字声明的地方结束, 除非那个包指示字在一个大括号范围之内.在那种情况下, I<Perl> 会记住前面的包, 并在其范围结束时恢复它.这里是个例子。
=EN Perl doesn't make us create an explicit main( ) loop like C. Perl knows that every script needs one, so it gives it to us for free.
=CN I<Perl> 不会让我们像C那样创建一个显式的 I<main(> )循环 I<.Perl> 清楚每个脚本都需要它, 所以它自动为我们做了这项工作。
=EN The current package is lexically scoped, similar to the scope of my variables, narrowed to the innermost-enclosing brace pair or file in which we introduced the package.
=CN 当前的包是词法范围的, 像 I<my> 声明的变量一样, 范围限制在大括号的最里层或我们引入包的文件范围之内。
=EN Most libraries have only one package declaration at the top of the file. Most programs leave the package as the default main package. However it's nice to know that we can temporarily have a different current package.
=CN 大多数的库只在一个文件里放一个包, 并且在文件开始的地方声明包名.大多数的程序就把缺省的 I<main> 作为包名.不过知道我们可以临时有个不同的当前包名是不错的 I<.[> +]
=EN Some names are always in package main regardless of the current package: ARGV, ARGVOUT, ENV, INC, SIG, STDERR, STDIN, and STDOUT. We can always refer to @INC and be assured of getting @main::INC. The punctuation mark variables, such as $_, $2, and $!, are either all lexicals or forced into package main, so when we write $. , we never get $Navigation::. by mistake.
=CN 有些名字总是在 I<main> 包里, 而不论当前的包是什么： I<ARGV> , I<ARGVOUT> , I<ENV> , I<INC> , I<SIG> , I<STDERR> , I<STDIN> 和 I<STDOUT.> 我们可以总是引用 I<@INC> 而得到 I<@main::INC.> 那些标点符号标记的变量名, 如 I<$_> , I<$2> , 及$!, 也是要么是词法变量或者强制属于 I<main> 包, 所以当我们写 I<$.> , 我们不必加上 I<$Navigation::> 而导致错误。
