=EN A Few Notes About @ISA
=CN 有关 I<@ISA> 的一些说明
=EN This magical @ISA variable (pronounced "is a" not "ice-uh") declares that Cow "is a" Animal. [*] Note that it's an array, not a simple single value, because on rare occasions it makes sense to have more than one parent class searched for the missing methods. We'll show more about that later.
=CN 这个神奇的 I<@ISA> 变量（发音是 I<"is> I<a"> 不是 I<"ice-uh"> ）声明了 I<Cow"> 是一个"动物 I<.[> *] 注意它是一个数组, 不是一个简单的标量值, 因为在罕有的情况下它可能有多重祖先, 我们将会在下面讨论这个问题。
=EN ISA is actually a linguistic term. Once again, Larry Wall's background as a linguist has come back to influence Perl.
=CN I<ISA> 实际上是一个语言学上的术语.再提醒一次, I<Larry> I<Wall> 的语言学家的背景又在反过来影响了 I<Perl.>
=EN If Animal also had an @ISA, Perl would check there too. [] Typically, each @ISA has only one element (multiple elements means multiple inheritance and multiple headaches), so we get a nice tree of inheritance.
=CN 如果 I<Animal> 同样也有一个 I<@ISA> 数组, I<Perl> 也会再去查找 I<.[> +] 一般来说, 每个 I<@ISA> 只有一个元素（多个元素意味着多重继承及多重"头痛"）, 这样我们就可以得到一个清楚的继承树 I<.[> +]
=EN The search is recursive, depth-first, and left to right in each @ISA.
=CN 查找是递归的, 在每个 I<@ISA> 数组中是从上到下, 从左到右。
=EN There is also inheritance through UNIVERSAL and AUTOLOAD; see the perlobj manpage for the whole story.
=CN 同样可以从 I<UNIVERSAL> 和 I<AUTOLOAD> 继承;可以查看 I<perlobj> 手册页来得到它的身世。
=EN When we turn on use strict, we'll get complaints on @ISA because it's not a variable containing an explicit package name, nor is it a lexical (my) variable. We can't make it a lexical variable, though: it has to belong to the package to be found by the inheritance mechanism.
=CN 当我们打开 I<strict> 后, 我们会有关于 I<@ISA> 的警告信息, 因为它既不是一个有明确包名的变量, 也不是一个词法（ I<my> 声明)的变量.我们不能把它定义为词法变量, 因为它属于它所继承的那个包。
=EN There are a couple of straightforward ways to handle the declaration and setting of @ISA. The easiest is to just spell out the package name:
=CN 有两个简单方法来处理对 I<@ISA> 的声明和设置.最简单的方法是指出包名：
=EN We can also allow it as an implicitly named package variable:
=CN 我们也允许它作为一个隐含命名的包变量：
=EN If you're on a recent-enough Perl (5. 6 or later), you can use the our declaration to shorten it to:
=CN 如果你用的是比较新版本的 I<Perl> , 你可以用如下的简短形式：
=EN However, if you think your code might be used by people stuck with Perl 5. 005 or earlier, it's best to avoid our.
=CN 当然, 如果你需要你的代码让那些执着于 I<Perl> I<5.005> 或更早的版本的人, 最好避免使用 I<our.>
=EN If we're bringing in the class from outside, via an object-oriented module, we can change:
=CN 如果我们要用从外面(通过一个面对对象的模块)带进来的类, 我们可以改成：
=EN to just:
=CN 或者：
=EN That's pretty darn compact. Furthermore, use base has the advantage that it's performed at compile time, eliminating a few potential errors from setting @ISA at runtime, like some of the other solutions.
=CN 这是非常简短的形式了.此外, I<use> I<base> 有个优点是它是在编译时执行的, 这样消除了在运行时设置 I<@ISA> 可能发生的潜在错误, 就像先前的一些解决方案那样。
