=EN Dynamic Code with eval
=CN 用 I<eval> 动态编译代码
=EN There's also a second form of eval, whose parameter is a string expression instead of a block.
=CN I<eval> 有另外一种用法, 其参数是作为一个字串表达式, 而不是代码块。
=EN It compiles and executes code from a string at runtime. While this is useful and supported, it is also dangerous if any untrustworthy data has gotten into the string.
=CN 在运行时, 它将字串临时编译成代码并且执行.这很易用, 但也很危险, 因为有可能会把具有危害性的代码放到字串里。
=EN With a few notable exceptions, we recommend you avoid eval on a string.
=CN 除了极少数值得一提的例外情况, 我们建议你尽量避免这种用法。
=EN We'll use it a bit later, and you might see it in other people's code, so we'll show you how it works anyway.
=CN 稍后我们会用这种用法, 然后我们就不用这种用法了, 我们只是展示它是怎么工作的。
=EN Perl executes that code in the lexical context of the code around it, meaning that it's virtually as if we had typed that code right there.
=CN I<Perl> 在词法环境中执行那段代码, 这意味着我们好像在执行的时候输入这些代码的一样。
=EN The result of the eval is the last evaluated expression, so we really don't need the entire statement inside the eval.
=CN I<eval> 的结果就是最后一个表达式求值的值, 所以我们不必在 I<eval> 中输入整个语句。
=EN Here, we go through the operators + - * / and use each of those inside our eval code.
=CN 上例中, 我们依次把 + - * / 四个操作符用到我们的 I<eval> 代码块中。
=EN In the string we give to eval, we interpolate the value of $operator into the string.
=CN 在给 I<eval> 的字串中, 我们内插了变量 I<$operator> 的值。
=EN The eval executes the code that the string represents and returns the last evaluated expression, which we assign it to $result.
=CN I<eval> 执行并返回了我们给出字串的值, 并且放到变量 I<$result> 中。
=EN If eval can't properly compile and run the Perl code we hand it, it sets $@ just like in its block form.
=CN 如果 I<eval> 不能正确编译和执行我们传给它的 I<Perl> 代码, 它就会像代码块形式的结果一样设置变量 I<$@> 一个值。
=EN In this example, we want to trap any divide-by-zero errors, but we don't divide by anything (another sort of error).
=CN 在下例中, 我们想要捕捉任何除零错误, 但我们遇到了另外一种错误 I<--> 分母缺失。
=EN The eval catches the syntax error and puts the message in $@, which we check immediately after calling eval.
=CN I<eval> 捕捉语法错误, 然后在我们调用 I<eval> 后, 在检查 I<$@> 值时, 把出错信息放到变量 I<$@> 中。
=EN Later, in Chapters 10, 17, and 18, we'll use this to optionally load modules.
=CN 在稍后的第 I<10> 、 I<17> 和 I<18> 章中, 我们会用这种办法来调用可选模块。
=EN If we can't load the module, Perl normally would stop the program.
=CN 如果我们调用模块失败, I<Perl> 会中止程序。
=EN We'll catch the error and recover on our own when this happens.
=CN 而我们会捕捉到这种错误, 并由我们自己以我们的办法恢复程序的运行。
=EN In case you didn't catch our warning before, we'll say it again: be very careful with this form of eval.
=CN 万一你还没有注意我们的警告, 我们在这里重申：要非常小心这种形式的 I<eval> 用法。
=EN If you can find another way to do what you need, try that first.
=CN 如果你有其它的方法来替代 I<eval> 用法, 那就试试其它方法。
=EN We'll use it later, in Chapter 10 to load code from an external file, but then we'll also show you a much better way to do that too.
=CN 我们在后来第 I<10> 章会用到这种办法从外部文件中载入代码, 但我们同样会向你展示出更好的替代方案。
