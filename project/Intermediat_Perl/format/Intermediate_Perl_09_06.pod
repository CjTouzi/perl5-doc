=EN Recursively Defined Data
=CN 数据的嵌套定义
=EN While the data we've processed with references up to this point has been rather fixed structure, sometimes we have to deal with hierarchical data, which is often defined recursively. 
=CN 我们到现在为止处理的引用都是固定结构的, 可有时候我们要处理一般同递归来定义的层次结构的数据. 
=EN For Example One, consider an HTML table that has rows containing cellsand some of those cells may also contain entire tables. Example Two could be a visual representation of a filesystem consisting of directories containing files and other directories. Example Three is a company organization chart, which has managers with direct reports, some of whom may be managers themselves. And Example Four is a more complex organization chart, which can contain instances of the HTML tables of Example One, the filesystem representations of Example Two, or even entire organization charts. . . . 
=CN 举个例子来说, 考虑一下一个含有表行表列的HTML表, 而表里的单位格可能还有其它的表. 例二是个虚拟的文件系统的例子, 一个文件系统中有一些目录, 而在目录中有文件或其它目录. 例子三是公司的组织结构图, 各部经理向他们的上司报告, 而其中有的经理向自己报告. 例子四是更加复杂的组织结构图, 可以包括上述例一的HTML表、例二的文件系统, 或者整个公司的组织结构图表… …
=EN We can use references to acquire, store, and process such hierarchical information. Frequently, the routines to manage the data structures end up as recursive subroutines. 
=CN 我们可以用引用的办法来获得, 存储以及处理这些层次结构的信息. 一般来说, 处理这些层次结构的子程序最终都是递归程序. 
=EN Recursive algorithms deal with the unlimited complexity of their data by beginning with a base case and building upon that. [*] The base case considers what to do in the simplest case: when the leaf node has no branches, when the array is empty, when the counter is at zero. In fact, it's common to have more than one base case in various branches of a recursive algorithm. A recursive algorithm with no base case is an infinite loop. 
=CN 递归算法用处理起始的一个基础例子并由此建立的程序来处理无限复杂的数据. [*] 所谓基础例子是指在一个最最简单的情况下如何处理：没有分支的叶子节点, 当数组还是空的情况, 当计数器是零时. 实际上, 在递归算法的不同分支中一般有多个基础例子. 如果递归算法没有基础例子, 程序就会导致无限循环. 
=EN Recursive functions should all have a base, or trivial case, where they don't need to recurse and that all other recursions can eventually reach. That is, unless we have a lot of time on our hands to let the function recurse forever. 
=CN 递归程序应该都有一个基础的, 或最简的例子, 这种例子无须再用递归处理了, 而且其它递归可以在此结束. 就是说, 除非我们手上有的是时间让它永无止境地运行下去. 
=EN A recursive subroutine has a branch from which it calls itself to handle a portion of the task, and a branch that doesn't call itself to handle the base cases. In Example One above, the base case could be a table cell that is empty. There could also be base cases for empty tables and table rows. In Example Two, base cases would be needed for files, and perhaps for empty directories. 
=CN 递归子程序有一个分支来调用自己来处理部份任务, 有一个分支处理基础例子. 在上面第一个例子中, 基础例子就是当表格单元空的时候. 同样空行或空表也是基础例子. 在第二人例子中, 基础例子是文件或者空的目录. 
=EN For example, a recursive subroutine handling the factorial function, which is one of the simplest recursive functions, might look like:
=CN 比如, 下面的一个处理阶乘的递归子程序, 是最简单的递归应用：
=EN Here we have a base case where $n is less than or equal to 1, which does not invoke the recursive instance, along with a recursive case for $n greater than 1, which calls the routine to handle a portion of the problem (i. e. , compute the factorial of the next lower number). 
=CN 这里的基础例子是变量$n小于或等一1时, 这时就不会调用递归子程序, 而在$n大于1时, 就会调用子程序来处理这部分问题（如, 为下一个更小的数处理阶乘）
=EN This task would probably be solved better using iteration rather than recursion, even though the classic definition of factorial is often given as a recursive operation. 
=CN 这个任务可能用迭代来做比用递归更好, 即使阶乘的经典定义是常常被作为一个递归操作. 
