=EN Don't Look Inside the Box
=CN 不要往盒子里看
=EN We might have obtained or set the color outside the class simply by following the hash reference: $tv_horse->{Color}.
=CN 我们可以通过下面的散列引用 $tv_horse->{Color} 通过类的外部来获取或设置颜色. 
=EN However, this violates the encapsulation of the object by exposing its internal structure. 
=CN 然而, 这样就因为暴露了内部结构而违反了对象的封装性. 
=EN The object is supposed to be a black box, but we've pried off the hinges and looked inside. 
=CN 对象应该是一个黑盒, 而我们已经撬开了绞链, 看到了里边. 
=EN One purpose of OOP is to enable the maintainer of Animal or Horse to make reasonably independent changes to the implementation of the methods and still have the exported interface work properly.
=CN 面向对象设计的目标之一就是要让 Animal 或 Horse 的代码维护者在进行合理独立的改动方法的实现的时候, 使接口仍然可以工作. 
=EN To see why accessing the hash directly violates this, let's say that Animal no longer uses a simple color name for the color, but instead changes to use a computed RGB triple to store the color (holding it as an arrayref).
=CN 要看为什么直接访问散列就破坏了封装, 让我们打个比方, 如果我们不用简单的颜色名字来代表颜色, 而是用ＲＧＢ三色数字来代表颜色（用一个数组引用来代表）. 
=EN In this example, we use a fictional (at the time of this writing) Color::Conversions module to change the format of the color data behind the scenes:
=CN 在这个例子中, 我们用一个假想的（写这本书的时候）Color::Conversions 模块来改幕后的色彩格式：
=EN We can still maintain the old interface if we use a setter and getter, because they can perform the translations without the user knowing about it. We can also add new interfaces now to enable the direct setting and getting of the RGB triple:
=CN 我们可以在维护旧的接口时一样可以用设置和取值程序, 因为在用户不知道具体细节的情况下他们可以自动转换. 我们也可以添加新的方法来直接改ＲＧＢ三色数字：
=EN If we use code outside the class that looks at $tv_horse->{Color} directly, this change is no longer possible.
=CN 如果我们在类的外面直接看$tv_horse->{Color}, 这样的改变是不可能的. 
=EN It won't work to store a string ('blue') where an arrayref is needed ([0, 0, 255]) or to use an arrayref as a string.
=CN 它不能在存数组引用（[0, 0, 255]）的地方存字串（'blue'）或把数组引用当作字串. 
=EN This is why OO programming encourages you to call getters and setters, even if they take some time. 
=CN 这就是为什么面向对象的编程鼓励你用设置器或取值器, 尽管他们可能费些写代码的时间. 
