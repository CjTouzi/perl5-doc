=EN Returning a Subroutine from a Subroutine
=CN 从子程序中返回一个子程序
=EN Although a naked block worked nicely to define the callback, having a subroutine return that subroutine reference instead might be more useful:
=CN 尽管定义回调时用裸块的话, 会工作得很好, 但是如果让子程序返回一个对子程序的引用的做法更加有用：
use File::Find;
sub create_find_callback_that_counts {
 my $count = 0;
 return sub { print ++$count, ": $File::Find::name\n" };
}
my $callback = create_find_callback_that_counts( );
find($callback, '. ');
=EN It's the same process here, just written a bit differently. When we invoke create_find_callback_that_counts( ), we initialize the lexical variable $count to 0. The return value from that subroutine is a reference to an anonymous subroutine that is also a closure because it accesses the $count variable. Even though $count goes out of scope at the end of the create_find_callback_that_counts( ) subroutine, there's still a binding between it and the returned subroutine reference, so the variable stays alive until the subroutine reference is finally discarded. 
=CN 上面那个程序与之前的程序有同样的功能, 只稍稍做了些改动. 当我们调用create_find_callback_that_counts()的时候, 我们会把词法变量$count置为零. 子程序返回的是一个对匿名子程序的引用, 它同样是一个闭包, 因为这个闭包访问$count变量. 尽管$count在create_find_callback_that_counts( ) 子程序结束后跑出范围, 但仍旧有一个绑定它和返回的子程序引用, 所以, 变量会一直存在, 直到子程序引用最后被丢弃. 
=EN If we reuse the callback, the same variable still has its most recently used value. The initialization occurred in the original subroutine (create_find_callback_that_counts), not the callback (unnamed) subroutine:
=CN 如果我们重用回调, 相同的变量仍会保留它最近的值. 初始值是在最初调用子程序的时候创建的（create_find_callback_that_counts）, 并不是回调的匿名子程序中：
use File::Find;
sub create_find_callback_that_counts {
 my $count = 0;
 return sub { print ++$count, ": $File::Find::name\n" };
}
my $callback = create_find_callback_that_counts( );
print "my bin:\n";
find($callback, 'bin');
print "my lib:\n";
find($callback, 'lib');
=EN This example prints consecutive numbers starting at 1 for the entries below bin, but then continues the numbering when we start entries in lib. The same $count variable is used in both cases. However, if we invoke the create_find_callback_that_counts( ) twice, we get two different $count variables:
=CN 下面这个例子从1开始为整个bin目录下的文件计数, 接着前面的数值, 继续为lib目录下所有的文件计数. 在两个程序用同样一个$count变量的值. 然而, 如果我们调用两次create_find_callback_that_counts( ), 我们会得到两个不同的$count变量的值：
use File::Find;
sub create_find_callback_that_counts {
 my $count = 0;
 return sub { print ++$count, ": $File::Find::name\n" };
}
my $callback1 = create_find_callback_that_counts( );
my $callback2 = create_find_callback_that_counts( );
print "my bin:\n";
find($callback1, 'bin');
print "my lib:\n";
find($callback2, 'lib');
=EN In this case, we have two separate $count variables, each accessed from within their own callback subroutine. 
=CN 上面的例子中, 我们有两个分开的$count变量, 各自被他们自己的回调子程序访问. 
=EN How would we get the total size of all found files from the callback? Earlier, we were able to do this by making $total_size visible. If we stick the definition of $total_size into the subroutine that returns the callback reference, we won't have access to the variable. But we can cheat a bit. For one thing, we can determine that we'll never call the callback subroutine with any parameters, so, if the subroutine receives a parameter, we make it return the total size:
=CN 那我们怎么得到所有找到的文件的总的文件大小呢？在前一章的例子中, 我们的作法是让$total_size变量在范围内可见. 如果我们把$total_size的定义放在返回回调引用的子程序里的话, 我们将无法访问这个变量. 但是我们可以耍个小花招. 即我们可以决定, 只要收到任何参数, 我们就不调用回调子程序, 这样的话, 如果子程序收到一个参数, 我们就让它返回总字节数：
use File::Find;
sub create_find_callback_that_sums_the_size {
 my $total_size = 0;
 return sub {
 if (@_) { # it's our dummy invocation
 return $total_size;
 } else { # it's a callback from File::Find:
 $total_size += -s if -f;
 }
 };
}
my $callback = create_find_callback_that_sums_the_size( );
find($callback, 'bin');
my $total_size = $callback->('dummy'); # dummy parameter to get size
print "total size of bin is $total_size\n";
=EN Distinguishing actions by the presence or absence of parameters is not a universal solution. Fortunately, we can create more than one subroutine reference in create_find_callback_that_counts( ):
=CN 当然, 用区分参数存在或者不存在的来决定程序行为不是一个通用的解决方案. 还好, 我们可以在create_find_callback_that_counts( )中创建多个子程序. 
use File::Find;
sub create_find_callbacks_that_sum_the_size {
 my $total_size = 0;
 return(sub { $total_size += -s if -f }, sub { return $total_size });
}
my ($count_em, $get_results) = create_find_callbacks_that_sum_the_size( );
find($count_em, 'bin');
my $total_size = &$get_results( );
print "total size of bin is $total_size\n";
=EN Because we created both subroutine references from the same scope, they both have access to the same $total_size variable. Even though the variable has gone out of scope before we call either subroutine, they still share the same heritage and can use the variable to communicate the result of the calculation. 
=CN 因为创建的两个匿名子程序在同一个范围内, 所以他们都访问相同的$total_size变量. 尽管在我们调用任一个匿名子程序之前, 这个变量已经跑出范围, 但他们仍能共享这个变量并且可以用这个变量交换计算结果. 
=EN Returning the two subroutine references from the creating subroutine does not invoke them. The references are just data at that point. It is not until we invoke them as a callback or an explicit subroutine dereferencing that they actually do their duty. 
=CN 在返回这两个匿名子程序引用时, 并不执行他们. 这时仅仅返回程序引用而已. 真正调用是在他们作为回调程序被执行或还原后被执行时. 
=EN What if we invoke this new subroutine more than once?
=CN 那我们多执行几遍这个新的子程序会怎么样？
use File::Find;
sub create_find_callbacks_that_sum_the_size {
 my $total_size = 0;
 return(sub { $total_size += -s if -f }, sub { return $total_size });
}
## set up the subroutines
my %subs;
foreach my $dir (qw(bin lib man)) {
 my ($callback, $getter) = create_find_callbacks_that_sum_the_size( );
 $subs{$dir}{CALLBACK} = $callback;
 $subs{$dir}{GETTER} = $getter;
}
## gather the data
for (keys %subs) {
 find($subs{$_}{CALLBACK}, $_);
}
## show the data
for (sort keys %subs) {
 my $sum = $subs{$_}{GETTER}->( );
 print "$_ has $sum bytes\n";
}
=EN In the section to set up the subroutines, we create three instances of callback-and-getter pairs. Each callback has a corresponding subroutine to get the results. Next, in the section to gather the data, we call find three times with each corresponding callback subroutine reference. This updates the individual $total_size variables associated with each callback. Finally, in the section to show the data, we call the getter routines to fetch the results. 
=CN 在创建子程序的程序片断中, 我们创建了回调／求总对的三个实例. 每一个回调程序都有相应的求总程序. 接下来, 在取得文件字节总数的程序片断中, 我们三次用相应的回调匿名子程序的引用调用find程序, 这更新了与这三个回调匿名子程序关联的三个独立的$total_size变量. 最后, 在展示结果的程序片断中, 我们调用返回字节求总的那个匿名子程序来取得结果. 
=EN The six subroutines (and the three $total_size variables they share) are reference counted. When we modify %subs or it goes out of scope, the values have their reference counts reduced, recycling the contained data. (If that data also references further data, those reference counts are reduced appropriately. )
=CN 六个匿名子程序（他们共享了三个$total_size变量）是引用计数的. 当我们修改%subs或者它跑出范围时, 引用计数减少, 重用他们包含的数据. （如果这些数据同样引用其它数据, 那么那些数据的引用计数也相应减少. ）
