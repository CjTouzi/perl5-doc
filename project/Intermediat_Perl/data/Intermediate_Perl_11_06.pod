=EN 11.6. Overriding the Methods
=CN 11.6. 重载方法
=EN Let’s add a mouse that can barely be heard:
=CN 让我们来加一种少有耳闻的老鼠：

{ package Animal;
  sub speak {
    my $class = shift;
    print "a $class goes ", $class->sound, "!\n";
  }
}
{ package Mouse;
  @ISA = qw(Animal);
  sub sound { ‘squeak’ }
  sub speak {
    my $class = shift;
    print "a $class goes ", $class->sound, "!\n";
    print "[but you can barely hear it!]\n";
  }
}
Mouse->speak;

=EN which results in:
=CN 其输出是：

=EN a Mouse goes squeak!
=CN [但你罕有机会听到它的叫声!]

=EN Here, Mouse has its own speaking routine, so Mouse->speak doesn’t immediately invoke Animal->speak. This is known as overriding . We use overriding to shadow the method in the derived class (Mouse) because we have a specialized version of the routine, instead of calling the more general base class’s method (in Animal). In fact, we didn’t even need to initialize @Mouse::ISA to say that a Mouse was an Animal, because all the methods needed for speak are defined completely with Mouse.
=CN 这里，老鼠有自己的发声程序， 所以Mouse->speak不会立即调用Animal->speak。 这被称为重载。 我们用重载来在继承类（Mouse）中重写方法，因为我们有个特别版本的子程序来代替原来基础类里更一般化的类方法（在Animal类中）。 实际上， 我们甚至根本不需要初始化@Mouse::ISA来声明Mouse是动物,因为所有有关发声的方法都已经在Mouse中定义了。
=EN We’ve now duplicated some of the code from Animal->speak; this can be a maintenance headache. For example, suppose someone decides that the word goes in the output of the Animal class is a bug. Now the maintainer of that class changes goes to says. Our mice will still say goes, which means the code still has the bug. The problem is that we invoked cut and paste to duplicate code, and in OOP, that’s a sin. We should reuse code through inheritance, not by cut and paste.
=CN 我们现在已经在Animal->speak重复写了些代码了； 这会引起维护上的问题。 比如，某人认为Animal类的输出的词不对，是个错误。 现在代码维护者改变了程序。 而我们的老鼠仍旧说原来的话，意味着错误仍旧存在。问题是我们采用剪切和粘贴来复制代码， 在面向对象编程中， 这是不可饶恕的罪过。 我们应该通过继承来重用代码，而不是靠剪切和粘贴。
=EN How can we avoid that? Can we say somehow that a Mouse does everything any other Animal does, but add in the extra comment? Sure!
=CN 我们能避免吗？ 我们可以做到一只老鼠能做其它动物能做的，然后有其自己的特殊的情况吗？当然可以！
=EN As our first attempt, let’s invoke the Animal::speak method directly:
=CN 像我们首先尝试的， 当我们直接调用Animal::speak:

{ package Animal;
  sub speak {
    my $class = shift;
    print "a $class goes ", $class->sound, "!\n";
  }
}
{ package Mouse;
  @ISA = qw(Animal);
  sub sound { ‘squeak’ }
  sub speak {
    my $class = shift;
    Animal::speak($class);
    print "[but you can barely hear it!]\n";
  }
}

=EN Note that because we’ve stopped using the method arrow, we have to include the $class parameter (almost surely the value Mouse) as the first parameter to Animal::speak.
=CN 注意，因为我们已经不用方法箭头， 我们必须用$class参数（当然其值是Mouse）作为Animal::speak的第一个参数。
=EN Why did we stop using the arrow? Well, if we invoke Animal->speak there, the first parameter to the method is "Animal" not "Mouse" and when the time comes for it to call for the sound, it won’t have the right class to select the proper methods for this object.
=CN 为什么我们不用方法箭头？哦，如果我们在那里用Animal->speak，那给方法的第一个参数就是Animal而不是Mouse，而且当程序调用sound的时候，它不会选用正确的类。
=EN Invoking Animal::speak directly is a mess, however. What if Animal::speak didn’t exist before, and it inherited from a class mentioned in @Animal::ISA? For example, suppose the code was:
=CN 然而， 调用直接调用Animal::speak是一个错误。 如果Animal::speak事先不存在呢？ 它会从@Animal::ISA继承？如：

{ package LivingCreature;
  sub speak { … }
  …
}
{ package Animal;
  @ISA = qw(LivingCreature);
  # no definition for speak(  )
  …
}
{ package Mouse;
  @ISA = qw(Animal);
  sub speak {
    …
    Animal::speak(  … );
  }
  …
}

=EN Because we no longer use the method arrow, we get one and only one chance to hit the right method because we’re treating it like a regular subroutine with no inheritance magic. We’ll look for it in Animal and not find it, and the program aborts.
=CN 因为我们不用方法箭头，我们有一个且只有一个机会命中正确的方法，因为我们对待它就像是一般的，没有继承特色的子程序。 我们会在Animal类中找，没找到它，程序就停止。
=EN The Animal class name is now hardwired into the method selection. This is a mess if someone maintains the code, changing @ISA for Mouse, and doesn’t notice Animal there in speak. Thus, this is probably not the right way to go.
=CN 现在Animal类名被硬编码用于方法选择。这对维护代码的人很不方便，为Mouse改@ISA,并不会注意到Speak中的Animal类。所以，这并非最好的解决方法。
