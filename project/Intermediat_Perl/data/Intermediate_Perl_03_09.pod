=EN 3.9. Setting the Path at the Right Time
=CN 3.9. 适时地打开路径
=EN Perl finds modules by looking through the directories in the special Perl array, @INC. The use statement executes at compile time, so it looks at the module search path, @INC, at compile time. That can break our program in hard-to-understand ways unless we take @INC into consideration. 
=CN Perl会从一个专门的Perl数组:@INC中包含的目录条目中查找程序调用的模块。use语句会在编译时执行，所以它会在编译时在@INC数组所包含的路径中查找模块。所以，除非我们把@INC的因素考虑进去，否则我们就很难理解有时我们的程序会莫明其妙地中断。
=EN For example, suppose we have our own directory under /home/gilligan/lib, and we place our own Navigation::SeatOfPants module in /home/gilligan/lib/Navigation/SeatOfPants.pm. When we load our module, Perl won’t find it. 
=CN 举个例子，假定我们有个目录/home/gilligan/lib,并且把模块Navigation::SeatOfPants放到这个目录下面的Navigation目录中的SeatOfPants.pm文件中。但Perl在用如下语句调用我们的模块时是不会找到它的。
=EN Perl complains to us that it can’t find the module in @INC and shows us all of the directories it has in that array. 
=CN Perl会向我们报怨在@INC中找不到需要的模块，并且向我们展示数组中包含的所有目录。
=EN You might think that we should just add our module directory to @INC before we call the use. However, even adding: 
=CN 我们可能会想在调用模块之前，把路径加进@INC不就成了？然而，当我们加入如下语句：
=EN doesn’t work. Why? Because the unshift happens at runtime, long after the use was attempted at compile time. The two statements are lexically adjacent but not temporally adjacent. Just because we wrote them next to each other doesn’t mean they execute in that order. We want to change @INC before the use executes. One way to fix this is to add a BEGIN block around the push: 
=CN 这样做不对，为什么？因为unshift是在运行时发生的，远在use来调用模块的编译时之后。两条语句虽然在词法上紧挨着但并不表示在编辑时间上靠近。仅仅因为次序上一句挨着另一句并不意味着执行上也按相同的次序。我们得让@INC在use语句执行之前改变。一种解决办法是加上BEGIN块：
=EN Now the BEGIN block compiles and executes at compile time, setting up the proper path for the following use. 
=CN 这下BEGIN块会在编译时被执行，在用use调用模块之前设置好适当的路径。
=EN However, this is noisy and prone to require far more explanation than you might be comfortable with, especially for the maintenance programmer who has to edit your code later. Let’s replace all that clutter with that simple pragma we used before: 
=CN 不过，这样做看上去很烦琐，不容易去解释，特别是以后向那些维护你代码的同事去解释。这样，我们用一个简洁的编译提示来换掉原来用的那些乱七八糟的东西。
=EN Here, the lib pragma takes one or more arguments and adds them at the beginning of the @INC array, just like unshift did before.[*] It works because it executes at compile time, not runtime. Hence, it’s ready in time for the use immediately following.
=CN [*]这样，lib编译提示取一个或多个参数，并且把他们加入数组@INC开头，就像前面所说的用unshift的效果一样。
=EN [*] use lib also unshifts an architecture-dependent library below the requested library, making it more valuable than the explicit counterpart presented earlier.
=CN [*]之所以有效是因为它在编译期间执行而不是在运行时执行。接下来正是时候立即用use了。
=EN Because a use lib pragma will pretty much always have a site-dependent pathname, it is traditional and we encourage you to put it near the top of the file. This makes it easier to find and update when we need to move the file to a new system or when the lib directory’s name changes. (Of course, we can eliminate use lib entirely if we can install our modules in standard @INC locations, but that’s not always practical.) 
=CN 因为use lib编译提示总是包含站点相关的路径名，所以一般来说我们推荐你把它写在文件的开头。这样当你需要为新系统移动文件，或库目录名字变化时比较容易更新。（当然，还有一种办法，我们压根去掉use lib编译提示，如果我们可以把我们的模块直接安装在@INC包括的标准路径下，但这不是总是可行的。）
=EN Think of use lib as not "use this library" but rather "use this path to find my libraries (and modules)." Too often, we see code written like: 
=CN 要注意到：use lib不是指"用这个库", 而是指“用这个路径可以找到我的库（以及模块）。” 很多情况下，我们会看到代码被写成这样：
=EN and then the programmer wonders why it didn’t pull in the definitions. Be aware that use lib indeed runs at compile time, so this also doesn’t work: 
=CN 这样程序员会迷惑为什么没有把定义加进去。还要注意use lib实际上是在编译时执行的，所以如下代码同样不能工作：
=EN Certainly, Perl establishes the declaration of the $LIB_DIR variable at compile time (so we won’t get an error with use strict, although the actual use lib should complain), but the actual assignment of the /home/gilligan/lib/ value doesn’t happen until runtime. Oops, too late again! 
=CN 当然，Perl声明$LIB_DIR变量的确是在编译期（所以我们用use strict也不会收到出错信息，尽管实际use lib时会报错），但给变量赋上’/home/gilligan/lib’这个值却直到运行时才发生，真是的，又晚了一步！
=EN At this point, we need to put something inside a BEGIN block or perhaps rely on yet another compile-time operation: setting a constant with use constant: 
=CN 这个时候，你就需要把它放在BEGIN块中，或依赖另一个编译期操作：设置一个常量：
=EN There. Fixed again. That is, until we need the library to depend on the result of a calculation. (Where will it all end? Somebody stop the madness!) This should handle about 99 percent of our needs. 
=CN 好，又解决问题了。就是说，直到我们需要的库取决于计算的结果。(要到哪里算是个头啊？停下来吧！)我们99％的需求可以满足了。
=EN 3.9.1. Handling Module Dependencies
=CN 3.9.1. 处理模块依赖
=EN We just saw that if we try to install a module that uses Module::Build, we have to install Module::Build first. That’s a mild case of the general dependency headache, and all the coconuts on our castaways’ island aren’t going to fix it. We might have to install several other modules too, each of which, in turn, depends on even more modules. 
=CN 我们刚才看到如果我们要安装一个模块，并且这个模块要引用Module::Build模块的话， 我们要事先装好Module::Build模块。这就是个稍稍让人头痛的有关一般模块依赖性的例子。 那我们的castaways岛的所有的椰子应该如何处理呢？我们要安装另一些模块，而这些模块各自又依赖更多的其它不同的模块。
=EN Fortunately, we have tools to help us. The CPAN.pm module has been part of the core distribution since Perl 5.004. It gives us an interactive module installation shell. 
=CN 幸而，我们有工具来助一臂之力。自从Perl 5.004版开始，CPAN.pm模块成为核心发布的一部份。它给我们提供了一个交互式的模块安装环境。
=EN To install a module along with its dependencies, we issue the install command with the name of the module. Now, CPAN.pm handles all the work of downloading, unpacking, building, testing, and installing the module, and it does so recursively for all its dependencies. 
=CN 要装一个模块和它所依赖的模块，我们只要发出一个带模块名字的安装命令即可。如此，CPAN.pm会处理所有下载、解包、编译、测试以及安装模块的工作，并且它会递归处理所有的依赖关系。
=EN That’s a bit too much work, though, so brian created the cpan script, which also comes with Perl. We simply list the modules we want to install, and it handles it for us. 
=CN 如果觉得用上面的方法还烦琐，brian写了个cpan脚本放在Perl的发行包里。我们只要简单的列出要安装的模块，由脚本来处理余下的事情。
=EN Another tool, CPANPLUS, is a complete rewrite of CPAN.pm, but it isn’t part of the core distribution as we write this. 
=CN 还有一个工具：CPANPLUS,是对CPAN.pm完全的重写。但它不是Perl核心包的一部份，如下：
=EN To install a module, we use the i command. 
=CN 我们用i命令来安装模块：
=EN The CPANPLUS module also comes with a convenience script, called cpanp. If we give it the i switch and a list of modules, it installs them just like before. 
=CN CPANPLUS模块同样有一个方便的脚本，叫做cpanp. 执行起来用i开关并列出要安装的模块列表，像如下那样：
