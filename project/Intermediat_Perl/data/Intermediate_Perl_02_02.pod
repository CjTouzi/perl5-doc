=EN 2.2. Trapping Errors with eval
=CN 2.2. 用eval捕捉错误
=EN Many lines of ordinary code have the potential to terminate a program prematurely if something goes wrong.
=CN 有一些代码看上去很平常，但是却含有潜在的危险，一旦某种条件不对就会使程序中断，过早地结束程序。
=EN divide by zero? 
=CN 若除零呢？
=EN illegal pattern?
=CN 若传过来的正则表达式不对呢？
=EN user-defined die? 
=CN 若打开失败呢？
=EN die inside sub? 
=CN 若在子程序里出错退出程序呢？
=EN But just because something has gone wrong with one part of our code, that doesn’t mean that we want everything to crash. Perl uses the eval operator as its error-trapping mechanism.
=CN 可是，不能因为代码的某一片断出错而使我们的整个程序崩溃。Perl用eval操作符来实现捕捉错误的机制。
=EN If an error happens while running code inside an eval block, the block is done executing. But even though the code inside the block is finished, Perl continues running the code just after the eval. It’s most common after an eval to immediately check $@, which will either be empty (meaning that there was no error) or the dying words Perl had from the code that failed, perhaps something like "divide by zero" or a longer error message.
=CN 如果在eval块里代码发生错误，系统会退出这个块。但是，尽管退出块，Perl会继续执行eval块之外的代码。我们在eval块的后面一般做法是检查一下$@变量，这个变量要么是空（表示没有出错）或者代码出错时系统返回的“遗言”，多半是“除零错误”之类云云。
=EN The semicolon is needed after the eval block because eval is a function (not a control structure, such as if or while). But the block is a true block and may include lexical variables ("my" variables) and any other arbitrary statements. As a function, eval has a return value much like a subroutine’s (the last expression evaluated, or a value returned early by the return keyword). Of course, if the code in the block fails, no value is returned; this gives undef in a scalar context, or an empty list in a list context. Thus, another way to calculate an average safely looks like this:
=CN eval块的结束时的分号是必须的，因为不像 if或者while那样的控制结构，eval实际上是个函数。但是代码块是真的块，所以可以包括词法变量（"my" 修饰的变量）和另外其它的断言语句。因为是个函数，eval有像子例程那样的返回值（最后一个表达式的求值结果，或者由return语句返回的结果）。 当然，如果代码块失败则没有值返回；如果在标量环境将返回未定义值，在列表环境将返回一个空的列表。因此，比较安全的求平均值的代码的写法如下：
=EN Now $average is either the quotient or undef, depending upon whether the operation completed successfully or not.
=CN 现在，根据这个操作执行的成败，变量$average要么是两数之商要么是个未定义值。
=EN Perl even supports nested eval blocks. The power of an eval block to trap errors extends for as long as it’s executing, so it catches errors deep within nested subroutine calls. eval can’t trap the most serious of errors, though: the ones in which Perl itself stops running. These include things such as an uncaught signal, running out of memory, and other catastrophes. eval doesn’t catch syntax errors , either; because Perl compiles the eval block with the rest of the code, it catches syntax errors at compile time, not at runtime. It doesn’t catch warnings either (although Perl does provide a way to intercept warning messages; see $SIG{_ _WARN_ _}).
=CN Perl也支持eval代码块的嵌套。只要代码执行，eval块总能捕捉错误，所以它能捕捉嵌套子例程里发生的错误。尽管如此，eval不能捕捉到非常严重的错误，这些错误发生时Perl自己会中断执行。这些错误包括无法捕捉的信号，内存溢出或其它的灾难。eval同样不能捕捉到语法错误；因为Perl在编译eval及其它代码的时候检查语法错误，而不是在运行时。还有，eval也不能捕捉警告。（但是Perl的确提供一个方法来捕捉警告信息；可以查阅一下变量$SIG{__WARN__}）。
