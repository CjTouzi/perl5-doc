=head2 第二章 进阶基础

在开始深入学习这本书之前, 我们要介绍一些中阶Perl语言的"习惯用语". 我们会在整本书里都用到这些"习语". 对这些"习语"的掌握程度区分了一个程序员对Perl的运用等级是中阶还是初阶. 我们将会在贯穿整本书的例子里向您介绍这些"演员".

=head2 2. 1. 列表操作符

你可能已经知道Perl的一些列表操作符, 但并没有想过他们是怎么同列表一起工作的. 最常用的列表操作符应该是print了.  我们给它一些参数, 然后它把他们合在一起显示出来. 


  print 'Two castaways are ', 'Gilligan', ' and ', 'Skipper', "\n"; 

在Learning Perl这本书里, 你可能知道了另外一些列表操作符. 如sort操作符将输入的列表按顺序列出.  在Gilligan's Island的主题歌中的那些求生者没有按字母次序出场, sort可以为我们修正这一点. 


  my @castaways = sort qw(Gilligan Skipper Ginger Professor Mary-Ann); 

reverse操作符返回反向排序的列表. 


  my @castaways = reverse qw(Gilligan Skipper Ginger Professor Mary-Ann); 

Perl 还有其它与列表打交道的操作符. 而且一旦你使用他们, 你会发现这些语句会使你表达得更清楚, 写更少的代码. 

=head2 2. 1. 1. 用grep操作符来过滤列表

grep操作符取一个列表和一个"测试表达式". 它一个一个地从列表中把元素取出来放到$_变量中, 并在标量环境中, 用"测试表达式"来检验这个值. 如果检验出来是个"真"值, grep会把$_变量送到输出列表中. 


  my @lunch_choices = grep &is_edible($_), @gilligans_posessions.  

在一个列表上下文中, grep操作符会返回所有被选出元素的列表. 而在一个标量上下文中, grep返回被选出元素的个数. 


  my @results = grep EXPR, @input_list; 
  my $count   = grep EXPR, @input_list; 

在下面的例子中, EXPR代表一个返回标量的表达式, 它引用$_变量（显式或隐式的）. 比如找出大于10的数, EXPR表达式来处理$_是否大于10. 


  my @input_numbers = (1, 2, 4, 8, 16, 32, 64); 
  my @bigger_than_10 = grep $_ > 10, @input_numbers; 

输出结果当然是：16, 32 和64. 上例中显式地引用了变量$_. 下面有个隐式引用变量$_的例子, 在正则表达式中隐式引用了变量$_:


  my @end_in_4 = grep /4$/, @input_numbers; 

现在我们得到的输出是4和64. 

当grep工作的时候, 它是从$_变量中把值"借"出来用. 就是说grep把$_的值"借"过来用一下, 用完后再把原值放回$_变量中. 所以$_变量仅仅是拷贝一下值而己. 是实际数据元素的一个别名. 就像foreach loop中的控制变量. 

如果检验表达式太复杂, 我们可以把检验代码隐藏到一个子例程里去：


  my @odd_digit_sum = grep digit_sum_is_odd($_), @input_numbers; 


  sub digit_sum_is_odd { 
         my $input = shift; 
         my @digits = split //, $input;  # Assume no nondigit characters 
         my $sum; 
         $sum += $_ for @digits; 
         return $sum % 2; 
  } 

对于这个例子, 我们得到的输出是1, 16和32. 程序把这些数据的数位加起来后, 因为最后一行返回的余数都是"1", 所以返回值为"真". 

所以, grep语法有两种形式：前面秀给你们看的表达式形式和下面要展示给你们看的代码块形式. 因为代码只用一次, 我们现在不把代码放到子例程中, 而是以代码块的形式直接放在grep语法里, 所谓的块形式：[*][*]

[*] 在grep的块形式中, 代码块和输入数组中间是没有逗号的. 而在grep的表达式形式中, 表达式和输入数组中间必须要有一个逗号. 区别如下：


  my @results = grep { 
    block; 
    of; 
    code; 
  } @input_list; 


  my $count = grep { 
    block; 
    of; 
    code; 
  } @input_list; 

同grep的表达式形式一样, grep临时把输入数组中每个元素放到$_中去, 然后, 它用代码块来处理这个值. 代码块里最后一个表达式来检验值. 就像所有的测试表达式一样, 在标量上下文来检验值. 因为是完整的块, 所以我们可以在其中用以块为范围的变量. 我们来用块形式重写上面的例子：:


  my @odd_digit_sum = grep { 
    my $input = $_; 
    my @digits = split //, $input;   # Assume no nondigit characters 
    my $sum; 
    $sum += $_ for @digits; 
    $sum % 2; 
  } @input_numbers; 

注意与用子例程的方法有两个地方的变化：输入值是通过变量$_, 而不是输入参数列表, 而且在代码块形式中我们去掉了return关键字. 实际上如果我们保留return的话是会出错的, 因为我们不是在用一个子例程, 仅仅是一个代码块. [*]当然, 这个例子我们还可以优化一下, 去掉中间变量：

[*] 保留return的结果会导致Perl从包含这个代码块的子例程中退出. 当然, 我们中有些人在最初编程的时候就深受其苦. 


  my @odd_digit_sum = grep { 
    my $sum; 
    $sum += $_ for split //; 
    $sum % 2; 
   } @input_numbers; 

如果显式使用中间变量能使代码让你和你的同事更易理解和维护代码的话, 尽管用它. 好代码才是主要的. 

=head2 2. 1. 2. 用map作列表的转换

map操作符的语法同grep操作符非常相像, 他们有相同的操作步骤. 例如它们都是把输入列表中的元素临时地放到$_变量中去, 而且他们的语法中都有表达式形式和代码块形式. 

然而, grep中的测试表达式在map中变成了映射表达式. map操作符在列表环境中为表达式求值（而不是像grep那样在标量环境下求值）. 每次表达式求值都成为整个输出结果的一部分. 为各个元素求值结果连在一起成为完整全部的输出. 在标量环境下, map返回在输入列表里多少个元素被处理. 但是map应该总是用在列表环境下, 很少用在标量环境下. 

让我们开始一个简单的实例：:


  my @input_numbers = (1, 2, 4, 8, 16, 32, 64); 
  my @result = map $_ + 100, @input_numbers; 

For each of the seven items map places into $_, we get a single output result: the number that is 100 greater than the input number. So the value of @result is 101, 102, 104, 108, 116, 132, and 164.

But we're not limited to having only one output for each input. Let's see what happens when each input produces two output items:


  my @result = map { $_, 3 * $_ } @input_numbers; 

Now there are two items for each input item: 1, 3, 2, 6, 4, 12, 8, 24, 16, 48, 32, 96, 64, and 192. We can store those pairs in a hash, if we need a hash showing what number is three times a small power of two:


  my %hash = @result; 

Or, without using the intermediate array from the map:


  my %hash = map { $_, 3 * $_ } @input_numbers; 

You can see that map is pretty versatile; we can produce any number of output items for each input item. And we don't always need to produce the same number of output items. Let's see what happens when we break apart the 数码:


  my @result = map { split //, $_ } @input_numbers; 

The inline 块 of code splits each number into its individual 数码. For 1, 2, 4, and 8, we get a single result. For 16, 32, and 64, we get two results per number. When map concatenates the results lists, we end up with 1, 2, 4, 8, 1, 6, 3, 2, 6, and 4.

If a particular invocation results in an empty list, map concatenates that empty result into the larger list, contributing nothing to the list. We can use this feature to select and reject items. For example, suppose we want only the split 数码 of numbers ending in 4:


  my @result = map { 
         my @digits = split //, $_; 
         if ($digits[-1] =  = 4) { 
           @digits; 
         } else { 
           (  ); 
         } 
  } @input_numbers; 

If the last digit is 4, we return the 数码 themselves by evaluating @数码 (which is in list context). If the last digit is not 4, we return an empty list, effectively removing results for that particular item. Thus, we can always use a map in place of a grep, but not vice versa.

Of course, everything we can do with map and grep, we can also do with explicit foreach loops. But then again, we can also code in assembler or by toggling bits into a front panel. [*] The point is that proper application of grep and map can help reduce the complexity of the program, allowing us to concentrate on high-level issues rather than details.

=head2 2. 2. 用eval捕捉错误

有一些代码看上去很平常, 但是却含有潜在的危险, 一旦某种条件不对就会使程序中断, 过早地结束程序. 


  my $average = $total / $count;                # divide by zero? 
  print "okay\n" unless /$match/;                # illegal pattern? 


  open MINNOW, '>ship. txt' 
  or die "Can't create 'ship. txt': $!";        # user-defined die? 


  &implement($_) foreach @rescue_scheme;        # die inside sub? 

可是, 不能因为代码的某一片断出错而使我们的整个程序崩溃.  Perl用eval操作符来实现捕捉错误的机制. .


  eval { $average = $total / $count } ; 

如果在eval块里代码发生错误, 系统会退出这个块.  但是, 尽管退出块, Perl会继续执行eval块之外的代码. 我们在eval块的后面一般做法是检查一下$@变量, 这个变量要么是空（表示没有出错）或者代码出错时系统返回的"遗言", 多半是"除零错误"之类云云. .


  eval { $average = $total / $count } ; 
  print "Continuing after error: $@" if $@; 


  eval { &rescue_scheme_42 } ; 
  print "Continuing after error: $@" if $@; 

eval块的结束时的分号是必须的, 因为不像 if或者while那样的控制结构, eval实际上是个函数.  但是代码块是真的块, 所以可以包括词法变量（"my" 修饰的变量）和另外其它的断言语句.  因为是个函数, eval有像子例程那样的返回值（最后一个表达式的求值结果, 或者由return语句返回的结果）.  当然, 如果代码块失败则没有值返回;如果在标量环境将返回未定义值, 在列表环境将返回一个空的列表. 因此, 比较安全的求平均值的代码的写法如下：


  my $average = eval { $total / $count } ; 

现在, 根据这个操作执行的成败, 变量$average要么是两数之商要么是个未定义值. 

Perl也支持eval代码块的嵌套. 只要代码执行, eval块总能捕捉错误, 所以它能捕捉嵌套子例程里发生的错误. 尽管如此, eval不能捕捉到非常严重的错误, 这些错误发生时Perl自己会中断执行. 这些错误包括无法捕捉的信号, 内存溢出或其它的灾难. eval同样不能捕捉到语法错误;因为Perl在编译eval及其它代码的时候检查语法错误, 而不是在运行时. 还有, eval也不能捕捉警告. （但是Perl的确提供一个方法来捕捉警告信息;可以查阅一下变量$SIG{__WARN__}）.

=head2 2. 3. 用eval动态编译代码

eval有另外一种用法, 其参数是作为一个字串表达式, 而不是代码块.  在运行时, 它将字串临时编译成代码并且执行. 这很易用, 但也很危险, 因为有可能会把具有危害性的代码放到字串里.  除了极少数值得一提的例外情况, 我们建议你尽量避免这种用法.  稍后我们会用这种用法, 然后我们就不用这种用法了, 我们只是展示它是怎么工作的. 


  eval '$sum = 2 + 2'; 
  print "The sum is $sum\n"; 

Perl在词法环境中执行那段代码, 这意味着我们好像在执行的时候输入这些代码的一样. eval的结果就是最后一个表达式求值的值, 所以我们不必在eval中输入整个语句. 


  #!/usr/bin/perl 


  foreach my $operator ( qw(+ - * /) ) { 
         my $result = eval "2 $operator 2"; 
         print "2 $operator 2 is $result\n"; 
         } 

上例中, 我们依次把+ - * /四个操作符用到我们的eval代码块中.  在给eval的字串中, 我们内插了变量$operator的值.  eval执行并返回了我们给出字串的值, 并且放到变量$result中. 

如果eval不能正确编译和执行我们传给它的Perl代码, 它就会像代码块形式的结果一样设置变量$@一个值.  在下例中, 我们想要捕捉任何除零错误, 但我们遇到了另外一种错误－－分母缺失. 


  print 'The quotient is ', eval '5 /', "\n"; 
  warn $@ if $@; 

eval捕捉语法错误, 然后在我们调用eval后, 在检查$@值时, 把出错信息放到变量$@中. 

The quotie（绑定操作符）nt is


  syntax error at (eval 1) line 2, at EOF 

在稍后的第10、17和18章中, 我们会用这种办法来调用可选模块.  如果我们调用模块失败, Perl会中止程序.  而我们会捕捉到这种错误, 并由我们自己以我们的办法恢复程序的运行. 

万一你还没有注意我们的警告, 我们在这里重申：要非常小心这种形式的eval用法. 如果你有其它的方法来替代eval用法, 那就试试其它方法.  我们在后来第10章会用到这种办法从外部文件中载入代码, 但我们同样会向你展示出更好的替代方案. 

=head2 2. 4. 习题

答案在附录中的"第二章的答案"中;

=head2 2. 4. 1. 习题 1 [15 分钟]

写一个程序从命令行取一个文件清单, 然后用grep把那些文件大小在1000字节以内的文件找出来.  用map把这个清单里的每个字串前加四个空格并在字串后面加上换行符.  然后输出列表结果. 

=head2 2. 4. 2. 练习 2 [25 分钟]

写一个程序要求用户输入一个正则表达式的模板.  不要以命令行参数形式输入, 要从键盘读取. 然后从一些目录中（可以是硬编码的, 如： "/etc" 或 'C:\\Windows'）中读取符合模板的文件名.  重复这个操作直到用户输入空串.  要屏蔽用户输入的正斜杠("/"), 因为那是Perl里正则表达式的分隔符;输入的模板用换行符为分隔.  要保证不会因为用户输入了一个错误的正则表达式, 如括号不匹配之类的, 而导致程序崩溃. 

