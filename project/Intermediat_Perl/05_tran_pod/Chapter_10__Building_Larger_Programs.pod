=head2 第十章 构建更大的程序

这一章我们来看看如何把程序分成一些小的部份, 并且包括那些把小程序组合成一个整体时会发生的问题. 以及多个人协同完成一个项目时分发生的问题. 

=head2 10. 1. The Cure for the Common Code

Skipper写了许多Perl程序应Minnow的要求为一般的港口提供导航服务. 他发现自己不停的在各个程序之间复制和粘贴一个通用子例程：


 sub turn_toward_heading { 
   my $new_heading = shift; 
   my $current_heading = current_heading(  ); 
   print "Current heading is ", $current_heading, ". \n"; 
   print "Come about to $new_heading "; 
   my $direction = 'right'; 
   my $turn = ($new_heading - $current_heading) % 360; 
   if ($turn > 180) { # long way around 
     $turn = 360 - $turn; 
     $direction = 'left'; 
   } 
   print "by turning $direction $turn degrees. \n"; 
 } 

这个通用子例程提供从当前航向的最短的转向（从子程序current_heading()返回）到一个新的航向（由第一个参数输入）. 

子程序的第一行可以用如下行代替：


 my ($new_heading) = @_; 

这是另一特色的调用：两种情况, 第一个参数都结束于$new_heading. 然而, 正像他们指出的, 从@_提取元素比较方便. 所以, 我们大多数情况下用"shift"风格的参数解析. （？）现在回到我们手头的程序… …

用这个例程写了一打程序之后, Skipper发现这样用下来, 当他花时间调到正确的航向时, 已经有非常多的输出（或者作简单的在正确的航向漂流）. 毕竟, 如果当前航向是234度, 而他要转234度, 我们会看到：


 Current heading is 234.  
 Come about to 234 by turning right 0 degrees.  

真烦人！Skipper决定修正这个0航向的问题：


 sub turn_toward_heading { 
   my $new_heading = shift; 
   my $current_heading = current_heading(  ); 
   print "Current heading is ", $current_heading, ". \n"; 
   my $direction = 'right'; 
   my $turn = ($new_heading - $current_heading) % 360; 
   unless ($turn) { 
     print "On course (good job!). \n"; 
     return; 
   } 
   print "Come about to $new_heading "; 
   if ($turn > 180) { # long way around 
     $turn = 360 - $turn; 
     $direction = 'left'; 
   } 
   print "by turning $direction $turn degrees. \n"; 
 } 

不错. 新的子程序工作得很好. 然而, 因为前期他已经用拷贝粘贴的办法把这个程序贴在导航程序里很多地方, 其它程序仍旧出现令Skipper不胜其烦的超量输出信息. 

Skipper需要一种方法, 只写一篇程序, 然后把它共享给其它程序. 而且, 正像Perl的大多数事物一样, 条条大路通罗马. 

=head2 10. 2. Inserting Code with eval

Skipper可以把程序turn_toward_heading的定义独立出为另一个文件以节省磁盘空间（也是脑力空间）. 比如, 如果Skipper发现与导航相关的半打通用子程序, 他可能用在大多数或所有的程序中. 他可以把它们放在一个分开的文件叫做navigation. pm中, 只包含有需要的子程序. 

到目前为止, 我们如何告诉Perl从另外一个程序中拉出一块程序代码呢？ 我们可以用硬编码, 第二章所讨论过的用eval的形式来求一个字串的值. 


 sub load_common_subroutines { 
   open MORE_CODE, 'navigation. pm' or die "navigation. pm: $!"; 
   undef $/; # enable slurp mode 
   my $more_code = <MORE_CODE>; 
   close MORE_CODE; 
   eval $more_code; 
   die $@ if $@; 
 } 

Perl把navigation. pm程序的代码写入变量$more_code. 我们用eval来让Perl把这段文本以代码来处理. 任何$more_code变量中的词法变量被当作本地变量来求值. ［＊］如果其中有语法错误, Perl会设置$@变量, 并且导致程序以适当的出错信息退出. 

［＊］奇怪的是, 变量$morecode同样对于求值代码可见, 不像其它eval求值时会改变变量. 

现在, 不必在每个文件里的打上几十行通用代码, 我们方便地把一个子程序放到每个文件中. 

不过这不是最漂亮的, 特别是当我们需要重复这些工作的时候. 好在, Perl 有多种途径来帮助我们. 

=head2 10. 3. Using do

Skipper把一些导航通用子程序放入navigation. pm后, 如果Skipper只将如下语句：


 do 'navigation. pm'; 
 die $@ if $@; 

放到导航程序里的话, 它几乎同我们用eval把代码插在同一地点的执行结果是相同的. [+] []

[] [+] 这排除了考虑@INC、%INC的情况, 以及丢失文件定位处理, 这个我们在后面的章节会遇到. 

那就是说, do 操作符的功能就像把navigation. pm中的代码直接引入现当前的程序一样, 尽管在它自己的块范围内, 所以词法变量（my 声明的变量） 和大多数指示字（如use strict）不会流到主程序里去. 

这样, Skipper可能安全的修改一处拷贝, 而不必把这些修改和扩展拷贝到所有其它他创建和使用的导航程序中. 图10-1展示了Skipper如何使用他的通用程序库. 

图10-1. Skipper在他其它所有的导航程序中使用navigation. pm 文件中的程序

当然, 这样做需要一些约束, 因为如果在给出的子程序中破坏了一个预期的接口, 会影响到许多其它的程序而不只自己一个. [+] Skipper需要对组件的重用性和模块化的设计给予专门的考虑. 我们先假定Skipper有这方面的经验, 但是我们会在以后的章节中展示更多这方面的知识. 

[] [+] 在后面的章节中, 我们会展示如何建立测试程序来维护可重用的代码. 

通过将一些代码放到文件中, 其它的程序员可以重用Skipper写的程序, 反过来也一样. 如果Gilligan写了一个程序:drop_dnchor(), 并且将其放到文件drop_anchor. pm中, 这样Skipper就可以通过引入库的办法使用Gilligan的代码：


 do 'drop_anchor. pm'; 
 die $@ if $@; . . .  
 drop_anchor(  ) if at_dock(  ) or in_port(  ); 

所以, 从分开的文件引入代码可以使我们可以更方便地维护和协同编程. 

当代码从一个. pm文件导入的时候可以有直接可执行的语句, 这比用do简单定义子程序更为常用. 

我们再回到drop_anchor. pm库, 如果Skipper要写个程序需要"抛锚"和导航呢？


 do 'drop_anchor. pm'; 
 die $@ if $@; 
 do 'navigation. pm'; 
 die $@ if $@; . . .  
 turn_toward_heading(90); . . .  
 drop_anchor(  ) if at_dock(  ); 

这一工作很好很顺利. 子程序在两个库中定义, 使用起来就像在这个程序里一样. 

=head2 10. 4. Using require

假定navigation. pm自己, 因为一些导航任务而把drop_anchor. pm引进自己的模块里. Perl在处理导航程序包的时候将文件一次直接读入. 在这次重新定义drop_anchor()是不必要的. 更糟的是, 如果我们把警告打开, 我们会从Perl得到一个警告信息, 说我们已经重新定义子程序, 尽管是一模一样的定义. 

[*] 你开启警告是吗？你可以用-w开关, 以及use warnings来开始警告;

我们需要一种机制来跟踪哪些文件我们已经调入了, 而且应该只把它们调入一次. Perl提供了这个功能, 叫作require. 把前面的代码改成如下就可以了：


 require 'drop_anchor. pm'; 
 require 'navigation. pm'; 

require操作符会在Perl每次读入文件的时候进行跟踪[+] 一旦Perl成功加载了一个文件, 它就会忽略之后require引入相同的文件. 这意味着就算navigation. pm包括require "drop_anchor. pm", Perl只会把drop_anchor. pm引入一次, 我们就不会收到烦人的警告重复定义子程序的消息了（见图10－2）. 更重要的是, 我们同样节省时间, 不必多次加载文件了. 

[] 在%INC散列中, 正如perlfunc文档中require条目所描述的一样. 

图10-2. 一旦Perl调入drop_anchor. pm文件, 它会忽略其它相同文件的导入

require操作符同样有以下两个功能：

任何语法错误会导致程序终止; 所以许多 die $@ if $@语句在这里是不需要的. 

文件最后一个求值必须返回真值

Because of the second point, most 文件 evaluated for require have a cryptic 1; as their last line of code. This ensures that the last evaluated expression is, in fact, true. Try to carry on this tradition as well.

Originally, the mandatory true value was intended as a way for an included file to signal to the invoker that the code was processed successfully and that no error condition existed. However, nearly everyone has adopted the die if. . . strategy instead, deeming the "last expression evaluated is false" strategy a mere historic annoyance.

=head2 10. 5. require and @INC

到目前为止, 这些例子都忽略了我们如何建立目录结构来安排主要代码和要导入的代码文件应该安放的位置. 那是因为"能工作就行", 用最简单的情形, 我们把程序和它的库放在同一目录, 并就在这个目录里运行程序. 

当库文件不在当前目录的时候, 事件就有些复杂了. 实际上, Perl按库一个库搜索路径来查找库, 有些像UNIX shell用PATH环境变量一样. 当前目录（在Unix里以句点表示）是查寻目录之一. 所以只要我们的库在我们的当前工作目录, 就没问题. 

查寻目录是在一个特别的数组@INC中的列表中一系列的元素, 就象我们在第三章讲过的一样. 缺省时, 数组包括当前目录和一些由编译Perl的用户指定的目录. 在命令行输入Perl -V 可以在最后几行显示出这些目录. 用如下的命令也可以显示@INC所包括的目录[*]

[*] 在Windows操作系统的电脑上, 用双引号代替单引号. 


 perl -le 'print for @INC' 

在输出列表中, 除了句点. , 除非我们是负责在这台电脑上维护Perl的人, 我们大概不能写任何其它的目录进去. 在这种情况下, 我们应该能把它们写进去. 象我们后面要看到的, 余下的目录是Perl系统搜索系统库和模块的目录, 象我们后面所看到的. 

=head2 10. 5. 1. Extending @INC

我们可能碰到这些情况, 即不能（想）在预先配置在@INC中的目录中安装模块. 但我们可以在require之前先改变数组@INC自己, 这样Perl也会去查找我们的目录. 数组@INC就是平常的数组, 所以让Skipper把它主目录加进去：


 unshift @INC, '/home/skipper/perl-lib'; 

现在, 除了搜索标准目录和当前目录, Perl还搜索Skipper的个人Perl模块库. 实际上, Perl首先就会查这个目录, 因为这条会排在数组@INC最前面. 因为使用的是unshift而不是push, Perl会将取Skipper的文件放在优先位置, 以此解决Skipper的私有文件与系统安装的文件之间可能的冲突. 

一般来说, 我们要保证添加搜索目录一定要放在其它事之前, 我们可以把它放进BEGIN块. Perl会在编译阶段执行在BEGIN块中的语句, 而在运行时执行require语句. 除此之外, Perl会以文件中的自然顺序执行语句, 所以我们要保证我们的unshift要出现在我们的require之前. 


 BEGIN { 
   unshift @INC, '/home/skipper/perl-lib'; 
 }; 

因为这个操作太常见了, 所以Perl有一个编译指示字来处理. 编译指示字发生在任何运行时之前, 所以我们可以得到预期的效果.  它会把我们指示的目录放到@INC数组的最前面, 正象我们前面做的那样. 

use lib qw(/home/skipper/perl-lib);

我们不一定总是能事先预知目录路径. 在前面的例子中, 我们对路径是硬编码的. 如果我们事先不知道路径是什么, 这有可能是我们在几个机器之前传送代码, Perl自带的FindBin模块可以帮助你. 它会找到脚本所在的目录的全路径, 这样我们可以依此来建立自己的路径. 


 use FindBin qw($Bin); 

现在, 变量$Bin中的路径是我们的脚本所在的路径. 如果我们把库放在同一路径, 我们下一行可以是：


 use lib $Bin; 

如果我们把库放在脚本目录中的一个目录, 我们只要把正确的路径加上去就可以了, 这样就能工作了. 


 use lib "$Bin/lib";    # in a subdirectory 


 use lib "$Bin/. . /lib"; # up one, then down into lib 

这样, 如果我们知道脚本目录的相对路径, 我们就不必硬编码全路径了. 这使我们的脚本更加易于移植. 

=head2 10. 5. 2. Extending @INC with PERL5LIB

Skipper必须编辑每个程序里以使用他的私有库来导入前面的那些代码. 如果这样编辑太麻烦了, 他可以设置PERL5LIB环境变量, 加上库文件目录. 比如, 在C shell中, 他可以用下面这行：


 setenv PERL5LIB /home/skipper/perl-lib 

在Bourne类型的shell中, 他可以用类似于如下的行：


 PERL5LIB=/home/skipper/perl-lib; export PERL5LIB 

Skipper可以在一次设置PERL5LIB后就把它忘了. 然而, 除非Gilligan使用同样的PERL5LIB环境变量, 它的程序就会失败！ 因为PERL5LIB对个人使用非常有用, 当我们与其它人共享程序时, 我们不能依靠它. （而且我们也不能让我们整个程序员团队的人用一个共同的PERL5LIB变量. 相信我们, 我们试过. ）

PERL5LIB环境变量可以加多个目录, 中间用分号分开. Perl会把所有这些目录加到@INC中. 

当一个系统管理员把PERL5LIB作为系统范围的设置, 大多数人可能为此而不悦. PERL5LIB的目录是使非管理员来扩展Perl搜索目录. 如果一个系统管理员要添加目录, 它仅仅需要重编译和重装Perl. 

=head2 10. 5. 3. Extending @INC with -I

如果Gilligan注意到Skipper的程序丢失了合适的指示字, Gilligan可以通过设置正确的PERL5LIB环境变量, 也可以用Perl的-I 选项. 比如, 要调用Skipper的get_us_home程序, 在命令行可能是：


 perl -I/home/skipper/perl-lib /home/skipper/bin/get_us_home 

显然, 如果程序自己定义额外的库, 对Gilligan来说更方便. 但有时加一个-I仅是修复一些东西. [*] 这在Gilligan无需编辑Skipper的程序的情况下也能工作. 当然, 它要有读的权限, 但是, 举个例子来说, Gilligan可以用这个技术试一个使用Skipper程序的新版本. 

[*] Extending @INC with either PERL5LIB orI also automatically adds the versionand architecture-specific subdirectories of the specified directories. Adding these directories automatically simplifies the task of installing Perl modules that include architecture- or version-sensitive components, such as compiled C code.

=head2 10. 6. The Problem of Namespace Collisions

有时候Sipper要把船开进一个小岛, 但有时程序里会发生一对名字发生冲突的情况. 假定Skipper把他的所有的有用和酷的子程序加到navigation. pm中, 而Gilligan已经导入他自己的导航程序包, head_toward_island:


 #!/usr/bin/perl 


 require 'navigation. pm'; 


 sub turn_toward_port { 
   turn_toward_heading(compute_heading_to_island(  )); 
 } 


 sub compute_heading_to_island { . . code here. .  
 } 

. . more program here. .

Gilligan开始调试自己的程序（可能有一个有个聪明的人在帮他, 我们叫他"教授"）, 一切顺利. 

然而, 现在Skipper决定修改他的navigation. pm库, 加一个子程序：turn_toward_port, 使船可以以45度角向左舷转向（航海术语, 左舷是靠向岸的舷）. 

Gilligan的程序总是在他准备转向岸时就出现灾难：他会使船总是转圈！ 问题在于Perl编译器开始编译Gilligan主程序中的turn_toward_port, 然后当Perl在运行时解析require时, 它以Skipper的定义的turn_toward_port重新定义了这个程序. 当然, 录果Gilligan打开了警告, 他会注意有出错信息, 但他为什要仰赖这个呢？

问题在于Gilligan定义的turn_toward_port的作用是"把左舷靠向岛", 而Skipper的定义是"向左转". 如何来解决这个问题呢？

一种方法是需要Skipper加个显式的前缀在每个他定义的库中的程序名上, 比如, navigation_. 这样, Gilligan的程序看上去是这样的：


 #!/usr/bin/perl 


 require 'navigation. pm'; 


 sub turn_toward_port { 
   navigation_turn_toward_heading(compute_heading_to_island(  )); 
 } 


 sub compute_heading_to_island { . . code here. .  
 } 

. . more program here. .

这样就明白了, navigation_turn_toward_heading来自于navigation. pm文件. 这对Gilligan是不错, 不过让Skipper很窘, 因为他的程序现在有很长的程序名：


 sub navigation_turn_toward_heading { . . code here. .  
 } 

=head2 10. 7. Packages as Namespace Separators

package Navigation;


 package Navigation; 


 sub turn_toward_heading { . . code here. .  
 } 


 sub turn_toward_port { . . code here. .  
 } 


 1; 

在文件的开始的程序包声明, 显式地告诉Perl将Navigation::插入到文件中大多数名字的前面. 这样, 上面的代码实际上在说：


 sub Navigation::turn_toward_heading { . . code here. .  
 } 


 sub Navigation::turn_toward_port { . . code here. .  
 } 


 1; 

现在Gilligan导入这个文件, 他只要简单的把在库里引用的子例程前加上Navigation::前缀即可, 而在他自己的同名程序前面不加前缀. 


 #!/usr/bin/perl 


 require 'navigation. pm'; 


 sub turn_toward_port { 
   Navigation::turn_toward_heading(compute_heading_to_island(  )); 
 } 


 sub compute_heading_to_island { . . code here. .  
 } 

. . more program here. .

程序包名字与变量名字相同：他们包括字母和数字及下划线, 但是不能以数字开头. 同样, 因为在Perl的perlmodlib文档中说明的理由, 一个程序包名应该以大写开头, 并且不与现存的Perl综合典藏网或核心的模块名重名. 包名可以以双冒号分隔定义多个名字, 如：Minnow::Navigation及Minnow::Food::Storage. 

几乎所有的标量、数组、散列、子程序及文件句柄名字实际上已经加上了当前的程序包的名字, 除非原来的名字已经包括一个或多个双冒号标记. 

[*] 除了词法变量, 我们会在后面说到. 

所以, 在navigation. pm中, 我们可以用下面的变量名：[+][]

[] [+] 小注：21. 283度以北, 157. 842度以西是现实生活中一个地点, 上过一个著名的电视节目. 如果你不信, 可以查查Google Maps. 


 package Navigation; 
 @homeport = (21. 283, -157. 842); 


 sub turn_toward_port { . . code. .  
 } 

我们可以在主程序中用全名引用@homeport变量：


 @destination = @Navigation::homeport; 

如果每个名字前面都有包名字, 那么主程序的名字会是什么？是的, 他们同样有包名字, 称作main. 就好象在main这个程序包里面;在每个文件开始的地方. 所以, 要Gilligan避免说Navigation::turn_toward_heading, navigation. pm文件中可以用：


 sub main::turn_toward_heading { . . code here. .  
 } 

现在, 子程序被定义在main程序包中, 不在navigation包中. 这不是一个好的解决方法（我们会在第15章, 讨论Exporter的时候来说更好的做法）, 但是, 至少目前也没有其它利害的独特方案可以匹分main与其它包. 

这就是在第三章中的那些模块在导入符号到脚本时要做的事情, 但是当时我们没有告诉你整个故事的细节. 这些模块把子例程和变量导入到当前的包（通常, 这是你这个脚本的main包）. 换句话说, 这些符号仅存在于那些包中, 除非你全名引用. 我们会在后面来详述这套机制是如何工作的. 

=head2 10. 8. Scope of a Package Directive

所有的文件都好像以main程序包开始;[*] 所有的包指示字的范围在其声明处开始到下一个包指示字声明的地方结束, 除非那个包指示字在一个大括号范围之内. 在那种情况下, Perl会记住前面的包, 并在其范围结束时恢复它. 这里是个例子. 

[*] Perl 不会让我们像C那样创建一个显式的main( )循环. Perl清楚每个脚本都需要它, 所以它自动为我们做了这项工作. 


 package Navigation; 


 {  # start scope block 
   package main;  # now in package main 


   sub turn_toward_heading {  # main::turn_toward_heading . . code here. .  
   } 


 }  # end scope block 


 # back to package Navigation 


 sub turn_toward_port { # Navigation::turn_toward_port . . code here. .  
 } 

当前的包是词法范围的, 像my声明的变量一样, 范围限制在大括号的最里层或我们引入包的文件范围之内. 

大多数的库只在一个文件里放一个包, 并且在文件开始的地方声明包名. 大多数的程序就把缺省的main作为包名. 不过知道我们可以临时有个不同的当前包名是不错的. [+] []

[] [+] 有些名字总是在main包里, 而不论当前的包是什么： 命令行传入参数, 命令行传入参数OUT, ENV, INC, SIG, STDERR, STDIN和STDOUT. 我们可以总是引用@INC而得到@main::INC. 那些标点符号标记的变量名, 如$_, $2, 及$!, 也是要么是词法变量或者强制属于main包, 所以当我们写$. , 我们不必加上$Navigation::而导致错误. 

=head2 10. 9. Packages and Lexicals

一个词法变量（以my声明的变量） 不会有当前包名做前缀, 因为包变量已经是全局的了：我们总是可以引用一个包变量, 如果我们知道它的全名. 一个词法变量通常是临时的或只在程序的局部可访问. 如果我们声明一个词法变量, 然后不带包前缀地使用它, 就获得一个词法变量. 一个包前缀保证我们可以访问一个包变量, 而不是词法变量. 

举例来说, 假定navigationpm中的一个子例程声明了一个词法变量@homeport. 那么, 任何使用@homeport时, 都是指新引入的词法变量, 但是如果用全名来引用@havigation::homeport将访问的是包变量. 


 package Navigation; 
 @homeport = (21. 283, -157. 842); 


 sub get_me_home { 
   my @homeport; 

. . @homeport. . # refers to the lexical variable . . @Navigation::homeport. . # refers to the package variable


 } 

. . @homeport. . # refers to the package variable

显然, 这段代码会导致混淆, 所以我们不应该搞这种没必要的双重声明. 尽管结果早就会料到. 

=head2 10. 10. 习题

答案见附录. 

=head2 10. 10. 1. 练习 1 [25 分钟]

岛上的土著Oogaboogoo对于日期和月份着不同寻常的名字. 这里有个从Gilligan来的简单但写得不是很好的代码. 修改一下, 给月份名加一个对话函数, 并把这些放到一个库里. 为了更好的可靠性, 添加一个错误检查程序以及文档. 


 @day = qw(ark dip wap sen pop sep kir); 
 sub number_to_day_name { my $num = shift @_; $day[$num]; } 
 @month = qw(diz pod bod rod sip wax lin sen kun fiz nap dep); 

=head2 10. 10. 2. 练习2 [15分钟]

写个程序使用你的库并用如下代码打印一些信息, 如今天是dip, sen 15, 2011, 表示今天是八月的周一. （暗示：localtime返回的年月数字可能并不一定是你想要的, 所以你要查一下文档. ）


 my($sec, $min, $hour, $mday, $mon, $year, $wday) = localtime; 

