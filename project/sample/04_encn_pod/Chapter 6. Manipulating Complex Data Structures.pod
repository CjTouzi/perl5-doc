=EN Manipulating Complex Data Structures Now that you've seen the basics of references, let's look at additional ways to manipulate complex data.

=CN Manipulating Complex Data Structures Now That You'Ve Seen The basics Of References, Let's Look At Additional Ways To 操纵 综合的 Data.

=EN We'll start by using the debugger to examine complex data structures and then use Data::Dumper to show the data under programmatic control.

=CN We'我 Start By Using The Debugger To 检查 综合的 Data Structures And Then Use Data::Dumper To Show The Data 在 programmatic Control.

=EN Next, you'll learn to store and retrieve complex data easily and quickly using Storable, and finally we'll wrap up with a review of grep and map and see how they apply to complex data.

=CN Next, You'我 学习 To 商店 And retrieve 综合的 Data 容易地 And 快 Using Storable, And 最终 We'我 包 Up With a 检查 Of Grep And Map And See How They 应用 To 综合的 Data.

=EN Using the Debugger to View Complex Data The Perl debugger can display complex data easily.

=CN Using The Debugger To View Complex Data The Perl Debugger Can 陈列 综合的 Data 容易地.

=EN For example, let's single-step through one version of the byte-counting program from Chapter 5:

=CN For Example, Let's Single-脚步 通过 One Version Of The 字节-counting Program From Chapter 5:

=EN my %total_bytes; while (<>) {

=CN My %total_bytes; While (<>) {

=EN Here's the data we'll use to test it:

=CN Here's The Data We'我 Use To Test It:

=EN professor.hut gilligan.crew.hut 1250 professor.hut lovey.howell.hut 910 thurston.howell.hut lovey.howell.hut 1250 professor.hut lovey.howell.hut 450 ginger.girl.hut professor.hut 1218 ginger.girl.hut maryann.girl.hut 199

=CN professor.hut gilligan.crew.小屋 1250 professor.hut lovey.howell.小屋 910 thurston.howell.小屋 lovey.howell.小屋 1250 professor.hut lovey.howell.小屋 450 ginger.girl.小屋 professor.hut 1218 ginger.girl.小屋 maryann.girl.小屋 199

=EN We can do this a number of ways.

=CN We Can Do This a Number Of Ways.

=EN One of the easiest is to invoke Perl with a -d switch on the command line:

=CN One Of The easiest Is To 调用 Perl With a -d Switch On The 命令 Line:

=EN myhost% perl -d bytecounts bytecounts-in

=CN myhost% Perl -d bytecounts bytecounts-In

=EN Loading DB routines from perl5db.pl version 1.19 Editor support available.

=CN Loading DB Routines From perl5db.pl Version 1.19 Editor Support Available.

=EN Enter h or 'h h' for help, or 'man perldebug' for more help.

=CN Enter h Or 'h h' For Help, Or '人 perldebug' For More Help.

=EN main::(bytecounts:2): my %total_bytes;

=CN Main::(bytecounts:2): My %total_bytes;

=EN If you're playing along at home, be aware that each new release of the debugger works differently than any other, so your screen probably won't look exactly like ours.

=CN If You'Re 玩 沿着 At 家, Be 知道的 That Each New Release Of The Debugger Works 不同地 Than Any Other, So Your 屏 Probably Won't Look Exactly Like ours.

=EN Also, if you get stuck at any time, type h for help or look at perldoc perldebug.

=CN Also, If You Get stuck At Any Time, Type h For Help Or Look At perldoc perldebug.

=EN The debugger shows each line of code before it executes it.

=CN The Debugger Shows Each Line Of Code Before It 实行 It.

=EN That means that, at this point, we're about to invoke the autovivification, and we've got our keys established.

=CN That Means That, At This 尖, We'Re About To 调用 The autovivification, And We'Ve Got Our Keys 已建立的.

=EN The s command single-steps the program, while the x command dumps a list of values in a nice format.

=CN The s 命令 Single-步骤 The Program, While The x 命令 dumps a List Of Values In a Nice Format.

=EN We can see that $source, $destination, and $bytes are correct, and now it's time to update the data:

=CN We Can See That $Source, $终点, And $字节 Are 正确的, And Now It's Time To Update The Data:

=EN We've created the hash entries through autovivification.

=CN We'Ve Created The Hash Entries 通过 autovivification.

=EN Let's see what we've got:

=CN Let's See What We'Ve Got:

=EN Let's see what happens just after the next assignment:

=CN Let's See What Happens Just After The 下一次 Assignment:

=EN Now we've added bytes flowing from professor.hut to lovey.howell.hut.

=CN Now We'Ve added 字节 flowing From professor.hut To lovey.howell.小屋.

=EN The top-level hash hasn't changed, but the second-level hash has added a new entry.

=CN The 顶-Level Hash hasn't 改变, But The Second-Level Hash Has added a New Entry.

=EN Let's continue:

=CN Let's Continue:

=EN Now we're adding in some more bytes from professor.hut to lovey.howell.hut, reusing the existing value place.

=CN Now We'Re Adding In Some More 字节 From professor.hut To lovey.howell.小屋, 重用 The 现存的 Value Place.

=EN Nothing too exciting there.

=CN Nothing Too 令人激动的 There.

=EN Let's keep stepping:

=CN Let's 保持 stepping:

=EN This time, we added a new source, ginger.girl.hut.

=CN This Time, We added a New Source, ginger.girl.小屋.

=EN Notice that the top level hash now has three elements, and each element has a different hash reference value.

=CN Notice That The 顶 Level Hash Now Has Three Elements, And Each Element Has a Different Hash Reference Value.

=EN Let's step some more:

=CN Let's 脚步 Some More:

=EN Now we've added a second destination to the hash that records information for all bytes originating at ginger.girl.hut.

=CN Now We'Ve added a Second 终点 To The Hash That Records Information For All 字节 originating At ginger.girl.小屋.

=EN Because that was the final line of data (in this run), a step brings us down to the lower foreach loop:

=CN Because That Was The 最终的 Line Of Data (In This Run), a 脚步 brings Us 向下 To The Lower Foreach Loop:

=EN Even though we can't directly examine the list value from inside those parentheses, we can display it:

=CN Even Though We Can't 直接地 检查 The List Value From 里面 Those Parentheses, We Can 陈列 It:

=EN DB<14> x sort keys %total_bytes

=CN DB<14> x Sort Keys %total_bytes

=EN This is the list the foreach now scans.

=CN This Is The List The Foreach Now 扫描.

=EN These are all the sources for transferred bytes seen in this particular logfile.

=CN These Are All The 来源 For transferred 字节 Seen In This Particular logfile.

=EN Here's what happens when we step into the inner loop:

=CN Here's What Happens When We 脚步 Into The Inner Loop:

=EN At this point, we can determine from the inside out exactly what values will result from the list value from inside the parentheses.

=CN At This 尖, We Can 决心 From The 里面 Out Exactly What Values Will Result From The List Value From 里面 The Parentheses.

=EN Let's look at them:

=CN Let's Look At Them:

=EN DB<15> x $source

=CN DB<15> x $Source

=EN Note that dumping $total_bytes{$source} shows that it was a hash reference.

=CN Note That 倾销 $total_bytes{$Source} Shows That It Was a Hash Reference.

=EN Also, the sort appears not to have done anything, but the output of keys is not necessarily in a sorted order.

=CN Also, The Sort Appears Not To Have Done Anything, But The 出产 Of Keys Is Not Necessarily In a 分类 Order.

=EN The next step finds the data:

=CN The 下一次 脚步 发现 The Data:

=EN As we can see with the debugger, we can easily show the data, even structured data, to help us understand our program.

=CN As We Can See With The Debugger, We Can 容易地 Show The Data, Even structured Data, To Help Us Understand Our Program.

=EN Viewing Complex Data with Data::Dumper Another way to visualize a complex data structure rapidly is to dump it.

=CN Viewing Complex Data With Data::Dumper Another Way To visualize a 综合的 Data Structure 迅速地 Is To 倾倒 It.

=EN A particularly nice dumping package is included in the Perl core distribution, called Data::Dumper.

=CN A 特别地 Nice 倾销 Package Is 包括 In The Perl Core 分配, Called Data::Dumper.

=EN Let's replace the last half of the byte-counting program with a simple call to Data::Dumper:

=CN Let's 归还原处 The Last 一半 Of The 字节-counting Program With a Simple Call To Data::Dumper:

=EN use Data::Dumper;

=CN Use Data::Dumper;

=EN print Dumper(\%total_bytes);

=CN Print Dumper(\%total_bytes);

=EN The Data::Dumper module defines the Dumper subroutine.

=CN The Data::Dumper Module 定义 The Dumper Subroutine.

=EN This subroutine is similar to the x command in the debugger.

=CN This Subroutine Is Similar To The x 命令 In The Debugger.

=EN We can give Dumper one or more values, and Dumper turns those values into a printable string.

=CN We Can Give Dumper One Or More Values, And Dumper Turns Those Values Into a printable String.

=EN The difference between the debugger's x command and Dumper, however, is that the string generated by Dumper is Perl code:

=CN The Difference Between The Debugger's x 命令 And Dumper, However, Is That The String Generated By Dumper Is Perl Code:

=EN myhost% perl bytecounts2 <bytecounts-in $VAR1 = {

=CN myhost% Perl bytecounts2 <bytecounts-In $VAR1 = {

=EN The Perl code is fairly understandable; it shows that we have a reference to a hash of three elements, with each value of the hash being a reference to a nested hash.

=CN The Perl Code Is 公平地 Understandable; It Shows That We Have a Reference To a Hash Of Three Elements, With Each Value Of The Hash Being a Reference To a 嵌套的 Hash.

=EN We can evaluate this code and get a hash that's equivalent to the original hash.

=CN We Can 估价 This Code And Get a Hash That's Equivalent To The Original Hash.

=EN However, if you're thinking about doing this in order to have a complex data structure persist from one program invocation to the next, please keep reading.

=CN However, If You'Re 思想 About Doing This In Order To Have a 综合的 Data Structure 坚持 From One Program 调用 To The 下一次, 使高兴 保持 读书.

=EN Data::Dumper, like the debugger's x command, handles shared data properly.

=CN Data::Dumper, Like The Debugger's x 命令, 处理 Shared Data Properly.

=EN For example, go back to that "leaking" data from Chapter 5:

=CN For Example, Go Back To That "leaking" Data From Chapter 5:

=EN use Data::Dumper; $Data::Dumper::Purity = 1; # declare possibly self-referencing structures my @data1 = qw(one won); my @data2 = qw(two too to); push @data2, \@data1; push @data1, \@data2; print Dumper(\@data1, \@data2);

=CN Use Data::Dumper; $Data::Dumper::Purity = 1; # Declare Possibly 自己-referencing Structures My @data1 = Qw(One Won); My @data2 = Qw(Two Too To); Push @data2, \@data1; Push @data1, \@data2; Print Dumper(\@data1, \@data2);

=EN Here's the output from this program:

=CN Here's The 出产 From This Program:

=EN Notice how we've created two different variables now, since there are two parameters to Dumper.

=CN Notice How We'Ve Created Two Different Variables Now, Since There Are Two Parameters To Dumper.

=EN The element $VAR1 corresponds to a reference to @data1, while $VAR2 corresponds to a reference to @data2.

=CN The Element $VAR1 对应吗 To a Reference To @data1, While $VAR2 对应吗 To a Reference To @data2.

=EN The debugger shows the values similarly:

=CN The Debugger Shows The Values 同样:

=EN Note that the phrase REUSED_ADDRESS indicates that some parts of the data are actually references we've already seen.

=CN Note That The 词组 REUSED_ADDRESS 表明 That Some 部分 Of The Data Are Actually References We'Ve Already Seen.

=EN YAML Data::Dumper is not the only game on the island, though.

=CN YAML Data::Dumper Is Not The Only 游戏 On The 岛屿, Though.

=EN Brian Ingerson came up with Yet Another Markup Language (YAML) to provide a more readable (and more compact) dump.

=CN Brian Ingerson 来 Up With Yet Another Markup Language (YAML) To Provide a More 可读性 (And More 严密的) 倾倒.

=EN It works in the same way as Data::Dumper.

=CN It Works In The Same Way As Data::Dumper.

=EN We'll see more about YAML when we talk about modules later, so we won't say much about it here.

=CN We'我 See More About YAML When We 谈话 About Modules 更晚, So We Won't Say Much About It Here.

=EN From the earlier example, we plug in YAML where we had Data::Dumper, and use Dump( ) where we had Dumper( ).

=CN From The Earlier Example, We 塞子 In YAML Where We Had Data::Dumper, And Use Dump( ) Where We Had Dumper( ).

=EN use YAML;

=CN Use YAML;

=EN my %total_bytes;

=CN My %total_bytes;

=EN while (<>) {

=CN While (<>) {

=EN print Dump(\%total_bytes);

=CN Print Dump(\%total_bytes);

=EN When you use the same data from the earlier example, you get this output:

=CN When You Use The Same Data From The Earlier Example, You Get This 出产:

=EN --- #YAML:1.0 ginger.girl.hut:

=CN --- #YAML:1.0 ginger.girl.小屋:

=EN That's a lot easier to read because it takes up less space on the screen, which can be really handy when you have deeply nested data structures.

=CN That's a 许多 Easier To Read Because It Takes Up 更少的 Space On The 屏, Which Can Be Really 方便的 When You Have Deeply 嵌套的 Data Structures.

=EN Storing Complex Data with Storable We can take the output of Data::Dumper's Dumper routine, place it into a file, and then load the file to a different program.

=CN Storing Complex Data With Storable We Can Take The 出产 Of Data::Dumper's Dumper Routine, Place It Into a File, And Then Load The File To a Different Program.

=EN When we evaluate the code as Perl code, we end up with two package variables, $VAR1 and $VAR2, that are equivalent to the original data.

=CN When We 估价 The Code As Perl Code, We End Up With Two Package Variables, $VAR1 And $VAR2, That Are Equivalent To The Original Data.

=EN This is called marshaling the data: converting complex data into a form that we can write to a file as a stream of bytes for later reconstruction.

=CN This Is Called marshaling The Data: converting 综合的 Data Into a Form That We Can Write To a File As a 小溪 Of 字节 For 更晚 reconstruction.

=EN However, another Perl core module is much better suited for marshaling: Storable.

=CN However, 另一个 Perl Core Module Is Much Better suited For marshaling: Storable.

=EN It's better suited because compared to Data::Dumper, Storable produces smaller and faster-to-process files.

=CN It's Better suited Because 相比 To Data::Dumper, Storable Produces smaller And Faster-To-程序 Files.

=EN (The Storable module is standard in recent versions of Perl, but you can always install it from the CPAN if it's missing.)

=CN (The Storable Module Is Standard In 近来的 Versions Of Perl, But You Can Always 安装 It From The Perl综合典藏网 If It's Missing.)

=EN The interface is similar to using Data::Dumper, except we must put everything into one reference.

=CN The Interface Is Similar To Using Data::Dumper, Except We Must Put Everything Into One Reference.

=EN For example, let's store the mutually referencing data structures:

=CN For Example, Let's 商店 The mutually referencing Data Structures:

=EN use Storable; my @data1 = qw(one won); my @data2 = qw(two too to); push @data2, \@data1; push @data1, \@data2; store [\@data1, \@data2], 'some_file';

=CN Use Storable; My @data1 = Qw(One Won); My @data2 = Qw(Two Too To); Push @data2, \@data1; Push @data1, \@data2; 商店 [\@data1, \@data2], 'some_file';

=EN The file produced by this step is under 100 bytes, which is quite a bit shorter than the equivalent Data::Dumper output.

=CN The File produced By This 脚步 Is 在 100 字节, Which Is Quite a Bit 短 Than The Equivalent Data::Dumper 出产.

=EN It's also much less readable for humans.

=CN It's Also Much 更少的 可读性 For humans.

=EN It's easy for Storable to read, as you'll soon see.[*] Next, fetch the data, again using the Storable module.

=CN It's Easy For Storable To Read, As You'我 不久 See.[*] Next, 去取来 The Data, Again Using The Storable Module.

=EN The result will be a single array reference.

=CN The Result Will Be a Single Array Reference.

=EN We dump the result to see if it stored the right values:

=CN We 倾倒 The Result To See If It Stored The Right Values:

=EN [*] The format used by Storable is architecture byte-order dependent by default.

=CN [*] The Format Used By Storable Is 建筑学 字节-Order 依靠的 By Default.

=EN Its documentation shows how to create byte-order-independent storage files.

=CN Its 提供文件 Shows How To Create 字节-Order-独立的 贮藏 Files.

=EN use Storable; my $result = retrieve 'some_file'; use Data::Dumper; $Data::Dumper::Purity = 1; print Dumper($result);

=CN Use Storable; My $Result = retrieve 'some_file'; Use Data::Dumper; $Data::Dumper::Purity = 1; Print Dumper($Result);

=EN Here's the result:

=CN Here's The Result:

=EN This is functionally the same as the original data structure.

=CN This Is functionally The Same As The Original Data Structure.

=EN We're now looking at the two array references within one top-level array.

=CN We'Re Now 看 At The Two Array References Within One 顶-Level Array.

=EN To get something closer to what we saw before, we can be more explicit about the return value:

=CN To Get Something 近 To What We 锯 Before, We Can Be More 清楚的 About The Return Value:

=EN use Storable; my ($arr1, $arr2) = @{ retrieve 'some_file' }; use Data::Dumper; $Data::Dumper::Purity = 1; print Dumper($arr1, $arr2);

=CN Use Storable; My ($arr1, $arr2) = @{ retrieve 'some_file' }; Use Data::Dumper; $Data::Dumper::Purity = 1; Print Dumper($arr1, $arr2);

=EN or equivalently:

=CN Or 设置:

=EN use Storable; my $result = retrieve 'some_file'; use Data::Dumper; $Data::Dumper::Purity = 1; print Dumper(@$result);

=CN Use Storable; My $Result = retrieve 'some_file'; Use Data::Dumper; $Data::Dumper::Purity = 1; Print Dumper(@$Result);

=EN and we'll get:

=CN And We'我 Get:

=EN just as we did in the original program.

=CN Just As We Did In The Original Program.

=EN With Storable, we can store data and retrieve it later.

=CN With Storable, We Can 商店 Data And retrieve It 更晚.

=EN More information on Storable can be found in perldoc Storable, as always.

=CN More Information On Storable Can Be Found In perldoc Storable, As Always.

=EN Using the map and grep Operators As the data structures become more complex, it helps to have higher-level constructs deal with common tasks such as selection and transformation.

=CN Using The Map And Grep Operators As The Data Structures 变成 More 综合的, It 帮助 To Have 更高的-Level Constructs 处理 With Common Tasks Such As 选择 And 转化.

=EN In this regard, Perl's grep and map operators are worth mastering.

=CN In This Regard, Perl's Grep And Map Operators Are worth mastering.

=EN Applying a Bit of Indirection Some problems that may appear very complex are actually simple once we've seen a solution or two.

=CN Applying a Bit Of Indirection Some 问题 That May Appear Very 综合的 Are Actually Simple Once We'Ve Seen a 解决 Or Two.

=EN For example, suppose we want to find the items in a list that have odd digit sums but don't want the items themselves.

=CN For Example, 猜想 We Want To 寻找 The 物品 In a List That Have 古怪的 数字 sums But Don't Want The 物品 他们、它们自己.

=EN What we want to know is where they occurred in the original list.

=CN What We Want To Know Is Where They Occurred In The Original List.

=EN All that's required is a bit of indirection .[*] First, we have a selection problem, so we use a grep.

=CN All That's 要求 Is a Bit Of indirection .[*] First, We Have a 选择 Problem, So We Use a Grep.

=EN Let's not grep the values themselves but the index for each item:

=CN Let's Not Grep The Values 他们、它们自己 But The Index For Each 条款:

=EN [*] A famous computing maxim states that "there is no problem so complex that it cannot be solved with appropriate additional layers of indirection."

=CN [*] A 著名的 computing maxim states That "There Is No Problem So 综合的 That It Cannot Be 解决 With 恰当的 Additional 层 Of indirection."

=EN Of course, with indirection comes obfuscation, so there's got to be a magic middle ground somewhere.

=CN Of Course, With indirection 来 obfuscation, So There's Got To Be a Magic 当中 地面 Somewhere.

=EN my @input_numbers = (1, 2, 4, 8, 16, 32, 64); my @indices_of_odd_digit_sums = grep {

=CN My @input_numbers = (1, 2, 4, 8, 16, 32, 64); My @indices_of_odd_digit_sums = Grep {

=EN Here, the expression 0..$#input_numbers will be a list of indices for the array.

=CN Here, The Expression 0..$#input_numbers Will Be a List Of indices For The Array.

=EN Inside the block, $_ is a small integer, from 0 to 6 (seven items total).

=CN Inside The Block, $_ Is a Small 整数, From 0 To 6 (seven 物品 总).

=EN Now, we don't want to decide whether $_ has an odd digit sum.

=CN Now, We Don't Want To Decide Whether $_ Has An 古怪的 数字 总数.

=EN We want to know whether the array element at that index has an odd digit sum.

=CN We Want To Know Whether The Array Element At That Index Has An 古怪的 数字 总数.

=EN Instead of using $_ to get the number of interest, use $input_numbers[$_]:

=CN Instead Of Using $_ To Get The Number Of 兴趣, Use $input_numbers[$_]:

=EN my @indices_of_odd_digit_sums = grep {

=CN My @indices_of_odd_digit_sums = Grep {

=EN The result will be the indices at which 1, 16, and 32 appear in the list: 0, 4, and 5.

=CN The Result Will Be The indices At Which 1, 16, And 32 Appear In The List: 0, 4, And 5.

=EN We could use these indices in an array slice to get the original values again:

=CN We Could Use These indices In An Array 薄片 To Get The Original Values Again:

=EN my @odd_digit_sums = @input_numbers[ @indices_of_odd_digit_sums ];

=CN My @odd_digit_sums = @input_numbers[ @indices_of_odd_digit_sums ];

=EN The strategy here for an indirect grep or map is to think of the $_ values as identifying a particular item of interest, such as the key in a hash or the index of an array, and then use that identification within the block or expression to access the actual values.

=CN The 战略 Here For An Indirect Grep Or Map Is To 想 Of The $_ Values As identifying a Particular 条款 Of 兴趣, Such As The Key In a Hash Or The Index Of An Array, And Then Use That 识别 Within The Block Or Expression To Access The Actual Values.

=EN Here's another example: select the elements of @x that are larger than the corresponding value in @y.

=CN Here's 另一个 Example: 挑选 The Elements Of @x That Are larger Than The 相应的 Value In @y.

=EN Again, we'll use the indices of @x as our $_ items:

=CN Again, We'我 Use The indices Of @x As Our $_ 物品:

=EN my @bigger_indices = grep {

=CN My @bigger_indices = Grep {

=EN  # yes, select it

=CN  # Yes, 挑选 It

=EN  # no, don't select it

=CN  # No, Don't 挑选 It

=EN In the grep, $_ varies from 0 to the highest index of @x.

=CN In The Grep, $_ 变化 From 0 To The highest Index Of @x.

=EN If that element is beyond the end of @y, we automatically select it.

=CN If That Element Is Beyond The End Of @y, We Automatically 挑选 It.

=EN Otherwise, we look at the individual corresponding values of the two arrays, selecting only the ones that meet our match.

=CN Otherwise, We Look At The Individual 相应的 Values Of The Two Arrays, 选择 Only The Ones That 遇到 Our Match.

=EN However, this is a bit more verbose than it needs to be.

=CN However, This Is a Bit More 罗嗦 Than It Needs To Be.

=EN We could simply return the boolean expression rather than a separate 1 or 0:

=CN We Could Simply Return The 布尔 Expression Rather Than a Separate 1 Or 0:

=EN More easily, we can skip the step of building the intermediate array by simply returning the items of interest with a map:

=CN More 容易地, We Can 跳过 The 脚步 Of 建筑物 The 中间的 Array By Simply Returning The 物品 Of 兴趣 With a Map:

=EN my @bigger = map {

=CN My @bigger = Map {

=EN If the index is good, return the resulting array value.

=CN If The Index Is Good, Return The 造成 Array Value.

=EN If the index is bad, return an empty list, making that item disappear.

=CN If The Index Is 坏的, Return An Empty List, 制作 That 条款 失踪.

=EN Selecting and Altering Complex Data We can use these operators on more complex data.

=CN Selecting And Altering Complex Data We Can Use These Operators On More 综合的 Data.

=EN Taking the provisions list from Chapter 5:

=CN Taking The provisions List From Chapter 5:

=EN my %provisions = (

=CN My %provisions = (

=EN In this case, $provisions{"The Professor"} gives an array reference of the provisions brought by the Professor, and $provisions{"Gilligan"}[-1] gives the last item Gilligan thought to bring.

=CN In This Case, $provisions{"The Professor"} Gives An Array Reference Of The provisions brought By The Professor, And $provisions{"Gilligan"}[-1] Gives The Last 条款 Gilligan Thought To 拿来.

=EN We run a few queries against this data.

=CN We Run a Few queries 反对 This Data.

=EN Who brought fewer than five items?

=CN Who brought fewer Than five 物品?

=EN my @packed_light = grep @{ $provisions{$_} } < 5, keys %provisions;

=CN My @packed_light = Grep @{ $provisions{$_} } < 5, Keys %provisions;

=EN In this case, $_ is the name of a person.

=CN In This Case, $_ Is The Name Of a 人.

=EN We take that name, look up the array reference of the provisions for that person, dereference that in a scalar context to get the count of provisions, and then compare it to 5.

=CN We Take That Name, Look Up The Array Reference Of The provisions For That 人, 废弃 That In a Scalar Context To Get The 计算 Of provisions, And Then 比较 It To 5.

=EN And wouldn't you know it; the only name is Gilligan.

=CN And Wouldn't You Know It; The Only Name Is Gilligan.

=EN Here's a trickier one.

=CN Here's a trickier One.

=EN Who brought a water bottle?

=CN Who brought a 水 瓶子?

=EN my @all_wet = grep {

=CN My @all_wet = Grep {

=EN Starting with the list of names again (keys %provisions), we pull up all the packed items first and then use that list in an inner grep to count the number of those items that equal water_bottle.

=CN Starting With The List Of Names Again (Keys %provisions), We 拖 Up All The packed 物品 First And Then Use That List In An Inner Grep To 计算 The Number Of Those 物品 That Equal water_bottle.

=EN If the count is 0, there's no bottle, so the result is false for the outer grep.

=CN If The 计算 Is 0, There's No 瓶子, So The Result Is False For The 外部的 Grep.

=EN If the count is nonzero, we have a bottle, so the result is true for the outer grep.

=CN If The 计算 Is nonzero, We Have a 瓶子, So The Result Is True For The 外部的 Grep.

=EN Now we see that the Skipper will be a bit thirsty later, without any relief.

=CN Now We See That The Skipper Will Be a Bit 渴的 更晚, Without Any 解除.

=EN We can also perform transformations.

=CN We Can Also 执行 transformations.

=EN For example, turn this hash into a list of array references, with each array containing two items.

=CN For Example, 转向 This Hash Into a List Of Array References, With Each Array Containing Two 物品.

=EN The first is the original person's name; the second is a reference to an array of the provisions for that person:

=CN The First Is The Original 人's Name; The Second Is a Reference To An Array Of The provisions For That 人:

=EN my @remapped_list = map {

=CN My @remapped_list = Map {

=EN The keys of %provisions are names of the people.

=CN The Keys Of %provisions Are Names Of The People.

=EN For each name, we construct a two-element list of the name and the corresponding provisions array reference.

=CN For Each Name, We Construct a Two-Element List Of The Name And The 相应的 provisions Array Reference.

=EN This list is inside an anonymous array constructor, so we get back a reference to a newly created array for each person.

=CN This List Is 里面 An Anonymous Array 构造函数, So We Get Back a Reference To a 新 Created Array For Each 人.

=EN Three names in; three references out.[*] Or, let's go a different way.

=CN Three Names In; Three References Out.[*] Or, Let's Go a Different Way.

=EN Turn the input hash into a series of references to arrays.

=CN Turn The Input Hash Into a 系列 Of References To Arrays.

=EN Each array will have a person's name and one of the items they brought:

=CN Each Array Will Have a 人's Name And One Of The 物品 They brought:

=EN [*] If we had left the inner brackets off, we'd end up with six items out.

=CN [*] If We Had Left The Inner 支架 Off, We'd End Up With six 物品 Out.

=EN That's not very useful, unless we're creating a different hash from them.

=CN That's Not Very Useful, Unless We'Re Creating a Different Hash From Them.

=EN my @person_item_pairs = map {

=CN My @person_item_pairs = Map {

=EN Yes, a map within a map.

=CN Yes, a Map Within a Map.

=EN The outer map selects one person at a time.

=CN The 外部的 Map 选择 One 人 At a Time.

=EN We save this name in $person, and then we extract the item list from the hash.

=CN We Save This Name In $人, And Then We 取出 The 条款 List From The Hash.

=EN The inner map walks over this item list, executing the expression to construct an anonymous array reference for each item.

=CN The Inner Map walks 在 This 条款 List, 执行 The Expression To Construct An Anonymous Array Reference For Each 条款.

=EN The anonymous array contains the person's name and the provision item.

=CN The Anonymous Array 包含 The 人's Name And The 准备 条款.

=EN We had to use $person here to hold the outer $_ temporarily.

=CN We Had To Use $人 Here To Hold The 外部的 $_ temporarily.

=EN Otherwise, we can't refer to both temporary values for the outer map and the inner map.

=CN Otherwise, We Can't Refer To Both temporary Values For The 外部的 Map And The Inner Map.

=EN Exercises You can find the answers to these exercises in "Answers for Chapter 6" in the Appendix.

=CN Exercises You Can 寻找 The answers To These exercises In "Answers For Chapter 6" In The Appendix.

=EN Exercise 1 [20 min] The program from Exercise 2 in Chapter 5 needs to read the entire datafile each time it runs.

=CN Exercise 1 [20 min] The Program From Exercise 2 In Chapter 5 Needs To Read The 完全的 datafile Each Time It 跑.

=EN However, the Professor has a new router logfile each day and doesn't want to keep all that data in one giant file that takes longer and longer to process.

=CN However, The Professor Has a New router logfile Each 一天 And Doesn't Want To 保持 All That Data In One 巨人 File That Takes 长 And 长 To 程序.

=EN Fix up that program to keep the running totals in a datafile so the Professor can simply run it on each day's logs to get the new totals.

=CN Fix Up That Program To 保持 The 连续的 totals In a datafile So The Professor Can Simply Run It On Each 一天's logs To Get The New totals.

=EN Exercise 2 [5 min] To make it really useful, what other features should be added to that program?

=CN Exercise 2 [5 min] To Make It Really Useful, What Other 特征 Should Be added To That Program?

=EN You don't need to implement them!

=CN You Don't Need To 实行 Them!

