=EN Building Larger Programs This chapter looks at how to break up a program into pieces and includes some of the concerns that arise when we put those pieces back together again, or when many people work together on the same program.

=CN Building Larger Programs This 章 Looks At How To 打破 Up a Program Into 件 And 包括 Some Of The 关注 That 起来 When We Put Those 件 Back Together Again, Or When Many People Work Together On The Same Program.

=EN The Cure for the Common Code The Skipper writes many Perl programs to provide navigation for all the common ports of call for the Minnow.

=CN The Cure For The Common Code The Skipper 写 Many Perl Programs To Provide 航行 For All The Common ports Of Call For The Minnow.

=EN He finds himself cutting and pasting a very common routine into each program:

=CN He 发现 他自己 切片 And pasting a Very Common Routine Into Each Program:

=EN sub turn_toward_heading {

=CN Sub turn_toward_heading {

=EN  # long way around

=CN  # Long Way Around

=EN This routine gives the shortest turn to make from the current heading (returned by the subroutine current_heading( )) to a new heading (given as the first parameter to the subroutine).

=CN This Routine Gives The shortest 转向 To Make From The Current 标题 (Returned By The Subroutine current_heading( )) To a New 标题 (Given As The First Parameter To The Subroutine).

=EN The first line of this subroutine might have read instead:

=CN The First Line Of This Subroutine Might Have Read Instead:

=EN my ($new_heading) = @_;

=CN My ($new_heading) = @_;

=EN This is mostly a style call: in both cases, the first parameter ends up in $new_heading.

=CN This Is Mostly a Style Call: In Both Cases, The First Parameter Ends Up In $new_heading.

=EN However, we've seen that removing the items from @_ as they are identified does have some advantages.

=CN However, We'Ve Seen That removing The 物品 From @_ As They Are identified Does Have Some advantages.

=EN So, we stick (mostly) with the "shifting" style of argument parsing.

=CN So, We Stick (Mostly) With The "shifting" Style Of Argument 解析.

=EN Now back to the matter at hand . . . .

=CN Now Back To The Matter At Hand . . . .

=EN After writing a dozen programs using this routine, the Skipper realizes that the output is excessively chatty when he's already taken the time to steer the proper course (or perhaps simply started drifting in the proper direction).

=CN After 写作 a 一打 Programs Using This Routine, The Skipper realizes That The 出产 Is excessively chatty When 他's Already Taken The Time To 驾驶 The 合适的 Course (Or 也许 Simply 开始 drifting In The 合适的 方向).

=EN After all, if the current heading is 234 degrees and he needs to turn to 234 degrees, we see:

=CN After All, If The Current 标题 Is 234 度 And 他 Needs To 转向 To 234 度, We See:

=EN Current heading is 234.

=CN Current 标题 Is 234.

=EN Come about to 234 by turning right 0 degrees.

=CN Come About To 234 By Turning Right 0 度.

=EN The Skipper decides to fix this problem by checking for a zero turn value:

=CN The Skipper decides To 固定 This Problem By Checking For a 零 转向 Value:

=EN The new subroutine works nicely in the current navigation program.

=CN The New Subroutine Works 好 In The Current 航行 Program.

=EN However, because he had previously cut and pasted it into a half-dozen other navigation programs, those other programs will still annoy the Skipper with extraneous turning messages.

=CN However, Because 他 Had Previously Cut And pasted It Into a 一半-一打 Other 航行 Programs, Those Other Programs Will Still 烦扰 The Skipper With extraneous Turning Messages.

=EN The Skipper needs a way to write the code in one place and then share it among many programs.

=CN The Skipper Needs a Way To Write The Code In One Place And Then 份 It Among Many Programs.

=EN And, like most things in Perl, there's more than one way to do it.

=CN And, Like Most Things In Perl, There's More Than One Way To Do It.

=EN Inserting Code with eval The Skipper can save disk space (and brain space) by bringing the definition for turn_toward_heading out into a separate file.

=CN Inserting Code With Eval The Skipper Can Save disk Space (And 脑子 Space) By bringing The Definition For turn_toward_heading Out Into a Separate File.

=EN For example, suppose the Skipper figures out a half-dozen common subroutines related to navigating the Minnow that he seems to use in most or all of the programs he's writing for the task.

=CN For Example, 猜想 The Skipper figures Out a 一半-一打 Common Subroutines Related To navigating The Minnow That 他 似乎 To Use In Most Or All Of The Programs 他's 写作 For The 工作.

=EN He can put them in a separate file called navigation.pm, which consists only of the needed subroutines.

=CN He Can Put Them In a Separate File Called navigation.pm, Which consists Only Of The Needed Subroutines.

=EN But now, how can we tell Perl to pull in that program snippet from another file?

=CN But Now, How Can We Tell Perl To 拖 In That Program snippet From 另一个 File?

=EN We could do it the hard way, using the string form of eval that we discussed in Chapter 2.

=CN We Could Do It The 硬的 Way, Using The String Form Of Eval That We 讨论 In Chapter 2.

=EN sub load_common_subroutines {

=CN Sub load_common_subroutines {

=EN  # enable slurp mode

=CN  # 使能够 Slurp 方式

=EN Perl reads the code from navigation.pm into the $more_code variable.

=CN Perl Reads The Code From navigation.pm Into The $more_code Variable.

=EN We then use eval to process that text as Perl code.

=CN We Then Use Eval To 程序 That 正文 As Perl Code.

=EN Any lexical variables in $more_code remain local to the evaluated code.[*] If there's a syntax error, Perl sets the $@ variable and causes the subroutine to die with the appropriate error message.

=CN Any Lexical Variables In $more_code 依旧的 Local To The 评估 Code.[*] If There's a Syntax Error, Perl Sets The $@ Variable And Causes The Subroutine To Die With The 恰当的 Error 音讯.

=EN [*] Oddly, the variable $more_code is also visible to the evaluated code, not that it is of any use to change that variable during the eval.

=CN [*] Oddly, The Variable $more_code Is Also Visible To The 评估 Code, Not That It Is Of Any Use To Change That Variable 在 The Eval.

=EN Now, instead of a few dozen lines of common subroutines to place in each file, we simply have one subroutine to insert in each file.

=CN Now, Instead Of a Few 一打 Lines Of Common Subroutines To Place In Each File, We Simply Have One Subroutine To 插入 In Each File.

=EN But that's not very nice, especially if we need to keep doing this kind of task repeatedly.

=CN But That's Not Very Nice, Especially If We Need To 保持 Doing This Kind Of 工作 重复地.

=EN Luckily, Perl has several ways to help us out.

=CN Luckily, Perl Has Several Ways To Help Us Out.

=EN Using do The Skipper placed a few common navigation subroutines into navigation.pm.

=CN Using Do The Skipper Placed a Few Common 航行 Subroutines Into navigation.pm.

=EN If the Skipper merely inserts:

=CN If The Skipper 仅仅 inserts:

=EN do 'navigation.pm'; die $@ if $@;

=CN Do 'navigation.pm'; Die $@ If $@;

=EN into his typical navigation program, it's almost the same as if the eval code were executed right at that point in the program.[]

=CN Into 他的 典型的 航行 Program, It's Almost The Same As If The Eval Code Were Executed Right At That 尖 In The Program.[]

=EN [] Except in regard to @INC, %INC, and missing file handling, which we'll show later.

=CN [] Except In Regard To @INC, %INC, And Missing File 处理, Which We'我 Show 更晚.

=EN That is, the do operator acts as if the code from navigation.pm were incorporated into the current program, although in its own scope block, so that lexicals (my variables) and most directives (such as use strict) from the included file don't leak into the main program.

=CN That Is, The Do Operator 徒 As If The Code From navigation.pm Were 有限的 Into The Current Program, Although In Its Own Scope Block, So That Lexicals (My Variables) And Most directives (Such As Use Strict) From The 包括 File Don't 漏 Into The Main Program.

=EN Now the Skipper can safely update and maintain one copy of the common subroutines without having to copy and recopy all the fixes and extensions into the many separate navigation programs he creates and uses.

=CN Now The Skipper Can Safely Update And Maintain One Copy Of The Common Subroutines Without Having To Copy And recopy All The fixes And 延伸 Into The Many Separate 航行 Programs 他 Creates And Uses.

=EN Figure 10-1 illustrates how the Skipper can use his common library.

=CN Figure 10-1 illustrates How The Skipper Can Use 他的 Common Library.

=EN The Skipper uses the navigation.pm file in all his other navigation programs

=CN The Skipper Uses The navigation.pm File In All 他的 Other 航行 Programs

=EN Of course, this requires a bit of discipline, because breaking the expected interface of a given subroutine now breaks many programs instead of just one.[] The Skipper needs to give special thought to his design for reusable components and modularity design.

=CN Of Course, This Requires a Bit Of 训练, Because 打破 The Expected Interface Of a Given Subroutine Now 打破 Many Programs Instead Of Just One.[] The Skipper Needs To Give Special Thought To 他的 设计 For reusable 组件 And 模块化 设计.

=EN We'll presume the Skipper has had some experience at that, but we'll show some more on that in later chapters.

=CN We'我 假定 The Skipper Has Had Some 经历 At That, But We'我 Show Some More On That In 更晚 chapters.

=EN [] In later chapters, we'll show how to set up tests to be used while maintaining reused code.

=CN [] In 更晚 chapters, We'我 Show How To Set Up 测试 To Be Used While maintaining 重用 Code.

=EN By placing some of the code into a separate file, other programmers can reuse the Skipper's routines, and vice versa.

=CN By placing Some Of The Code Into a Separate File, Other Programmers Can Reuse The Skipper's Routines, And 坏事 versa.

=EN If Gilligan writes a routine to drop_anchor( ) and places it in the file drop_anchor.pm, then the Skipper can use Gilligan's code by including his library:

=CN If Gilligan 写 a Routine To drop_anchor( ) And Places It In The File drop_anchor.pm, Then The Skipper Can Use Gilligan's Code By Including 他的 Library:

=EN do 'drop_anchor.pm'; die $@ if $@; ... drop_anchor( ) if at_dock( ) or in_port( );

=CN Do 'drop_anchor.pm'; Die $@ If $@; ... drop_anchor( ) If at_dock( ) Or in_port( );

=EN Thus, the code that we bring in from separate files permits easy maintenance and interprogrammer cooperation.

=CN Thus, The Code That We 拿来 In From Separate Files permits Easy 保养 And interprogrammer 合作.

=EN While the code we brought in from a .pm file can have direct executable statements, it's much more common to simply define subroutines that we can load using do.

=CN While The Code We brought In From a .Pm File Can Have Direct executable Statements, It's Much More Common To Simply Define Subroutines That We Can Load Using Do.

=EN Going back to that drop_anchor.pm library for a second, what if the Skipper wrote a program that needed to "drop anchor" as well as navigate?

=CN Going Back To That drop_anchor.pm Library For a Second, What If The Skipper 写 a Program That Needed To "落下 锚" As Well As 浏览?

=EN do 'drop_anchor.pm'; die $@ if $@; do 'navigation.pm'; die $@ if $@; ... turn_toward_heading(90); ... drop_anchor( ) if at_dock( );

=CN Do 'drop_anchor.pm'; Die $@ If $@; Do 'navigation.pm'; Die $@ If $@; ... turn_toward_heading(90); ... drop_anchor( ) If at_dock( );

=EN That works fine and dandy.

=CN That Works Fine And dandy.

=EN The subroutines defined in both libraries are available to this program.

=CN The Subroutines Defined In Both 库 Are Available To This Program.

=EN Using require Suppose navigation.pm itself also pulls in drop_anchor.pm for some common navigation task.

=CN Using Require Suppose navigation.pm Itself Also pulls In drop_anchor.pm For Some Common 航行 工作.

=EN Perl reads the file once directly and then again while processing the navigation package.

=CN Perl Reads The File Once 直接地 And Then Again While 加工（的） The 航行 Package.

=EN Worse than that, if we have warnings enabled, [*] we'll get a warning from Perl that we've redefined the subroutine, even if it's the same definition.

=CN Worse Than That, If We Have 警告 Enabled, [*] We'我 Get a Warning From Perl That We'Ve 重新定义了 The Subroutine, Even If It's The Same Definition.

=EN [*] You are using warnings, right?

=CN [*] You Are Using 警告, Right?

=EN You can enable them with either -w or use warnings;.

=CN You Can 使能够 Them With Either -w Or Use 警告;.

=EN We need a mechanism that tracks which files we've brought in and then brings them in only once.

=CN We Need a Mechanism That 轨迹 Which Files We'Ve brought In And Then brings Them In Only Once.

=EN Perl has such an operation, called require.

=CN Perl Has Such An Operation, Called Require.

=EN Change the previous code to simply:

=CN Change The Previous Code To Simply:

=EN require 'drop_anchor.pm'; require 'navigation.pm';

=CN Require 'drop_anchor.pm'; Require 'navigation.pm';

=EN The require operator keeps track of the files Perl has read.[] Once Perl has processed a file successfully, it simply ignores any further require operations on that same file.

=CN The Require Operator 保持 径赛 Of The Files Perl Has Read.[] Once Perl Has processed a File 成功地, It Simply 忽略了 Any Further Require 操作 On That Same File.

=EN This means that even if navigation.pm contains require "drop_anchor.pm", Perl imports the drop_anchor.pm file exactly once, and we'll get no annoying error messages about duplicate subroutine definitions (see Figure 10-2).

=CN This Means That Even If navigation.pm 包含 Require "drop_anchor.pm", Perl Imports The drop_anchor.pm File Exactly Once, And We'我 Get No annoying Error Messages About 二重的 Subroutine 定义 (See Figure 10-2).

=EN Most importantly, we'll also save time by not processing the file more than once.

=CN Most 重要的是, We'我 Also Save Time By Not 加工（的） The File More Than Once.

=EN [] In the %INC hash, as described in the entry for require in the perlfunc documentation.

=CN [] In The %INC Hash, As Described In The Entry For Require In The perlfunc 提供文件.

=EN Once Perl brings in the drop_anchor.pm file, it ignores another attempt to require it

=CN Once Perl brings In The drop_anchor.pm File, It 忽略了 另一个 尝试 To Require It

=EN The require operator also has two additional features:

=CN The Require Operator Also Has Two Additional 特征:

=EN Any syntax error in the required file causes the program to die; thus, the many die $@ if $@ statements are unnecessary.

=CN Any Syntax Error In The 要求 File Causes The Program To Die; 如此, The Many Die $@ If $@ Statements Are 不必要的.

=EN The last expression evaluated in the file must return a true value.

=CN The Last Expression 评估 In The File Must Return a True Value.

=EN Because of the second point, most files evaluated for require have a cryptic 1; as their last line of code.

=CN Because Of The Second 尖, Most Files 评估 For Require Have a cryptic 1; As Their Last Line Of Code.

=EN This ensures that the last evaluated expression is, in fact, true.

=CN This ensures That The Last 评估 Expression Is, In Fact, True.

=EN Try to carry on this tradition as well.

=CN Try To 搬运 On This 传统 As Well.

=EN Originally, the mandatory true value was intended as a way for an included file to signal to the invoker that the code was processed successfully and that no error condition existed.

=CN Originally, The 强制性 True Value Was 预期 As a Way For An 包括 File To 信号 To The invoker That The Code Was processed 成功地 And That No Error 状态 existed.

=EN However, nearly everyone has adopted the die if ... strategy instead, deeming the "last expression evaluated is false" strategy a mere historic annoyance.

=CN However, 几乎 Everyone Has adopted The Die If ... 战略 Instead, deeming The "Last Expression 评估 Is False" 战略 a 仅仅的 历史性的 烦恼.

=EN 10.5. require and @INC So far, the examples have glossed over how we've set up the directory structure of where the main code and the included files are located.

=CN 10.5. Require And @INC So Far, The Examples Have glossed 在 How We'Ve Set Up The Directory Structure Of Where The Main Code And The 包括 Files Are Located.

=EN That's because it "just works" for the simplest case where we have a program and its libraries in the same directory and we run the program from that directory.

=CN That's Because It "Just Works" For The simplest Case Where We Have a Program And Its 库 In The Same Directory And We Run The Program From That Directory.

=EN Things get a bit more complicated when the libraries aren't in the current directory.

=CN Things Get a Bit More 错综复杂的 When The 库 还't In The Current Directory.

=EN In fact, Perl searches for libraries along a library search path, similar to what the shell does with the PATH environment variable.

=CN In Fact, Perl searches For 库 沿着 a Library 搜查 Path, Similar To What The 壳 Does With The PATH 环境 Variable.

=EN The current directory (represented in Unix by a single dot) is an element of the search path.

=CN The Current Directory (Represented In Unix By a Single 点) Is An Element Of The 搜查 Path.

=EN So, as long as our libraries are in our current working directory, everything is fine.

=CN So, As Long As Our 库 Are In Our Current Working Directory, Everything Is Fine.

=EN The search path is a list of elements in the special @INC array, as we briefly discussed in Chapter 3.

=CN The 搜查 Path Is a List Of Elements In The Special @INC Array, As We 简单地 讨论 In Chapter 3.

=EN By default, the array contains the current directory and a half-dozen or so directories specified by the person who compiled Perl.

=CN By Default, The Array 包含 The Current Directory And a 一半-一打 Or So directories 指定 By The 人 Who Compiled Perl.

=EN Typing perl -V on the command line shows what these directories are, in the last dozen lines of the output.

=CN Typing Perl -V On The 命令 Line Shows What These directories Are, In The Last 一打 Lines Of The 出产.

=EN Also, the following command displays just the @INC directories:[*]

=CN Also, The Following 命令 displays Just The @INC directories:[*]

=EN [*] On a Windows machine, use double quotes instead of single quotes on the command line.

=CN [*] On a 微软视窗操作系统 机器, Use 两倍的 引用 Instead Of Single 引用 On The 命令 Line.

=EN perl -le 'print for @INC'

=CN Perl -引导 'Print For @INC'

=EN Except for . in that list, we probably won't be able to write to any of the other directories unless we're the person responsible for maintaining Perl on our machine, in which case, we should be able to write to all of them.

=CN Except For . In That List, We Probably Won't Be Able To Write To Any Of The Other directories Unless We'Re The 人 负责的 For maintaining Perl On Our 机器, In Which Case, We Should Be Able To Write To All Of Them.

=EN The remaining directories are where Perl searches for system-wide libraries and modules, as we'll see later.

=CN The Remaining directories Are Where Perl searches For System-宽的 库 And Modules, As We'我 See 更晚.

=EN Extending @INC We may run into some cases where we can't install modules in the pre-configured directories in @INC.

=CN Extending @INC We May Run Into Some Cases Where We Can't 安装 Modules In The Pre-configured directories In @INC.

=EN We can change @INC itself before the require, so Perl searches our directories too.

=CN We Can Change @INC Itself Before The Require, So Perl searches Our directories Too.

=EN The @INC array is an ordinary array, so have the Skipper add a directory below his home directory to the mix:

=CN The @INC Array Is An Ordinary Array, So Have The Skipper 增添 a Directory Below 他的 家 Directory To The 混合:

=EN unshift @INC, '/home/skipper/perl-lib';

=CN unshift @INC, '/家/skipper/Perl-lib';

=EN Now, in addition to searching the standard directories and the current directory, Perl searches the Skipper's personal Perl library.

=CN Now, In 增加 To 搜索 The Standard directories And The Current Directory, Perl searches The Skipper's 私人的 Perl Library.

=EN In fact, Perl searches in that directory first, since it is the first one in @INC.

=CN In Fact, Perl searches In That Directory First, Since It Is The First One In @INC.

=EN By using unshift rather than push, Perl resolves any conflict in names between the Skipper's private files and the system-installed files, with the Skipper's file-taking precedence.

=CN By Using unshift Rather Than Push, Perl resolves Any 冲突 In Names Between The Skipper's Private Files And The System-安装 Files, With The Skipper's File-Taking 领先.

=EN Normally we want to ensure that this happens before anything else, so we can wrap it in a BEGIN block.

=CN Normally We Want To Ensure That This Happens Before Anything Else, So We Can 包 It In a BEGIN Block.

=EN Perl executes the code in the BEGIN block during the compile phase before the require executes at runtime.

=CN Perl 实行 The Code In The BEGIN Block 在 The Compile 阶段 Before The Require 实行 At Runtime.

=EN Otherwise, Perl executes statements in the order that it finds them, and we have to ensure that our unshift shows up before our require.

=CN Otherwise, Perl 实行 Statements In The Order That It 发现 Them, And We Have To Ensure That Our unshift Shows Up Before Our Require.

=EN This is such a common operation, though, that Perl has a pragma for it.

=CN This Is Such a Common Operation, Though, That Perl Has a Pragma For It.

=EN The pragma makes everything happen before runtime, so we'll get what we expect.

=CN The Pragma 使 Everything 发生 Before Runtime, So We'我 Get What We 盼望.

=EN It puts the directories we specify at the beginning of @INC, just like we did before.

=CN It 把 The directories We Specify At The 开端 Of @INC, Just Like We Did Before.

=EN use lib qw(/home/skipper/perl-lib);

=CN Use lib Qw(/家/skipper/Perl-lib);

=EN We don't always have to know the path ahead of time, either.

=CN We Don't Always Have To Know The Path 在 Of Time, Either.

=EN In the previous examples, we've hardcoded the paths.

=CN In The Previous Examples, We'Ve hardcoded The paths.

=EN If we don't know what those will be because we're passing code around to several machines, the FindBin module, which comes with Perl, can help.

=CN If We Don't Know What Those Will Be Because We'Re Passing Code Around To Several Machines, The FindBin Module, Which 来 With Perl, Can Help.

=EN It finds the full path to the script directory so we can use it to build paths.

=CN It 发现 The Full Path To The 临时单据 Directory So We Can Use It To Build paths.

=EN use FindBin qw($Bin);

=CN Use FindBin Qw($Bin);

=EN Now, in $Bin is the path to the directory that holds our script.

=CN Now, In $Bin Is The Path To The Directory That holds Our 临时单据.

=EN If we have our libraries in the same directory, our next line can be:

=CN If We Have Our 库 In The Same Directory, Our 下一次 Line Can Be:

=EN use lib $Bin;

=CN Use lib $Bin;

=EN If we have the libraries in a directory close to the script directory, we put the right path components together to make it work.

=CN If We Have The 库 In a Directory Close To The 临时单据 Directory, We Put The Right Path 组件 Together To Make It Work.

=EN use lib "$Bin/lib"; # in a subdirectory

=CN Use lib "$Bin/lib"; # In a 子目录

=EN use lib "$Bin/../lib"; # up one, then down into lib

=CN Use lib "$Bin/../lib"; # Up One, Then 向下 Into lib

=EN So, if we know the relative path from the script directory, we don't have to hardcode the whole path.

=CN So, If We Know The 亲戚 Path From The 临时单据 Directory, We Don't Have To hardcode The Whole Path.

=EN This makes the script more portable.

=CN This 使 The 临时单据 More 手提的.

=EN Extending @INC with PERL5LIB The Skipper must edit each program that uses his private libraries to include those lines from the previous section.

=CN Extending @INC With PERL5LIB The Skipper Must 校订 Each Program That Uses 他的 Private 库 To Include Those Lines From The Previous Section.

=EN If that seems like too much editing, he can instead set the PERL5LIB environment variable to the directory name.

=CN If That 似乎 Like Too Much editing, 他 Can Instead Set The PERL5LIB 环境 Variable To The Directory Name.

=EN For example, in the C shell, he'd use the line:

=CN For Example, In The C 壳, 他'd Use The Line:

=EN setenv PERL5LIB /home/skipper/perl-lib

=CN setenv PERL5LIB /家/skipper/Perl-lib

=EN In Bourne-style shells, he'd use something like:

=CN In Bourne-Style shells, 他'd Use Something Like:

=EN PERL5LIB=/home/skipper/perl-lib; export PERL5LIB

=CN PERL5LIB=/家/skipper/Perl-lib; Export PERL5LIB

=EN The Skipper can set PERL5LIB once and forget about it.

=CN The Skipper Can Set PERL5LIB Once And 忘记 About It.

=EN However, unless Gilligan has the same PERL5LIB environment variable, his program will fail!

=CN However, Unless Gilligan Has The Same PERL5LIB 环境 Variable, 他的 Program Will 失败!

=EN While PERL5LIB is useful for personal use, we can't rely on it for programs we intend to share with others.

=CN While PERL5LIB Is Useful For 私人的 Use, We Can't 依靠 On It For Programs We 打算 To 份 With 别人.

=EN (And we can't make our entire team of programmers add a common PERL5LIB variable.

=CN (And We Can't Make Our 完全的 小队 Of Programmers 增添 a Common PERL5LIB Variable.

=EN Believe us, we've tried.)

=CN Believe Us, We'Ve tried.)

=EN The PERL5LIB variable can include multiple directories separated by colons.

=CN The PERL5LIB Variable Can Include Multiple directories Separated By 冒号.

=EN Perl inserts all specified directories at the beginning of @INC.

=CN Perl inserts All 指定 directories At The 开端 Of @INC.

=EN While a system administrator might add a setting of PERL5LIB to a system-wide startup script, most people frown on that.

=CN While a System administrator Might 增添 a Setting Of PERL5LIB To a System-宽的 startup 临时单据, Most People 皱眉头 On That.

=EN The purpose of PERL5LIB is to enable non-administrators to extend Perl to recognize additional directories.

=CN The Purpose Of PERL5LIB Is To 使能够 Non-administrators To 延伸 Perl To 认出 Additional directories.

=EN If a system administrator wants additional directories, he merely needs to recompile and reinstall Perl.

=CN If a System administrator 要 Additional directories, 他 仅仅 Needs To recompile And 重新 Perl.

=EN Extending @INC with -I If Gilligan recognizes that one of the Skipper's programs is missing the proper directive, Gilligan can either add the proper PERL5LIB variable or invoke Perl directly with one or more -I options.

=CN Extending @INC With -I If Gilligan recognizes That One Of The Skipper's Programs Is Missing The 合适的 命令, Gilligan Can Either 增添 The 合适的 PERL5LIB Variable Or 调用 Perl 直接地 With One Or More -I 选项.

=EN For example, to invoke the Skipper's get_us_home program, the command line might be something like:

=CN For Example, To 调用 The Skipper's get_us_home Program, The 命令 Line Might Be Something Like:

=EN perl -I/home/skipper/perl-lib /home/skipper/bin/get_us_home

=CN Perl -I/家/skipper/Perl-lib /家/skipper/bin/get_us_home

=EN Obviously, it's easier for Gilligan if the program itself defines the extra libraries.

=CN Obviously, It's Easier For Gilligan If The Program Itself 定义 The Extra 库.

=EN But sometimes just adding a -I fixes things right up.[*] This works even if Gilligan can't edit the Skipper's program.

=CN But Sometimes Just Adding a -I fixes Things Right Up.[*] This Works Even If Gilligan Can't 校订 The Skipper's Program.

=EN He still has to be able to read it, of course, but Gilligan can use this technique to try a new version of his library with the Skipper's program, for example.

=CN He Still Has To Be Able To Read It, Of Course, But Gilligan Can Use This 技术 To Try a New Version Of 他的 Library With The Skipper's Program, For Example.

=EN [*] Extending @INC with either PERL5LIB orI also automatically adds the versionand architecture-specific subdirectories of the specified directories.

=CN [*] Extending @INC With Either PERL5LIB orI Also Automatically Adds The versionand 建筑学-特殊的 subdirectories Of The 指定 directories.

=EN Adding these directories automatically simplifies the task of installing Perl modules that include architecture- or version-sensitive components, such as compiled C code.

=CN Adding These directories Automatically simplifies The 工作 Of installing Perl Modules That Include 建筑学- Or Version-Sensitive 组件, Such As Compiled C Code.

=EN The Problem of Namespace Collisions Sometimes the Skipper runs a ship into an island, but sometimes the collision involved is just a couple of names in a Perl program.

=CN The Problem Of Namespace Collisions Sometimes The Skipper 跑 a 船 Into An 岛屿, But Sometimes The 猛烈碰拉 涉及的 Is Just a 一对 Of Names In a Perl Program.

=EN Suppose that the Skipper has added all his cool and useful routines to navigation.pm and that Gilligan has incorporated the library into his own navigation package, head_toward_island:

=CN Suppose That The Skipper Has added All 他的 凉的 And Useful Routines To navigation.pm And That Gilligan Has 有限的 The Library Into 他的 Own 航行 Package, head_toward_island:

=EN #!/usr/bin/perl

=CN #!/usr/bin/Perl

=EN require 'navigation.pm';

=CN Require 'navigation.pm';

=EN sub turn_toward_port {

=CN Sub turn_toward_port {

=EN sub compute_heading_to_island {

=CN Sub compute_heading_to_island {

=EN .. more program here ..

=CN .. More Program Here ..

=EN Gilligan then has his program debugged (perhaps with the aid of a smart person whom we'll call "the Professor"), and everything works well.

=CN Gilligan Then Has 他的 Program debugged (也许 With The 援助 Of a 聪明的 人 谁（宾格） We'我 Call "The Professor"), And Everything Works Well.

=EN However, now the Skipper decides to modify his navigation.pm library, adding a routine called turn_toward_port that makes a 45-degree turn toward the left (known as "port" in nautical jargon).

=CN However, Now The Skipper decides To Modify 他的 navigation.pm Library, Adding a Routine Called turn_toward_port That 使 a 45-程度 转向 向 The Left (Known As "港口" In nautical jargon).

=EN Gilligan's program will fail in a catastrophic way as soon as he tries to head to port: he'll start steering the ship in circles!

=CN Gilligan's Program Will 失败 In a 灾难性的 Way As 不久 As 他 试 To Head To 港口: 他'我 Start steering The 船 In circles!

=EN The problem is that the Perl compiler first compiles turn_toward_port from Gilligan's main program, then when Perl evaluates the require at runtime, it redefines turn_toward_port as the Skipper's definition.

=CN The Problem Is That The Perl Compiler First compiles turn_toward_port From Gilligan's Main Program, Then When Perl 评价 The Require At Runtime, It redefines turn_toward_port As The Skipper's Definition.

=EN Sure, if Gilligan has warnings enabled, he'll notice something is wrong, but why should he have to count on that?

=CN Sure, If Gilligan Has 警告 Enabled, 他'我 Notice Something Is 错误的, But Why Should 他 Have To 计算 On That?

=EN The problem is that Gilligan defined turn_toward_port as meaning "turn toward the port on the island, " while the Skipper defined it as "turn toward the left."

=CN The Problem Is That Gilligan Defined turn_toward_port As Meaning "转向 向 The 港口 On The 岛屿, " While The Skipper Defined It As "转向 向 The Left."

=EN How do we resolve this?

=CN How Do We 决定 This?

=EN One way is to require that the Skipper put an explicit prefix in front of every name defined in the library, say, navigation_.

=CN One Way Is To Require That The Skipper Put An 清楚的 前缀 In Front Of Every Name Defined In The Library, Say, navigation_.

=EN Thus, Gilligan's program ends up looking like:

=CN Thus, Gilligan's Program Ends Up 看 Like:

=EN Clearly, the navigation_turn_toward_heading comes from the navigation.pm file.

=CN Clearly, The navigation_turn_toward_heading 来 From The navigation.pm File.

=EN This is great for Gilligan but awkward for the Skipper, as his file now has longer subroutine names:

=CN This Is 大的 For Gilligan But 笨拙的 For The Skipper, As 他的 File Now Has 长 Subroutine Names:

=EN sub navigation_turn_toward_heading {

=CN Sub navigation_turn_toward_heading {

=EN Packages as Namespace Separators If the name prefix of the last example didn't have to be spelled out on every use, things would work much better.

=CN Packages As Namespace Separators If The Name 前缀 Of The Last Example Didn't Have To Be spelled Out On Every Use, Things Would Work Much Better.

=EN We can improve the situation by using a package:

=CN We Can 改善 The 形势 By Using a Package:

=EN package Navigation;

=CN Package Navigation;

=EN The package declaration at the beginning of this file tells Perl to virtually insert Navigation:: in front of most names within the file.

=CN The Package Declaration At The 开端 Of This File 告诉 Perl To 几乎 插入 Navigation:: In Front Of Most Names Within The File.

=EN Thus, the code above practically says:

=CN Thus, The Code Above 实际地 说:

=EN sub Navigation::turn_toward_heading {

=CN Sub Navigation::turn_toward_heading {

=EN sub Navigation::turn_toward_port {

=CN Sub Navigation::turn_toward_port {

=EN Now when Gilligan uses this file, he simply adds Navigation:: to the subroutines defined in the library and leaves the Navigation:: prefix off for subroutines he defines on his own:

=CN Now When Gilligan Uses This File, 他 Simply Adds Navigation:: To The Subroutines Defined In The Library And 叶子 The Navigation:: 前缀 Off For Subroutines 他 定义 On 他的 Own:

=EN Package names are like variable names: they consist of alphanumerics and underscores but can't begin with a digit.

=CN Package Names Are Like Variable Names: They 由 Of alphanumerics And underscores But Can't 开始 With a 数字.

=EN Also, for reasons explained in the perlmodlib documentation, a package name should begin with a capital letter and not overlap an existing CPAN or core module name.

=CN Also, For Reasons explained In The perlmodlib 提供文件, a Package Name Should 开始 With a 首都 字母 And Not 重叠 An 现存的 Perl综合典藏网 Or Core Module Name.

=EN Package names can also have multiple names separated by double colons, such as Minnow::Navigation and Minnow::Food::Storage.

=CN Package Names Can Also Have Multiple Names Separated By 两倍的 冒号, Such As Minnow::Navigation And Minnow::Food::Storage.

=EN Nearly every scalar, array, hash, subroutine, and filehandle name[*] is actually prefixed by the current package, unless the name already contains one or more double-colon markers.

=CN Nearly Every Scalar, Array, Hash, Subroutine, And Filehandle Name[*] Is Actually 前缀 By The Current Package, Unless The Name Already 包含 One Or More 两倍的-结肠 markers.

=EN [*] Except lexicals, as we'll show in a moment.

=CN [*] Except Lexicals, As We'我 Show In a Moment.

=EN So, in navigation.pm, we can use variables such as:[]

=CN So, In navigation.pm, We Can Use Variables Such As:[]

=EN [] Trivia note: 21.283 degrees north, 157.842 degrees west is the location of the real-life marina where the opening shot of a famous television series was filmed.

=CN [] Trivia Note: 21.283 度 North, 157.842 度 西方 Is The 地点 Of The Real-生活 marina Where The 开始 射击 Of a 著名的 电视 系列 Was filmed.

=EN Check it out on Google Maps if you don't believe us.

=CN Check It Out On Google Maps If You Don't 相信 Us.

=EN package Navigation; @homeport = (21.283, -157.842);

=CN Package Navigation; @homeport = (21.283, -157.842);

=EN We can refer to the @homeport variable in the main code with its full package specification:

=CN We Can Refer To The @homeport Variable In The Main Code With Its Full Package 规格:

=EN @destination = @Navigation::homeport;

=CN @终点 = @Navigation::homeport;

=EN If every name has a package name inserted in front of it, what about names in the main program?

=CN If Every Name Has a Package Name 插入 In Front Of It, What About Names In The Main Program?

=EN Yes, they are also in a package, called main.

=CN Yes, They Are Also In a Package, Called Main.

=EN It's as if package main; were at the beginning of each file.

=CN It's As If Package Main; Were At The 开端 Of Each File.

=EN Thus, to keep Gilligan from having to say Navigation::turn_toward_heading, the navigation.pm file can say:

=CN Thus, To 保持 Gilligan From Having To Say Navigation::turn_toward_heading, The navigation.pm File Can Say:

=EN sub main::turn_toward_heading {

=CN Sub Main::turn_toward_heading {

=EN Now the subroutine is defined in the main package, not the Navigation package.

=CN Now The Subroutine Is Defined In The Main Package, Not The Navigation Package.

=EN This isn't an optimal solution (we'll show better solutions in Chapter 15 when we talk about Exporter), but at least there's nothing sacred or terribly unique about main compared to any other package.

=CN This Isn't An 最佳的 解决 (We'我 Show Better solutions In Chapter 15 When We 谈话 About Exporter), But At Least There's Nothing 神圣的 Or 可怕地 唯一的 About Main 相比 To Any Other Package.

=EN This is what the modules in Chapter 3 were doing when they imported symbols into our scripts, but we didn't tell you the whole story then.

=CN This Is What The Modules In Chapter 3 Were Doing When They Imported Symbols Into Our Scripts, But We Didn't Tell You The Whole 故事 Then.

=EN Those modules imported the subroutines and variables into the current package (again, that's main in our scripts, usually).

=CN Those Modules Imported The Subroutines And Variables Into The Current Package (Again, That's Main In Our Scripts, Usually).

=EN That is, those symbols are only available in that package unless we use the full package specification.

=CN That Is, Those Symbols Are Only Available In That Package Unless We Use The Full Package 规格.

=EN We'll get more into how this works later.

=CN We'我 Get More Into How This Works 更晚.

=EN Scope of a Package Directive All files start as if we had said package main;.[*] Any package directive remains in effect until the next package directive, unless that package directive is inside a curly-braced scope.

=CN Scope Of a Package Directive All Files Start As If We Had Said Package Main;.[*] Any Package 命令 剩余 In Effect Until The 下一次 Package 命令, Unless That Package 命令 Is 里面 a 卷曲的-braced Scope.

=EN In that case, Perl remembers the prior package and restores it when that scope ends.

=CN In That Case, Perl 记得 The 较早的 Package And restores It When That Scope Ends.

=EN Here's an example:

=CN Here's An Example:

=EN [*] Perl doesn't make us create an explicit main( ) loop like C. Perl knows that every script needs one, so it gives it to us for free.

=CN [*] Perl Doesn't Make Us Create An 清楚的 Main( ) Loop Like C. Perl 知道 That Every 临时单据 Needs One, So It Gives It To Us For Free.

=EN { # start scope block

=CN { # Start Scope Block

=EN  # now in package main

=CN  # Now In Package Main

=EN  # main::turn_toward_heading

=CN  # Main::turn_toward_heading

=EN } # end scope block

=CN } # End Scope Block

=EN # back to package Navigation

=CN # Back To Package Navigation

=EN sub turn_toward_port { # Navigation::turn_toward_port

=CN Sub turn_toward_port { # Navigation::turn_toward_port

=EN The current package is lexically scoped, similar to the scope of my variables, narrowed to the innermost-enclosing brace pair or file in which we introduced the package.

=CN The Current Package Is Lexically Scoped, Similar To The Scope Of My Variables, narrowed To The 内心-Enclosing 支撑 对 Or File In Which We Introduced The Package.

=EN Most libraries have only one package declaration at the top of the file.

=CN Most 库 Have Only One Package Declaration At The 顶 Of The File.

=EN Most programs leave the package as the default main package.

=CN Most Programs 出发 The Package As The Default Main Package.

=EN However it's nice to know that we can temporarily have a different current package.[]

=CN However It's Nice To Know That We Can temporarily Have a Different Current Package.[]

=EN [] Some names are always in package main regardless of the current package: ARGV, ARGVOUT, ENV, INC, SIG, STDERR, STDIN, and STDOUT.

=CN [] Some Names Are Always In Package Main 不顾的（地） Of The Current Package: 命令行传入参数, 命令行传入参数OUT, ENV, INC, SIG, STDERR, STDIN, And STDOUT.

=EN We can always refer to @INC and be assured of getting @main::INC.

=CN We Can Always Refer To @INC And Be 感到放心的 Of 得到 @Main::INC.

=EN The punctuation mark variables, such as $_, $2, and $!, are either all lexicals or forced into package main, so when we write $., we never get $Navigation::. by mistake.

=CN The 准时 痕迹 Variables, Such As $_, $2, And $!, Are Either All Lexicals Or 迫使 Into Package Main, So When We Write $., We Never Get $Navigation::. By 错误.

=EN Packages and Lexicals A lexical variable (a variable introduced with my) isn't prefixed by the current package because package variables are always global: we can always reference a package variable if we know its full name.

=CN Packages And Lexicals A Lexical Variable (a Variable Introduced With My) Isn't 前缀 By The Current Package Because Package Variables Are Always Global: We Can Always Reference a Package Variable If We Know Its Full Name.

=EN A lexical variable is usually temporary and accessible for only a portion of the program.

=CN A Lexical Variable Is Usually temporary And Accessible For Only a 一份 Of The Program.

=EN If we declare a lexical variable, then using that name without a package prefix gets the lexical variable.

=CN If We Declare a Lexical Variable, Then Using That Name Without a Package 前缀 Gets The Lexical Variable.

=EN A package prefix ensures that we are accessing a package variable and never a lexical variable.

=CN A Package 前缀 ensures That We Are 访问 a Package Variable And Never a Lexical Variable.

=EN For example, suppose a subroutine within navigation.pm declares a lexical @homeport variable.

=CN For Example, 猜想 a Subroutine Within navigation.pm Declares a Lexical @homeport Variable.

=EN Any mention of @homeport will then be the newly introduced lexical variable, but a fully qualified mention of @Navigation::homeport accesses the package variable instead.

=CN Any 提及 Of @homeport Will Then Be The 新 Introduced Lexical Variable, But a Fully 有资格的 提及 Of @Navigation::homeport Accesses The Package Variable Instead.

=EN sub get_me_home {

=CN Sub get_me_home {

=EN  # refers to the lexical variable

=CN  # Refers To The Lexical Variable

=EN  # refers to the package variable

=CN  # Refers To The Package Variable

=EN .. @homeport .. # refers to the package variable

=CN .. @homeport .. # Refers To The Package Variable

=EN Obviously, this can lead to confusing code, so we shouldn't introduce such duplication needlessly.

=CN Obviously, This Can 铅 To 混淆 Code, So We 应该't 介绍 Such duplication needlessly.

=EN The results are completely predictable, though.

=CN The Results Are 完全地 predictable, Though.

=EN Exercises You can find the answers to these exercises in "Answers for Chapter 10" in the Appendix.

=CN Exercises You Can 寻找 The answers To These exercises In "Answers For Chapter 10" In The Appendix.

=EN Exercise 1 [25 min] The Oogaboogoo natives on the island have unusual names for the days and months.

=CN Exercise 1 [25 min] The Oogaboogoo natives On The 岛屿 Have 不寻常的 Names For The 天 And 月.

=EN Here is some simple but not very well-written code from Gilligan.

=CN Here Is Some Simple But Not Very Well-Written Code From Gilligan.

=EN Fix it up, add a conversion function for the month names, and make the whole thing into a library.

=CN Fix It Up, 增添 a 转变 Function For The 月份 Names, And Make The Whole Thing Into a Library.

=EN For extra credit, add suitable error checking and consider what should be in the documentation.

=CN For Extra 信誉, 增添 Suitable Error Checking And Consider What Should Be In The 提供文件.

=EN @day = qw(ark dip wap sen pop sep kir); sub number_to_day_name { my $num = shift @_; $day[$num]; } @month = qw(diz pod bod rod sip wax lin sen kun fiz nap dep);

=CN @一天 = Qw(ark 蘸 wap sen Pop sep kir); Sub number_to_day_name { My $胡 = Shift @_; $一天[$胡]; } @月份 = Qw(diz B<pod> bod 小棒 sip 蜡 lin sen kun fiz 打盹 dep);

=EN Exercise 2 [15 min] Make a program that uses your library and the following code to print out a message, such as Today is dip, sen 15, 2011, meaning that today is a Monday in August.

=CN Exercise 2 [15 min] Make a Program That Uses Your Library And The Following Code To Print Out a 音讯, Such As Today Is 蘸, sen 15, 2011, Meaning That 今天现在 Is a Monday In August.

=EN (Hint: the year and month numbers returned by localtime may not be what you'd expect, so you need to check the documentation.)

=CN (Hint: The 年 And 月份 编号 Returned By localtime May Not Be What You'd 盼望, So You Need To Check The 提供文件.)

=EN my($sec, $min, $hour, $mday, $mon, $year, $wday) = localtime;

=CN My($sec, $min, $小时, $mday, $mon, $年, $wday) = localtime;

