=EN Essential Testing As we briefly described in Chapter 16, a distribution contains a testing facility that we can invoke from make test.

=CN Essential Testing As We 简单地 Described In Chapter 16, a 分配 包含 a testing 方便 That We Can 调用 From Make Test.

=EN This allows us to write and run tests during development and maintenance, and it also lets our end user verify that the module works in her environment.

=CN This Allows Us To Write And Run 测试 在 进展 And 保养, And It Also Lets Our End User 检验 That The Module Works In Her 环境.

=EN Although we cover testing briefly here, you should check out Perl Testing: A Developer's Notebook (O'Reilly), which covers the subject in depth.

=CN Although We 盖 testing 简单地 Here, You Should Check Out Perl Testing: A Developer's Notebook (O'Reilly), Which covers The Subject In 深度.

=EN More Tests Mean Better Code Why should we test during development?

=CN More Tests Mean Better Code Why Should We Test 在 进展?

=EN The short answer is that we find out about problems sooner and tests force us to program in much smaller chunks (since they are easier to test), which is generally good programming practice.

=CN The 短的 Answer Is That We 寻找 Out About 问题 sooner And 测试 Force Us To Program In Much smaller chunks (Since They Are Easier To Test), Which Is Generally Good Programming Practice.

=EN Although we may think we have extra work to do, that's only short-term overhead.

=CN Although We May 想 We Have Extra Work To Do, That's Only 短的-期限 头上的.

=EN We win down the line when we spend less time debugging, both because we've fixed most of the problems before they were problems and because the tests usually point us right at the problem we need to fix.

=CN We 赢得 向下 The Line When We 花费 更少的 Time Debugging, Both Because We'Ve Fixed Most Of The 问题 Before They Were 问题 And Because The 测试 Usually 尖 Us Right At The Problem We Need To 固定.

=EN Along with that, we'll find that it's psychologically easier to modify code because the tests will tell us if we broke something.

=CN Along With That, We'我 寻找 That It's psychologically Easier To Modify Code Because The 测试 Will Tell Us If We broke Something.

=EN When we talk to our boss or coworkers, we'll also have the confidence in our code to answer their queries and questions.

=CN When We 谈话 To Our 上司 Or coworkers, We'我 Also Have The 信任 In Our Code To Answer Their queries And Questions.

=EN The tests tell us how healthy our code is.

=CN The 测试 Tell Us How 健康的 Our Code Is.

=EN Different people have different ideas about testing.

=CN Different People Have Different 思想 About testing.

=EN One school of thought, known as Test-Driven Development, says that we should write the tests before we write the code that is being tested.

=CN One 学校 Of Thought, Known As Test-Driven 开发, 说 That We Should Write The 测试 Before We Write The Code That Is Being 测试.

=EN On the first go-around, the test fails.

=CN On The First Go-Around, The Test 失败.

=EN What good is the test if it doesn't fail when it should?

=CN What Good Is The Test If It Doesn't 失败 When It Should?

=EN Once we know it fails, we write the code to make it work.

=CN Once We Know It 失败, We Write The Code To Make It Work.

=EN When that works, we write a test for another feature, repeat the process, and keep doing that until we're done.

=CN When That Works, We Write a Test For 另一个 Feature, 重复 The 程序, And 保持 Doing That Until We'Re Done.

=EN Along the way, we've verified the functionality and features.

=CN Along The Way, We'Ve verified The Functionality And 特征.

=EN We're never really done, though.

=CN We'Re Never Really Done, Though.

=EN Even when the module ships, we shouldn't abandon the test suite!

=CN Even When The Module ships, We 应该't 抛弃 The Test 随员!

=EN Unless we code the mythical "bug-free module, " our users will send us bug reports.

=CN Unless We Code The mythical "臭虫-Free Module, " Our Users Will 派遣 Us 臭虫 Reports.

=EN We can turn each report into a test case.[*] While fixing the bug, the remaining tests prevent our code from regressing to a less functional version of the codehence the name regression testing .

=CN We Can 转向 Each 报告 Into a Test Case.[*] While fixing The 臭虫, The Remaining 测试 防止 Our Code From regressing To a 更少的 Functional Version Of The codehence The Name regression testing .

=EN [*] If we're reporting a bug in someone else's code, we can generally assume that they'll appreciate us sending them a test for the bug.

=CN [*] If We'Re reporting a 臭虫 In Someone Else's Code, We Can Generally 假定 That They'我 欣赏 Us sending Them a Test For The 臭虫.

=EN They'll appreciate a patch even more!

=CN They'我 欣赏 a 补丁 Even More!

=EN Then there are always the future releases to think about.

=CN Then There Are Always The Future Releases To 想 About.

=EN When we want to add new features, we start by adding tests.[] Because the existing tests ensure our upward compatibility, we can be confident that our new release does everything the old release did, and then some.

=CN When We Want To 增添 New 特征, We Start By Adding 测试.[] Because The 现存的 测试 Ensure Our 向上（的） 兼容性, We Can Be 确信的 That Our New Release Does Everything The Old Release Did, And Then Some.

=EN [] And writing the documentation at the same time, made easier by Test::Inline, as we'll see later.

=CN [] And 写作 The 提供文件 At The Same Time, Made Easier By Test::Inline, As We'我 See 更晚.

=EN A Simple Test Script Before we go on, let's write some Perl code.

=CN A Simple Test Script Before We Go On, Let's Write Some Perl Code.

=EN We just told you about creating the tests before you write the code, so maybe we should follow our own advice.

=CN We Just told You About Creating The 测试 Before You Write The Code, So 或许 We Should 跟随 Our Own 忠告.

=EN We'll get to the details later, but for now we start with the Test::More module, [] which comes with the standard Perl distribution.

=CN We'我 Get To The Details 更晚, But For Now We Start With The Test::More Module, [] Which 来 With The Standard Perl 分配.

=EN [] There is also a Test::Simple module, but most people use its successor, Test::More, so we'll stick to that.

=CN [] There Is Also a Test::Simple Module, But Most People Use Its 继承人, Test::More, So We'我 Stick To That.

=EN To start our testing, we write a simple Perl script.

=CN To Start Our testing, We Write a Simple Perl 临时单据.

=EN All of our tests are going to be scripts, so we can use the stuff you already know about Perl.

=CN All Of Our 测试 Are Going To Be Scripts, So We Can Use The 材料 You Already Know About Perl.

=EN We load Test::More and tell it how many tests we want to run.

=CN We Load Test::More And Tell It How Many 测试 We Want To Run.

=EN After that, we use the convenience functions from Test::More, which we'll go through later.

=CN After That, We Use The 方便 Functions From Test::More, Which We'我 Go 通过 更晚.

=EN In short, most of them compare their first argument, which is the result we got, to the second argument, which is what we expected.

=CN In 短的, Most Of Them 比较 Their First Argument, Which Is The Result We Got, To The Second Argument, Which Is What We Expected.

=EN #!/usr/bin/perl

=CN #!/usr/bin/Perl

=EN use Test::More tests => 4;

=CN Use Test::More 测试 => 4;

=EN ok( 1, '1 is true' );

=CN Ok( 1, '1 Is True' );

=EN is( 2 + 2, 4, 'The sum is 4' );

=CN Is( 2 + 2, 4, 'The 总数 Is 4' );

=EN is( 2 * 3, 5, 'The product is 5' );

=CN Is( 2 * 3, 5, 'The 产品 Is 5' );

=EN isnt( 2 ** 3, 6, "The result isn't 6" );

=CN isnt( 2 ** 3, 6, "The Result Isn't 6" );

=EN like( 'Alpaca Book', qr/alpaca/i, 'I found an alpaca!' );

=CN Like( 'Alpaca Book', qr/alpaca/我, 'I Found An alpaca!' );

=EN When we run this simple script, we get this output.

=CN When We Run This Simple 临时单据, We Get This 出产.

=EN When the received and expected values are the same, Test::More outputs a line starting with ok.

=CN When The received And Expected Values Are The Same, Test::More outputs a Line Starting With Ok.

=EN When those values don't match, it outputs a line starting with not ok.

=CN When Those Values Don't Match, It outputs a Line Starting With Not Ok.

=EN It also outputs some diagnostic information that tells us what the test expected and what we actually gave it.

=CN It Also outputs Some 诊断 Information That 告诉 Us What The Test Expected And What We Actually 给 It.

=EN 1..4 ok 1 - 1 is true ok 2 - The sum is 4 not ok 3 - The product is 5 # Failed test 'The product is 5' # in /Users/brian/Desktop/test at line 9. # got: '6' # expected: '5' # Looks like you planned 4 tests but ran 1 extra. # Looks like you failed 1 test of 5 run. ok 4 - The result isn't 6 ok 5 - I found an alpaca!

=CN 1..4 Ok 1 - 1 Is True Ok 2 - The 总数 Is 4 Not Ok 3 - The 产品 Is 5 # Failed Test 'The 产品 Is 5' # In /Users/brian/Desktop/Test At Line 9. # Got: '6' # Expected: '5' # Looks Like You 计划 4 测试 But ran 1 Extra. # Looks Like You failed 1 Test Of 5 Run. Ok 4 - The Result Isn't 6 Ok 5 - I Found An alpaca!

=EN Later on, we'll see how Perl takes all of this output to create a nice report for us.

=CN Later On, We'我 See How Perl Takes All Of This 出产 To Create a Nice 报告 For Us.

=EN We won't have to look at a lot of output to find the important bits once Test::Harness goes through it for us.

=CN We Won't Have To Look At a 许多 Of 出产 To 寻找 The Important 位 Once Test::Harness 去 通过 It For Us.

=EN The Art of Testing Good tests also give small examples of what we meant in our documentation.

=CN The Art Of Testing Good 测试 Also Give Small Examples Of What We 意味着 In Our 提供文件.

=EN It's another way to express the same thing, and some people may like one way over the other.[*] Good tests also give confidence to the user that your code (and all its dependencies) is portable enough to work on her system.

=CN It's 另一个 Way To Express The Same Thing, And Some People May Like One Way 在 The Other.[*] Good 测试 Also Give 信任 To The User That Your Code (And All Its dependencies) Is 手提的 Enough To Work On Her System.

=EN [*] A few of the modules we've used from CPAN are easier to learn from test examples than by the actual POD.

=CN [*] A Few Of The Modules We'Ve Used From Perl综合典藏网 Are Easier To 学习 From Test Examples Than By The Actual POD.

=EN Of course, any really good example should be repeated in your module's POD documentation.

=CN Of Course, Any Really Good Example Should Be 重复 In Your Module's POD 提供文件.

=EN Testing is an art.

=CN Testing Is An 艺术.

=EN People have written and read dozens of how-to-test books (and then ignore them, it seems).

=CN People Have Written And Read dozens Of How-To-Test books (And Then 忽视 Them, It 似乎).

=EN Mostly, it's important to remember everything we have ever done wrong while programming (or heard other people do), and then test that we didn't do it again for this project.

=CN Mostly, It's Important To 记得 Everything We Have 曾经 Done 错误的 While Programming (Or heard Other People Do), And Then Test That We Didn't Do It Again For This 计划.

=EN When you create tests, think like a person using a module, not like one writing a module.

=CN When You Create 测试, 想 Like a 人 Using a Module, Not Like One 写作 a Module.

=EN You know how you should use your module, because you invented it and had a specific need for it.

=CN You Know How You Should Use Your Module, Because You 发明 It And Had a 特殊的 Need For It.

=EN Other people will probably have different uses for it and they'll try to use it in all sorts of different ways.

=CN Other People Will Probably Have Different Uses For It And They'我 Try To Use It In All 各样 Of Different Ways.

=EN You probably already know that given the chance, users will find every other way to use your code.

=CN You Probably Already Know That Given The Chance, Users Will 寻找 Every Other Way To Use Your Code.

=EN You need to think like that when you test.

=CN You Need To 想 Like That When You Test.

=EN Test things that should break as well as things that should work.

=CN Test Things That Should 打破 As Well As Things That Should Work.

=EN Test the edges and the middle.

=CN Test The edges And The 当中.

=EN Test one more or one less than the edge.

=CN Test One More Or One 更少的 Than The 边.

=EN Test things one at a time.

=CN Test Things One At a Time.

=EN Test many things at once.

=CN Test Many Things At Once.

=EN If something should throw an exception, make sure it doesn't also have bad side effects.

=CN If Something Should 投 An Exception, Make Sure It Doesn't Also Have 坏的 Side Effects.

=EN Pass extra parameters.

=CN Pass Extra Parameters.

=EN Pass insufficient parameters.

=CN Pass 不充足的 Parameters.

=EN Mess up the capitalization on named parameters.

=CN Mess Up The 资本化 On Named Parameters.

=EN Throw far too much or too little data at it.

=CN Throw Far Too Much Or Too Little Data At It.

=EN Test what happens for unexpected values such as undef.

=CN Test What Happens For 意外的 Values Such As Undef.

=EN Since we can't look at your module, let's suppose that we want to test Perl's sqrt function, which calculates square roots.

=CN Since We Can't Look At Your Module, Let's 猜想 That We Want To Test Perl's sqrt Function, Which calculates 正方形 roots.

=EN It's obvious that we need to make sure it returns the right values when its parameter is 0, 1, 49, or 100.

=CN It's 明显的 That We Need To Make Sure It Returns The Right Values When Its Parameter Is 0, 1, 49, Or 100.

=EN It's nearly as obvious to see that sqrt(0.25) should come out to be 0.5.

=CN It's 几乎 As 明显的 To See That sqrt(0.25) Should 来到 Out To Be 0.5.

=EN We should also ensure that multiplying the value for sqrt(7) by itself gives something between 6.99999 and 7.00001.[*]

=CN We Should Also Ensure That multiplying The Value For sqrt(7) By Itself Gives Something Between 6.99999 And 7.00001.[*]

=EN [*] Remember, floating-point numbers aren't always exact; there's usually a little roundoff.

=CN [*] Remember, Floating-尖 编号 还't Always Exact; There's Usually a Little roundoff.

=EN The Test::Number::Delta module can handle those situations.

=CN The Test::Number::Delta Module Can Handle Those 情况.

=EN Let's express that as code.

=CN Let's Express That As Code.

=EN We use the same stuff that we used for our first example.

=CN We Use The Same 材料 That We Used For Our First Example.

=EN This script tests things that should work.

=CN This 临时单据 测试 Things That Should Work.

=EN use Test::More tests => 6;

=CN Use Test::More 测试 => 6;

=EN is( sqrt( 0), 0, 'The square root of 0 is 0' ); is( sqrt( 1), 1, 'The square root of 1 is 1' ); is( sqrt( 49), 7, 'The square root of 49 is 7' ); is( sqrt(100), 10, 'The square root of 100 is 10' );

=CN Is( sqrt( 0), 0, 'The 正方形 Root Of 0 Is 0' ); Is( sqrt( 1), 1, 'The 正方形 Root Of 1 Is 1' ); Is( sqrt( 49), 7, 'The 正方形 Root Of 49 Is 7' ); Is( sqrt(100), 10, 'The 正方形 Root Of 100 Is 10' );

=EN is( sqrt(0.25), 0.5, 'The square root of 0.25 is 0.5' );

=CN Is( sqrt(0.25), 0.5, 'The 正方形 Root Of 0.25 Is 0.5' );

=EN my $product = sqrt(7) * sqrt(7);

=CN My $产品 = sqrt(7) * sqrt(7);

=EN ok( $product > 6.999 && $product < 7.001,

=CN Ok( $产品 > 6.999 && $产品 < 7.001,

=EN We should make sure that sqrt(-1) yields a fatal error and that sqrt(-100) does too.

=CN We Should Make Sure That sqrt(-1) yields a Fatal Error And That sqrt(-100) Does Too.

=EN What happens when we request sqrt(&test_sub( )), and &test_sub returns a string of "10000"?

=CN What Happens When We 请求 sqrt(&test_sub( )), And &test_sub Returns a String Of "10000"?

=EN What does sqrt(undef) do?

=CN What Does sqrt(undef) Do?

=EN How about sqrt( ) or sqrt(1, 1)?

=CN How About sqrt( ) Or sqrt(1, 1)?

=EN Maybe we want to give our function a googol: sqrt( 10**100 ).

=CN Maybe We Want To Give Our Function a googol: sqrt( 10**100 ).

=EN Because this function is documented to work on $_ by default, we should ensure that it does so.

=CN Because This Function Is Documented To Work On $_ By Default, We Should Ensure That It Does So.

=EN Even a simple function such as sqrt should get a couple dozen tests; if our code does more complex tasks than sqrt does, expect it to need more tests, too.

=CN Even a Simple Function Such As sqrt Should Get a 一对 一打 测试; If Our Code Does More 综合的 Tasks Than sqrt Does, 盼望 It To Need More 测试, Too.

=EN There are never too many tests.

=CN There Are Never Too Many 测试.

=EN In this simple script, we tested a lot of odd conditions.[]

=CN In This Simple 临时单据, We 测试 a 许多 Of 古怪的 条件.[]

=EN [] And in writing this, we discovered that we can't write sqrt(-1) because eval doesn't trap that.

=CN [] And In 写作 This, We discovered That We Can't Write sqrt(-1) Because Eval Doesn't 陷井 That.

=EN Apparently, Perl catches it at compile time.

=CN Apparently, Perl catches It At Compile Time.

=EN use Test::More tests => 9;

=CN Use Test::More 测试 => 9;

=EN sub test_sub { '10000' }

=CN Sub test_sub { '10000' }

=EN is( $@, '', '$@ is not set at start' );

=CN Is( $@, '', '$@ Is Not Set At Start' );

=EN { $n = -1; eval { sqrt($n) }; ok( $@, '$@ is set after sqrt(-1)' ); }

=CN { $n = -1; Eval { sqrt($n) }; Ok( $@, '$@ Is Set After sqrt(-1)' ); }

=EN eval { sqrt(1) }; is( $@, '', '$@ is not set after sqrt(1)' );

=CN Eval { sqrt(1) }; Is( $@, '', '$@ Is Not Set After sqrt(1)' );

=EN { my $n = -100; eval { sqrt($n) }; ok( $@, '$@ is set after sqrt(-100)' ); }

=CN { My $n = -100; Eval { sqrt($n) }; Ok( $@, '$@ Is Set After sqrt(-100)' ); }

=EN is( sqrt( test_sub( ) ), 100, 'String value works in sqrt( )' );

=CN Is( sqrt( test_sub( ) ), 100, 'String Value Works In sqrt( )' );

=EN eval { sqrt(undef) }; is( $@, '', '$@ is not set after sqrt(undef)' );

=CN Eval { sqrt(undef) }; Is( $@, '', '$@ Is Not Set After sqrt(undef)' );

=EN is( sqrt, 0, 'sqrt( ) works on $_ (undefined) by default' );

=CN Is( sqrt, 0, 'sqrt( ) Works On $_ (Undefined) By Default' );

=EN $_ = 100; is( sqrt, 10, 'sqrt( ) works on $_ by default' );

=CN $_ = 100; Is( sqrt, 10, 'sqrt( ) Works On $_ By Default' );

=EN is( sqrt( 10**100 ), 10**50, 'sqrt( ) can handle a googol' );

=CN Is( sqrt( 10**100 ), 10**50, 'sqrt( ) Can Handle a googol' );

=EN If you write the code and not just the tests, think about how to get every line of your code exercised at least once for full code coverage.

=CN If You Write The Code And Not Just The 测试, 想 About How To Get Every Line Of Your Code exercised At Least Once For Full Code 覆盖率.

=EN (Are you testing the else clause?

=CN (Are You testing The Else 条款?

=EN Are you testing every elsif case?)

=CN Are You testing Every Elsif Case?)

=EN If you aren't writing the code or aren't sure, use the code coverage facilities.[*]

=CN If You 还't 写作 The Code Or 还't Sure, Use The Code 覆盖率 facilitie(绑定操作符)s.[*]

=EN [*] Basic code coverage tools such as Devel::Cover are available in CPAN.

=CN [*] Basic Code 覆盖率 Tools Such As Devel::Cover Are Available In Perl综合典藏网.

=EN Check out other test suites, too.

=CN Check Out Other Test suites, Too.

=EN There are literally tens of thousands of test files on CPAN, and some of them contain hundreds of tests.

=CN There Are 简直 tens Of thousands Of Test Files On Perl综合典藏网, And Some Of Them Contain hundreds Of 测试.

=EN The Perl distribution itself comes with thousands of tests, designed to verify that Perl compiles correctly on our machine in every possible way.

=CN The Perl 分配 Itself 来 With thousands Of 测试, 设计 To 检验 That Perl compiles 正确地 On Our 机器 In Every Possible Way.

=EN That should be enough examples for anyone.

=CN That Should Be Enough Examples For 无论谁.

=EN Michael Schwern earned the title of "Perl Test Master" for getting the Perl core completely tested and still constantly beats the drum for "test! test! test!" in the community.

=CN Michael Schwern earned The 标题 Of "Perl Test Master" For 得到 The Perl Core 完全地 测试 And Still 经常地 beats The 鼓 For "Test! Test! Test!" In The 团体.

=EN The Test Harness We usually invoke tests, either as the developer or the user, by using make test .

=CN The Test Harness We Usually 调用 测试, Either As The developer Or The User, By Using Make Test .

=EN The Makefile uses the Test::Harness module to run the tests, watch the output, and report the results.

=CN The Makefile Uses The Test::Harness Module To Run The 测试, 观看 The 出产, And 报告 The Results.

=EN Tests live in files in the t directory at the top level of the distribution, and each test file ends in .t.

=CN Tests 居住生存 In Files In The t Directory At The 顶 Level Of The 分配, And Each Test File Ends In .t.

=EN The test harness invokes each file separately, so an exit or die terminates only the testing in that file, not the whole testing process.[*]

=CN The Test 支配 invokes Each File 分别地, So An Exit Or Die 终止 Only The testing In That File, Not The Whole testing 程序.[*]

=EN [*] If we decide that we need to stop all testing, we can "bail out" of the process by printing "bail out" to standard output.

=CN [*] If We Decide That We Need To Stop All testing, We Can "bail Out" Of The 程序 By 印刷 "bail Out" To Standard 出产.

=EN This can be handy if we encounter an error that is going to cause a cascade of errors that we don't want to wait to encounter or sift through.

=CN This Can Be 方便的 If We 面临 An Error That Is Going To 原因 a cascade Of Errors That We Don't Want To 等候 To 面临 Or 筛 通过.

=EN The test file communicates with the test harness through simple messages on standard output.[] The three most important messages are the test count, a success message, and a failure message.

=CN The Test File communicates With The Test 支配 通过 Simple Messages On Standard 出产.[] The Three Most Important Messages Are The Test 计算, a 成功 音讯, And a 失败 音讯.

=EN [] The exact details are documented in the perldoc Test::Harness::TAP, if you're curious.

=CN [] The Exact Details Are Documented In The perldoc Test::Harness::TAP, If You'Re 好奇的.

=EN Actually, they're there, even if you're not curious.

=CN Actually, They'Re There, Even If You'Re Not 好奇的.

=EN An individual test file comprises one or more tests.

=CN An Individual Test File comprises One Or More 测试.

=EN These tests are numbered as counting numbers, starting with one.

=CN These 测试 Are numbered As counting 编号, Starting With One.

=EN The first thing a test file must announce to the test harness (on STDOUT) is the expected number of tests, as a string that looks like a Perl range, 1..N. For example, if there are 17 tests, the first line of output should be:

=CN The First Thing a Test File Must 宣布 To The Test 支配 (On STDOUT) Is The Expected Number Of 测试, As a String That Looks Like a Perl 射程, 1..N. For Example, If There Are 17 测试, The First Line Of 出产 Should Be:

=EN followed by a newline.

=CN 跟着 By a 换行符.

=EN The test harness uses the upper number to verify that the test file hasn't just terminated early.

=CN The Test 支配 Uses The Upper Number To 检验 That The Test File hasn't Just terminated Early.

=EN If the test file is testing optional things and has no testing to do for this particular invocation, the string 1..0 suffices.

=CN If The Test File Is testing Optional Things And Has No testing To Do For This Particular 调用, The String 1..0 suffices.

=EN We don't have to worry about printing that ourselves, though, because Test::More does it for us.

=CN We Don't Have To 烦恼 About 印刷 That 我们自己, Though, Because Test::More Does It For Us.

=EN When we load the module, we tell it the number of tests that we want to run, and the module outputs the test range for us.

=CN When We Load The Module, We Tell It The Number Of 测试 That We Want To Run, And The Module outputs The Test 射程 For Us.

=EN To get that 1..17, we tell Test::More we're running 17 tests.

=CN To Get That 1..17, We Tell Test::More We'Re 连续的 17 测试.

=EN use Test::More tests => 17;

=CN Use Test::More 测试 => 17;

=EN After we print the test range, we send to standard output one line per test.

=CN After We Print The Test 射程, We 派遣 To Standard 出产 One Line 每 Test.

=EN That line starts with ok if the test passed, or not ok if the test failed.

=CN That Line Starts With Ok If The Test Passed, Or Not Ok If The Test failed.

=EN If we wrote that by hand, a test to check that 1 plus 2 is 3 might look like this:

=CN If We 写 That By Hand, a Test To Check That 1 Plus 2 Is 3 Might Look Like This:

=EN print +(1 + 2 = = 3 ? '', 'not '), "ok 1\n";

=CN Print +(1 + 2 = = 3 ? '', 'Not '), "Ok 1\n";

=EN We could also print the not only if the test failed, with the ok as a separate step.

=CN We Could Also Print The Not Only If The Test failed, With The Ok As a Separate 脚步.

=EN But on some platforms, this may fail unnecessarily, due to some I/O-related oddity.

=CN But On Some Platforms, This May 失败 不必要的, Due To Some I/O-Related oddity.

=EN For maximum portability, print the entire string of ok N or not ok N in one print step.

=CN For 最大量 可移植性, Print The 完全的 String Of Ok N Or Not Ok N In One Print 脚步.

=EN Don't forget the space after not!

=CN Don't 忘记 The Space After Not!

=EN print 'not ' unless 2 * 4 = = 8; print "ok 2\n";

=CN Print 'Not ' Unless 2 * 4 = = 8; Print "Ok 2\n";

=EN We don't have to do that much work, though, and we don't have to count the tests ourselves.

=CN We Don't Have To Do That Much Work, Though, And We Don't Have To 计算 The 测试 我们自己.

=EN What if we wanted to add a test between the two previous tests?

=CN What If We 想要 To 增添 a Test Between The Two Previous 测试?

=EN We'd have to give that new test the test number 2 and change the last test to test number 3.

=CN We'd Have To Give That New Test The Test Number 2 And Change The Last Test To Test Number 3.

=EN Not only that, we haven't output anything useful if the test fails, so we won't know what went wrong.

=CN Not Only That, We 还't 出产 Anything Useful If The Test 失败, So We Won't Know What 去 错误的.

=EN We could do all that, but it's too much work!

=CN We Could Do All That, But It's Too Much Work!

=EN Luckily, we can use the convenience functions from Test::More.

=CN Luckily, We Can Use The 方便 Functions From Test::More.

=EN Writing Tests with Test::More The Test::More[*] module comes with the standard Perl distribution starting with Perl 5.8, and it's available on CPAN if we need to install it on earlier Perl versions.

=CN Writing Tests With Test::More The Test::More[*] Module 来 With The Standard Perl 分配 Starting With Perl 5.8, And It's Available On Perl综合典藏网 If We Need To 安装 It On Earlier Perl Versions.

=EN It works all the way back to perl5.6, at least.

=CN It Works All The Way Back To perl5.6, At Least.

=EN We rewrite the tests from the previous section (and throw in a couple more) in this test script, which uses the ok( ) function from Test::More.

=CN We 重写 The 测试 From The Previous Section (And 投 In a 一对 More) In This Test 临时单据, Which Uses The Ok( ) Function From Test::More.

=EN [*] The name plays off Test::Simple, which did some of the same stuff but with far fewer convenience functions.

=CN [*] The Name plays Off Test::Simple, Which Did Some Of The Same 材料 But With Far fewer 方便 Functions.

=EN ok(1 + 2 = = 3, '1 + 2 = = 3'); ok(2 * 4 = = 8, '2 * 4 = = 8'); my $divide = 5 / 3; ok(abs($divide - 1.666667) < 0.001, '5 / 3 = = (approx) 1.666667'); my $subtract = -3 + 3; ok(($subtract eq '0' or $subtract eq '-0'), '-3 + 3 = = 0');

=CN Ok(1 + 2 = = 3, '1 + 2 = = 3'); Ok(2 * 4 = = 8, '2 * 4 = = 8'); My $分开 = 5 / 3; Ok(abs($分开 - 1.666667) < 0.001, '5 / 3 = = (approx) 1.666667'); My $减去 = -3 + 3; Ok(($减去 Eq '0' Or $减去 Eq '-0'), '-3 + 3 = = 0');

=EN The ok( ) function prints "ok" if its first argument is true, and "not ok" otherwise.

=CN The Ok( ) Function Prints "Ok" If Its First Argument Is True, And "Not Ok" Otherwise.

=EN The optional second argument lets us name the test.

=CN The Optional Second Argument Lets Us Name The Test.

=EN After the initial output to indicate success, ok( ) adds a hyphen and then the name of the test.

=CN After The Initial 出产 To 指明 成功, Ok( ) Adds a hyphen And Then The Name Of The Test.

=EN When we find a test that does not work, we can find it by the name that we gave it.

=CN When We 寻找 a Test That Does Not Work, We Can 寻找 It By The Name That We 给 It.

=EN 1..4 ok 1 - 1 + 2 = = 3 ok 2 - 2 * 4 = = 8 ok 3 - 5 / 3 = = (approx) 1.666667 ok 4 - -3 + 3 = = 0

=CN 1..4 Ok 1 - 1 + 2 = = 3 Ok 2 - 2 * 4 = = 8 Ok 3 - 5 / 3 = = (approx) 1.666667 Ok 4 - -3 + 3 = = 0

=EN Now Test::More does all of the hard work.

=CN Now Test::More Does All Of The 硬的 Work.

=EN We don't have to think about the output or the test numbering.

=CN We Don't Have To 想 About The 出产 Or The Test numbering.

=EN But what about that nasty little 4 constant in the first line?

=CN But What About That 肮脏的 Little 4 Constant In The First Line?

=EN That's fine once we're shipping the code, but while we're testing, retesting (retesting some more), and adding more tests, we don't want to keep updating that number to keep the test harness from complaining about too many or too few tests.

=CN That's Fine Once We'Re 船运 The Code, But While We'Re testing, retesting (retesting Some More), And Adding More 测试, We Don't Want To 保持 updating That Number To 保持 The Test 支配 From complaining About Too Many Or Too Few 测试.

=EN We change that to no_plan so Test::More can figure it out later.

=CN We Change That To no_plan So Test::More Can 数字 It Out 更晚.

=EN use Test::More "no_plan"; # during development

=CN Use Test::More "no_plan"; # 在 进展

=EN The output from Test::More is a bit different, and the test range moves to the end.

=CN The 出产 From Test::More Is a Bit Different, And The Test 射程 moves To The End.

=EN That's just the number of tests that we actually ran, which might not be the number we intended to run:

=CN That's Just The Number Of 测试 That We Actually ran, Which Might Not Be The Number We 预期 To Run:

=EN ok 1 - 1 + 2 = = 3 ok 2 - 2 * 4 = = 8 ok 3 - 5 / 3 = = (approx) 1.666667 ok 4 - -3 + 3 = = 0 1..4

=CN Ok 1 - 1 + 2 = = 3 Ok 2 - 2 * 4 = = 8 Ok 3 - 5 / 3 = = (approx) 1.666667 Ok 4 - -3 + 3 = = 0 1..4

=EN The test harness knows that if it doesn't see a header, it's expecting a footer.

=CN The Test 支配 知道 That If It Doesn't See a Header, It's expecting a footer.

=EN If the number of tests disagree or there's no footer (and no header), it's a broken result.

=CN If The Number Of 测试 意见不合 Or There's No footer (And No Header), It's a Broken Result.

=EN We can use this during development, but we have to remember to put the final number of tests in the script before we ship it as real code.

=CN We Can Use This 在 进展, But We Have To 记得 To Put The 最终的 Number Of 测试 In The 临时单据 Before We 船 It As Real Code.

=EN But wait: there's more (to Test::More).

=CN But 等候: There's More (To Test::More).

=EN Instead of a simple yes/no, we can ask if two values are the same.

=CN Instead Of a Simple Yes/No, We Can 问 If Two Values Are The Same.

=EN The is( ) function, as we showed earlier, compares its first argument, which is the result we got, with the second argument, which is what we expected.

=CN The Is( ) Function, As We showed Earlier, compares Its First Argument, Which Is The Result We Got, With The Second Argument, Which Is What We Expected.

=EN The optional third argument is the name we give the test, just as we did with the ok function earlier.

=CN The Optional 第三 Argument Is The Name We Give The Test, Just As We Did With The Ok Function Earlier.

=EN use Test::More 'no_plan';

=CN Use Test::More 'no_plan';

=EN is(1 + 2, 3, '1 + 2 is 3'); is(2 * 4, 8, '2 * 4 is 8');

=CN Is(1 + 2, 3, '1 + 2 Is 3'); Is(2 * 4, 8, '2 * 4 Is 8');

=EN Note that we've gotten rid of numeric equality and instead asked if "this is that."

=CN Note That We'Ve gotten 使摆脱 Of 数值 平等 And Instead 问 If "This Is That."

=EN On a successful test, this doesn't give much advantage, but on a failed test, we get much more interesting output.

=CN On a 成功的 Test, This Doesn't Give Much 优点, But On a failed Test, We Get Much More Interesting 出产.

=EN is(1 + 2, 3, '1 + 2 is 3'); is(2 * 4, 6, '2 * 4 is 6');

=CN Is(1 + 2, 3, '1 + 2 Is 3'); Is(2 * 4, 6, '2 * 4 Is 6');

=EN This script yields much more useful output that tells us what is( ) was expecting and what it actually got.

=CN This 临时单据 yields Much More Useful 出产 That 告诉 Us What Is( ) Was expecting And What It Actually Got.

=EN ok 1 - 1 + 2 is 3 not ok 2 - 2 * 4 is 6 # Failed test (1.t at line 4) # got: '8' # expected: '6' 1..2 # Looks like you failed 1 tests of 2.

=CN Ok 1 - 1 + 2 Is 3 Not Ok 2 - 2 * 4 Is 6 # Failed Test (1.t At Line 4) # Got: '8' # Expected: '6' 1..2 # Looks Like You failed 1 测试 Of 2.

=EN Of course, this is an error in the test, but note that the output told us what happened: we got an 8 when we were expecting a 6.[*] This is far better than just "something went wrong" as before.

=CN Of Course, This Is An Error In The Test, But Note That The 出产 told Us What Happened: We Got An 8 When We Were expecting a 6.[*] This Is Far Better Than Just "Something 去 错误的" As Before.

=EN There's also a corresponding isnt( ) when we want to compare for inequality rather than equality.

=CN There's Also a 相应的 isnt( ) When We Want To 比较 For inequality Rather Than 平等.

=EN [*] More precisely: we got an '8' but were expecting a '6'.

=CN [*] More 精确地: We Got An '8' But Were expecting a '6'.

=EN Did you notice that these are strings?

=CN Did You Notice That These Are Strings?

=EN The is( ) test checks for string equality.

=CN The Is( ) Test 检查 For String 平等.

=EN If we don't want that, we just build an ok( ) test instead, or try cmp_ok, coming up in a moment.

=CN If We Don't Want That, We Just Build An Ok( ) Test Instead, Or Try cmp_ok, coming Up In a Moment.

=EN What about that third test, where we allowed the value to vary within some tolerance?

=CN What About That 第三 Test, Where We Allowed The Value To 变化 Within Some 宽容?

=EN Well, we can just use the cmp_ok routine instead.[*] The first and third arguments are the operands, [] and the intervening, second argument is the comparison operator (as a string!).

=CN Well, We Can Just Use The cmp_ok Routine Instead.[*] The First And 第三 Arguments Are The operands, [] And The intervening, Second Argument Is The 比较 Operator (As a String!).

=EN [*] Although Test::Number::Delta can handle this for us.

=CN [*] Although Test::Number::Delta Can Handle This For Us.

=EN [] There's no joy for RPN fans.

=CN [] There's No 高兴 For RPN fans.

=EN my $divide = 5 / 3; cmp_ok(abs($divide - 1.666667), '<', 0.001,

=CN My $分开 = 5 / 3; cmp_ok(abs($分开 - 1.666667), '<', 0.001,

=EN If the test we give in the second argument fails between the first and third arguments, then we get a descriptive error message with both of the values and the comparison, rather than a simple pass or fail value as before.

=CN If The Test We Give In The Second Argument 失败 Between The First And 第三 Arguments, Then We Get a descriptive Error 音讯 With Both Of The Values And The 比较, Rather Than a Simple Pass Or 失败 Value As Before.

=EN How about that last test?

=CN How About That Last Test?

=EN We wanted to see if the result was a 0 or minus 0 (on the rare systems that give back a minus 0).

=CN We 想要 To See If The Result Was a 0 Or 减去 0 (On The 稀有的 系统 That Give Back a 减去 0).

=EN We can do that with the like( ) function:

=CN We Can Do That With The Like( ) Function:

=EN my $subtract = -3 + 3; like($subtract, qr/^-?0$/, '-3 + 3 = = 0');

=CN My $减去 = -3 + 3; Like($减去, qr/^-?0$/, '-3 + 3 = = 0');

=EN Here, we take the string form of the first argument and attempt to match it against the second argument.

=CN Here, We Take The String Form Of The First Argument And 尝试 To Match It 反对 The Second Argument.

=EN The second argument is typically a regular expression object (created here with qr), but we can also use a simple string, which like( ) will convert to a regular expression object.

=CN The Second Argument Is 典型的 a 正则表达式 Object (Created Here With qr), But We Can Also Use a Simple String, Which Like( ) Will Convert To a 正则表达式 Object.

=EN We can even write the string form as if it were (almost) a regular expression:

=CN We Can Even Write The String Form As If It Were (Almost) a 正则表达式:

=EN like($subtract, qr/^-?0$/, '-3 + 3 = = 0');

=CN Like($减去, qr/^-?0$/, '-3 + 3 = = 0');

=EN The string form is portable back to older Perls.[] If the match succeeds, it's a good test.

=CN The String Form Is 手提的 Back To Older Perls.[] If The Match 成功, It's a Good Test.

=EN If not, the original string and the regex are reported along with the test failure.

=CN If Not, The Original String And The 正则表达式 Are reported 沿着 With The Test 失败.

=EN We can change like to unlike if we expect the match to fail instead.

=CN We Can Change Like To 不同的 If We 盼望 The Match To 失败 Instead.

=EN [] The qr// form wasn't introduced until Perl 5.005.

=CN [] The qr// Form Wasn't Introduced Until Perl 5.005.

=EN Testing Object-Oriented Features For object-oriented modules, we want to ensure that we get back an object when we call the constructor.

=CN Testing Object-Oriented Features For Object-Oriented Modules, We Want To Ensure That We Get Back An Object When We Call The 构造函数.

=EN For this, isa_ok( ) and can_ok( ) are good interface tests:

=CN For This, isa_ok( ) And can_ok( ) Are Good Interface 测试:

=EN use Horse; my $trigger = Horse->named('Trigger'); isa_ok($trigger, 'Horse'); isa_ok($trigger, 'Animal'); can_ok($trigger, $_) for qw(eat color);

=CN Use Horse; My $扳机 = Horse->Named('Trigger'); isa_ok($扳机, 'Horse'); isa_ok($扳机, 'Animal'); can_ok($扳机, $_) For Qw(吃 颜色);

=EN These tests have default test names, so our test output looks like this:

=CN These 测试 Have Default Test Names, So Our Test 出产 Looks Like This:

=EN ok 1 - The object isa Horse ok 2 - The object isa Animal ok 3 - Horse->can('eat') ok 4 - Horse->can('color') 1..4

=CN Ok 1 - The Object isa Horse Ok 2 - The Object isa Animal Ok 3 - Horse->Can('吃') Ok 4 - Horse->Can('颜色') 1..4

=EN The output of this shows us that the unnamed Horse is not quite what we thought it was.

=CN The 出产 Of This Shows Us That The unnamed Horse Is Not Quite What We Thought It Was.

=EN ok 1 - The object isa Horse ok 2 - The object isa Horse ok 3 - Trigger's name is correct ok 4 - Mr. Ed's name is correct not ok 5 # Failed test (1.t at line 13) # got: 'an unnamed Horse' # expected: 'a generic Horse' 1..5 # Looks like you failed 1 tests of 5.

=CN Ok 1 - The Object isa Horse Ok 2 - The Object isa Horse Ok 3 - Trigger's Name Is 正确的 Ok 4 - Mr. Ed's Name Is 正确的 Not Ok 5 # Failed Test (1.t At Line 13) # Got: 'An unnamed Horse' # Expected: 'a 通用 Horse' 1..5 # Looks Like You failed 1 测试 Of 5.

=EN Look at that.

=CN Look At That.

=EN We wrote a generic Horse, but the string really is an unnamed Horse.

=CN We 写 a 通用 Horse, But The String Really Is An unnamed Horse.

=EN That's an error in our test, not in the module, so we should correct that test error and retry.

=CN That's An Error In Our Test, Not In The Module, So We Should 正确的 That Test Error And retry.

=EN Unless, of course, the module's specification actually called for 'a generic Horse.'[] You shouldn't be afraid to just write the tests and test the module.

=CN Unless, Of Course, The Module's 规格 Actually Called For 'a 通用 Horse.'[] You 应该't Be 害怕的 To Just Write The 测试 And Test The Module.

=EN If you get either one wrong, the other will generally catch it.

=CN If You Get Either One 错误的, The Other Will Generally Catch It.

=EN [] And, we'll find that the tests not only check the code, but they create the specification in code form.

=CN [] And, We'我 寻找 That The 测试 Not Only Check The Code, But They Create The 规格 In Code Form.

=EN You can even test the use with Test::More when you want to ensure that the module loads correctly:

=CN You Can Even Test The Use With Test::More When You Want To Ensure That The Module loads 正确地:

=EN my $trigger = Horse->named('Trigger'); isa_ok($trigger, 'Horse'); # .. other tests as before ..

=CN My $扳机 = Horse->Named('Trigger'); isa_ok($扳机, 'Horse'); # .. Other 测试 As Before ..

=EN The difference between doing this as a test and doing it as a simple use is that the test won't completely abort if the use fails, although many other tests are likely to fail as well.

=CN The Difference Between Doing This As a Test And Doing It As a Simple Use Is That The Test Won't 完全地 abort If The Use 失败, Although Many Other 测试 Are Likely To 失败 As Well.

=EN It's also counted as one of the tests, so we get an "ok" for free even if all it does is compile properly to help pad our success numbers for the weekly status report.

=CN It's Also 数 As One Of The 测试, So We Get An "Ok" For Free Even If All It Does Is Compile Properly To Help 垫 Our 成功 编号 For The 每周的 形势 报告.

=EN We put the use_ok inside a BEGIN block so any exported subroutines from the module are properly declared for the rest of the program, as recommended by the documentation.

=CN We Put The use_ok 里面 a BEGIN Block So Any Exported Subroutines From The Module Are Properly Declared For The 休息 Of The Program, As recommended By The 提供文件.

=EN For most object-oriented modules, this won't matter because they don't export subroutines.

=CN For Most Object-Oriented Modules, This Won't Matter Because They Don't Export Subroutines.

=EN A Testing To-Do List When we write tests before we write the code, the tests will initially fail.

=CN A Testing To-Do List When We Write 测试 Before We Write The Code, The 测试 Will 最初 失败.

=EN We might even add new features that temporarily fail while we are developing.

=CN We Might Even 增添 New 特征 That temporarily 失败 While We Are 发展中的.

=EN There are several situations where we realize a test is going to fail, but we don't want to pay attention to its failure.

=CN There Are Several 情况 Where We 认识到 a Test Is Going To 失败, But We Don't Want To 支付 注意 To Its 失败.

=EN The Test::More module realizes this and allows us to mark a test as TODO, meaning that we expect it to fail and we'll get to it later.

=CN The Test::More Module realizes This And Allows Us To 痕迹 a Test As TODO, Meaning That We 盼望 It To 失败 And We'我 Get To It 更晚.

=EN In this example, we know that we want to add the talk( ) method to our Horses class, but we haven't actually done it.

=CN In This Example, We Know That We Want To 增添 The 谈话( ) Method To Our Horses Class, But We 还't Actually Done It.

=EN We wrote the test already, since it was part of our specification.

=CN We 写 The Test Already, Since It Was Part Of Our 规格.

=EN We know the test is going to fail, and that's okay.

=CN We Know The Test Is Going To 失败, And That's Okay.

=EN Test::More won't really count it as a failure.

=CN Test::More Won't Really 计算 It As a 失败.

=EN use_ok('Horse'); my $tv_horse = Horse->named('Mr. Ed');

=CN use_ok('Horse'); My $tv_horse = Horse->Named('Mr. Ed');

=EN  # he can talk! }

=CN  # 他 Can 谈话! }

=EN is($tv_horse->name, 'Mr. Ed', 'I am Mr. Ed!');

=CN Is($tv_horse->Name, 'Mr. Ed', 'I Am Mr. Ed!');

=EN The naked block of code we labeled with TODO to mark the section of the tests that we expect to fail.

=CN The 裸体的 Block Of Code We labeled With TODO To 痕迹 The Section Of The 测试 That We 盼望 To 失败.

=EN Inside the block, we create a local version of $TODO, which holds as its value the reason we think the tests will fail.

=CN Inside The Block, We Create a Local Version Of $TODO, Which holds As Its Value The Reason We 想 The 测试 Will 失败.

=EN Test::More marks the test as a TODO test in the output, and the test harness[*] notices it and doesn't penalize us for the failure.[]

=CN Test::More 标志 The Test As a TODO Test In The 出产, And The Test 支配[*] notices It And Doesn't penalize Us For The 失败.[]

=EN [*] TODO tests require Test::Harness Version 2.0 or later, which comes with Perl 5.8, but in earlier releases, they have to be installed from CPAN.

=CN [*] TODO 测试 Require Test::Harness 版本 2.0 Or 更晚, Which 来 With Perl 5.8, But In Earlier Releases, They Have To Be 安装 From Perl综合典藏网.

=EN [] Although, if the test passes when we said it should fail, it warns us that the test unexpectedly passed.

=CN [] Although, If The Test 经过 When We Said It Should 失败, It warns Us That The Test 竟然 Passed.

=EN That might mean that the test doesn't fail when it should.

=CN That Might Mean That The Test Doesn't 失败 When It Should.

=EN ok 1 - use Horse; not ok 2 - Horse->can('talk') # TODO haven't taught Horses to talk yet # Failed (TODO) test (1.t at line 7) # Horse->can('talk') failed ok 3 - I am Mr. Ed! 1..3

=CN Ok 1 - Use Horse; Not Ok 2 - Horse->Can('谈话') # TODO 还't taught Horses To 谈话 仍然 # Failed (TODO) Test (1.t At Line 7) # Horse->Can('谈话') failed Ok 3 - I Am Mr. Ed! 1..3

=EN Skipping Tests In some cases, we want to skip tests.

=CN Skipping Tests In Some Cases, We Want To 跳过 测试.

=EN For instance, some of our features may only work for a particular version of Perl, a particular operating system, or only when optional modules are available.

=CN For 例子, Some Of Our 特征 May Only Work For a Particular Version Of Perl, a Particular Operating System, Or Only When Optional Modules Are Available.

=EN To skip tests, we do much the same thing we did for the TODO tests, but Test::More does something much different.

=CN To 跳过 测试, We Do Much The Same Thing We Did For The TODO 测试, But Test::More Does Something Much Different.

=EN In this example, we again use a naked block to create a section of code to skip, and we label it with SKIP.

=CN In This Example, We Again Use a 裸体的 Block To Create a Section Of Code To 跳过, And We 标签 It With SKIP.

=EN While testing, Test::More will not execute these tests, unlike the TODO block where it ran them anyway.

=CN While testing, Test::More Will Not Execute These 测试, 不同的 The TODO Block Where It ran Them 不管怎样.

=EN At the start of the block, we call the skip( ) function to tell it why we want to skip the tests and how many tests we want to skip.

=CN At The Start Of The Block, We Call The 跳过( ) Function To Tell It Why We Want To 跳过 The 测试 And How Many 测试 We Want To 跳过.

=EN In this example, we check if the Mac::Speech module is installed before we try to test the say_it_aloud( ) method.

=CN In This Example, We Check If The Mac::Speech Module Is 安装 Before We Try To Test The say_it_aloud( ) Method.

=EN If it isn't, the eval( ) block returns false and we execute the skip( ) function.

=CN If It Isn't, The Eval( ) Block Returns False And We Execute The 跳过( ) Function.

=EN When Test::More skips tests, it outputs special ok messages to keep the test numbering right and to tell the test harness what happened.

=CN When Test::More 翻斗车 测试, It outputs Special Ok Messages To 保持 The Test numbering Right And To Tell The Test 支配 What Happened.

=EN Later, the test harness can report how many tests we skipped.

=CN Later, The Test 支配 Can 报告 How Many 测试 We Skipped.

=EN Don't skip tests because they aren't working right.

=CN Don't 跳过 测试 Because They 还't Working Right.

=EN Use the TODO block for that.

=CN Use The TODO Block For That.

=EN We use SKIP when we want to make tests optional in certain circumstances.

=CN We Use SKIP When We Want To Make 测试 Optional In 确信的 情况下.

=EN More Complex Tests (Multiple Test Scripts) Initially, the h2xs program[*] gave us a single testing file, t/1.t.[] We can stick all our tests into this file, but it generally makes more sense to break the tests into logical groups in separate files.

=CN More Complex Tests (Multiple Test Scripts) Initially, The h2xs Program[*] 给 Us a Single testing File, t/1.t.[] We Can Stick All Our 测试 Into This File, But It Generally 使 More Sense To 打破 The 测试 Into 逻辑的 groups In Separate Files.

=EN [*] If you're using one of the other module creation tools from Chapter 16, you probably got other test files, and ones that are more complex.

=CN [*] If You'Re Using One Of The Other Module 创造 Tools From Chapter 16, You Probably Got Other Test Files, And Ones That Are More 综合的.

=EN [] As of Perl 5.8, that is.

=CN [] As Of Perl 5.8, That Is.

=EN Earlier versions create a test.pl file, which is still run from a test harness during make test, but the output isn't captured in the same way.

=CN Earlier Versions Create a test.pl File, Which Is Still Run From a Test 支配 在 Make Test, But The 出产 Isn't captured In The Same Way.

=EN The easiest way for us to add additional tests is to create t/2.t.

=CN The easiest Way For Us To 增添 Additional 测试 Is To Create t/2.t.

=EN That's itjust bump the 1 to a 2.

=CN That's itjust 碰 The 1 To a 2.

=EN We don't need to change anything in the Makefile.PL or in the test harness: the file is noticed and executed automatically.

=CN We Don't Need To Change Anything In The Makefile.PL Or In The Test 支配: The File Is Noticed And Executed Automatically.

=EN We can keep adding files until we get to 9.t, but once we add 10.t, we might notice that it gets executed between 1.t and 2.t.

=CN We Can 保持 Adding Files Until We Get To 9.t, But Once We 增添 10.t, We Might Notice That It Gets Executed Between 1.t And 2.t.

=EN Because the tests are always executed in sorted order.

=CN Because The 测试 Are Always Executed In 分类 Order.

=EN This is a good thing because it lets us ensure that the most fundamental tests are executed before the more exotic tests simply by controlling the names.

=CN This Is a Good Thing Because It Lets Us Ensure That The Most 基本的 测试 Are Executed Before The More exotic 测试 Simply By controlling The Names.

=EN Many people choose to rename the files to reflect a specific ordering and purpose by using names like 01-core.t, 02-basic.t, 03-advanced.t, 04-saving.t, and so on.

=CN Many People 选择 To rename The Files To 反射 a 特殊的 订购 And Purpose By Using Names Like 01-core.t, 02-basic.t, 03-advanced.t, 04-saving.t, And So On.

=EN The first two digits control the testing order, while the rest of the name gives a hint about the general area of testing.

=CN The First Two digits Control The testing Order, While The 休息 Of The Name Gives a 暗示 About The General Area Of testing.

=EN As we saw earlier in Chapter 16, different module creation tools do different things and create one or more default tests.

=CN As We 锯 Earlier In Chapter 16, Different Module 创造 Tools Do Different Things And Create One Or More Default 测试.

=EN By default, Test::Harness runs those tests in the same order we just described.

=CN By Default, Test::Harness 跑 Those 测试 In The Same Order We Just Described.

=EN Besides that, brian wrote Test::Manifest to get around this sort of naming scheme.

=CN Besides That, brian 写 Test::Manifest To Get Around This Sort Of Naming 计划.

=EN Instead of letting the filenames dictate the order of tests, the file t/test_manifest does.

=CN Instead Of 让 The filenames 口授 The Order Of 测试, The File t/test_manifest Does.

=EN Only the tests in that file run, and they run in the order we have them in the file.

=CN Only The 测试 In That File Run, And They Run In The Order We Have Them In The File.

=EN We name our test files after what they do rather than what order they should run.

=CN We Name Our Test Files After What They Do Rather Than What Order They Should Run.

=EN Later, when we want to insert new test files anywhere in the testing order, we just change the order in t/test_manifest.

=CN Later, When We Want To 插入 New Test Files Anywhere In The testing Order, We Just Change The Order In t/test_manifest.

=EN Exercise You can find the answer to this exercise in "Answer for Chapter 17" in the Appendix.

=CN Exercise You Can 寻找 The Answer To This 锻炼 In "Answer For Chapter 17" In The Appendix.

=EN Exercise [60 min] Write a module distribution, starting from the tests first.

=CN Exercise [60 min] Write a Module 分配, Starting From The 测试 First.

=EN Your goal is to create a module My::List::Util that exports two routines on request: sum( ) and shuffle( ).

=CN Your Goal Is To Create a Module My::List::Util That exports Two Routines On 请求: 总数( ) And 拖脚走( ).

=EN The sum( ) routine takes a list of values and returns the numeric sum.

=CN The 总数( ) Routine Takes a List Of Values And Returns The 数值 总数.

=EN The shuffle( ) routine takes a list of values and randomly shuffles the ordering, returning the list.

=CN The 拖脚走( ) Routine Takes a List Of Values And randomly shuffles The 订购, Returning The List.

=EN Start with sum( ).

=CN Start With 总数( ).

=EN Write the tests, and then add the code.

=CN Write The 测试, And Then 增添 The Code.

=EN You'll know you're done when the tests pass.

=CN You'我 Know You'Re Done When The 测试 Pass.

=EN Now include tests for shuffle, and then add the implementation for shuffle.

=CN Now Include 测试 For 拖脚走, And Then 增添 The 实行 For 拖脚走.

=EN You might peek in the perlfaq to find a shuffle( ) implementation.

=CN You Might peek In The perlfaq To 寻找 a 拖脚走( ) 实行.

=EN Be sure to update the documentation and MANIFEST file as you go along.

=CN Be Sure To Update The 提供文件 And MANIFEST File As You Go 沿着.

=EN If you can pair up with someone on this exercise, even better.

=CN If You Can 对 Up With Someone On This 锻炼, Even Better.

=EN One person writes the test for sum( ) and the implementation code for shuffle( ), and the other does the opposite.

=CN One 人 写 The Test For 总数( ) And The 实行 Code For 拖脚走( ), And The Other Does The 对立的.

=EN Swap the t/* files, and see if you can locate any errors!

=CN Swap The t/* Files, And See If You Can Locate Any Errors!

