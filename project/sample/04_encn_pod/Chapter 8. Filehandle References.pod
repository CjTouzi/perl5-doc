=EN We've seen arrays, hashes, and subroutines passed around in references, permitting a level of indirection to solve certain types of problems.

=CN We'Ve Seen Arrays, Hashes, And Subroutines Passed Around In References, permitting a Level Of indirection To 解答 确信的 Types Of 问题.

=EN We can also store filehandles in references.

=CN We Can Also 商店 Filehandles In References.

=EN Let's look at the old problems and the new solutions.

=CN Let's Look At The Old 问题 And The New solutions.

=EN The Old Way In the olden days, Perl used barewords for filehandle names.

=CN The Old Way In The olden 天, Perl Used barewords For Filehandle Names.

=EN The filehandle is another Perl data type, although people don't talk about it too much since it doesn't get its own special sigil.

=CN The Filehandle Is 另一个 Perl Data Type, Although People Don't 谈话 About It Too Much Since It Doesn't Get Its Own Special 印记.

=EN You've probably already seen a lot of code that uses these bareword filehandles . ''''''''''''''''''''''''''''''''' open LOG_FH, '>> castaways.log'

=CN You'Ve Probably Already Seen a 许多 Of Code That Uses These Bareword Filehandles . ''''''''''''''''''''''''''''''''' Open LOG_FH, '>> castaways.log'

=EN What happens if we want to pass around these filehandles so we could share them with other parts of our code, such as libraries?

=CN What Happens If We Want To Pass Around These Filehandles So We Could 份 Them With Other 部分 Of Our Code, Such As 库?

=EN You've probably seen some tricky looking code that uses a typeglob or a reference to a typeglob.

=CN You'Ve Probably Seen Some 巧妙的 看 Code That Uses a typeglob Or a Reference To a typeglob.

=EN log_message( *LOG_FH, 'The Globetrotters are stranded with us!' );

=CN log_message( *LOG_FH, 'The Globetrotters Are stranded With Us!' );

=EN log_message( *LOG_FH, 'An astronaut passes overhead' );

=CN log_message( *LOG_FH, 'An 宇宙飞行员 经过 头上的' );

=EN In the log_message( ) routine, we take the first element off of the argument list and store it in another typeglob.

=CN In The log_message( ) Routine, We Take The First Element Off Of The Argument List And 商店 It In 另一个 typeglob.

=EN Without going into too many details, a typeglob stores pointers to all the package variables of that name.

=CN Without Going Into Too Many Details, a typeglob stores pointers To All The Package Variables Of That Name.

=EN When we assign one typeglob to another, we create aliases to the same data.

=CN When We Assign One typeglob To 另一个, We Create Aliases To The Same Data.

=EN We can now access the data, including the details of the filehandle, from another name.

=CN We Can Now Access The Data, Including The Details Of The Filehandle, From 另一个 Name.

=EN Then, when we use that name as a filehandle, Perl knows to look for the filehandle portion of the typeglob.

=CN Then, When We Use That Name As a Filehandle, Perl 知道 To Look For The Filehandle 一份 Of The typeglob.

=EN We'd have a much easier time if filehandles had sigils! ''''''''''''''''''''''''' sub log_message {

=CN We'd Have a Much Easier Time If Filehandles Had sigils! ''''''''''''''''''''''''' Sub log_message {

=EN Notice the use of local there.

=CN Notice The Use Of Local There.

=EN A typeglob works with the symbol table, which means it's dealing with package variables.

=CN A typeglob Works With The Symbol Table, Which Means It's 交往 With Package Variables.

=EN Package variables can't be lexical variables, so we can't use my.

=CN Package Variables Can't Be Lexical Variables, So We Can't Use My.

=EN Since we don't want to stomp on anything else that might be named FH somewhere else in the script, we must use local to say that the name FH has a temporary value for the duration of the log_message subroutine and that when the subroutine finishes, Perl should restore any previous values to FH as if we were never there.

=CN Since We Don't Want To 踩 On Anything Else That Might Be Named FH Somewhere Else In The 临时单据, We Must Use Local To Say That The Name FH Has a temporary Value For The 期间 Of The log_message Subroutine And That When The Subroutine finishes, Perl Should Restore Any Previous Values To FH As If We Were Never There.

=EN If all of that makes you nervous and wish that none of this stuff existed, that's good.

=CN If All Of That 使 You 神经质的 And Wish That 没人 Of This 材料 existed, That's Good.

=EN Don't do this anymore!

=CN Don't Do This 了!

=EN We put it in a section called "The Old Way" because there is a much better way to do it now.

=CN We Put It In a Section Called "The Old Way" Because There Is a Much Better Way To Do It Now.

=EN Pretend this section never existed and move on to the next one.

=CN Pretend This Section Never existed And Move On To The 下一次 One.

=EN The Improved Way Starting with Perl 5.6, open can create a filehandle reference in a normal scalar variable.

=CN The Improved Way Starting With Perl 5.6, Open Can Create a Filehandle Reference In a Normal Scalar Variable.

=EN Instead of using a bareword for the filehandle name, we use a scalar variable whose value is undef.

=CN Instead Of Using a Bareword For The Filehandle Name, We Use a Scalar Variable Whose Value Is Undef.

=EN my $log_fh; open $log_fh, '>> castaways.log'

=CN My $log_fh; Open $log_fh, '>> castaways.log'

=EN If the scalar already has a value, this doesn't work because Perl won't stomp on our data.

=CN If The Scalar Already Has a Value, This Doesn't Work Because Perl Won't 踩 On Our Data.

=EN my $log_fh = 5; open $log_fh, '>> castaways.log'

=CN My $log_fh = 5; Open $log_fh, '>> castaways.log'

=EN  # doesn't work

=CN  # Doesn't Work

=EN However, the Perl idiom is to do everything in one step.

=CN However, The Perl 习语 Is To Do Everything In One 脚步.

=EN We can declare the variable right in the open statement.

=CN We Can Declare The Variable Right In The Open Statement.

=EN It looks funny at first, but after doing it a couple (okay, maybe several) times, you'll get used to it and like it better. ''''''' open my $log_fh, '>> castaways.log'

=CN It Looks Funny At First, But After Doing It a 一对 (Okay, 或许 Several) Times, You'我 Get Used To It And Like It Better. ''''''' Open My $log_fh, '>> castaways.log'

=EN When we want to print to the filehandle, we use the scalar variable instead of a bareword.

=CN When We Want To Print To The Filehandle, We Use The Scalar Variable Instead Of a Bareword.

=EN Notice that there is still no comma after the filehandle.

=CN Notice That There Is Still No 逗号 After The Filehandle.

=EN print $log_fh "We have no bananas today!\n";

=CN Print $log_fh "We Have No bananas 今天现在!\n";

=EN That syntax might look funny to you, though, and even if it doesn't look funny to you, it might look odd to the person who has to read your code later.

=CN That Syntax Might Look Funny To You, Though, And Even If It Doesn't Look Funny To You, It Might Look 古怪的 To The 人 Who Has To Read Your Code 更晚.

=EN In Perl Best Practices, Damian Conway recommends putting braces around the filehandle portion to explicitly state what you intend.

=CN In Perl Best Practices, Damian Conway 推荐 Putting 牙套 Around The Filehandle 一份 To 清晰地 State What You 打算.

=EN This syntax makes it look more like grep and map with inline blocks. ''''''''''''''''''''''''''''''''' print {$log_fh} "We have no bananas today!\n";

=CN This Syntax 使 It Look More Like Grep And Map With inline Blocks. ''''''''''''''''''''''''''''''''' Print {$log_fh} "We Have No bananas 今天现在!\n";

=EN Now we treat the filehandle reference just like any other scalar.

=CN Now We treat The Filehandle Reference Just Like Any Other Scalar.

=EN We don't have to do any tricky magic to make it work. ''''''''''''''''''''''''''''''''' log_message( $log_fh, 'My name is Mr. Ed' );

=CN We Don't Have To Do Any 巧妙的 Magic To Make It Work. ''''''''''''''''''''''''''''''''' log_message( $log_fh, 'My Name Is Mr. Ed' );

=EN sub log_message {

=CN Sub log_message {

=EN We can also create filehandle references from which we can read.

=CN We Can Also Create Filehandle References From Which We Can Read.

=EN We simply put the right thing in the second argument.

=CN We Simply Put The Right Thing In The Second Argument.

=EN open my $fh, "castaways.log"

=CN Open My $Fh, "castaways.log"

=EN Now we use the scalar variable in place of the bareword in the line input operator.

=CN Now We Use The Scalar Variable In Place Of The Bareword In The Line Input Operator.

=EN Before, we would have seen the bareword between the angle brackets:

=CN Before, We Would Have Seen The Bareword Between The 角 支架:

=EN while( <LOG_FH> ) { ... }

=CN While( <LOG_FH> ) { ... }

=EN And now we see the scalar variable in its place.

=CN And Now We See The Scalar Variable In Its Place.

=EN while( <$log_fh> ) { ... }

=CN While( <$log_fh> ) { ... }

=EN In general, where we've seen the bareword filehandle we can substitute the scalar variable filehandle reference.

=CN In General, Where We'Ve Seen The Bareword Filehandle We Can 代替 The Scalar Variable Filehandle Reference.

=EN In any of these forms, when the scalar variable goes out of scope (or we assign another value to it), Perl closes the file.

=CN In Any Of These 形式, When The Scalar Variable 去 Out Of Scope (Or We Assign 另一个 Value To It), Perl closes The File.

=EN We don't have to explicitly close the file ourselves.

=CN We Don't Have To 清晰地 Close The File 我们自己.

=EN The Even Better Way So far, our examples have shown the two-argument form of open, but that actually has a catch: the open mode and the filename both live in the second argument.

=CN The Even Better Way So Far, Our Examples Have shown The Two-Argument Form Of Open, But That Actually Has a Catch: The Open 方式 And The 文件名 Both 居住生存 In The Second Argument.

=EN That means that we have to store two different things in one string, and we have to trust Perl to be able to figure it out.

=CN That Means That We Have To 商店 Two Different Things In One String, And We Have To 委托 Perl To Be Able To 数字 It Out.

=EN To get around that, we break the second argument into two separate arguments.

=CN To Get Around That, We 打破 The Second Argument Into Two Separate Arguments.

=EN open my $log_fh, '>>', 'castaways.log'

=CN Open My $log_fh, '>>', 'castaways.log'

=EN This three-argument form has the added advantage of access to the Perl IO filters.

=CN This Three-Argument Form Has The added 优点 Of Access To The Perl IO Filters.

=EN We won't go into too much detail here.[*] The open function's entry in perlfunc is over 400 lines, even though it has its own perldoc tutorial, perlopentut.

=CN We Won't Go Into Too Much 细节 Here.[*] The Open Function's Entry In perlfunc Is 在 400 Lines, Even Though It Has Its Own perldoc 个别指导, perlopentut.

=EN IO::Handle Behind the scenes, Perl is really using the IO::Handle module to work this magic, so our filehandle scalar is really an object.[*] The IO::Handle package is a base class for input-output things, so it handles a lot more than just files.

=CN IO::Handle Behind The scenes, Perl Is Really Using The IO::Handle Module To Work This Magic, So Our Filehandle Scalar Is Really An Object.[*] The IO::Handle Package Is a Base Class For Input-出产 Things, So It 处理 a 许多 More Than Just Files.

=EN [*] Have you ever wondered why there is no comma after the filehandle portion of the print?

=CN [*] Have You 曾经 wondered Why There Is No 逗号 After The Filehandle 一份 Of The Print?

=EN It iss really the indirect object notation (which we have not mentioned yet, unless you have read the whole book before you read the footnotes, like we told you to do in the preface!).

=CN It iss Really The Indirect Object 符号 (Which We Have Not Mentioned 仍然, Unless You Have Read The Whole 书 Before You Read The footnotes, Like We told You To Do In The 序言!).

=EN Unless you are creating new IO modules, you probably shouldn't use IO::Handle directly.

=CN Unless You Are Creating New IO Modules, You Probably 应该't Use IO::Handle 直接地.

=EN Instead, use some of the handy modules built on top of it.

=CN Instead, Use Some Of The 方便的 Modules Built On 顶 Of It.

=EN We haven't told you about object-oriented programming (OOP) yet (it's in Chapter 11, so we almost have), but in this case, you just have to follow the example in its documentation.

=CN We 还't told You About Object-Oriented Programming (OOP) 仍然 (It's In Chapter 11, So We Almost Have), But In This Case, You Just Have To 跟随 The Example In Its 提供文件.

=EN Some of these modules do some of the same things that we can already do with Perl's built-in open (depending on which version of Perl we have), but they can be handy when we want to decide as late as possible which module should handle input or output.

=CN Some Of These Modules Do Some Of The Same Things That We Can Already Do With Perl's Built-In Open (Depending On Which Version Of Perl We Have), But They Can Be 方便的 When We Want To Decide As 迟到的 As Possible Which Module Should Handle Input Or 出产.

=EN Instead of using the built-in open, we use the module interface.

=CN Instead Of Using The Built-In Open, We Use The Module Interface.

=EN To switch the behavior, we simply change the module name.

=CN To Switch The Behavior, We Simply Change The Module Name.

=EN Since we've set up our code to use a module interface, it's not that much work to switch modules.

=CN Since We'Ve Set Up Our Code To Use a Module Interface, It's Not That Much Work To Switch Modules.

=EN IO::File The IO::File module subclasses IO::Handle to work with files.

=CN IO::File The IO::File Module 子类 IO::Handle To Work With Files.

=EN It comes with the standard Perl distribution, so you should already have it.

=CN It 来 With The Standard Perl 分配, So You Should Already Have It.

=EN There are a variety of ways to create an IO::File object.

=CN There Are a 多样（性） Of Ways To Create An IO::File Object.

=EN We can create the filehandle reference with the one-argument form of the constructor.

=CN We Can Create The Filehandle Reference With The One-Argument Form Of The 构造函数.

=EN We check the result of the operation by looking for a defined value in the filehandle reference variable.

=CN We Check The Result Of The Operation By 看 For a Defined Value In The Filehandle Reference Variable.

=EN use IO::File;

=CN Use IO::File;

=EN my $fh = IO::File->new( '> castaways.log' )

=CN My $Fh = IO::File->New( '> castaways.log' )

=EN If you do not like that (for the same reasons as regular open), use one of the other calling conventions.

=CN If You Do Not Like That (For The Same Reasons As Regular Open), Use One Of The Other Calling 公约.

=EN The optional second argument is the filehandle mode.[]

=CN The Optional Second Argument Is The Filehandle 方式.[]

=EN [] These are the ANSI C fopen mode strings.

=CN [] These Are The ANSI C Fopen 方式 Strings.

=EN You can also use these with the built-in open.

=CN You Can Also Use These With The Built-In Open.

=EN Indeed, IO::File uses the built-in open behind the scenes.

=CN Indeed, IO::File Uses The Built-In Open 在 The scenes.

=EN my $read_fh = IO::File->new( 'castaways.log', 'r' ); my $write_fh = IO::File->new( 'castaways.log', 'w' );

=CN My $read_fh = IO::File->New( 'castaways.log', 'r' ); My $write_fh = IO::File->New( 'castaways.log', 'w' );

=EN Using a bit mask as the mode allows for more granular control.

=CN Using a Bit 假面具 As The 方式 Allows For More granular Control.

=EN The IO::File module supplies the constants.

=CN The IO::File Module Supplies The Constants.

=EN my $append_fh = IO::File->new( 'castaways.log', O_WRONLY|O_APPEND );

=CN My $append_fh = IO::File->New( 'castaways.log', O_WRONLY|O_APPEND );

=EN Besides opening named files, we might want to open an anonymous temporary file.

=CN Besides 开始 Named Files, We Might Want To Open An Anonymous temporary File.

=EN On systems that support this sort of thing, we simply create the new object to get a read-write filehandle.

=CN On 系统 That Support This Sort Of Thing, We Simply Create The New Object To Get a Read-Write Filehandle.

=EN my $temp_fh = IO::File->new_tmpfile;

=CN My $temp_fh = IO::File->new_tmpfile;

=EN As before, Perl closes these files when the scalar variable goes out of scope, but if that is not enough, we do it ourselves explicitly.

=CN As Before, Perl closes These Files When The Scalar Variable 去 Out Of Scope, But If That Is Not Enough, We Do It 我们自己 清晰地.

=EN $temp_fh->close;

=CN $temp_fh->Close;

=EN undef $append_fh;

=CN Undef $append_fh;

=EN If we don't put our IO::File object in a simple scalar variable, some operations require a slightly modified syntax to work.

=CN If We Don't Put Our IO::File Object In a Simple Scalar Variable, Some 操作 Require a 轻微地 Modified Syntax To Work.

=EN For example, we want to copy every file matched by the glob pattern of *.input to a corresponding file whose suffix is .output, but do it in parallel.

=CN For Example, We Want To Copy Every File matched By The Glob 模式 Of *.Input To a 相应的 File Whose 后缀 Is .出产, But Do It In 平行的.

=EN First, we open all the files, both inputs and outputs:'

=CN First, We Open All The Files, Both inputs And outputs:'

=EN my @handlepairs;

=CN My @handlepairs;

=EN foreach my $file ( glob( '*.input' ) ) {

=CN Foreach My $File ( Glob( '*.Input' ) ) {

=EN Now we have an array of references to arrays, each element of which is an IO::File object.

=CN Now We Have An Array Of References To Arrays, Each Element Of Which Is An IO::File Object.

=EN Now, let us pump the data from the input files to the output files.

=CN Now, Let Us 泵 The Data From The Input Files To The 出产 Files.

=EN while (@handlepairs) {

=CN While (@handlepairs) {

=EN As long as we have pairs, we keep passing the list through the grep structure:

=CN As Long As We Have 双, We 保持 Passing The List 通过 The Grep Structure:

=EN @handlepairs = grep { CONDITION } @handlepairs;

=CN @handlepairs = Grep { CONDITION } @handlepairs;

=EN On each pass, only the handle pairs that evaluate as true in the grep CONDITION survive.

=CN On Each Pass, Only The Handle 双 That 估价 As True In The Grep CONDITION 幸免于.

=EN Inside, we take the first element of each pair and try to read from it.

=CN Inside, We Take The First Element Of Each 对 And Try To Read From It.

=EN If that's successful, write that line to the second element of the pair (the corresponding output handle).

=CN If That's 成功的, Write That Line To The Second Element Of The 对 (The 相应的 出产 Handle).

=EN If the print is successful, it returns true, which lets grep know that we want to keep that pair.

=CN If The Print Is 成功的, It Returns True, Which Lets Grep Know That We Want To 保持 That 对.

=EN If either the print fails or the getline returns undef, the grep sees the false value as an indication to discard that pair.

=CN If Either The Print 失败 Or The getline Returns Undef, The Grep 看到 The False Value As An 表示 To 丢弃 That 对.

=EN Discarding the pair automatically closes both filehandles.

=CN Discarding The 对 Automatically closes Both Filehandles.

=EN Note that we can't use the more traditional filehandle read or filehandle print operations, because the reading and writing filehandles were not in a simple scalar variable.

=CN Note That We Can't Use The More 传统的 Filehandle Read Or Filehandle Print 操作, Because The 读书 And 写作 Filehandles Were Not In a Simple Scalar Variable.

=EN We can rewrite that loop to see if copying the handles is easier:

=CN We Can 重写 That Loop To See If 复制 The 处理 Is Easier:

=EN This scenario is arguably better.

=CN This scenario Is arguably Better.

=EN Most of the time, simply copying the complexly referenced value into a simple scalar is easier on the eyes.

=CN Most Of The Time, Simply 复制 The complexly 参考 Value Into a Simple Scalar Is Easier On The eyes.

=EN In fact, another way to write that loop is to get rid of the ugly if structure:

=CN In Fact, 另一个 Way To Write That Loop Is To Get 使摆脱 Of The 丑恶的 If Structure:

=EN As long as someone understands that and is a partial evaluator and that print returns true when everything is okay, this is a fine replacement.

=CN As Long As Someone understands That And Is a 局部的 evaluator And That Print Returns True When Everything Is Okay, This Is a Fine Replacement.

=EN Remember the Perl motto: "There's more than one way to do it" (although not all of them are equally nice or legitimate).

=CN Remember The Perl 座右铭: "There's More Than One Way To Do It" (Although Not All Of Them Are 相等地 Nice Or 合法的).

=EN IO::Scalar Sometimes we don't want to print to a file and would rather build up the output in a string.

=CN IO::Scalar Sometimes We Don't Want To Print To a File And Would Rather Build Up The 出产 In a String.

=EN Some module interfaces don't give us that option, so we have to make it look like we are printing to a file by using a filehandle.

=CN Some Module 接口 Don't Give Us That 选择, So We Have To Make It Look Like We Are 印刷 To a File By Using a Filehandle.

=EN We might also want to build up our content before we write it to a file so we can encrypt it, compress it, or send it as email directly from your program.

=CN We Might Also Want To Build Up Our 含量 Before We Write It To a File So We Can encrypt It, 压缩 It, Or 派遣 It As 電子郵件 直接地 From Your Program.

=EN The IO::Scalar module uses the magic of tie behind the scenes to give us a filehandle reference that appends to a scalar.

=CN The IO::Scalar Module Uses The Magic Of tie（绑定操作符）(绑定操作符) 在 The scenes To Give Us a Filehandle Reference That appends To a Scalar.

=EN This module doesn't come with the standard Perl distribution, so you'll have to install it yourself most likely.

=CN This Module Doesn't 来到 With The Standard Perl 分配, So You'我 Have To 安装 It 你（们）自己 Most Likely.

=EN use IO::Scalar;

=CN Use IO::Scalar;

=EN my $string_log = ''; my $scalar_fh = IO::Scalar->new( \$string_log );

=CN My $string_log = ''; My $scalar_fh = IO::Scalar->New( \$string_log );

=EN print $scalar_fh "The Howells' private beach club is closed\n";

=CN Print $scalar_fh "The Howells' Private 海滩 俱乐部 Is 关闭的\n";

=EN Now our log message ends up in the scalar variable $string_log instead of a file.

=CN Now Our 原木 音讯 Ends Up In The Scalar Variable $string_log Instead Of a File.

=EN What if we want to read from our logfile, though?

=CN What If We Want To Read From Our logfile, Though?

=EN We do the same thing.

=CN We Do The Same Thing.

=EN In this example, we create $scalar_fh just as we did before, then read from it with the line input operator.

=CN In This Example, We Create $scalar_fh Just As We Did Before, Then Read From It With The Line Input Operator.

=EN In our while loop, we'll extract the log messages that contain Gilligan (which is probably most of them, since he's always part of the mess):

=CN In Our While Loop, We'我 取出 The 原木 Messages That Contain Gilligan (Which Is Probably Most Of Them, Since 他's Always Part Of The 肮脏):

=EN while( <$scalar_fh> ) {

=CN While( <$scalar_fh> ) {

=EN As of Perl version 5.8, we can do this directly in Perl without using IO::Scalar.

=CN As Of Perl Version 5.8, We Can Do This 直接地 In Perl Without Using IO::Scalar.

=EN open( my $fh, '>>', \$string_log )

=CN Open( My $Fh, '>>', \$string_log )

=EN IO::Tee What if we want to send output to more than one place at a time?

=CN IO::Tee What If We Want To 派遣 出产 To More Than One Place At a Time?

=EN What if we want to send it to a file and save it in a string at the same time?

=CN What If We Want To 派遣 It To a File And Save It In a String At The Same Time?

=EN Using what we know already, we had have to do something like this:

=CN Using What We Know Already, We Had Have To Do Something Like This:

=EN my $string = '';

=CN My $String = '';

=EN my $log_message = "The Minnow is taking on water!\n" print $log_fh $log_message; print $scalar_fh $log_message;

=CN My $log_message = "The Minnow Is Taking On 水!\n" Print $log_fh $log_message; Print $scalar_fh $log_message;

=EN Of course, we could shorten that a bit so we only have one print statement.

=CN Of Course, We Could 缩短 That a Bit So We Only Have One Print Statement.

=EN We use the foreach control structure to iterate through the filehandle references, store each in $fh in turn, and print to each one.

=CN We Use The Foreach Control Structure To iterate 通过 The Filehandle References, 商店 Each In $Fh In 转向, And Print To Each One.

=EN foreach my $fh ( $log_fh, $scalar_fh ) {

=CN Foreach My $Fh ( $log_fh, $scalar_fh ) {

=EN That's still a bit too much work.

=CN That's Still a Bit Too Much Work.

=EN In the foreach, we had to decide which filehandles to include.

=CN In The Foreach, We Had To Decide Which Filehandles To Include.

=EN What if we could just define a group of filehandles that answered to the same name?

=CN What If We Could Just Define a Group Of Filehandles That answered To The Same Name?

=EN Well, that's what IO::Tee does for us.

=CN Well, That's What IO::Tee Does For Us.

=EN Imagine it like a tee connector on a bilge output pipe; when the water gets to the tee, it can flow it two different directions at the same time.

=CN Imagine It Like a tee connector On a bilge 出产 Pipe; When The 水 Gets To The tee, It Can 流动 It Two Different 方向 At The Same Time.

=EN When our output gets to IO::Tee, it can go to two (or more) different channels at the same time.

=CN When Our 出产 Gets To IO::Tee, It Can Go To Two (Or More) Different channels At The Same Time.

=EN That is, IO::Tee multiplexes output.

=CN That Is, IO::Tee multiplexes 出产.

=EN In this example, the castaways log message goes to both the logfile and the scalar variable.

=CN In This Example, The castaways 原木 音讯 去 To Both The logfile And The Scalar Variable.

=EN use IO::Tee;

=CN Use IO::Tee;

=EN $tee_fh = IO::Tee->new( $log_fh, $scalar_fh );

=CN $tee_fh = IO::Tee->New( $log_fh, $scalar_fh );

=EN print $tee_fh "The radio works in the middle of the ocean!\n";

=CN Print $tee_fh "The 无线电 Works In The 当中 Of The 海洋!\n";

=EN That's not all, though.

=CN That's Not All, Though.

=EN If the first argument to IO::Tee is an input filehandle (the succeeding arguments must be output filehandles), we can use the same teed filehandle to read from input and write to the output.

=CN If The First Argument To IO::Tee Is An Input Filehandle (The succeeding Arguments Must Be 出产 Filehandles), We Can Use The Same teed Filehandle To Read From Input And Write To The 出产.

=EN The source and destination channels are different, but we get to treat them as a single filehandle.'

=CN The Source And 终点 channels Are Different, But We Get To treat Them As a Single Filehandle.'

=EN $tee_fh = IO::Tee->new( $read_fh, $log_fh, $scalar_fh );

=CN $tee_fh = IO::Tee->New( $read_fh, $log_fh, $scalar_fh );

=EN # reads from $read_fh my $message = <$tee_fh>;

=CN # Reads From $read_fh My $音讯 = <$tee_fh>;

=EN # prints to $log_fh and $scalar_fh print $tee_fh $message;

=CN # Prints To $log_fh And $scalar_fh Print $tee_fh $音讯;

=EN The $read_fh doesn't have to be connected to a file, either.

=CN The $read_fh Doesn't Have To Be connected To a File, Either.

=EN It might also be connected to a socket, a scalar variable, an external command's output, [*] or anything else we can dream up.

=CN It Might Also Be connected To a socket, a Scalar Variable, An External 命令's 出产, [*] Or Anything Else We Can 梦 Up.

=EN Directory Handle References In the same way that we can create references to filehandles, we can create directory handle references.

=CN Directory Handle References In The Same Way That We Can Create References To Filehandles, We Can Create Directory Handle References.

=EN opendir my $dh, '.' or die "Could not open directory: $!";

=CN Opendir My $dh, '.' Or Die "Could Not Open Directory: $!";

=EN foreach my $file ( readdir( $dh ) ) {

=CN Foreach My $File ( Readdir( $dh ) ) {

=EN The directory handle reference obeys the same rules we laid out before.

=CN The Directory Handle Reference obeys The Same 规则 We 铺设 Out Before.

=EN This only works if the scalar variable does not already have a value, and the handle automatically closes when the variable goes out of scope or we assign it a new value.

=CN This Only Works If The Scalar Variable Does Not Already Have a Value, And The Handle Automatically closes When The Variable 去 Out Of Scope Or We Assign It a New Value.

=EN IO::Dir We can use object-oriented interfaces for directory handles too.

=CN IO::Dir We Can Use Object-Oriented 接口 For Directory 处理 Too.

=EN The IO::Dir module has been part of the standard Perl distribution since 5.6.

=CN The IO::Dir Module Has Been Part Of The Standard Perl 分配 Since 5.6.

=EN It doesn't add interesting new features but wraps the Perl built-in functions.[]'

=CN It Doesn't 增添 Interesting New 特征 But wraps The Perl Built-In Functions.[]'

=EN [] For each IO::Dir method name, append "dir" and look at the documentation in perlfunc.

=CN [] For Each IO::Dir Method Name, append "dir" And Look At The 提供文件 In perlfunc.

=EN use IO::Dir;

=CN Use IO::Dir;

=EN my $dir_fh = IO::Dir->new( '.' ) || die "Could not open dirhandle! $!\n";

=CN My $dir_fh = IO::Dir->New( '.' ) || Die "Could Not Open dirhandle! $!\n";

=EN while( defined( my $file = $dir_fh->read ) ) {

=CN While( Defined( My $File = $dir_fh->Read ) ) {

=EN We don't have to create a new directory handle if we decide we want to go through the list again (perhaps later in the program).

=CN We Don't Have To Create a New Directory Handle If We Decide We Want To Go 通过 The List Again (也许 更晚 In The Program).

=EN We can rewind the directory handle to start over:

=CN We Can rewind The Directory Handle To Start 在:

=EN # time passes $dir_fh->rewind;

=CN # Time 经过 $dir_fh->rewind;

=EN Exercises You can find the answers to these exercises in "Answers for Chapter 8" in the Appendix.

=CN Exercises You Can 寻找 The answers To These exercises In "Answers For Chapter 8" In The Appendix.

=EN Exercise 1 [20 min] Write a program that prints the date and the day of the week, but allow the user to choose to send the output either to a file, a scalar, or both at the same time.

=CN Exercise 1 [20 min] Write a Program That Prints The Date And The 一天 Of The 星期, But Allow The User To 选择 To 派遣 The 出产 Either To a File, a Scalar, Or Both At The Same Time.

=EN No matter which output channels the user selects, send the output with a single print statement.

=CN No Matter Which 出产 channels The User 选择, 派遣 The 出产 With a Single Print Statement.

=EN If the user chooses to send the output to a scalar, at the end of the program print the scalar's value to standard output.

=CN If The User chooses To 派遣 The 出产 To a Scalar, At The End Of The Program Print The Scalar's Value To Standard 出产.

=EN Exercise 2 [30 min] The Professor has to read a logfile that looks like:

=CN Exercise 2 [30 min] The Professor Has To Read a logfile That Looks Like:

=EN Gilligan: 1 coconut Skipper: 3 coconuts Gilligan: 1 banana Ginger: 2 papayas Professor: 3 coconuts MaryAnn: 2 papayas ...

=CN Gilligan: 1 coconut Skipper: 3 coconuts Gilligan: 1 香蕉 Ginger: 2 papayas Professor: 3 coconuts MaryAnn: 2 papayas ...

=EN He wants to write a series of files, called gilligan.info, maryann.info, and so on.

=CN He 要 To Write a 系列 Of Files, Called gilligan.info, maryann.info, And So On.

=EN Each file should contain all the lines that begin with that name.

=CN Each File Should Contain All The Lines That 开始 With That Name.

=EN (Names are always delimited by the trailing colon.)

=CN (Names Are Always delimited By The 落后 结肠.)

=EN At the end, gilligan.info should start with:

=CN At The End, gilligan.info Should Start With:

=EN Gilligan: 1 coconut Gilligan: 1 banana

=CN Gilligan: 1 coconut Gilligan: 1 香蕉

=EN Now the logfile is large, and the coconut-powered computer is not very fast, so he wants to process the input file in one pass and write all output files in parallel.

=CN Now The logfile Is Large, And The coconut-powered 计算机 Is Not Very 快的, So 他 要 To 程序 The Input File In One Pass And Write All 出产 Files In 平行的.

=EN How does he do it?

=CN How Does 他 Do It?

=EN Hint: use a hash, keyed by the castaway name, holding IO::File objects for each output file.

=CN Hint: Use a Hash, keyed By The castaway Name, 支持 IO::File Objects For Each 出产 File.

=EN Create them as necessary.

=CN Create Them As 必要的.

