=EN Exporter In Chapter 3, we showed you how to use modules, some of which pulled functions into the current namespace.

=CN Exporter In Chapter 3, We showed You How To Use Modules, Some Of Which 拉 Functions Into The Current Namespace.

=EN Now we're going to show you how to get your own modules to do that.

=CN Now We'Re Going To Show You How To Get Your Own Modules To Do That.

=EN What use Is Doing So, just what does use do?

=CN What Use Is Doing So, Just What Does Use Do?

=EN How does the import list come into action?

=CN How Does The Import List 来到 Into 行为?

=EN Perl interprets the use list as a particular form of BEGIN block wrapped around a require and a method call.

=CN Perl interprets The Use List As a Particular Form Of BEGIN Block wrapped Around a Require And a Method Call.

=EN For example, the following two operations are equivalent:

=CN For Example, The Following Two 操作 Are Equivalent:

=EN use Island::Plotting::Maps qw( load_map scale_map draw_map );

=CN Use Island::Plotting::Maps Qw( load_map scale_map draw_map );

=EN Let's break this code down, piece by piece.

=CN Let's 打破 This Code 向下, 件 By 件.

=EN First, the require is a package-name require, rather than the string-expression require from Chapter 10.

=CN First, The Require Is a Package-Name Require, Rather Than The String-Expression Require From Chapter 10.

=EN The colons are turned into the native directory separator (such as / for Unix-like systems), and the name is suffixed with .pm (for "Perl module").

=CN The 冒号 Are 转 Into The Native Directory Separator (Such As / For Unix-Like 系统), And The Name Is suffixed With .Pm (For "Perl Module").

=EN For this example on a Unix-like system, we end up with:

=CN For This Example On a Unix-Like System, We End Up With:

=EN require "Island/Plotting/Maps.pm";

=CN Require "Island/Plotting/Maps.pm";

=EN Recalling the operation of require from earlier, this means Perl looks in the current value of @INC, checking through each directory for a subdirectory named Island that contains a further subdirectory named Plotting that contains the file named Maps.pm.[*] If Perl doesn't find an appropriate file after looking at all of @INC, the program dies.[] Otherwise, the first file found is read and evaluated.

=CN Recalling The Operation Of Require From Earlier, This Means Perl Looks In The Current Value Of @INC, Checking 通过 Each Directory For a 子目录 Named Island That 包含 a Further 子目录 Named Plotting That 包含 The File Named Maps.pm.[*] If Perl Doesn't 寻找 An 恰当的 File After 看 At All Of @INC, The Program Dies.[] Otherwise, The First File Found Is Read And 评估.

=EN As always with require, the last expression evaluated must be true (or the program dies), [*] and once Perl has read a file, it will not reread if requested again.

=CN As Always With Require, The Last Expression 评估 Must Be True (Or The Program Dies), [*] And Once Perl Has Read a File, It Will Not reread If Requested Again.

=EN In the module interface, we expect the require'd file to define subroutines in the same-named package, not the caller's package.

=CN In The Module Interface, We 盼望 The Require'd File To Define Subroutines In The Same-Named Package, Not The Caller's Package.

=EN So, for example, a portion of the File::Basename file might look something like this, if we took out all the good stuff:

=CN So, For Example, a 一份 Of The File::Basename File Might Look Something Like This, If We took Out All The Good 材料:

=EN [*] The .pm portion is defined by the interface and can't be changed.

=CN [*] The .Pm 一份 Is Defined By The Interface And Can't Be 改变.

=EN Thus, all module filenames must end in dot-p-m.

=CN Thus, All Module filenames Must End In 点-m-m.

=EN [] Trappable with an eval, of course.

=CN [] Trappable With An Eval, Of Course.

=EN [*] Again, trappable with eval.

=CN [*] Again, trappable With Eval.

=EN package File::Basename; sub dirname { ... } sub basename { ... } sub fileparse { ... } 1;

=CN Package File::Basename; Sub dirname { ... } Sub basename { ... } Sub fileparse { ... } 1;

=EN These three subroutines are then defined in the File::Basename package, not the package in which our use occurs.

=CN These Three Subroutines Are Then Defined In The File::Basename Package, Not The Package In Which Our Use Occurs.

=EN A require'd file must return a true value, and it's traditional to use 1; as the last line of a module's code.

=CN A Require'd File Must Return a True Value, And It's 传统的 To Use 1; As The Last Line Of a Module's Code.

=EN How do these subroutines get from the module's package into the user's package?

=CN How Do These Subroutines Get From The Module's Package Into The User's Package?

=EN That's the second step inside the BEGIN block.

=CN That's The Second 脚步 里面 The BEGIN Block.

=EN Perl automatically calls a routine called import in the module's package, passing along the entire import list.

=CN Perl Automatically Calls a Routine Called Import In The Module's Package, Passing 沿着 The 完全的 Import List.

=EN Typically, this routine aliases some of the names from the imported namespace to the importing namespace.

=CN Typically, This Routine Aliases Some Of The Names From The Imported Namespace To The Importing Namespace.

=EN The module author is responsible for providing an appropriate import routine.

=CN The Module 作者 Is 负责的 For 提供 An 恰当的 Import Routine.

=EN It's easier than it sounds, as discussed later in this chapter.

=CN It's Easier Than It 听起来, As 讨论 更晚 In This 章.

=EN Finally, the whole thing is wrapped in a BEGIN block.

=CN Finally, The Whole Thing Is wrapped In a BEGIN Block.

=EN This means that the use operation happens at compile time, rather than runtime, and indeed it does.

=CN This Means That The Use Operation Happens At Compile Time, Rather Than Runtime, And 的确 It Does.

=EN Thus, subroutines are associated with those defined in the module, prototypes are properly defined, and so on.

=CN Thus, Subroutines Are Associated With Those Defined In The Module, 原型 Are Properly Defined, And So On.

=EN Importing with Exporter In Chapter 3, we skipped over that "and now magic happens" part where the import routine (defined by the module author) is supposed to take File::Basename::fileparse and somehow alias it into the caller's package so it's callable as fileparse.

=CN Importing With Exporter In Chapter 3, We Skipped 在 That "And Now Magic Happens" Part Where The Import Routine (Defined By The Module 作者) Is 应该 To Take File::Basename::fileparse And 以某种方式 Alias It Into The Caller's Package So It's 提前赎回的 As fileparse.

=EN Perl provides a lot of introspection capabilities.

=CN Perl Provides a 许多 Of 内省 capabilitie(绑定操作符)s.

=EN Specifically, we can look at the symbol table (where all subroutines and many variables are named), see what is defined, and alter those definitions.

=CN Specifically, We Can Look At The Symbol Table (Where All Subroutines And Many Variables Are Named), See What Is Defined, And 改变 Those 定义.

=EN You saw a bit of that back in the AUTOLOAD mechanism earlier in Chapter 14.

=CN You 锯 a Bit Of That Back In The AUTOLOAD Mechanism Earlier In Chapter 14.

=EN In fact, as the author of File::Basename, if we simply want to force filename, basename, and fileparse from the current package into the main package, we can write import like this:

=CN In Fact, As The 作者 Of File::Basename, If We Simply Want To Force 文件名, basename, And fileparse From The Current Package Into The Main Package, We Can Write Import Like This:

=EN sub import {

=CN Sub Import {

=EN Boy, is that cryptic!

=CN Boy, Is That cryptic!

=EN And limited.

=CN And Limited.

=EN What if the caller didn't want fileparse?

=CN What If The Caller Didn't Want fileparse?

=EN What if the caller invoked use in a package other than main?

=CN What If The Caller invoked Use In a Package Other Than Main?

=EN Thankfully, there's a standard import that's available in the Exporter module.

=CN Thankfully, There's a Standard Import That's Available In The Exporter Module.

=EN As the module author, all we do is add:

=CN As The Module 作者, All We Do Is 增添:

=EN use base qw(Exporter);

=CN Use Base qw(Exporter);

=EN Now the import call to the package will inherit upward to the Exporter class, providing an import routine that knows how to take a list of subroutines[*] and export them to the caller's package.

=CN Now The Import Call To The Package Will 继承 向上（的） To The Exporter Class, 提供 An Import Routine That 知道 How To Take a List Of Subroutines[*] And Export Them To The Caller's Package.

=EN [*] And variables, although far less common, and arguably the wrong thing to do.

=CN [*] And Variables, Although Far 更少的 Common, And arguably The 错误的 Thing To Do.

=EN 15.3. @EXPORT and @EXPORT_OK The import provided by Exporter examines the @EXPORT variable in the module's package to determine which variables it exports by default.

=CN 15.3. @EXPORT And @EXPORT_OK The Import Provided By Exporter examines The @EXPORT Variable In The Module's Package To 决心 Which Variables It exports By Default.

=EN For example, File::Basename might do something like:

=CN For Example, File::Basename Might Do Something Like:

=EN package File::Basename; our @EXPORT = qw( basename dirname fileparse ); use base qw(Exporter);

=CN Package File::Basename; Our @EXPORT = Qw( basename dirname fileparse ); Use Base qw(Exporter);

=EN The @EXPORT list both defines a list of available subroutines for export (the public interface) and provides a default list for Perl to use when we don't specify an import list.

=CN The @EXPORT List Both 定义 a List Of Available Subroutines For Export (The 公众的 Interface) And Provides a Default List For Perl To Use When We Don't Specify An Import List.

=EN For example, these two calls are equivalent:

=CN For Example, These Two Calls Are Equivalent:

=EN use File::Basename;

=CN Use File::Basename;

=EN BEGIN { require File::Basename; File::Basename->import }

=CN BEGIN { Require File::Basename; File::Basename->Import }

=EN We pass no list to import.

=CN We Pass No List To Import.

=EN In that case, the Exporter->import routine looks at @EXPORT and provides everything in the list.[]

=CN In That Case, The Exporter->Import Routine Looks At @EXPORT And Provides Everything In The List.[]

=EN [] Remember, having no list is not the same as having an empty list.

=CN [] Remember, Having No List Is Not The Same As Having An Empty List.

=EN If the list is empty, the module's import method is simply not called at all.

=CN If The List Is Empty, The Module's Import Method Is Simply Not Called At All.

=EN What if we had subroutines we didn't want as part of the default import but that would still be available if we asked for them?

=CN What If We Had Subroutines We Didn't Want As Part Of The Default Import But That Would Still Be Available If We 问 For Them?

=EN We can add those subroutines to the @EXPORT_OK list in the module's package.

=CN We Can 增添 Those Subroutines To The @EXPORT_OK List In The Module's Package.

=EN For example, suppose that Gilligan's module provides the guess_direction_toward routine by default but could also provide the ask_the_skipper_about and get_north_from_professor routines, if requested.

=CN For Example, 猜想 That Gilligan's Module Provides The guess_direction_toward Routine By Default But Could Also Provide The ask_the_skipper_about And get_north_from_professor Routines, If Requested.

=EN We can start it like this:

=CN We Can Start It Like This:

=EN package Navigate::SeatOfPants; our @EXPORT = qw(guess_direction_toward); our @EXPORT_OK = qw(ask_the_skipper_about get_north_from_professor); use base qw(Exporter);

=CN Package Navigate::SeatOfPants; Our @EXPORT = qw(guess_direction_toward); Our @EXPORT_OK = Qw(ask_the_skipper_about get_north_from_professor); Use Base qw(Exporter);

=EN The following invocations would then be valid:

=CN The Following invocations Would Then Be Valid:

=EN use Navigate::SeatOfPants; # gets guess_direction_toward

=CN Use Navigate::SeatOfPants; # Gets guess_direction_toward

=EN use Navigate::SeatOfPants qw(guess_direction_toward); # same

=CN Use Navigate::SeatOfPants qw(guess_direction_toward); # Same

=EN use Navigate::SeatOfPants

=CN Use Navigate::SeatOfPants

=EN  ## does NOT import guess_direction_toward!

=CN  ## Does NOT Import guess_direction_toward!

=EN If we specify any names, they must be in either @EXPORT or @EXPORT_OK, so this request is rejected by Exporter->import:

=CN If We Specify Any Names, They Must Be In Either @EXPORT Or @EXPORT_OK, So This 请求 Is 拒绝 By Exporter->Import:

=EN use Navigate::SeatOfPants qw(according_to_GPS);

=CN Use Navigate::SeatOfPants qw(according_to_GPS);

=EN because according_to_GPS is in neither @EXPORT nor @EXPORT_OK.[*] Thus, with those two arrays, we have control over our public interface.

=CN Because according_to_GPS Is In Neither @EXPORT Nor @EXPORT_OK.[*] Thus, With Those Two Arrays, We Have Control 在 Our 公众的 Interface.

=EN This does not stop someone from saying Navigate::SeatOfPants::according_to_GPS (if it existed), but at least now it's obvious that they're using something we didn't intend to offer them.

=CN This Does Not Stop Someone From Saying Navigate::SeatOfPants::according_to_GPS (If It existed), But At Least Now It's 明显的 That They'Re Using Something We Didn't 打算 To 提供 Them.

=EN [*] This check also catches misspellings and mistaken subroutine names, keeping you from wondering why the get_direction_from_professor routine isn't working.

=CN [*] This Check Also catches misspellings And 搞错了的 Subroutine Names, 一致 You From wondering Why The get_direction_from_professor Routine Isn't Working.

=EN 15.4. %EXPORT_TAGS We don't have to list every function or variable that we want to import, either.

=CN 15.4. %EXPORT_TAGS We Don't Have To List Every Function Or Variable That We Want To Import, Either.

=EN We can create shortcuts, or tags, to group them under a single name.

=CN We Can Create shortcuts, Or tags, To Group Them 在 a Single Name.

=EN In the import list, we precede the tag name with a colon.

=CN In The Import List, We 在前 The 标签 Name With a 结肠.

=EN For example, the core Fcntl module makes the flock constants available as a group with the :flock tag:

=CN For Example, The Core Fcntl Module 使 The 群 Constants Available As a Group With The :群 标签:

=EN use Fcntl qw( :flock ); # import all flock constants

=CN Use Fcntl Qw( :群 ); # Import All 群 Constants

=EN As described in the Exporter documentation, a few shortcuts are available automatically.

=CN As Described In The Exporter 提供文件, a Few shortcuts Are Available Automatically.

=EN The DEFAULT tag pulls in the same things as if we had provided no import list:

=CN The DEFAULT 标签 pulls In The Same Things As If We Had Provided No Import List:

=EN use Navigate::SeatOfPants qw(:DEFAULT);

=CN Use Navigate::SeatOfPants Qw(:DEFAULT);

=EN That isn't very useful on its own, but if we want to pull in the default symbols and more, we don't have to type everything out simply because we supply an import list:

=CN That Isn't Very Useful On Its Own, But If We Want To 拖 In The Default Symbols And More, We Don't Have To Type Everything Out Simply Because We Supply An Import List:

=EN use Navigate::SeatOfPants qw(:DEFAULT get_north_from_professor);

=CN Use Navigate::SeatOfPants Qw(:DEFAULT get_north_from_professor);

=EN These are rarely seen in practice.

=CN These Are 难得 Seen In Practice.

=EN The purpose of explicitly providing an import list is generally to control the subroutine names we use in our program.

=CN The Purpose Of 清晰地 提供 An Import List Is Generally To Control The Subroutine Names We Use In Our Program.

=EN Those last examples do not insulate us from future changes to the module, which may import additional subroutines that could collide with our code.[] In a few cases, a module may supply dozens or hundreds of possible symbols.

=CN Those Last Examples Do Not 绝缘 Us From Future Changes To The Module, Which May Import Additional Subroutines That Could 猛烈碰撞 With Our Code.[] In a Few Cases, a Module May Supply dozens Or hundreds Of Possible Symbols.

=EN These modules can use advanced techniques (described in the Exporter documentation) to make it easy to import batches of related symbols.

=CN These Modules Can Use 先进的 技术 (Described In The Exporter 提供文件) To Make It Easy To Import batches Of Related Symbols.

=EN [] For this reason, it is generally considered a bad idea for an update to a released module to introduce new default imports.

=CN [] For This Reason, It Is Generally Considered a 坏的 思想 For An Update To a released Module To 介绍 New Default Imports.

=EN If you know that your first release is still missing a function, though, there's no reason why you can't put in a placeholder: sub according_to_GPS { die "not implemented yet" }.

=CN If You Know That Your First Release Is Still Missing a Function, Though, There's No Reason Why You Can't Put In a placeholder: Sub according_to_GPS { Die "Not 实施 仍然" }.

=EN In our modules, we use the %EXPORT_TAGS hash to define these tags.

=CN In Our Modules, We Use The %EXPORT_TAGS Hash To Define These tags.

=EN The hash key is the name of the tag (without the colon), and the value is an anonymous array of symbols.

=CN The Hash Key Is The Name Of The 标签 (Without The 结肠), And The Value Is An Anonymous Array Of Symbols.

=EN package Navigate::SeatOfPants; use base qw(Exporter);

=CN Package Navigate::SeatOfPants; Use Base qw(Exporter);

=EN our @EXPORT = qw(guess_direction_toward); our @EXPORT_OK = qw(

=CN Our @EXPORT = qw(guess_direction_toward); Our @EXPORT_OK = Qw(

=EN our %EXPORT_TAGS = (

=CN Our %EXPORT_TAGS = (

=EN Our first tag, all, includes all of the exportable symbols (everything in both @EXPORT and @EXPORT_OK).

=CN Our First 标签, All, 包括 All Of The 可供出口的 Symbols (Everything In Both @EXPORT And @EXPORT_OK).

=EN The gps tag comprises only the functions that deal with GPS, and the direction tag includes all the functions that deal with direction.

=CN The gps 标签 comprises Only The Functions That 处理 With GPS, And The 方向 标签 包括 All The Functions That 处理 With 方向.

=EN The tags can contain overlaps too, and you'll notice that according_to_GPS shows up in each one of them.

=CN The tags Can Contain overlaps Too, And You'我 Notice That according_to_GPS Shows Up In Each One Of Them.

=EN No matter how we define our tags, everything they include has to be either in @EXPORT or @EXPORT_OK.

=CN No Matter How We Define Our tags, Everything They Include Has To Be Either In @EXPORT Or @EXPORT_OK.

=EN Once we define our export tags, our users can use them in their import lists:

=CN Once We Define Our Export tags, Our Users Can Use Them In Their Import Lists:

=EN use Navigate::SeatOfPants qw(:direction);

=CN Use Navigate::SeatOfPants Qw(:方向);

=EN Exporting in a Primarily OO Module As seen earlier, the normal means of using an object-oriented module is to call class methods and then methods against instances resulting from constructors of that class.

=CN Exporting In a Primarily OO Module As Seen Earlier, The Normal Means Of Using An Object-Oriented Module Is To Call Class Methods And Then Methods 反对 实例 造成 From 构造函数 Of That Class.

=EN This means that an OO module typically exports nothing, so we'll have:

=CN This Means That An OO Module 典型的 exports Nothing, So We'我 Have:

=EN package My::OOModule::Base; our @EXPORT = ( ); # you may even omit this line use base qw(Exporter);

=CN Package My::OOModule::Base; Our @EXPORT = ( ); # You May Even 省略 This Line Use Base qw(Exporter);

=EN What if we then derive a class from this base class?

=CN What If We Then 从 a Class From This Base Class?

=EN The most important thing to remember is that the import method must be defined from the Exporter class, so we add it like so:

=CN The Most Important Thing To 记得 Is That The Import Method Must Be Defined From The Exporter Class, So We 增添 It Like So:

=EN package My::OOModule::Derived; use base qw(Exporter My::OOModule::Base);

=CN Package My::OOModule::Derived; Use Base Qw(Exporter My::OOModule::Base);

=EN However, wouldn't the call to My::OOModule::Derived->import eventually find its way up to Exporter via My::OOModule::Base?

=CN However, Wouldn't The Call To My::OOModule::Derived->Import 最终 寻找 Its Way Up To Exporter Via My::OOModule::Base?

=EN Sure it would.

=CN Sure It Would.

=EN So we can leave that out:

=CN So We Can 出发 That Out:

=EN package My::OOModule::Derived; use base qw(My::OOModule::Base);

=CN Package My::OOModule::Derived; Use Base Qw(My::OOModule::Base);

=EN Only the base classes at the top of the tree need to specify Exporter, and only when they derive from no other classes.

=CN Only The Base 类 At The 顶 Of The 树 Need To Specify Exporter, And Only When They 从 From No Other 类.

=EN Please be aware of all the other reserved method names that can't be used by your OO module (as described in the Exporter manpage).

=CN Please Be 知道的 Of All The Other Reserved Method Names That Can't Be Used By Your OO Module (As Described In The Exporter manpage).

=EN At the time of this writing, the list is export_to_level, require_version, and export_fail.

=CN At The Time Of This 写作, The List Is export_to_level, require_version, And export_fail.

=EN Also, we may wish to reserve unimport because Perl will call that routine when we replace use with no.

=CN Also, We May Wish To 贮备 unimport Because Perl Will Call That Routine When We 归还原处 Use With No.

=EN That use is rare for user-written modules, however, although it often shows up with pragmas such as strict and warnings.

=CN That Use Is 稀有的 For User-Written Modules, However, Although It Often Shows Up With 的 Such As Strict And 警告.

=EN Even though an OO module typically exports nothing, we might choose to export a named constructor or management routine.

=CN Even Though An OO Module 典型的 exports Nothing, We Might 选择 To Export a Named 构造函数 Or 管理（人员） Routine.

=EN This routine typically acts a bit like a class method, but we want users to call it as a regular subroutine.

=CN This Routine 典型的 徒 a Bit Like a Class Method, But We Want Users To Call It As a Regular Subroutine.

=EN One example is the LWP library, available on the CPAN as part of the libwww-perl distribution.

=CN One Example Is The LWP Library, Available On The Perl综合典藏网 As Part Of The libwww-Perl 分配.

=EN The URI::URL module, now deprecated and replaced by the URI module, deals with universal resource identifiers, most commonly seen as URLs such as http://www.gilligan.crew.hut/maps/island.pdf.

=CN The URI::URL Module, Now deprecated And Replaced By The URI Module, deals With 宇宙的 资源 Identifiers, Most 通常 Seen As URLs Such As http://www.gilligan.crew.hut/maps/island.pdf.

=EN We can construct a URI::URL object as a traditional object constructor with:

=CN We Can Construct a URI::URL Object As a 传统的 Object 构造函数 With:

=EN use URI::URL; my $u = URI::URL->new('http://www.gilligan.crew.hut/maps/island.pdf');

=CN Use URI::URL; My $u = URI::URL->New('http://www.gilligan.crew.hut/maps/island.pdf');

=EN The default import list for URI::URL also imports a url subroutine, which we can use as a constructor as well:

=CN The Default Import List For URI::URL Also Imports a url Subroutine, Which We Can Use As a 构造函数 As Well:

=EN use URI::URL; my $u = url('http://www.gilligan.crew.hut/maps/island.pdf');

=CN Use URI::URL; My $u = url('http://www.gilligan.crew.hut/maps/island.pdf');

=EN Because this imported routine isn't a class method, we don't use the arrow method call to invoke it.

=CN Because This Imported Routine Isn't a Class Method, We Don't Use The 箭 Method Call To 调用 It.

=EN Also, the routine is unlike anything else in the module: it gets no initial class parameter.

=CN Also, The Routine Is 不同的 Anything Else In The Module: It Gets No Initial Class Parameter.

=EN Even though normal subroutines and method calls are both defined as subroutines in the package, the caller and the author must agree as to which is which.

=CN Even Though Normal Subroutines And Method Calls Are Both Defined As Subroutines In The Package, The Caller And The 作者 Must 同意 As To Which Is Which.

=EN The url convenience routine was nice, initially.

=CN The url 方便 Routine Was Nice, 最初.

=EN However, it clashed with the same-name routine that CGI.pm TRied to export as well, leading to interesting errors (especially in a mod_perl setting).

=CN However, It clashed With The Same-Name Routine That (（CGI）通用网关界面)通用网关界面.Pm TRied To Export As Well, 领先的 To Interesting Errors (Especially In a mod_perl Setting).

=EN The module that got there last won.

=CN The Module That Got There Last Won.

=EN (The modern interface in the URI module doesn't export such a constructor.)

=CN (The Modern Interface In The URI Module Doesn't Export Such a 构造函数.)

=EN Prior to that, in order to prevent a crash, we had to remember to bring it in with an empty import list:

=CN Prior To That, In Order To 防止 a 碰撞, We Had To 记得 To 拿来 It In With An Empty Import List:

=EN use URI::URL ( ); # don't import "url" my $u = URI::URL->new(...);

=CN Use URI::URL ( ); # Don't Import "url" My $u = URI::URL->New(...);

=EN Custom Import Routines Let's use CGI.pm as an example of a custom import routine before we show you how to write your own.

=CN Custom Import Routines Let's Use (（CGI）通用网关界面)通用网关界面.Pm As An Example Of a 风俗 Import Routine Before We Show You How To Write Your Own.

=EN Not satisfied with the incredible flexibility of the Exporter's import routine, CGI.pm author Lincoln Stein created a special import for the CGI module.[*] If you've ever gawked at the dizzying array of options that can appear after use CGI and wondered how it all worked, it's all a simple matter of programming.

=CN Not satisfied With The 不可信的 柔韧 Of The Exporter's Import Routine, (（CGI）通用网关界面)通用网关界面.Pm 作者 Lincoln Stein Created a Special Import For The (（CGI）通用网关界面)通用网关界面 Module.[*] If You'Ve 曾经 gawked At The dizzying Array Of 选项 That Can Appear After Use (（CGI）通用网关界面)通用网关界面 And wondered How It All 工作, It's All a Simple Matter Of Programming.

=EN You can just look at the source yourself.

=CN You Can Just Look At The Source 你（们）自己.

=EN [*] Some have dubbed this the "Lincoln Loader" out of a simultaneous deep respect for Lincoln and the sheer terror of having to deal with something that just doesn't work like anything else they've encountered.

=CN [*] Some Have dubbed This The "Lincoln Loader" Out Of a 同时（发生）的 深的 尊重 For Lincoln And The 全然的 恐怖 Of Having To 处理 With Something That Just Doesn't Work Like Anything Else They'Ve encountered.

=EN As part of the extension provided by this custom import, you can use the CGI module as an object-oriented module:

=CN As Part Of The 延伸 Provided By This 风俗 Import, You Can Use The (（CGI）通用网关界面)通用网关界面 Module As An Object-Oriented Module:

=EN use CGI; my $q = CGI->new; # create a query object my $f = $q->param('foo'); # get the foo field

=CN Use (（CGI）通用网关界面)通用网关界面; My $q = (（CGI）通用网关界面)通用网关界面->New; # Create a 询问 Object My $f = $q->param('Foo'); # Get The Foo 田野

=EN or a function-oriented module:

=CN Or a Function-Oriented Module:

=EN use CGI qw(param); # import the param function my $f = param('foo'); # get the foo field

=CN Use (（CGI）通用网关界面)通用网关界面 qw(param); # Import The param Function My $f = param('Foo'); # Get The Foo 田野

=EN If you don't want to spell out every possible subfunction, bring them all in:

=CN If You Don't Want To 拼写 Out Every Possible subfunction, 拿来 Them All In:

=EN use CGI qw(:all); # define 'param' and 800-gazillion others my $f = param('foo');

=CN Use (（CGI）通用网关界面)通用网关界面 Qw(:All); # Define 'param' And 800-gazillion 别人 My $f = param('Foo');

=EN And then there's pragmata available.

=CN And Then There's pragmata Available.

=EN For example, if you want to disable the normal sticky field handling, simply add -nosticky into the import list:

=CN For Example, If You Want To 使残废 The Normal 黏的 田野 处理, Simply 增添 -nosticky Into The Import List:

=EN use CGI qw(-nosticky :all);

=CN Use (（CGI）通用网关界面)通用网关界面 Qw(-nosticky :All);

=EN If you want to create the start_table and end_table routines, in addition to the others, it's simply:

=CN If You Want To Create The start_table And end_table Routines, In 增加 To The 别人, It's Simply:

=EN use CGI qw(-nosticky :all *table);

=CN Use (（CGI）通用网关界面)通用网关界面 Qw(-nosticky :All *Table);

=EN Truly a dizzying array of options.

=CN Truly a dizzying Array Of 选项.

=EN How did Lincoln make it all work?

=CN How Did Lincoln Make It All Work?

=EN You can just look in the CGI.pm code, see for yourself, but we'll show you the basics.

=CN You Can Just Look In The (（CGI）通用网关界面)通用网关界面.Pm Code, See For 你（们）自己, But We'我 Show You The basics.

=EN The import method is just a regular method, so we can make it do anything that we want.

=CN The Import Method Is Just a Regular Method, So We Can Make It Do Anything That We Want.

=EN Earlier we showed a simple (although hypothetical) example for File::Basename.

=CN Earlier We showed a Simple (Although 假设的) Example For File::Basename.

=EN In that case, instead of using the import method from Exporter as the real module does, we wrote our own to force the symbols into the main namespace.

=CN In That Case, Instead Of Using The Import Method From Exporter As The Real Module Does, We 写 Our Own To Force The Symbols Into The Main Namespace.

=EN This only works for main since that's what we hardcoded into the routine.

=CN This Only Works For Main Since That's What We hardcoded Into The Routine.

=EN We can figure out the calling package on the fly, however, by using the built-in caller.

=CN We Can 数字 Out The Calling Package On The Fly, However, By Using The Built-In Caller.

=EN In scalar context, caller returns the calling package:

=CN In Scalar Context, Caller Returns The Calling Package:

=EN We can get even more information from caller by using it in list context.

=CN We Can Get Even More Information From Caller By Using It In List Context.

=EN Since import is just a method, any arguments to it (that's the import list, remember) show up in @_.

=CN Since Import Is Just a Method, Any Arguments To It (That's The Import List, 记得) Show Up In @_.

=EN We can inspect the argument list and decide what to do.

=CN We Can 检查 The Argument List And Decide What To Do.

=EN Let's turn on debugging output only if debug shows up in the import list.

=CN Let's 转向 On Debugging 出产 Only If debug Shows Up In The Import List.

=EN We're not going to import a subroutine named debug.

=CN We'Re Not Going To Import a Subroutine Named debug.

=EN We're only going to set $debug to a true value if it's there, then do the same stuff we did before.

=CN We'Re Only Going To Set $debug To a True Value If It's There, Then Do The Same 材料 We Did Before.

=EN This time we only print the warning if we've turned on debugging.

=CN This Time We Only Print The Warning If We'Ve 转 On Debugging.

=EN These are the basic tricks that Lincoln used to work his CGI magic, and it's the same stuff that the Test::More module, which we introduce in Chapter 17, uses in its own import to control how testing works.

=CN These Are The 基本的 把戏 That Lincoln Used To Work 他的 (（CGI）通用网关界面)通用网关界面 Magic, And It's The Same 材料 That The Test::More Module, Which We 介绍 In Chapter 17, Uses In Its Own Import To Control How testing Works.

=EN Exercises You can find the answers to these exercises in "Answers for Chapter 15" in the Appendix.

=CN Exercises You Can 寻找 The answers To These exercises In "Answers For Chapter 15" In The Appendix.

=EN Exercise 1 [15 min] Take the Oogaboogoo library you created in Chapter 10, Exercise 1 and turn it into a module you can bring in with use.

=CN Exercise 1 [15 min] Take The Oogaboogoo Library You Created In Chapter 10, Exercise 1 And 转向 It Into a Module You Can 拿来 In With Use.

=EN Alter the invoking code so that it uses the imported routines (rather than the full package specification, as you did before), and test it.

=CN Alter The 调用 Code So That It Uses The Imported Routines (Rather Than The Full Package 规格, As You Did Before), And Test It.

=EN Exercise 2 [15 min] Modify your answer to Exercise 1 to use an export tag named all.

=CN Exercise 2 [15 min] Modify Your Answer To Exercise 1 To Use An Export 标签 Named All.

=EN When the user uses all, your module should import all of the subroutine names.

=CN When The User Uses All, Your Module Should Import All Of The Subroutine Names.

=EN use Oogaboogoo::date qw(:all);

=CN Use Oogaboogoo::Date Qw(:All);

