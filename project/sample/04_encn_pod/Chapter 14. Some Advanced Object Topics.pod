=EN Some Advanced Object Topics You might wonder, "Do all objects inherit from a common class?"

=CN Some Advanced Object Topics You Might 想知道诧异, "Do All Objects 继承 From a Common Class?"

=EN "What if a method is missing?"

=CN "What If a Method Is Missing?"

=EN "What about multiple inheritance?" or "How can I tell what sort of object I have?"

=CN "What About Multiple Inheritance?" Or "How Can I Tell What Sort Of Object I Have?"

=EN Well, wonder no more.

=CN Well, 想知道诧异 No More.

=EN This chapter covers these subjects and more.

=CN This 章 covers These subjects And More.

=EN UNIVERSAL Methods As we define classes, we create inheritance hierarchies through the global @ISA variables in each package.

=CN UNIVERSAL Methods As We Define 类, We Create Inheritance hierarchies 通过 The Global @ISA Variables In Each Package.

=EN To search for a method, Perl wanders through the @ISA TRee until it finds a match or fails.

=CN To 搜查 For a Method, Perl wanders 通过 The @ISA TRee Until It 发现 a Match Or 失败.

=EN After the search fails, however, Perl always looks in one special class called UNIVERSAL and invokes a method from there, if found, just as if it had been located in any other class or superclass.

=CN After The 搜查 失败, However, Perl Always Looks In One Special Class Called UNIVERSAL And invokes a Method From There, If Found, Just As If It Had Been Located In Any Other Class Or 基类.

=EN One way to look at this is that UNIVERSAL is the base class from which all objects derive.

=CN One Way To Look At This Is That UNIVERSAL Is The Base Class From Which All Objects 从.

=EN Any method we place here, such as:

=CN Any Method We Place Here, Such As:

=EN sub UNIVERSAL::fandango {

=CN Sub UNIVERSAL::fandango {

=EN enables all objects of our program to be called as $some_object->fandango.

=CN enables All Objects Of Our Program To Be Called As $some_object->fandango.

=EN Generally, we should provide a fandango method for specific classes of interest and then provide a definition in UNIVERSAL::fandango as a backstop, in case Perl can't find a more specific method.

=CN Generally, We Should Provide a fandango Method For 特殊的 类 Of 兴趣 And Then Provide a Definition In UNIVERSAL::fandango As a 控股, In Case Perl Can't 寻找 a More 特殊的 Method.

=EN A practical example might be a data-dumping routine for debugging or maybe a marshaling strategy to dump all application objects to a file.

=CN A 实用的 Example Might Be a Data-倾销 Routine For Debugging Or 或许 a marshaling 战略 To 倾倒 All 申请 Objects To a File.

=EN We simply provide the general method in UNIVERSAL and override it in the specific classes for unusual objects.

=CN We Simply Provide The General Method In UNIVERSAL And Override It In The 特殊的 类 For 不寻常的 Objects.

=EN Obviously, we should use UNIVERSAL sparingly, because there's only one universe of objects, and our fandango might collide with some other included module's fandango.

=CN Obviously, We Should Use UNIVERSAL sparingly, Because There's Only One 宇宙 Of Objects, And Our fandango Might 猛烈碰撞 With Some Other 包括 Module's fandango.

=EN For this reason, UNIVERSAL is hardly used for anything except methods that must be completely, well, universal, like during debugging or other Perl-internal behavior that ordinary programmers may blissfully ignore.

=CN For This Reason, UNIVERSAL Is 刚刚 Used For Anything Except Methods That Must Be 完全地, Well, 宇宙的, Like 在 Debugging Or Other Perl-Internal Behavior That Ordinary Programmers May blissfully 忽视.

=EN Testing Our Objects for Good Behavior Besides providing a place for us to put universally available methods, the UNIVERSAL package comes preloaded with two very useful utility methods: isa and can.

=CN Testing Our Objects For Good Behavior Besides 提供 a Place For Us To Put 普遍地 Available Methods, The UNIVERSAL Package 来 preloaded With Two Very Useful 效用 Methods: isa And Can.

=EN Because UNIVERSAL defines these methods, they are available to all objects.

=CN Because UNIVERSAL 定义 These Methods, They Are Available To All Objects.

=EN The isa method tests to see whether a given class or instance is a member of a given class or a member of a class that inherits from the given class.

=CN The isa Method 测试 To See Whether a Given Class Or 例子 Is a Member Of a Given Class Or a Member Of a Class That 继承 From The Given Class.

=EN For example, continuing on with the Animal family from the previous chapters:

=CN For Example, continuing On With The Animal 家庭 From The Previous chapters:

=EN if (Horse->isa('Animal')) { # does Horse inherit from Animal?

=CN If (Horse->isa('Animal')) { # Does Horse 继承 From Animal?

=EN my $tv_horse = Horse->named("Mr. Ed"); if ($tv_horse->isa('Animal')) { # is it an Animal?

=CN My $tv_horse = Horse->Named("Mr. Ed"); If ($tv_horse->isa('Animal')) { # Is It An Animal?

=EN  # is it a Horse?

=CN  # Is It a Horse?

=EN This is handy when we have a heterogeneous mix of objects in a data structure and want to distinguish particular categories of objects:

=CN This Is 方便的 When We Have a heterogeneous 混合 Of Objects In a Data Structure And Want To 辨别 Particular 类别 Of Objects:

=EN my @horses = grep $_->isa('Horse'), @all_animals;

=CN My @horses = Grep $_->isa('Horse'), @all_animals;

=EN The result will be only the horses (or racehorses) from the array.

=CN The Result Will Be Only The horses (Or racehorses) From The Array.

=EN We compare that with:

=CN We 比较 That With:

=EN my @horses_only = grep ref $_ eq 'Horse', @all_animals;

=CN My @horses_only = Grep Ref $_ Eq 'Horse', @all_animals;

=EN which picks out just the horses, because a RaceHorse won't return Horse for ref.

=CN Which 镐 Out Just The horses, Because a RaceHorse Won't Return Horse For Ref.

=EN In general, we shouldn't use:

=CN In General, We 应该't Use:

=EN ref($some_object) eq 'SomeClass'

=CN Ref($some_object) Eq 'SomeClass'

=EN in our programs because it prevents future users from subclassing that class.

=CN In Our Programs Because It 防止 Future Users From subclassing That Class.

=EN Use the isa construct as given earlier.

=CN Use The isa Construct As Given Earlier.

=EN One downside of the isa call here is that it works only on blessed references or scalars that look like class names.

=CN One downside Of The isa Call Here Is That It Works Only On 有福的 References Or Scalars That Look Like Class Names.

=EN If we happen to pass it an unblessed reference, we get a fatal (but trappable) error of:

=CN If We 发生 To Pass It An unblessed Reference, We Get a Fatal (But trappable) Error Of:

=EN Can't call method "isa" on unblessed reference at ...

=CN Can't Call Method "isa" On unblessed Reference At ...

=EN To call isa more robustly, we could call it as a subroutine:

=CN To Call isa More robustly, We Could Call It As a Subroutine:

=EN if (UNIVERSAL::isa($unknown_thing, 'Animal')) {

=CN If (UNIVERSAL::isa($unknown_thing, 'Animal')) {

=EN This runs without an error, no matter what $unknown_thing contains.

=CN This 跑 Without An Error, No Matter What $unknown_thing 包含.

=EN But it's subverting the OO mechanism, which has its own set of problems.[*] This is a job for an exception mechanism, which is eval.

=CN But It's subverting The OO Mechanism, Which Has Its Own Set Of 问题.[*] This Is a 工作 For An Exception Mechanism, Which Is Eval.

=EN If the value in $unknown_thing isn't a reference, then we can't call a method on it.

=CN If The Value In $unknown_thing Isn't a Reference, Then We Can't Call a Method On It.

=EN The eval TRaps that error and returns undef, which is false.

=CN The Eval TRaps That Error And Returns Undef, Which Is False.

=EN [*] Particularly, if Animal has a custom isa method (perhaps it rejects a mutant branch of talking animals in the family tree), calling UNIVERSAL::isa skips past Animal::isa and may give you the wrong answer.

=CN [*] Particularly, If Animal Has a 风俗 isa Method (也许 It rejects a mutant 树枝 Of 说话 animals In The 家庭 树), Calling UNIVERSAL::isa 翻斗车 过去的 Animal::isa And May Give You The 错误的 Answer.

=EN if (eval { $unknown_thing->isa('Animal') }) {

=CN If (Eval { $unknown_thing->isa('Animal') }) {

=EN As in the case of isa, we can test for acceptable behaviors with the can method.

=CN As In The Case Of isa, We Can Test For Acceptable Behaviors With The Can Method.

=EN For example:

=CN For Example:

=EN if ($tv_horse->can('eat')) {

=CN If ($tv_horse->Can('吃')) {

=EN If the result of can is true, then somewhere in the inheritance hierarchy, a class claims it can handle the eat method.

=CN If The Result Of Can Is True, Then Somewhere In The Inheritance 层次, a Class 声称 It Can Handle The 吃 Method.

=EN Again, the caveats about $tv_horse being only either a blessed reference or a class name as a scalar still apply, so the robust solution when we might deal with nearly anything looks like:

=CN Again, The caveats About $tv_horse Being Only Either a 有福的 Reference Or a Class Name As a Scalar Still 应用, So The 强壮的 解决 When We Might 处理 With 几乎 Anything Looks Like:

=EN if (eval { $tv_horse->can('eat') } ) { ... }

=CN If (Eval { $tv_horse->Can('吃') } ) { ... }

=EN Note that if we defined UNIVERSAL::fandango earlier, then:

=CN Note That If We Defined UNIVERSAL::fandango Earlier, Then:

=EN $object->can('fandango')

=CN $Object->Can('fandango')

=EN always returns true, because all objects can do the fandango.

=CN Always Returns True, Because All Objects Can Do The fandango.

=EN AUTOLOAD as a Last Resort After Perl searches the inheritance tree and UNIVERSAL for a method, it doesn't just stop there if the search is unsuccessful.

=CN AUTOLOAD As a Last Resort After Perl searches The Inheritance 树 And UNIVERSAL For a Method, It Doesn't Just Stop There If The 搜查 Is unsuccessful.

=EN Perl repeats the search through the very same hierarchy (including UNIVERSAL), looking for a method named AUTOLOAD.

=CN Perl repeats The 搜查 通过 The Very Same 层次 (Including UNIVERSAL), 看 For a Method Named AUTOLOAD.

=EN If an AUTOLOAD exists, the subroutine is called in place of the original method, passing it the normal predetermined argument list: the class name or instance reference, followed by any arguments provided to the method call.

=CN If An AUTOLOAD Exists, The Subroutine Is Called In Place Of The Original Method, Passing It The Normal predetermined Argument List: The Class Name Or 例子 Reference, 跟着 By Any Arguments Provided To The Method Call.

=EN The original method name is passed in the package variable called $AUTOLOAD (in the package where the subroutine was compiled) and contains the fully qualified method name, so we should generally strip everything up to the final double colon if we want a simple method name.

=CN The Original Method Name Is Passed In The Package Variable Called $AUTOLOAD (In The Package Where The Subroutine Was Compiled) And 包含 The Fully 有资格的 Method Name, So We Should Generally Strip Everything Up To The 最终的 两倍的 结肠 If We Want a Simple Method Name.

=EN The AUTOLOAD subroutine can execute the desired operation itself, install a subroutine and then jump into it, or perhaps just die if asked to perform an unknown method.

=CN The AUTOLOAD Subroutine Can Execute The Desired Operation Itself, 安装 a Subroutine And Then 跳跃 Into It, Or 也许 Just Die If 问 To 执行 An Unknown Method.

=EN One use of AUTOLOAD defers the compilation of a large subroutine until it is actually needed.

=CN One Use Of AUTOLOAD defers The 编译 Of a Large Subroutine Until It Is Actually Needed.

=EN For example, suppose the eat method for an animal is complex but unused in nearly every invocation of the program.

=CN For Example, 猜想 The 吃 Method For An 动物 Is 综合的 But unused In 几乎 Every 调用 Of The Program.

=EN We can defer its compilation as follows:

=CN We Can 拖延 Its 编译 As Follows:

=EN ## in Animal sub AUTOLOAD {

=CN ## In Animal Sub AUTOLOAD {

=EN  # remove package name

=CN  # 移开 Package Name

=EN  ## define eat:

=CN  ## Define 吃:

=EN  # End of eval's q{ } string

=CN  # End Of Eval's q{ } String

=EN  # if typo snuck in

=CN  # If typo 偷偷 In

=EN  # jump into it

=CN  # 跳跃 Into It

=EN  # unknown method

=CN  # Unknown Method

=EN If the method name is eat, we'll define eat (which we had previously in a string but had not compiled) and then jump into it with a special construct that replaces the current subroutine invocation of AUTOLOAD with an invocation of eat, just as if we invoked &eat instead of AUTOLOAD.[*] After the first AUTOLOAD hit, the eat subroutine is now defined, so we won't be coming back here.

=CN If The Method Name Is 吃, We'我 Define 吃 (Which We Had Previously In a String But Had Not Compiled) And Then 跳跃 Into It With a Special Construct That Replaces The Current Subroutine 调用 Of AUTOLOAD With An 调用 Of 吃, Just As If We invoked &吃 Instead Of AUTOLOAD.[*] After The First AUTOLOAD 打, The 吃 Subroutine Is Now Defined, So We Won't Be coming Back Here.

=EN This is great for compile-as-you-go programs because it minimizes startup overhead.

=CN This Is 大的 For Compile-As-You-Go Programs Because It minimizes startup 头上的.

=EN [*] Although goto is generally (and rightfully) considered evil, this form of goto, which gives a subroutine name as a target, is not really the evil goto; it's the good goto.

=CN [*] Although Goto Is Generally (And rightfully) Considered 坏的, This Form Of Goto, Which Gives a Subroutine Name As a 目标, Is Not Really The 坏的 Goto; It's The Good Goto.

=EN In particular, this is the "magic goto."

=CN In Particular, This Is The "Magic Goto."

=EN Its trick is that AUTOLOAD is completely invisible to the subroutine.

=CN Its 诡计 Is That AUTOLOAD Is 完全地 Invisible To The Subroutine.

=EN For a more automated way of creating code to do this, which makes it easy to turn the autoloading off during development and debugging, see the AutoLoader and SelfLoader core module documentation.

=CN For a More automated Way Of Creating Code To Do This, Which 使 It Easy To 转向 The autoloading Off 在 进展 And Debugging, See The AutoLoader And SelfLoader Core Module 提供文件.

=EN Using AUTOLOAD for Accessors Chapter 12 showed how to create color and set_color to get and set the color of an animal.

=CN Using AUTOLOAD For Accessors Chapter 12 showed How To Create 颜色 And set_color To Get And Set The 颜色 Of An 动物.

=EN If we had 20 attributes instead of 1 or 2, the code would be painfully repetitive.

=CN If We Had 20 Attributes Instead Of 1 Or 2, The Code Would Be painfully 重复的.

=EN However, using an AUTOLOAD method, we can construct the nearly identical accessors as needed, saving both compilation time and wear-and-tear on the developer's keyboard.

=CN However, Using An AUTOLOAD Method, We Can Construct The 几乎 同一的 accessors As Needed, Saving Both 编译 Time And 穿-And-眼泪 On The developer's 键盘.

=EN We use a code reference as a closure to do the job.

=CN We Use a Code Reference As a Closure To Do The 工作.

=EN First, we set up an AUTOLOAD for the object and define a list of hash keys for which we want trivial accessors:

=CN First, We Set Up An AUTOLOAD For The Object And Define a List Of Hash Keys For Which We Want 琐碎的 accessors:

=EN sub AUTOLOAD {

=CN Sub AUTOLOAD {

=EN Next, we'll see if the method is a getter for one of these keys, and, if so, we install a getter and jump to it:

=CN Next, We'我 See If The Method Is a getter For One Of These Keys, And, If So, We 安装 a getter And 跳跃 To It:

=EN our $AUTOLOAD; if ($AUTOLOAD =~ /::(\w+)$/ and grep $1 eq $_, @elements) {

=CN Our $AUTOLOAD; If ($AUTOLOAD =~ /::(\w+)$/ And Grep $1 Eq $_, @Elements) {

=EN We need to use ucfirst because we named the method color to fetch the hash element called Color.

=CN We Need To Use ucfirst Because We Named The Method 颜色 To 去取来 The Hash Element Called Color.

=EN The glob notation here installs a wanted subroutine as defined by the coderef closure, which fetches the corresponding key from the object hash.

=CN The Glob 符号 Here 安装 a 想要 Subroutine As Defined By The coderef Closure, Which fetches The 相应的 Key From The Object Hash.

=EN Consider this part to be magic that we just cut and paste into our program.

=CN Consider This Part To Be Magic That We Just Cut And 浆糊 Into Our Program.

=EN Finally, the goto construct jumps into the newly defined subroutine.

=CN Finally, The Goto Construct jumps Into The 新 Defined Subroutine.

=EN Otherwise, perhaps it's a setter:

=CN Otherwise, 也许 It's a setter:

=EN if ($AUTOLOAD =~ /::set_(\w+)$/ and grep $1 eq $_, @elements) {

=CN If ($AUTOLOAD =~ /::set_(\w+)$/ And Grep $1 Eq $_, @Elements) {

=EN If it is neither, death awaits:

=CN If It Is Neither, 死 awaits:

=EN croak "$_[0] does not understand $method\n";

=CN croak "$_[0] Does Not Understand $Method\n";

=EN Again, we pay the price for the AUTOLOAD only on the first hit of a particular getter or setter.

=CN Again, We 支付 The 价格 For The AUTOLOAD Only On The First 打 Of a Particular getter Or setter.

=EN After that, a subroutine is now already defined, and we can just invoke it directly.

=CN After That, a Subroutine Is Now Already Defined, And We Can Just 调用 It 直接地.

=EN Creating Getters and Setters More Easily If all that coding for creating accessors using AUTOLOAD looks messy, rest assured that we really don't need to tackle it, because there's a CPAN module that does it a bit more directly: Class::MethodMaker.[*]

=CN Creating Getters And Setters More Easily If All That coding For Creating accessors Using AUTOLOAD Looks messy, 休息 感到放心的 That We Really Don't Need To 用具 It, Because There's a Perl综合典藏网 Module That Does It a Bit More 直接地: Class::MethodMaker.[*]

=EN [*] Sometimes Class::MethodMaker can be a bit much.

=CN [*] Sometimes Class::MethodMaker Can Be a Bit Much.

=EN We can also check out the lighter Class::Accessor.

=CN We Can Also Check Out The 打火机 Class::Accessor.

=EN For example, a simplified version of the Animal class might be defined as follows:

=CN For Example, a simplified Version Of The Animal Class Might Be Defined As Follows:

=EN package Animal; use Class::MethodMaker

=CN Package Animal; Use Class::MethodMaker

=EN The getters and setters for the four instance attributes (name, height, color, and age) are defined automatically, using the method color to get the color and set_color to set the color.

=CN The getters And setters For The 四 例子 Attributes (Name, 高度, 颜色, And 年龄) Are Defined Automatically, Using The Method 颜色 To Get The 颜色 And set_color To Set The 颜色.

=EN (The eiffel flag says "do it the way the Eiffel language does it, " which is the way it should be done here.)

=CN (The eiffel 旗 说 "Do It The Way The Eiffel 语言 Does It, " Which Is The Way It Should Be Done Here.)

=EN The messy blessing step is now hidden behind a simple new method.

=CN The messy 祝福 脚步 Is Now Hidden 在 a Simple New Method.

=EN We define the initial color as the default color, as before, because the generated new method calls the init method.

=CN We Define The Initial 颜色 As The Default 颜色, As Before, Because The Generated New Method Calls The Init Method.

=EN However, we can still call Horse->named('Mr. Ed') because it immediately calls the new routine as well.

=CN However, We Can Still Call Horse->Named('Mr. Ed') Because It 立即 Calls The New Routine As Well.

=EN Class::MethodMaker generated the sound method as an abstract method.

=CN Class::MethodMaker Generated The 声 Method As An 抽象的 Method.

=EN Abstract methods are placeholders, meant to be defined in a subclass.

=CN Abstract Methods Are placeholders, 意味着 To Be Defined In a 子类.

=EN If a subclass fails to define the method, the method Class::MethodMaker generates for Animal's sound dies.

=CN If a 子类 失败 To Define The Method, The Method Class::MethodMaker 产生 For Animal's 声 Dies.

=EN We lose the ability to call the getters (such as name) on the class itself, rather than an instance.

=CN We 失去 The 能力 To Call The getters (Such As Name) On The Class Itself, Rather Than An 例子.

=EN In turn, this breaks our prior usage of calling speak and eat on generic animals, since they call the accessors.

=CN In 转向, This 打破 Our 较早的 使用 Of Calling 说话 And 吃 On 通用 animals, Since They Call The accessors.

=EN One way around this is to define a more general version of name to handle either a class or instance and then change the other routines to call it:

=CN One Way Around This Is To Define a More General Version Of Name To Handle Either a Class Or 例子 And Then Change The Other Routines To Call It:

=EN sub generic_name {

=CN Sub generic_name {

=EN Now it's looking nearly drop-in compatible with the previous definition, except for those friend classes that referenced the attribute names directly in the hash as the initial-cap-keyed versions (such as Color) rather than through the accessors ($self->color).

=CN Now It's 看 几乎 落下-In Compatible With The Previous Definition, Except For Those 朋友 类 That 参考 The Attribute Names 直接地 In The Hash As The Initial-帽子-keyed Versions (Such As Color) Rather Than 通过 The accessors ($自己->颜色).

=EN That brings up the maintenance issue again.

=CN That brings Up The 保养 发行发布 Again.

=EN The more we can decouple our implementation (hash versus array, names of hash keys, or types of elements) from the interface (method names, parameter lists, or types of return values), the more flexible and maintainable our system becomes.

=CN The More We Can decouple Our 实行 (Hash 对 Array, Names Of Hash Keys, Or Types Of Elements) From The Interface (Method Names, Parameter Lists, Or Types Of Return Values), The More 柔韧的 And maintainable Our System Becomes.

=EN The flexibility isn't free, however.

=CN The 柔韧 Isn't Free, However.

=EN Since the performance cost of a method call is higher than the cost of a hash lookup, in some circumstances it may make sense to have a friend class peek inside.

=CN Since The 执行 成本 Of a Method Call Is 更高的 Than The 成本 Of a Hash 查找, In Some 情况下 It May Make Sense To Have a 朋友 Class peek 里面.

=EN Multiple Inheritance How does Perl wander through the @ISA TRee?

=CN Multiple Inheritance How Does Perl 徘徊 通过 The @ISA TRee?

=EN The answer may be simple or complex.

=CN The Answer May Be Simple Or 综合的.

=EN If we don't have multiple inheritance (that is, if no @ISA has more than one element), it is simple: Perl simply goes from one @ISA to the next until it finds the ultimate base class whose @ISA is empty.

=CN If We Don't Have Multiple Inheritance (That Is, If No @ISA Has More Than One Element), It Is Simple: Perl Simply 去 From One @ISA To The 下一次 Until It 发现 The 最终的 Base Class Whose @ISA Is Empty.

=EN Multiple inheritance is more complex.

=CN Multiple Inheritance Is More 综合的.

=EN It occurs when a class's @ISA has more than one element.

=CN It Occurs When a Class's @ISA Has More Than One Element.

=EN For example, suppose we have a class called Racer, which has the basic abilities for anything that can race, so that it's ready to be the base class for a runner, a fast car, or a racing turtle.

=CN For Example, 猜想 We Have a Class Called Racer, Which Has The 基本的 abilitie(绑定操作符)s For Anything That Can 种族, So That It's 准备好的 To Be The Base Class For a 奔跑者, a 快的 小汽车, Or a racing 海龟.

=EN With that, we could make the RaceHorse class as simply as this:[*]

=CN With That, We Could Make The RaceHorse Class As Simply As This:[*]

=EN [*] If there is a conflict among the methods of Horse and Racer, or if their implementations aren't able to work together, the situation can become much more difficult.

=CN [*] If There Is a 冲突 Among The Methods Of Horse And Racer, Or If Their 实现 还't Able To Work Together, The 形势 Can 变成 Much More 困难的.

=EN The various classes in @ISA may not play well together and may step on one another's data, for instance.

=CN The 各种各样的 类 In @ISA May Not 玩 Well Together And May 脚步 On One 另一个's Data, For 例子.

=EN Now a RaceHorse can do anything a Horse can do, and anything a Racer can do as well.

=CN Now a RaceHorse Can Do Anything a Horse Can Do, And Anything a Racer Can Do As Well.

=EN When Perl searches for a method that's not provided directly by RaceHorse, it first searches through all the capabilities of the Horse (including all its parent classes, such as Animal).

=CN When Perl searches For a Method That's Not Provided 直接地 By RaceHorse, It First searches 通过 All The capabilitie(绑定操作符)s Of The Horse (Including All Its 父或母亲 类, Such As Animal).

=EN When the Horse possibilities are exhausted, Perl turns to see whether Racer (or one of its subclasses) supplies the needed method.

=CN When The Horse possibilitie(绑定操作符)s Are 精疲力竭的, Perl Turns To See Whether Racer (Or One Of Its 子类) Supplies The Needed Method.

=EN On the other hand, if we want Perl to search Racer and its subclasses before searching Horse, we can put them into @ISA in that order (see Figure 14-1).

=CN On The Other Hand, If We Want Perl To 搜查 Racer And Its 子类 Before 搜索 Horse, We Can Put Them Into @ISA In That Order (See Figure 14-1).

=EN A class may not need to implement any methods of its own if it inherits everything it needs from its parent classes through multiple inheritance

=CN A Class May Not Need To 实行 Any Methods Of Its Own If It 继承 Everything It Needs From Its 父或母亲 类 通过 Multiple Inheritance

=EN Exercises You can find the answers to these exercises in "Answers for Chapter 14" in the Appendix.

=CN Exercises You Can 寻找 The answers To These exercises In "Answers For Chapter 14" In The Appendix.

=EN Exercise 1 [20 min] Write a module named MyDate that has an AUTOLOAD method that handles the calls to the methods named day, month, and year, returning the appropriate value for each one.

=CN Exercise 1 [20 min] Write a Module Named MyDate That Has An AUTOLOAD Method That 处理 The Calls To The Methods Named 一天, 月份, And 年, Returning The 恰当的 Value For Each One.

=EN For any other method, the AUTOLOAD should carp about the unknown method name.

=CN For Any Other Method, The AUTOLOAD Should 鲤鱼 About The Unknown Method Name.

=EN Write a script that uses your module and prints the values for the date, month, and year.

=CN Write a 临时单据 That Uses Your Module And Prints The Values For The Date, 月份, And 年.

=EN Exercise 2 [40 min] Starting with the script you wrote for the previous exercise, add a UNIVERSAL::debug function that prints a timestamp before the message you pass to it.

=CN Exercise 2 [40 min] Starting With The 临时单据 You 写 For The Previous 锻炼, 增添 a UNIVERSAL::debug Function That Prints a timestamp Before The 音讯 You Pass To It.

=EN Call the debug method on the MyDate object.

=CN Call The debug Method On The MyDate Object.

=EN What happens?

=CN What Happens?

=EN How does this get around the AUTOLOAD mechanism?

=CN How Does This Get Around The AUTOLOAD Mechanism?

