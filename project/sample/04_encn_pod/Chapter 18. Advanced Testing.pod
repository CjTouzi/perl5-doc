=EN Advanced Testing The Test::More module provides some simple and general functions, but other Test::* modules provide more specific tests for particular problem domains so that we don't have to write much code to do what we need.

=CN Advanced Testing The Test::More Module Provides Some Simple And General Functions, But Other Test::* Modules Provide More 特殊的 测试 For Particular Problem domains So That We Don't Have To Write Much Code To Do What We Need.

=EN If we use it once, we'll probably use it again, anyway.

=CN If We Use It Once, We'我 Probably Use It Again, 不管怎样.

=EN In this chapter, we give you a taste of some of the more popular test modules.

=CN In This 章, We Give You a 味道 Of Some Of The More 受欢迎的 Test Modules.

=EN Unless we say otherwise, these modules are not part of the Perl standard distribution (unlike Test::More) and you'll need to install them yourself.

=CN Unless We Say Otherwise, These Modules Are Not Part Of The Perl Standard 分配 (不同的 Test::More) And You'我 Need To 安装 Them 你（们）自己.

=EN You might feel a bit cheated by this chapter since we're going to say "See the module documentation" quite a bit, but we're gently nudging you out into the Perl world.

=CN You Might 感到 a Bit cheated By This 章 Since We'Re Going To Say "See The Module 提供文件" Quite a Bit, But We'Re 轻轻地 nudging You Out Into The Perl World.

=EN For much more detail, you can also check out Perl Testing: A Developer's Notebook, which covers the subject further.

=CN For Much More 细节, You Can Also Check Out Perl Testing: A Developer's Notebook, Which covers The Subject Further.

=EN Testing Large Strings We showed in Chapter 17 that when a test fails, Test::More can show us what we expected and what we actually got.

=CN Testing Large Strings We showed In Chapter 17 That When a Test 失败, Test::More Can Show Us What We Expected And What We Actually Got.

=EN #!/usr/bin/perl use Test::More 'no_plan'; is( "Hello Perl", "Hello perl" );

=CN #!/usr/bin/Perl Use Test::More 'no_plan'; Is( "Hello Perl", "Hello Perl" );

=EN When I run this program, Test::More shows me what went wrong.

=CN When I Run This Program, Test::More Shows Me What 去 错误的.

=EN $ perl test.pl not ok 1 # Failed test (test.pl at line 5) # got: 'Hello Perl' # expected: 'Hello perl' 1..1 # Looks like you failed 1 test of 1.

=CN $ Perl test.pl Not Ok 1 # Failed Test (test.pl At Line 5) # Got: 'Hello Perl' # Expected: 'Hello Perl' 1..1 # Looks Like You failed 1 Test Of 1.

=EN What if that string is really long?

=CN What If That String Is Really Long?

=EN We don't want to see the whole string, which might be hundreds or thousands of characters long.

=CN We Don't Want To See The Whole String, Which Might Be hundreds Or thousands Of Characters Long.

=EN We just want to see where they start to be different.

=CN We Just Want To See Where They Start To Be Different.

=EN #!/usr/bin/perl

=CN #!/usr/bin/Perl

=EN use Test::More 'no_plan'; use Test::LongString;

=CN Use Test::More 'no_plan'; Use Test::LongString;

=EN The error output doesn't have to show us the whole string to tell us where things went wrong.

=CN The Error 出产 Doesn't Have To Show Us The Whole String To Tell Us Where Things 去 错误的.

=EN It shows us the relevant parts along with the string lengths.

=CN It Shows Us The 相关的 部分 沿着 With The String 长度.

=EN Although our example is a bit contrived, imagine doing this with a web page, configuration file, or some other huge chunk of data that we don't want cluttering our testing output.

=CN Although Our Example Is a Bit contrived, 想象 Doing This With a 网 页, Configuration File, Or Some Other 庞大的 chunk Of Data That We Don't Want cluttering Our testing 出产.

=EN not ok 1 # Failed test in long_string.pl at line 6. # got: ..." the lazy dog\x{0a}"... # length: 450 # expected: ..." the lazy camel"... # length: 451 # strings begin to differ at char 447 1..1 # Looks like you failed 1 test of 1.

=CN Not Ok 1 # Failed Test In long_string.pl At Line 6. # Got: ..." The 懒惰的 狗\x{0a}"... # Length: 450 # Expected: ..." The 懒惰的 骆驼"... # Length: 451 # Strings 开始 To 不同 At Char 447 1..1 # Looks Like You failed 1 Test Of 1.

=EN Testing Files The code to test things like file existence and file size is simple, but the more code we write, and the more parts each code statement has, the more likely we are not only to mess up, but to miscommunicate our intent to the maintenance programmer.

=CN Testing Files The Code To Test Things Like File 存在 And File Size Is Simple, But The More Code We Write, And The More 部分 Each Code Statement Has, The More Likely We Are Not Only To 肮脏 Up, But To miscommunicate Our 意图 To The 保养 Programmer.

=EN We could test for file existence very easily.

=CN We Could Test For File 存在 Very 容易地.

=EN We use the -e file test operator in the ok( ) function from Test::More.

=CN We Use The -g File Test Operator In The Ok( ) Function From Test::More.

=EN That works just fine.

=CN That Works Just Fine.

=EN use Test::More 'no_plan';

=CN Use Test::More 'no_plan';

=EN ok( -e 'minnow.db' );

=CN Ok( -g 'minnow.db' );

=EN Well, it works just fine if that's what we meant to test, but nothing in that code tells anyone what we meant to do.

=CN Well, It Works Just Fine If That's What We 意味着 To Test, But Nothing In That Code 告诉 无论谁 What We 意味着 To Do.

=EN What if we wanted to ensure the file did not exist before we started testing?

=CN What If We 想要 To Ensure The File Did Not Exist Before We 开始 testing?

=EN The code for that is a difference of one character.

=CN The Code For That Is a Difference Of One Character.

=EN ok( ! -e 'minnow.db' );

=CN Ok( ! -g 'minnow.db' );

=EN We could add a code comment, but as you probably already know, most code comments seem to assume that you already know what's supposed to happen.

=CN We Could 增添 a Code Comment, But As You Probably Already Know, Most Code comments 好象 To 假定 That You Already Know What's 应该 To 发生.

=EN Does this comment let you know which of the two situations we want?

=CN Does This Comment Let You Know Which Of The Two 情况 We Want?

=EN Should we pass the test if the file is there?

=CN Should We Pass The Test If The File Is There?

=EN # test if the file is there ok( ! -e 'minnow.db' );

=CN # Test If The File Is There Ok( ! -g 'minnow.db' );

=EN The Test::File module, written by brian, encapsulates intent in the name of the function.

=CN The Test::File Module, Written By brian, encapsulates 意图 In The Name Of The Function.

=EN If we want the test to pass when the file is there, we use file_exists_ok.

=CN If We Want The Test To Pass When The File Is There, We Use file_exists_ok.

=EN use Test::More 'no_plan'; use Test::File;

=CN Use Test::More 'no_plan'; Use Test::File;

=EN If we want the test to pass when the file is not there, we use file_not_exists_ok.

=CN If We Want The Test To Pass When The File Is Not There, We Use file_not_exists_ok.

=EN That's a simple example, but the module has many other functions that follow the same naming scheme: the first part of the name tells you what the function checks (file_exists) and the last part tells you what happens if that's true (_ok).

=CN That's a Simple Example, But The Module Has Many Other Functions That 跟随 The Same Naming 计划: The First Part Of The Name 告诉 You What The Function 检查 (file_exists) And The Last Part 告诉 You What Happens If That's True (_ok).

=EN It's a lot harder to miscommunicate the intent when we have to type it out.

=CN It's a 许多 Harder To miscommunicate The 意图 When We Have To Type It Out.

=EN my $file = 'minnow.db';

=CN My $File = 'minnow.db';

=EN file_exists_ok( $file ); file_not_empty_ok( $file ); file_readable_ok( $file ); file_min_size_ok( $file, 500 ); file_mode_is( $file, 0775 );

=CN file_exists_ok( $File ); file_not_empty_ok( $File ); file_readable_ok( $File ); file_min_size_ok( $File, 500 ); file_mode_is( $File, 0775 );

=EN So, not only do the explicit function names communicate intent, but they also contribute to parallel structure in the code.

=CN So, Not Only Do The 清楚的 Function Names 传播 意图, But They Also 捐献 To 平行的 Structure In The Code.

=EN Testing STDOUT or STDERR One advantage to using the ok( ) functions (and friends) is that they don't write to STDOUT directly, but to a filehandle secretly duplicated from STDOUT when our test script begins.

=CN Testing STDOUT Or STDERR One 优点 To Using The Ok( ) Functions (And 朋友) Is That They Don't Write To STDOUT 直接地, But To a Filehandle secretly duplicated From STDOUT When Our Test 临时单据 begins.

=EN If we don't change STDOUT in our program, of course, this is a moot point.

=CN If We Don't Change STDOUT In Our Program, Of Course, This Is a moot 尖.

=EN But let's say we wanted to test a routine that writes something to STDOUT, such as making sure a horse eats properly:

=CN But Let's Say We 想要 To Test a Routine That 写 Something To STDOUT, Such As 制作 Sure a 马 Eats Properly:

=EN use Test::More 'no_plan'; use_ok 'Horse'; isa_ok(my $trigger = Horse->named('Trigger'), 'Horse');

=CN Use Test::More 'no_plan'; use_ok 'Horse'; isa_ok(My $扳机 = Horse->Named('Trigger'), 'Horse');

=EN open STDOUT, ">test.out" or die "Could not redirect STDOUT! $!"; $trigger->eat("hay"); close STDOUT;

=CN Open STDOUT, ">test.out" Or Die "Could Not redirect STDOUT! $!"; $扳机->吃("干草"); Close STDOUT;

=EN open T, "test.out" or die "Could not read from test.out! $!"; my @contents = <T>; close T; is(join("", @contents), "Trigger eats hay.\n", "Trigger ate properly");

=CN Open T, "test.out" Or Die "Could Not Read From test.out! $!"; My @Contents = <T>; Close T; Is(Join("", @Contents), "Trigger Eats 干草.\n", "Trigger ate Properly");

=EN END { unlink "test.out" } # clean up after the horses

=CN END { unlink "test.out" } # 清洁的 Up After The horses

=EN Note that just before we start testing the eat method, we (re)open STDOUT to our temporary output file.

=CN Note That Just Before We Start testing The 吃 Method, We (Re)Open STDOUT To Our temporary 出产 File.

=EN The output from this method ends up in the test.out file.

=CN The 出产 From This Method Ends Up In The test.out File.

=EN We bring the contents of that file in and give it to the is( ) function.

=CN We 拿来 The Contents Of That File In And Give It To The Is( ) Function.

=EN Even though we've closed STDOUT, the is( ) function can still access the original STDOUT, and thus the test harness sees the proper ok or not ok messages.

=CN Even Though We'Ve 关闭的 STDOUT, The Is( ) Function Can Still Access The Original STDOUT, And 如此 The Test 支配 看到 The 合适的 Ok Or Not Ok Messages.

=EN If you create temporary files like this, please note that your current directory is the same as the test script (even if you're running make test from the parent directory).

=CN If You Create temporary Files Like This, 使高兴 Note That Your Current Directory Is The Same As The Test 临时单据 (Even If You'Re 连续的 Make Test From The 父或母亲 Directory).

=EN Also, pick fairly safe cross-platform names if you want people to be able to use and test your module portably.

=CN Also, 拣 公平地 安全的 十字-讲台 Names If You Want People To Be Able To Use And Test Your Module portably.

=EN There is a better way to do this, though.

=CN There Is a Better Way To Do This, Though.

=EN The Test::Output module can handle this for us.

=CN The Test::Output Module Can Handle This For Us.

=EN This module gives us several functions that automatically take care of all of the details.

=CN This Module Gives Us Several Functions That Automatically Take Care Of All Of The Details.

=EN #!/usr/bin/perl use strict;

=CN #!/usr/bin/Perl Use Strict;

=EN use Test::More "noplan"; use Test::Output;

=CN Use Test::More "noplan"; Use Test::Output;

=EN sub print_hello { print STDOUT "Welcome Aboard!\n" } sub print_error { print STDERR "There's a hole in the ship!\n" }

=CN Sub print_hello { Print STDOUT "Welcome Aboard!\n" } Sub print_error { Print STDERR "There's a 洞 In The 船!\n" }

=EN stderr_like( \&print_error, qr/ship/ );

=CN stderr_like( \&print_error, qr/船/ );

=EN All of the functions take a code reference as their first argument, but that's not a problem because we told you all about those in Chapter 7.

=CN All Of The Functions Take a Code Reference As Their First Argument, But That's Not a Problem Because We told You All About Those In Chapter 7.

=EN If we don't have a subroutine to test, we wrap the code we want to test in a subroutine and use that.

=CN If We Don't Have a Subroutine To Test, We 包 The Code We Want To Test In a Subroutine And Use That.

=EN sub test_this { ...

=CN Sub test_this { ...

=EN If our code is short enough, we might want to skip the step where we define a named subroutine and use an anonymous one.

=CN If Our Code Is 短的 Enough, We Might Want To 跳过 The 脚步 Where We Define a Named Subroutine And Use An Anonymous One.

=EN stdout_is( sub { print "Welcome Aboard" }, "Welcome Aboard" );

=CN stdout_is( Sub { Print "Welcome Aboard" }, "Welcome Aboard" );

=EN We can even use an inline block of code, like we did with grep and map.

=CN We Can Even Use An inline Block Of Code, Like We Did With Grep And Map.

=EN As with those two list operators, notice that we don't have a comma after the inline code block.

=CN As With Those Two List Operators, Notice That We Don't Have a 逗号 After The inline Code Block.

=EN stdout_is { print "Welcome Aboard" } "Welcome Aboard";

=CN stdout_is { Print "Welcome Aboard" } "Welcome Aboard";

=EN Besides Test::Output, we can do something similar with Test::Warn, which specifically tests warning output.

=CN Besides Test::Output, We Can Do Something Similar With Test::Warn, Which 特别 测试 Warning 出产.

=EN Its interface uses the inline block form exclusively.

=CN Its Interface Uses The inline Block Form 独占地.

=EN use Test::More "noplan"; use Test::Warn;

=CN Use Test::More "noplan"; Use Test::Warn;

=EN sub add_letters { "Skipper" + "Gilligan" }

=CN Sub add_letters { "Skipper" + "Gilligan" }

=EN warning_like { add_letters( ) }, qr/non-numeric/;

=CN warning_like { add_letters( ) }, qr/Non-数值/;

=EN We all strive to make our code warning-free, and we can test for that too.

=CN We All 努力 To Make Our Code Warning-Free, And We Can Test For That Too.

=EN Perl warnings can change from version to version, and we want to know when the new warnings pop up, or if Perl will emit warnings on one of our customer's computers.

=CN Perl 警告 Can Change From Version To Version, And We Want To Know When The New 警告 Pop Up, Or If Perl Will 发射 警告 On One Of Our 顾客's computers.

=EN The Test::NoWarnings module is a bit different from the ones we've already shown.

=CN The Test::NoWarnings Module Is a Bit Different From The Ones We'Ve Already shown.

=EN It automatically adds a test just by loading the module, and we just have to ensure we add the hidden test to the count we give to Test::More.

=CN It Automatically Adds a Test Just By loading The Module, And We Just Have To Ensure We 增添 The Hidden Test To The 计算 We Give To Test::More.

=EN #!/usr/bin/perl use warnings;

=CN #!/usr/bin/Perl Use 警告;

=EN use Test::More tests => 1; use Test::NoWarnings;

=CN Use Test::More 测试 => 1; Use Test::NoWarnings;

=EN my( $n, $m ); # let's use an uninitialized value my $sum = $n + $m;

=CN My( $n, $m ); # Let's Use An 未初始化的 Value My $总数 = $n + $m;

=EN When we try to compute the sum, we use two variables to which we haven't given values.

=CN When We Try To 计算 The 总数, We Use Two Variables To Which We 还't Given Values.

=EN That triggers the annoying "use of uninitialized value" warning (ensure you have warnings turned on!).

=CN That triggers The annoying "Use Of 未初始化的 Value" Warning (Ensure You Have 警告 转 On!).

=EN We don't want those sorts of things filling up our logfiles, now, do we?

=CN We Don't Want Those 各样 Of Things Filling Up Our logfiles, Now, Do We?

=EN Test::NoWarnings tells us when that happens so we can fix it.

=CN Test::NoWarnings 告诉 Us When That Happens So We Can 固定 It.

=EN 1..1 not ok 1 - no warnings # Failed test 'no warnings' # in /usr/local/lib/perl5/5.8.7/Test/NoWarnings.pm at line 45. # There were 2 warning(s) # Previous test 0 '' # Use of uninitialized value in addition (+) at nowarnings.pl line 6. # # ---------- # Previous test 0 '' # Use of uninitialized value in addition (+) at nowarnings.pl line 6. # # Looks like you failed 1 test of 1 run.

=CN 1..1 Not Ok 1 - No 警告 # Failed Test 'No 警告' # In /usr/Local/lib/perl5/5.8.7/Test/NoWarnings.pm At Line 45. # There Were 2 warning(s) # Previous Test 0 '' # Use Of 未初始化的 Value In 增加 (+) At nowarnings.pl Line 6. # # ---------- # Previous Test 0 '' # Use Of 未初始化的 Value In 增加 (+) At nowarnings.pl Line 6. # # Looks Like You failed 1 Test Of 1 Run.

=EN Using Mock Objects Sometimes we don't want to ramp up the entire system to test only parts of it.

=CN Using Mock Objects Sometimes We Don't Want To ramp Up The 完全的 System To Test Only 部分 Of It.

=EN We can be fairly certain, or at least assume, that other parts of the system work.

=CN We Can Be 公平地 确信的, Or At Least 假定, That Other 部分 Of The System Work.

=EN We don't need to open expensive database connections or instantiate objects with large memory footprints to test every part of the code.

=CN We Don't Need To Open Expensive database connections Or 被实例化 Objects With Large Memory footprints To Test Every Part Of The Code.

=EN The Test::MockObject module creates "pretend" objects.

=CN The Test::MockObject Module Creates "假装" Objects.

=EN We give it information about the part of the object's interface we want to use, and it pretends to be that part of the interface.

=CN We Give It Information About The Part Of The Object's Interface We Want To Use, And It pretends To Be That Part Of The Interface.

=EN Basically, the pretend method has to return the right thing when we call it, and it doesn't have to do any processing.

=CN Basically, The 假装 Method Has To Return The Right Thing When We Call It, And It Doesn't Have To Do Any 加工（的）.

=EN Instead of creating a real Minnow object, which would mean turning on all sorts of things on the boat, we can create a mock object for it.

=CN Instead Of Creating a Real Minnow Object, Which Would Mean Turning On All 各样 Of Things On The 小船, We Can Create a 嘲笑 Object For It.

=EN Once we create the mock object and store it in $Minnow, we tell it how to respond to the methods we need to call.

=CN Once We Create The 嘲笑 Object And 商店 It In $Minnow, We Tell It How To 答复 To The Methods We Need To Call.

=EN In this case, we tell the mock object to return true for engines_on and to return false for moored_to_dock.

=CN In This Case, We Tell The 嘲笑 Object To Return True For engines_on And To Return False For moored_to_dock.

=EN We're not really testing the object for the ship, but we want to test our quartermaster object, which takes a ship as an argument.

=CN We'Re Not Really testing The Object For The 船, But We Want To Test Our quartermaster Object, Which Takes a 船 As An Argument.

=EN Rather than test the quartermaster with a real ship, we use our mock one.

=CN Rather Than Test The quartermaster With a Real 船, We Use Our 嘲笑 One.

=EN use Test::More 'no_plan'; use Test::MockObject;

=CN Use Test::More 'no_plan'; Use Test::MockObject;

=EN # my $Minnow = Real::Object::Class->new( ... ); my $Minnow = Test::MockObject->new( );

=CN # My $Minnow = Real::Object::Class->New( ... ); My $Minnow = Test::MockObject->New( );

=EN ok( $Minnow->engines_on, "Engines are on" ); ok( ! $Minnow->moored_to_dock, "Not moored to the dock" );

=CN Ok( $Minnow->engines_on, "Engines Are On" ); Ok( ! $Minnow->moored_to_dock, "Not moored To The 码头" );

=EN my $Quartermaster = Island::Plotting->new(

=CN My $Quartermaster = Island::Plotting->New(

=EN ok( $Quartermaster->has_maps, "We can find the maps" );

=CN Ok( $Quartermaster->has_maps, "We Can 寻找 The 地图" );

=EN We can create more complex methods that do anything we like.

=CN We Can Create More 综合的 Methods That Do Anything We Like.

=EN Suppose, instead of methods that return true or false, we need one that returns a list.

=CN Suppose, Instead Of Methods That Return True Or False, We Need One That Returns a List.

=EN Perhaps we need to pretend to connect to a database and retrieve some records.

=CN Perhaps We Need To 假装 To 连接 To a database And retrieve Some Records.

=EN As we're developing, we might try this several times and we'd rather not connect and disconnect from the real database every time we try to track down a bug.

=CN As We'Re 发展中的, We Might Try This Several Times And We'd Rather Not 连接 And disconnect From The Real database Every Time We Try To 径赛 向下 a 臭虫.

=EN In this example, we mock the database method list_names, which we know will return us three names.

=CN In This Example, We 嘲笑 The database Method list_names, Which We Know Will Return Us Three Names.

=EN Since we already know this, and we're actually testing something else (which we don't show you in this contrived example), it doesn't bother us to create the mock method that stands in place of the real database.

=CN Since We Already Know This, And We'Re Actually testing Something Else (Which We Don't Show You In This contrived Example), It Doesn't 打扰 Us To Create The 嘲笑 Method That Stands In Place Of The Real database.

=EN my $db = Test::MockObject->new( );

=CN My $db = Test::MockObject->New( );

=EN # $db = DBI->connect( ... ); $db->mock(

=CN # $db = DBI->连接( ... ); $db->嘲笑(

=EN my @names = $db->list_names;

=CN My @Names = $db->list_names;

=EN is( scalar @names, 3, 'Got the right number of results' ); is( $names[0], 'Gilligan', 'The first result is Gilligan' );

=CN Is( Scalar @Names, 3, 'Got The Right Number Of Results' ); Is( $Names[0], 'Gilligan', 'The First Result Is Gilligan' );

=EN print "The names are @names\n";

=CN Print "The Names Are @Names\n";

=EN Testing POD We can even test things that aren't code.

=CN Testing POD We Can Even Test Things That 还't Code.

=EN Documentation is just as important as code, since other people can't use our perfect, lovely code unless they know what to do with it.

=CN 文档 Is Just As Important As Code, Since Other People Can't Use Our 完美的, 好看的 Code Unless They Know What To Do With It.

=EN As we mentioned in Chapter 16, the Perl way to document code is by embedding POD formatted text in the code.

=CN As We Mentioned In Chapter 16, The Perl Way To Document Code Is By embedding POD formatted 正文 In The Code.

=EN Tools such as perldoc can extract the POD and display it in a variety of formats.

=CN Tools Such As perldoc Can 取出 The POD And 陈列 It In a 多样（性） Of Formats.

=EN What if we mess up the POD format so that formatters can't parse it as we intended?

=CN What If We 肮脏 Up The POD Format So That formatters Can't Parse It As We 预期?

=EN To solve this problem, brian wrote Test::Pod to go through his modules looking for POD errors.[*] For most things, we can take the entire test code from the Test::Pod documentation.

=CN To 解答 This Problem, brian 写 Test::Pod To Go 通过 他的 Modules 看 For POD Errors.[*] For Most Things, We Can Take The 完全的 Test Code From The Test::Pod 提供文件.

=EN [*] It's now maintained by Andy Lester and is so popular that it's become part of Module::Starter and the CPAN Testers Service's (CPANTS) Kwalitee rating.

=CN [*] It's Now maintained By Andy Lester And Is So 受欢迎的 That It's 变成 Part Of Module::Starter And The Perl综合典藏网 Testers Service's (Perl综合典藏网TS) Kwalitee 评级.

=EN use Test::More; eval "use Test::Pod 1.00"; plan skip_all => "Test::Pod 1.00 required for testing

=CN Use Test::More; Eval "Use Test::Pod 1.00"; 计划平面图 skip_all => "Test::Pod 1.00 要求 For testing

=EN We don't want to require everyone to install the module though, so the suggested test code first checks if we can load the module by using the string form of eval that we told you about in Chapter 2.

=CN We Don't Want To Require Everyone To 安装 The Module Though, So The 建议 Test Code First 检查 If We Can Load The Module By Using The String Form Of Eval That We told You About In Chapter 2.

=EN If that fails, eval sets the error variable $@, and once that is set, we tell Test::More to skip the rest of the tests.

=CN If That 失败, Eval Sets The Error Variable $@, And Once That Is Set, We Tell Test::More To 跳过 The 休息 Of The 测试.

=EN If we've installed the module, however, we'll get past the skip_all check and run all_pod_files_ok.

=CN If We'Ve 安装 The Module, However, We'我 Get 过去的 The skip_all Check And Run all_pod_files_ok.

=EN The module takes care of finding all the POD files, which it then checks for format.

=CN The Module Takes Care Of 发现 All The POD Files, Which It Then 检查 For Format.

=EN If we want to change which files it checks, we can do that too.

=CN If We Want To Change Which Files It 检查, We Can Do That Too.

=EN Without arguments, all_pod_files_ok TRies to find files in the usual places.

=CN Without Arguments, all_pod_files_ok TRies To 寻找 Files In The 通常的 Places.

=EN With arguments, it only tests the files we tell it to test.

=CN With Arguments, It Only 测试 The Files We Tell It To Test.

=EN use Test::More; eval "use Test::Pod 1.00"; plan skip_all => "Test::Pod 1.00 required for testing POD" if $@; all_pod_files_ok( 'lib/Maps.pm' );

=CN Use Test::More; Eval "Use Test::Pod 1.00"; 计划平面图 skip_all => "Test::Pod 1.00 要求 For testing POD" If $@; all_pod_files_ok( 'lib/Maps.pm' );

=EN Testing the POD format isn't all we can do, though.

=CN Testing The POD Format Isn't All We Can Do, Though.

=EN What if we want to ensure that we documented all of our methods?

=CN What If We Want To Ensure That We Documented All Of Our Methods?

=EN It's Test::Pod::Coverage to the rescue.

=CN It's Test::Pod::Coverage To The 救援.

=EN It goes through our embedded documentation and tells us which subroutine names don't have corresponding entries in the documentation.

=CN It 去 通过 Our embedded 提供文件 And 告诉 Us Which Subroutine Names Don't Have 相应的 Entries In The 提供文件.

=EN The example use looks almost the same as that for Test::Pod.[*]

=CN The Example Use Looks Almost The Same As That For Test::Pod.[*]

=EN [*] That's because Andy Lester wrote both examples.

=CN [*] That's Because Andy Lester 写 Both Examples.

=EN use Test::More; eval "use Test::Pod::Coverage"; plan skip_all =>

=CN Use Test::More; Eval "Use Test::Pod::Coverage"; 计划平面图 skip_all =>

=EN Both of these modules can do more than what we've shown you, so check their documentation to get the full story.

=CN Both Of These Modules Can Do More Than What We'Ve shown You, So Check Their 提供文件 To Get The Full 故事.

=EN If you use Module::Starter that we talked about in Chapter 16, you'll probably already have these tests in your distribution.

=CN If You Use Module::Starter That We 谈了 About In Chapter 16, You'我 Probably Already Have These 测试 In Your 分配.

=EN Coverage Testing We can also test our testing.

=CN Coverage Testing We Can Also Test Our testing.

=EN In a perfect world, we'd test our program with every possible input and environment so that our program follows every particular path.

=CN In a 完美的 World, We'd Test Our Program With Every Possible Input And 环境 So That Our Program Follows Every Particular Path.

=EN That's certainly what the Professor would do.

=CN That's Certainly What The Professor Would Do.

=EN In reality, we tend to be more like Gilligan, though.

=CN In 现实, We 趋向 To Be More Like Gilligan, Though.

=EN We won't go too deeply into the theory and practice of coverage tests, but there are many things that we can test.

=CN We Won't Go Too Deeply Into The 理论 And Practice Of 覆盖率 测试, But There Are Many Things That We Can Test.

=EN Statement coverage tells us how many of the statements in our code we execute during a run.

=CN Statement 覆盖率 告诉 Us How Many Of The Statements In Our Code We Execute 在 a Run.

=EN Branch coverage tells us how many of the decision paths we actually follow.

=CN Branch 覆盖率 告诉 Us How Many Of The 决定 paths We Actually 跟随.

=EN Path coverage, expression coverage, and other sorts of coverage exist too.

=CN Path 覆盖率, Expression 覆盖率, And Other 各样 Of 覆盖率 Exist Too.

=EN The best starting point is the Devel::Coverage::Tutorial documentation.

=CN The Best Starting 尖 Is The Devel::Coverage::Tutorial 提供文件.

=EN The module comes with a program named cover, which handles most of the things that we need to do.

=CN The Module 来 With a Program Named 盖, Which 处理 Most Of The Things That We Need To Do.

=EN For any particular program we want to measure, we simply load the Devel::Cover module when we run it.

=CN For Any Particular Program We Want To 尺寸, We Simply Load The Devel::Cover Module When We Run It.

=EN $ perl -MDevel::Cover yourprog args $ cover

=CN $ Perl -MDevel::Cover yourprog Args $ 盖

=EN After we finish running the program, Devel::Cover leaves behind a file with all of the information it collected.

=CN After We 结束 连续的 The Program, Devel::Cover 叶子 在 a File With All Of The Information It collected.

=EN Running the cover command turns that information into a set of HTML pages.

=CN Running The 盖 命令 Turns That Information Into a Set Of HTML 页.

=EN When we look at the coverage.html page, we see a summary of our project along with its coverage statistics.

=CN When We Look At The coverage.html 页, We See a 概要 Of Our 计划 沿着 With Its 覆盖率 统计（学）.

=EN The links on that page drill down into the individual files to see their coverage statistics too.

=CN The 链接 On That 页 钻头 向下 Into The Individual Files To See Their 覆盖率 统计（学） Too.

=EN If we want to test a distribution, we just do this at the same time that we run our test suite.

=CN If We Want To Test a 分配, We Just Do This At The Same Time That We Run Our Test 随员.

=EN First, we get rid of any previous coverage results by passing cover the -delete option.

=CN First, We Get 使摆脱 Of Any Previous 覆盖率 Results By Passing 盖 The -Delete 选择.

=EN After that, we have to run our make test and get Devel::Cover to do its magic at the same time.

=CN After That, We Have To Run Our Make Test And Get Devel::Cover To Do Its Magic At The Same Time.

=EN We can set the testing harness switches with the HARNESS_PERL_SWITCHES environment variable, in which we put the -MDevel::Cover we used on the command line previously.

=CN We Can Set The testing 支配 Switches With The HARNESS_PERL_SWITCHES 环境 Variable, In Which We Put The -MDevel::Cover We Used On The 命令 Line Previously.

=EN Now every time the test harness wants to invoke Perl (which is for every test file), it also loads Devel::Cover.

=CN Now Every Time The Test 支配 要 To 调用 Perl (Which Is For Every Test File), It Also loads Devel::Cover.

=EN As that script runs, it adds to the coverage database (which is why we deleted the database before we started).

=CN As That 临时单据 跑, It Adds To The 覆盖率 database (Which Is Why We Deleted The database Before We 开始).

=EN Finally, once we've finished going through the tests, we call cover again to turn the results into something we can read.

=CN Finally, Once We'Ve 制成的 Going 通过 The 测试, We Call 盖 Again To 转向 The Results Into Something We Can Read.

=EN $ cover -delete $ HARNESS_PERL_SWITCHES=-MDevel::Cover make test $ cover

=CN $ 盖 -Delete $ HARNESS_PERL_SWITCHES=-MDevel::Cover Make Test $ 盖

=EN Everything shows up in a directory named cover_db in the current working directory.

=CN Everything Shows Up In a Directory Named cover_db In The Current Working Directory.

=EN The coverage database shows up in cover_db, and the top-level page shows up in cover_db/coverage.html.

=CN The 覆盖率 database Shows Up In cover_db, And The 顶-Level 页 Shows Up In cover_db/coverage.html.

=EN Writing Your Own Test::* Modules You don't have to wait for other people to write cool test modules.

=CN Writing Your Own Test::* Modules You Don't Have To 等候 For Other People To Write 凉的 Test Modules.

=EN If you have a particular testing situation that you'd like to wrap up in a test function, you can write your own Test::* module using the Test::Builder module, which handles all of the tricky integration with Test::Harness and Test::More.

=CN If You Have a Particular testing 形势 That You'd Like To 包 Up In a Test Function, You Can Write Your Own Test::* Module Using The Test::Builder Module, Which 处理 All Of The 巧妙的 结合 With Test::Harness And Test::More.

=EN If you look behind the scenes of many of the Test::* modules, you'll find Test::Builder.

=CN If You Look 在 The scenes Of Many Of The Test::* Modules, You'我 寻找 Test::Builder.

=EN Again, the advantage to test functions is that they wrap reusable code in a function name.

=CN Again, The 优点 To Test Functions Is That They 包 reusable Code In a Function Name.

=EN To test something, you use the function name rather than typing out a bunch of separate statements.

=CN To Test Something, You Use The Function Name Rather Than 打字 Out a 一束 Of Separate Statements.

=EN It's easy for people to understand what you meant to test based on a single function name, but that gets harder as you write out several statements to do the same thing.

=CN It's Easy For People To Understand What You 意味着 To Test 基于 On a Single Function Name, But That Gets Harder As You Write Out Several Statements To Do The Same Thing.

=EN In Chapter 4, we wrote some code to check that the castaways had all of their required items.

=CN In Chapter 4, We 写 Some Code To Check That The castaways Had All Of Their 要求 物品.

=EN Let's turn that into a Test::* module.

=CN Let's 转向 That Into a Test::* Module.

=EN Here's the check_required_items subroutine as we left it:

=CN Here's The check_required_items Subroutine As We Left It:

=EN sub check_required_items {

=CN Sub check_required_items {

=EN  # not found in list?

=CN  # Not Found In List?

=EN We need to turn this into a Test::* module that simply checks the items (so it doesn't add the missing ones) and then outputs the right thing.

=CN We Need To 转向 This Into a Test::* Module That Simply 检查 The 物品 (So It Doesn't 增添 The Missing Ones) And Then outputs The Right Thing.

=EN The basics for any new testing module are the same.

=CN The basics For Any New testing Module Are The Same.

=EN We call our new module Test::Minnow::RequiredItems and start with this stub:

=CN We Call Our New Module Test::Minnow::RequiredItems And Start With This 存根:

=EN package Test::Minnow::RequiredItems; use strict;

=CN Package Test::Minnow::RequiredItems; Use Strict;

=EN use base qw(Exporter); use vars qw(@EXPORT $VERSION);

=CN Use Base qw(Exporter); Use Vars Qw(@EXPORT $VERSION);

=EN use Test::Builder;

=CN Use Test::Builder;

=EN my $Test = Test::Builder->new( );

=CN My $Test = Test::Builder->New( );

=EN sub check_required_items_ok {

=CN Sub check_required_items_ok {

=EN We start by declaring the package, then turning on strictures because we want to be good programmers (even if this three-hour tour is ultimately doomed, it won't be from one of our software errors).

=CN We Start By 宣布 The Package, Then Turning On 狭窄 Because We Want To Be Good Programmers (Even If This Three-小时 旅行 Is 最后 doomed, It Won't Be From One Of Our 软件 Errors).

=EN We pull in the Exporter module and add required_items_ok to @EXPORT, since we want that function to show in the calling namespace, just as we discussed in Chapter 15.

=CN We 拖 In The Exporter Module And 增添 required_items_ok To @EXPORT, Since We Want That Function To Show In The Calling Namespace, Just As We 讨论 In Chapter 15.

=EN We set $VERSION just like we discussed in Chapter 16.

=CN We Set $VERSION Just Like We 讨论 In Chapter 16.

=EN The only stuff we haven't shown you is Test::Builder.

=CN The Only 材料 We 还't shown You Is Test::Builder.

=EN At the beginning of our test module, we create a new Test::Builder object that we assign to the lexical variable $Test, which is scoped to the entire file.[*]

=CN At The 开端 Of Our Test Module, We Create a New Test::Builder Object That We Assign To The Lexical Variable $Test, Which Is Scoped To The 完全的 File.[*]

=EN [*] It's almost like a global variable, except it doesn't live in a package and can't be seen outside its file.

=CN [*] It's Almost Like a Global Variable, Except It Doesn't 居住生存 In a Package And Can't Be Seen Outside Its File.

=EN The $Test object is going to handle all of the testing details for us.

=CN The $Test Object Is Going To Handle All Of The testing Details For Us.

=EN We remove all of the output parts from check_required_items, and we take out the parts to modify the input list.

=CN We 移开 All Of The 出产 部分 From check_required_items, And We Take Out The 部分 To Modify The Input List.

=EN Once we go through the other logic, the only thing we need to do at the end is tell the test harness if the test is ok or not_ok.

=CN Once We Go 通过 The Other 逻辑, The Only Thing We Need To Do At The End Is Tell The Test 支配 If The Test Is Ok Or not_ok.

=EN Now we have to add the parts to turn our function into a testing one.

=CN Now We Have To 增添 The 部分 To 转向 Our Function Into a testing One.

=EN We call methods on $Test to tell the test harness what happened.

=CN We Call Methods On $Test To Tell The Test 支配 What Happened.

=EN In each case, the last evaluated expression should be a call to $Test->ok( ), so that becomes the return value of the entire function.[*] If we discovered missing items, we want the test to fail, so we pass a false value to $Test->ok( ), but before we do that we use $Test->diag( ) with a message to tell us what went wrong.

=CN In Each Case, The Last 评估 Expression Should Be a Call To $Test->Ok( ), So That Becomes The Return Value Of The 完全的 Function.[*] If We discovered Missing 物品, We Want The Test To 失败, So We Pass a False Value To $Test->Ok( ), But Before We Do That We Use $Test->diag( ) With a 音讯 To Tell Us What 去 错误的.

=EN [*] We often don't use the return value since most people call most test functions in a void context, but we might as well return something that makes sense.

=CN [*] We Often Don't Use The Return Value Since Most People Call Most Test Functions In a Void Context, But We Might As Well Return Something That 使 Sense.

=EN That's it.

=CN That's It.

=EN Although there are more things that we can do, there isn't more that we have to do.

=CN Although There Are More Things That We Can Do, There Isn't More That We Have To Do.

=EN Once we save our Test::Minnow::RequiredItems, we can use it immediately in a test script.

=CN Once We Save Our Test::Minnow::RequiredItems, We Can Use It 立即 In a Test 临时单据.

=EN We still use Test::More to set the plan.[*]

=CN We Still Use Test::More To Set The 计划平面图.[*]

=EN [*] We could do that from our module, but most likely the test script will use other modules too.

=CN [*] We Could Do That From Our Module, But Most Likely The Test 临时单据 Will Use Other Modules Too.

=EN Only one of them can set the plan, so we let Test::More handle that.

=CN Only One Of Them Can Set The 计划平面图, So We Let Test::More Handle That.

=EN use Test::More 'no_plan'; use Test::Minnow::RequiredItems;

=CN Use Test::More 'no_plan'; Use Test::Minnow::RequiredItems;

=EN my @gilligan = (

=CN My @gilligan = (

=EN Since Gilligan doesn't have all of his required items, the test fails.

=CN Since Gilligan Doesn't Have All Of 他的 要求 物品, The Test 失败.

=EN It prints the not_ok along with the diagnostic message.

=CN It Prints The not_ok 沿着 With The 诊断 音讯.

=EN not ok 1 1..1 # Gilligan needs preserver sunscreen jacket. # Failed test (/Users/Ginger/Desktop/package_test.pl at line 49) # Looks like you failed 1 test of 1.

=CN Not Ok 1 1..1 # Gilligan Needs preserver sunscreen 短外套. # Failed Test (/Users/Ginger/Desktop/package_test.pl At Line 49) # Looks Like You failed 1 Test Of 1.

=EN And, now that we've created the Test::Minnow::RequiredItems module, how we do we test the test?

=CN And, Now That We'Ve Created The Test::Minnow::RequiredItems Module, How We Do We Test The Test?

=EN We can use the Test::Builder::Tester module.

=CN We Can Use The Test::Builder::Tester Module.

=EN You'll have to investigate that one yourself, though.

=CN You'我 Have To 调查 That One 你（们）自己, Though.

=EN Exercises You can find the answers to these exercises in "Answers for Chapter 18" in the Appendix.

=CN Exercises You Can 寻找 The answers To These exercises In "Answers For Chapter 18" In The Appendix.

=EN Exercise 1 [20 min] Document the My::List::Util module you created in the exercise for Chapter 17.

=CN Exercise 1 [20 min] Document The My::List::Util Module You Created In The 锻炼 For Chapter 17.

=EN Add a test for the POD documentation using Test::Pod.

=CN Add a Test For The POD 提供文件 Using Test::Pod.

=EN Exercise 2 [20 min] Write your own test module, Test::My::List::Util, that has a single test function, sum_ok, which takes two arguments: the actual sum and the expected sum.

=CN Exercise 2 [20 min] Write Your Own Test Module, Test::My::List::Util, That Has a Single Test Function, sum_ok, Which Takes Two Arguments: The Actual 总数 And The Expected 总数.

=EN Print a diagnostic message if the two do not match.

=CN Print a 诊断 音讯 If The Two Do Not Match.

=EN my $sum = sum( 2, 2 ); sum_ok( $sum, 4 );

=CN My $总数 = 总数( 2, 2 ); sum_ok( $总数, 4 );

