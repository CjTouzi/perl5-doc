=EN Introduction to Objects Object-oriented programming (OOP) helps programmers run code sooner and maintain it easier by organizing the code into things that we can name.

=CN Introduction To Objects Object-Oriented Programming (OOP) 帮助 Programmers Run Code sooner And Maintain It Easier By organizing The Code Into Things That We Can Name.

=EN We need a little more infrastructure to get going with objects, but in the long run, it's worth it.

=CN We Need a Little More infrastructure To Get Going With Objects, But In The Long Run, It's worth It.

=EN The benefits of OOP become worthwhile when our program (including all external libraries and modules) exceeds about N lines of code.

=CN The 效益 Of OOP 变成 值得做的 When Our Program (Including All External 库 And Modules) exceeds About N Lines Of Code.

=EN Unfortunately, nobody can agree on what the value of N is, but for Perl programs, it's arguably around 1, 000 lines of code.

=CN Unfortunately, 谁也不 Can 同意 On What The Value Of N Is, But For Perl Programs, It's arguably Around 1, 000 Lines Of Code.

=EN If our whole program is only a couple hundred lines of code, using objects is probably overkill.

=CN If Our Whole Program Is Only a 一对 hundred Lines Of Code, Using Objects Is Probably overkill.

=EN Like references, Perl's object architecture was grafted on after a substantial amount of existing pre-Perl 5 code was already in use, so we had to ensure that it wouldn't break existing syntax.

=CN Like References, Perl's Object 建筑学 Was grafted On After a 可观的 数量 Of 现存的 Pre-Perl 5 Code Was Already In Use, So We Had To Ensure That It Wouldn't 打破 现存的 Syntax.

=EN Amazingly, the only additional syntax to achieve object nirvana is the method call, introduced shortly.

=CN Amazingly, The Only Additional Syntax To Achieve Object nirvana Is The Method Call, Introduced 立刻.

=EN But the meaning of that syntax requires a bit of study, so let's proceed.

=CN But The Meaning Of That Syntax Requires a Bit Of Study, So Let's 前进.

=EN The Perl object architecture relies heavily on packages, subroutines, and references, so if you're skipping around in this book, please go back to the beginning.

=CN The Perl Object 建筑学 relies 重 On Packages, Subroutines, And References, So If You'Re skipping Around In This 书, 使高兴 Go Back To The 开端.

=EN Here we go.

=CN Here We Go.

=EN If We Could Talk to the Animals...

=CN If We Could Talk To The Animals...

=EN Obviously, the castaways can't survive on coconuts and pineapples alone.

=CN Obviously, The castaways Can't 幸免于 On coconuts And pineapples 单独的.

=EN Luckily for them, a barge carrying random farm animals crashed on the island not long after they arrived, and the castaways began farming and raising animals.

=CN Luckily For Them, a 驳船 carrying 胡乱的 农场 animals crashed On The 岛屿 Not Long After They arrived, And The castaways began 农业 And raising animals.

=EN Let's listen to those animals for a moment:

=CN Let's 听 To Those animals For a Moment:

=EN sub Cow::speak {

=CN Sub Cow::说话 {

=EN Cow::speak; Horse::speak; Sheep::speak;

=CN Cow::说话; Horse::说话; Sheep::说话;

=EN This results in:

=CN This Results In:

=EN a Cow goes moooo! a Horse goes neigh! a Sheep goes baaaah!

=CN a Cow 去 moooo! a Horse 去 neigh! a Sheep 去 baaaah!

=EN Nothing spectacular here: simple subroutines, albeit from separate packages, and called using the full package name.

=CN Nothing 壮观的 Here: Simple Subroutines, 虽然 From Separate Packages, And Called Using The Full Package Name.

=EN Let's create an entire pasture:

=CN Let's Create An 完全的 牧场:

=EN my @pasture = qw(Cow Cow Horse Sheep Sheep); foreach my $beast (@pasture) {

=CN My @牧场 = Qw(Cow Cow Horse Sheep Sheep); Foreach My $野兽 (@牧场) {

=EN a Cow goes moooo! a Cow goes moooo! a Horse goes neigh! a Sheep goes baaaah! a Sheep goes baaaah!

=CN a Cow 去 moooo! a Cow 去 moooo! a Horse 去 neigh! a Sheep 去 baaaah! a Sheep 去 baaaah!

=EN That symbolic coderef dereferencing there in the body of the loop is pretty nasty.

=CN That Symbolic coderef dereferencing There In The 身体 Of The Loop Is 精致的 肮脏的.

=EN We're counting on no strict 'refs' mode, certainly not recommended for larger programs.[*] And why was that necessary?

=CN We'Re counting On No Strict '裁判' 方式, Certainly Not recommended For larger Programs.[*] And Why Was That 必要的?

=EN Because the name of the package seems inseparable from the name of the subroutine we want to invoke within that package.

=CN Because The Name Of The Package 似乎 inseparable From The Name Of The Subroutine We Want To 调用 Within That Package.

=EN [*] Although all examples in this book should be valid Perl code, some examples in this chapter will break the rules enforced by use strict to make them easier to understand.

=CN [*] Although All Examples In This 书 Should Be Valid Perl Code, Some Examples In This 章 Will 打破 The 规则 enforced By Use Strict To Make Them Easier To Understand.

=EN By the end of the chapter, though, we'll show how to make strict-compliant code again.

=CN By The End Of The 章, Though, We'我 Show How To Make Strict-柔顺 Code Again.

=EN Or is it?

=CN Or Is It?

=EN Introducing the Method Invocation Arrow A class is a group of things with similar behaviors and traits.

=CN Introducing The Method Invocation Arrow A Class Is a Group Of Things With Similar Behaviors And 特征.

=EN For now, let's say that Class->method invokes subroutine method in package Class.

=CN For Now, Let's Say That Class->Method invokes Subroutine Method In Package Class.

=EN A method is the object-oriented version of the subroutine, so we'll say "method" from now on.[*] That's not completely accurate, but we'll go on one step at a time.

=CN A Method Is The Object-Oriented Version Of The Subroutine, So We'我 Say "Method" From Now On.[*] That's Not 完全地 准确的, But We'我 Go On One 脚步 At a Time.

=EN Let's use it like so:

=CN Let's Use It Like So:

=EN [*] In Perl, there really isn't a difference between a subroutine and a method.

=CN [*] In Perl, There Really Isn't a Difference Between a Subroutine And a Method.

=EN They both get an argument list in @_, and we have to make sure we do the right thing.

=CN They Both Get An Argument List In @_, And We Have To Make Sure We Do The Right Thing.

=EN Cow->speak; Horse->speak; Sheep->speak;

=CN Cow->说话; Horse->说话; Sheep->说话;

=EN And once again, this results in:

=CN And Once Again, This Results In:

=EN That's not fun yet.

=CN That's Not 娱乐 仍然.

=EN We've got the same number of characters, all constant, no variables.

=CN We'Ve Got The Same Number Of Characters, All Constant, No Variables.

=EN However, the parts are separable now:

=CN However, The 部分 Are 可分离 Now:

=EN my $beast = 'Cow'; $beast->speak; # invokes Cow->speak

=CN My $野兽 = 'Cow'; $野兽->说话; # invokes Cow->说话

=EN Now that the package name is separated from the subroutine name, we can use a variable package name.

=CN Now That The Package Name Is Separated From The Subroutine Name, We Can Use a Variable Package Name.

=EN This time, we've got something that works even when we enable use strict 'refs'.

=CN This Time, We'Ve Got Something That Works Even When We 使能够 Use Strict '裁判'.

=EN Take the arrow invocation and put it back in the barnyard example:

=CN Take The 箭 调用 And Put It Back In The barnyard Example:

=EN Now all the animals are talking, and safely at that, without the use of symbolic coderefs.

=CN Now All The animals Are 说话, And Safely At That, Without The Use Of Symbolic coderefs.

=EN But look at all that common code.

=CN But Look At All That Common Code.

=EN Each speak method has a similar structure: a print operator and a string that contains common text, except for two words.

=CN Each 说话 Method Has a Similar Structure: a Print Operator And a String That 包含 Common 正文, Except For Two Words.

=EN One of OOP's core principles is to minimize common code: if we write it only once, we'll save time.

=CN One Of OOP's Core 原则 Is To 使减到最小 Common Code: If We Write It Only Once, We'我 Save Time.

=EN If we test and debug it only once, we'll save more time.

=CN If We Test And debug It Only Once, We'我 Save More Time.

=EN Now that we know more about what the method invocation arrow actually does, we've got an easier way to do the same thing.

=CN Now That We Know More About What The Method 调用 箭 Actually Does, We'Ve Got An Easier Way To Do The Same Thing.

=EN The Extra Parameter of Method Invocation The invocation of:

=CN The Extra Parameter Of Method Invocation The 调用 Of:

=EN Class->method(@args)

=CN Class->Method(@Args)

=EN attempts to invoke the subroutine Class::method as:

=CN Attempts To 调用 The Subroutine Class::Method As:

=EN Class::method('Class', @args);

=CN Class::Method('Class', @Args);

=EN (If it can't find the method, inheritance kicks in, but we'll show that later.)

=CN (If It Can't 寻找 The Method, Inheritance kicks In, But We'我 Show That 更晚.)

=EN This means that we get the class name as the first parameter, or the only parameter, if no arguments are given.

=CN This Means That We Get The Class Name As The First Parameter, Or The Only Parameter, If No Arguments Are Given.

=EN We can rewrite the Sheep speaking method as:

=CN We Can 重写 The Sheep 说 Method As:

=EN sub Sheep::speak {

=CN Sub Sheep::说话 {

=EN The other two animals come out similarly:

=CN The Other Two animals 来到 Out 同样:

=EN In each case, $class gets the value appropriate for that method.

=CN In Each Case, $Class Gets The Value 恰当的 For That Method.

=EN But once again, we have a lot of similar structure.

=CN But Once Again, We Have a 许多 Of Similar Structure.

=EN Can we factor out that commonality even further?

=CN Can We 因素 Out That commonality Even Further?

=EN Yesby calling another method in the same class.

=CN Yesby Calling 另一个 Method In The Same Class.

=EN Calling a Second Method to Simplify Things We can call out from speak to a helper method called sound.

=CN Calling a Second Method To Simplify Things We Can Call Out From 说话 To a helper Method Called 声.

=EN This method provides the constant text for the sound itself:

=CN This Method Provides The Constant 正文 For The 声 Itself:

=EN { package Cow;

=CN { Package Cow;

=EN Now, when we call Cow->speak, we get a $class of Cow in speak.

=CN Now, When We Call Cow->说话, We Get a $Class Of Cow In 说话.

=EN This, in turn, selects the Cow->sound method, which returns moooo.

=CN This, In 转向, 选择 The Cow->声 Method, Which Returns moooo.

=EN How different would this be for the Horse?

=CN How Different Would This Be For The Horse?

=EN { package Horse;

=CN { Package Horse;

=EN Only the name of the package and the specific sound change.

=CN Only The Name Of The Package And The 特殊的 声 Change.

=EN So can we share the definition for speak between the cow and the horse?

=CN So Can We 份 The Definition For 说话 Between The 母牛 And The 马?

=EN Yes, with inheritance !

=CN Yes, With Inheritance !

=EN Now let's define a common method package called Animal with the definition for speak:

=CN Now Let's Define a Common Method Package Called Animal With The Definition For 说话:

=EN { package Animal;

=CN { Package Animal;

=EN Then, for each animal, we can say it inherits from Animal, along with the animal-specific sound:

=CN Then, For Each 动物, We Can Say It 继承 From Animal, 沿着 With The 动物-特殊的 声:

=EN Note the added @ISA array.

=CN Note The added @ISA Array.

=EN We'll get to that in a minute.

=CN We'我 Get To That In a 分钟.

=EN What happens when we invoke Cow->speak now?

=CN What Happens When We 调用 Cow->说话 Now?

=EN First, Perl constructs the argument list.

=CN First, Perl Constructs The Argument List.

=EN In this case, it's just Cow.

=CN In This Case, It's Just Cow.

=EN Then Perl looks for Cow::speak.

=CN Then Perl Looks For Cow::说话.

=EN That's not there, so Perl checks for the inheritance array @Cow::ISA.

=CN That's Not There, So Perl 检查 For The Inheritance Array @Cow::ISA.

=EN It's there and contains the single name Animal.

=CN It's There And 包含 The Single Name Animal.

=EN Perl next checks for speak inside Animal instead, as in Animal::speak.

=CN Perl 下一次 检查 For 说话 里面 Animal Instead, As In Animal::说话.

=EN That found, Perl invokes that method with the already frozen argument list, as if we had said:

=CN That Found, Perl invokes That Method With The Already frozen Argument List, As If We Had Said:

=EN Animal::speak('Cow');

=CN Animal::说话('Cow');

=EN Inside the Animal::speak method, $class becomes Cow as the first argument is shifted off.

=CN Inside The Animal::说话 Method, $Class Becomes Cow As The First Argument Is shifted Off.

=EN When we get to the step of invoking $class->sound while performing the print, it looks for Cow->sound:

=CN When We Get To The 脚步 Of 调用 $Class->声 While performing The Print, It Looks For Cow->声:

=EN print "a $class goes ", $class->sound, "!\n"; # but $class is Cow, so... print 'a Cow goes ', Cow->sound, "!\n"; # which invokes Cow->sound, returning 'moooo', so print 'a Cow goes ', 'moooo', "!\n";

=CN Print "a $Class 去 ", $Class->声, "!\n"; # But $Class Is Cow, So... Print 'a Cow 去 ', Cow->声, "!\n"; # Which invokes Cow->声, Returning 'moooo', So Print 'a Cow 去 ', 'moooo', "!\n";

=EN and we get our desired output.

=CN And We Get Our Desired 出产.

=EN A Few Notes About @ISA This magical @ISA variable (pronounced "is a" not "ice-uh") declares that Cow "is a" Animal.[*] Note that it's an array, not a simple single value, because on rare occasions it makes sense to have more than one parent class searched for the missing methods.

=CN A Few Notes About @ISA This Magical @ISA Variable (pronounced "Is a" Not "冰-uh") Declares That Cow "Is a" Animal.[*] Note That It's An Array, Not a Simple Single Value, Because On 稀有的 occasions It 使 Sense To Have More Than One 父或母亲 Class searched For The Missing Methods.

=EN We'll show more about that later.

=CN We'我 Show More About That 更晚.

=EN [*] ISA is actually a linguistic term.

=CN [*] ISA Is Actually a linguistic 期限.

=EN Once again, Larry Wall's background as a linguist has come back to influence Perl.

=CN Once Again, Larry Wall's 背景 As a 语言学者 Has 来到 Back To 影响 Perl.

=EN If Animal also had an @ISA, Perl would check there too.[] Typically, each @ISA has only one element (multiple elements means multiple inheritance and multiple headaches), so we get a nice tree of inheritance.[]

=CN If Animal Also Had An @ISA, Perl Would Check There Too.[] Typically, Each @ISA Has Only One Element (Multiple Elements Means Multiple Inheritance And Multiple headaches), So We Get a Nice 树 Of Inheritance.[]

=EN [] The search is recursive, depth-first, and left to right in each @ISA.

=CN [] The 搜查 Is 递归, 深度-First, And Left To Right In Each @ISA.

=EN [] There is also inheritance through UNIVERSAL and AUTOLOAD; see the perlobj manpage for the whole story.

=CN [] There Is Also Inheritance 通过 UNIVERSAL And AUTOLOAD; See The perlobj manpage For The Whole 故事.

=EN When we turn on use strict, we'll get complaints on @ISA because it's not a variable containing an explicit package name, nor is it a lexical (my) variable.

=CN When We 转向 On Use Strict, We'我 Get complaints On @ISA Because It's Not a Variable Containing An 清楚的 Package Name, Nor Is It a Lexical (My) Variable.

=EN We can't make it a lexical variable, though: it has to belong to the package to be found by the inheritance mechanism.

=CN We Can't Make It a Lexical Variable, Though: It Has To 属于 To The Package To Be Found By The Inheritance Mechanism.

=EN There are a couple of straightforward ways to handle the declaration and setting of @ISA.

=CN There Are a 一对 Of 直爽的 Ways To Handle The Declaration And Setting Of @ISA.

=EN The easiest is to just spell out the package name:

=CN The easiest Is To Just 拼写 Out The Package Name:

=EN We can also allow it as an implicitly named package variable:

=CN We Can Also Allow It As An Implicitly Named Package Variable:

=EN package Cow; use vars qw(@ISA); @ISA = qw(Animal);

=CN Package Cow; Use Vars Qw(@ISA); @ISA = qw(Animal);

=EN If you're on a recent-enough Perl (5.6 or later), you can use the our declaration to shorten it to:

=CN If You'Re On a 近来的-Enough Perl (5.6 Or 更晚), You Can Use The Our Declaration To 缩短 It To:

=EN package Cow; our @ISA = qw(Animal);

=CN Package Cow; Our @ISA = qw(Animal);

=EN However, if you think your code might be used by people stuck with Perl 5.005 or earlier, it's best to avoid our.

=CN However, If You 想 Your Code Might Be Used By People stuck With Perl 5.005 Or Earlier, It's Best To Avoid Our.

=EN If we're bringing in the class from outside, via an object-oriented module, we can change:

=CN If We'Re bringing In The Class From Outside, Via An Object-Oriented Module, We Can Change:

=EN package Cow; use Animal; use vars qw(@ISA); @ISA = qw(Animal);

=CN Package Cow; Use Animal; Use Vars Qw(@ISA); @ISA = qw(Animal);

=EN to just:

=CN To Just:

=EN package Cow; use base qw(Animal);

=CN Package Cow; Use Base qw(Animal);

=EN That's pretty darn compact.

=CN That's 精致的 darn 严密的.

=EN Furthermore, use base has the advantage that it's performed at compile time, eliminating a few potential errors from setting @ISA at runtime, like some of the other solutions.

=CN Furthermore, Use Base Has The 优点 That It's 进行 At Compile Time, 消除 a Few 潜在的 Errors From Setting @ISA At Runtime, Like Some Of The Other solutions.

=EN Overriding the Methods Let's add a mouse that can barely be heard:

=CN Overriding The Methods Let's 增添 a 老鼠 That Can 赤裸裸地 Be heard:

=EN Mouse->speak;

=CN Mouse->说话;

=EN which results in:

=CN Which Results In:

=EN a Mouse goes squeak! [but you can barely hear it!]

=CN a Mouse 去 squeak! [But You Can 赤裸裸地 听见 It!]

=EN Here, Mouse has its own speaking routine, so Mouse->speak doesn't immediately invoke Animal->speak.

=CN Here, Mouse Has Its Own 说 Routine, So Mouse->说话 Doesn't 立即 调用 Animal->说话.

=EN This is known as overriding .

=CN This Is Known As Overriding .

=EN We use overriding to shadow the method in the derived class (Mouse) because we have a specialized version of the routine, instead of calling the more general base class's method (in Animal).

=CN We Use Overriding To 影子 The Method In The 派生 Class (Mouse) Because We Have a 专业的 Version Of The Routine, Instead Of Calling The More General Base Class's Method (In Animal).

=EN In fact, we didn't even need to initialize @Mouse::ISA to say that a Mouse was an Animal, because all the methods needed for speak are defined completely with Mouse.

=CN In Fact, We Didn't Even Need To Initialize @Mouse::ISA To Say That a Mouse Was An Animal, Because All The Methods Needed For 说话 Are Defined 完全地 With Mouse.

=EN We've now duplicated some of the code from Animal->speak; this can be a maintenance headache.

=CN We'Ve Now duplicated Some Of The Code From Animal->说话; This Can Be a 保养 头疼.

=EN For example, suppose someone decides that the word goes in the output of the Animal class is a bug.

=CN For Example, 猜想 Someone decides That The 字 去 In The 出产 Of The Animal Class Is a 臭虫.

=EN Now the maintainer of that class changes goes to says.

=CN Now The maintainer Of That Class Changes 去 To 说.

=EN Our mice will still say goes, which means the code still has the bug.

=CN Our mice Will Still Say 去, Which Means The Code Still Has The 臭虫.

=EN The problem is that we invoked cut and paste to duplicate code, and in OOP, that's a sin.

=CN The Problem Is That We invoked Cut And 浆糊 To 二重的 Code, And In OOP, That's a 罪.

=EN We should reuse code through inheritance, not by cut and paste.

=CN We Should Reuse Code 通过 Inheritance, Not By Cut And 浆糊.

=EN How can we avoid that?

=CN How Can We Avoid That?

=EN Can we say somehow that a Mouse does everything any other Animal does, but add in the extra comment?

=CN Can We Say 以某种方式 That a Mouse Does Everything Any Other Animal Does, But 增添 In The Extra Comment?

=EN As our first attempt, let's invoke the Animal::speak method directly:

=CN As Our First 尝试, Let's 调用 The Animal::说话 Method 直接地:

=EN Note that because we've stopped using the method arrow, we have to include the $class parameter (almost surely the value Mouse) as the first parameter to Animal::speak.

=CN Note That Because We'Ve stopped Using The Method 箭, We Have To Include The $Class Parameter (Almost 一定 The Value Mouse) As The First Parameter To Animal::说话.

=EN Why did we stop using the arrow?

=CN Why Did We Stop Using The 箭?

=EN Well, if we invoke Animal->speak there, the first parameter to the method is "Animal" not "Mouse" and when the time comes for it to call for the sound, it won't have the right class to select the proper methods for this object.

=CN Well, If We 调用 Animal->说话 There, The First Parameter To The Method Is "Animal" Not "Mouse" And When The Time 来 For It To Call For The 声, It Won't Have The Right Class To 挑选 The 合适的 Methods For This Object.

=EN Invoking Animal::speak directly is a mess, however.

=CN Invoking Animal::说话 直接地 Is a 肮脏, However.

=EN What if Animal::speak didn't exist before, and it inherited from a class mentioned in @Animal::ISA?

=CN What If Animal::说话 Didn't Exist Before, And It 继承 From a Class Mentioned In @Animal::ISA?

=EN For example, suppose the code was:

=CN For Example, 猜想 The Code Was:

=EN { package LivingCreature;

=CN { Package LivingCreature;

=EN  # no definition for speak( )

=CN  # No Definition For 说话( )

=EN Because we no longer use the method arrow, we get one and only one chance to hit the right method because we're treating it like a regular subroutine with no inheritance magic.

=CN Because We No 长 Use The Method 箭, We Get One And Only One Chance To 打 The Right Method Because We'Re 治疗 It Like a Regular Subroutine With No Inheritance Magic.

=EN We'll look for it in Animal and not find it, and the program aborts.

=CN We'我 Look For It In Animal And Not 寻找 It, And The Program aborts.

=EN The Animal class name is now hardwired into the method selection.

=CN The Animal Class Name Is Now hardwired Into The Method 选择.

=EN This is a mess if someone maintains the code, changing @ISA for Mouse, and doesn't notice Animal there in speak.

=CN This Is a 肮脏 If Someone Maintains The Code, Changing @ISA For Mouse, And Doesn't Notice Animal There In 说话.

=EN Thus, this is probably not the right way to go.

=CN Thus, This Is Probably Not The Right Way To Go.

=EN Starting the Search from a Different Place A better solution is to tell Perl to search from a different place in the inheritance chain:

=CN Starting The Search From a Different Place A Better 解决 Is To Tell Perl To 搜查 From a Different Place In The Inheritance 链条:

=EN As ugly as this is, it works.

=CN As 丑恶的 As This Is, It Works.

=EN Using this syntax, start with Animal to find speak and use all of Animal's inheritance chain if not found immediately.

=CN Using This Syntax, Start With Animal To 寻找 说话 And Use All Of Animal's Inheritance 链条 If Not Found 立即.

=EN The first parameter is $class (because we're using an arrow again), so the found speak method gets Mouse as its first entry and eventually works its way back to Mouse::sound for the details.

=CN The First Parameter Is $Class (Because We'Re Using An 箭 Again), So The Found 说话 Method Gets Mouse As Its First Entry And 最终 Works Its Way Back To Mouse::声 For The Details.

=EN This isn't the best solution, however.

=CN This Isn't The Best 解决, However.

=EN We still have to keep the @ISA and the initial search package in sync (changes in one must be considered for changes in the other).

=CN We Still Have To 保持 The @ISA And The Initial 搜查 Package In sync (Changes In One Must Be Considered For Changes In The Other).

=EN Worse, if Mouse had multiple entries in @ISA, we wouldn't necessarily know which one had actually defined speak.

=CN Worse, If Mouse Had Multiple Entries In @ISA, We Wouldn't Necessarily Know Which One Had Actually Defined 说话.

=EN So, is there an even better way?

=CN So, Is There An Even Better Way?

=EN The SUPER Way of Doing Things By changing the Animal class to the SUPER class in that invocation, we get a search of all our superclasses (classes listed in @ISA) automatically:

=CN The SUPER Way Of Doing Things By Changing The Animal Class To The SUPER Class In That 调用, We Get a 搜查 Of All Our 策略 (类 Listed In @ISA) Automatically:

=EN Thus, SUPER::speak means to look in the current package's @ISA for speak, invoking the first one found if there's more than one.

=CN Thus, SUPER::说话 Means To Look In The Current Package's @ISA For 说话, 调用 The First One Found If There's More Than One.

=EN In this case, we look in the one and only base class, Animal, find Animal::speak, and pass it Mouse as its only parameter.

=CN In This Case, We Look In The One And Only Base Class, Animal, 寻找 Animal::说话, And Pass It Mouse As Its Only Parameter.

=EN What to Do with @_ In that last example, had there been any additional parameters to the speak method (like how many times, or in what pitch for singing, for example), the parameters would be ignored by the Mouse::speak method.

=CN What To Do With @_ In That Last Example, Had There Been Any Additional Parameters To The 说话 Method (Like How Many Times, Or In What 搭帐篷 For singing, For Example), The Parameters Would Be Ignored By The Mouse::说话 Method.

=EN If we want them to be passed uninterpreted to the parent class, we can add it as a parameter:

=CN If We Want Them To Be Passed uninterpreted To The 父或母亲 Class, We Can 增添 It As a Parameter:

=EN $class->SUPER::speak(@_);

=CN $Class->SUPER::说话(@_);

=EN This invokes the speak method of the parent class, including all the parameters that we've not yet shifted off of our parameter list.

=CN This invokes The 说话 Method Of The 父或母亲 Class, Including All The Parameters That We'Ve Not 仍然 shifted Off Of Our Parameter List.

=EN Which one is correct?

=CN Which One Is 正确的?

=EN It depends.

=CN It Depends.

=EN If we are writing a class that simply adds to the parent class behavior, it's best to simply pass along arguments we haven't dealt with.

=CN If We Are 写作 a Class That Simply Adds To The 父或母亲 Class Behavior, It's Best To Simply Pass 沿着 Arguments We 还't 处理 With.

=EN However, if we want precise control over the parent class's behavior, we should determine the argument list explicitly and pass it.

=CN However, If We Want 精确的 Control 在 The 父或母亲 Class's Behavior, We Should 决心 The Argument List 清晰地 And Pass It.

=EN So far, we've used the method arrow syntax:

=CN So Far, We'Ve Used The Method 箭 Syntax:

=EN Class->method(@args);

=CN Class->Method(@Args);

=EN or the equivalent:

=CN Or The Equivalent:

=EN my $beast = 'Class'; $beast->method(@args);

=CN My $野兽 = 'Class'; $野兽->Method(@Args);

=EN which constructs an argument list of:

=CN Which Constructs An Argument List Of:

=EN ('Class', @args)

=CN ('Class', @Args)

=EN and attempts to invoke:

=CN And Attempts To 调用:

=EN However, if Perl doesn't find Class::method, it examines @Class::ISA (recursively) to locate a package that does indeed contain method and then invokes that version instead.

=CN However, If Perl Doesn't 寻找 Class::Method, It examines @Class::ISA (Recursively) To Locate a Package That Does 的确 Contain Method And Then invokes That Version Instead.

=EN Chapter 12 shows how to distinguish the individual animals by giving them associated properties, called instance variables.

=CN Chapter 12 Shows How To 辨别 The Individual animals By Giving Them Associated propertie(绑定操作符)s, Called 例子 Variables.

=EN Exercises You can find the answers to these exercises in "Answers for Chapter 11" in the Appendix.

=CN Exercises You Can 寻找 The answers To These exercises In "Answers For Chapter 11" In The Appendix.

=EN Exercise 1 [20 min] Type in the Animal, Cow, Horse, Sheep, and Mouse class definitions.

=CN Exercise 1 [20 min] Type In The Animal, Cow, Horse, Sheep, And Mouse Class 定义.

=EN Make it work with use strict.

=CN Make It Work With Use Strict.

=EN Use our if you're using a recent enough version of Perl.

=CN Use Our If You'Re Using a 近来的 Enough Version Of Perl.

=EN Your program should ask the user to enter the names of one or more barnyard animals.

=CN Your Program Should 问 The User To 进入 The Names Of One Or More barnyard animals.

=EN Create a barnyard with those animals, and have each animal speak once.

=CN Create a barnyard With Those animals, And Have Each 动物 说话 Once.

=EN Exercise 2 [40 min] Add a Person class at the same level as Animal, and have both of them inherit from a new class called LivingCreature.

=CN Exercise 2 [40 min] Add a Person Class At The Same Level As Animal, And Have Both Of Them 继承 From a New Class Called LivingCreature.

=EN Also make the speak method take a parameter of what to say, falling back to the sound (humming for a Person) if no parameter is given.

=CN Also Make The 说话 Method Take a Parameter Of What To Say, Falling Back To The 声 (humming For a Person) If No Parameter Is Given.

=EN Since this isn't Dr. Dolittle, make sure the animals can't talk.

=CN Since This Isn't Dr. Dolittle, Make Sure The animals Can't 谈话.

=EN (That is, don't let speak have any parameters for an animal.)

=CN (That Is, Don't Let 说话 Have Any Parameters For An 动物.)

=EN Try not to duplicate any code, but be sure to catch likely errors of usage, such as forgetting to define a sound for an animal.

=CN Try Not To 二重的 Any Code, But Be Sure To Catch Likely Errors Of 使用, Such As forgetting To Define a 声 For An 动物.

=EN Demonstrate the Person class by invoking a person with nothing to say, and then demonstrate it a second time by invoking a person with something to say.

=CN Demonstrate The Person Class By 调用 a 人 With Nothing To Say, And Then 论证 It a Second Time By 调用 a 人 With Something To Say.

