=EN References and Scoping We can copy and pass around references like any other scalar.

=CN References And Scoping We Can Copy And Pass Around References Like Any Other Scalar.

=EN At any given time, Perl knows the number of references to a particular data item.

=CN At Any Given Time, Perl 知道 The Number Of References To a Particular Data 条款.

=EN Perl can also create references to anonymous data structures (structures that do not have explicit names) and create references automatically as needed to fulfill certain kinds of operations.

=CN Perl Can Also Create References To Anonymous Data Structures (Structures That Do Not Have 清楚的 Names) And Create References Automatically As Needed To fulfill 确信的 种类 Of 操作.

=EN Let's look at copying references and how it affects scoping and memory usage.

=CN Let's Look At 复制 References And How It Affects Scoping And Memory 使用.

=EN More Than One Reference to Data Chapter 4 explored how to take a reference to an array @skipper and place it into a new scalar variable:

=CN More Than One Reference To Data Chapter 4 explored How To Take a Reference To An Array @skipper And Place It Into a New Scalar Variable:

=EN my @skipper = qw(blue_shirt hat jacket preserver sunscreen); my $reference_to_skipper = \@skipper;

=CN My @skipper = Qw(blue_shirt 帽子 短外套 preserver sunscreen); My $reference_to_skipper = \@skipper;

=EN We can then copy the reference or take additional references, and they'll all refer to the same thing and are interchangeable:

=CN We Can Then Copy The Reference Or Take Additional References, And They'我 All Refer To The Same Thing And Are interchangeable:

=EN my $second_reference_to_skipper = $reference_to_skipper; my $third_reference_to_skipper = \@skipper;

=CN My $second_reference_to_skipper = $reference_to_skipper; My $third_reference_to_skipper = \@skipper;

=EN At this point, we have four different ways to access the data contained in @skipper:

=CN At This 尖, We Have 四 Different Ways To Access The Data 包含 In @skipper:

=EN Perl tracks how many ways it can access the data through a mechanism called reference counting .

=CN Perl 轨迹 How Many Ways It Can Access The Data 通过 a Mechanism Called Reference counting .

=EN The original name counts as one, and each additional reference that we create (including copies of references) also counts as one.

=CN The Original Name 计数 As One, And Each Additional Reference That We Create (Including Copies Of References) Also 计数 As One.

=EN The total number of references to the array of provisions is now four.

=CN The 总 Number Of References To The Array Of provisions Is Now 四.

=EN We can add and remove references as we wish, and as long as the reference count doesn't hit zero, Perl maintains the array in memory and it is still accessible via any of the other access paths.

=CN We Can 增添 And 移开 References As We Wish, And As Long As The Reference 计算 Doesn't 打 零, Perl Maintains The Array In Memory And It Is Still Accessible Via Any Of The Other Access paths.

=EN For example, we might have a temporary reference:

=CN For Example, We Might Have a temporary Reference:

=EN When this subroutine executes, Perl creates a fifth reference to the data and copies it into @_ for the subroutine.

=CN When This Subroutine 实行, Perl Creates a fifth Reference To The Data And Copies It Into @_ For The Subroutine.

=EN The subroutine is free to create additional copies of that reference, which Perl notes as needed.

=CN The Subroutine Is Free To Create Additional Copies Of That Reference, Which Perl 备忘 As Needed.

=EN Typically, when the subroutine returns, Perl discards all such references automatically, and you're back to four references again.

=CN Typically, When The Subroutine Returns, Perl discards All Such References Automatically, And You'Re Back To 四 References Again.

=EN We can kill off each reference by using the variable for something other than a reference to the value of @skipper.

=CN We Can 杀死 Off Each Reference By Using The Variable For Something Other Than a Reference To The Value Of @skipper.

=EN For example, we can assign undef to the variable:

=CN For Example, We Can Assign Undef To The Variable:

=EN $reference_to_skipper = undef;

=CN $reference_to_skipper = Undef;

=EN Or, maybe we just let the variable go out of scope:

=CN Or, 或许 We Just Let The Variable Go Out Of Scope:

=EN my @skipper = ...;

=CN My @skipper = ...;

=EN { # naked block ... my $ref = \@skipper; ... ... } # $ref goes out of scope at this point

=CN { # 裸体的 Block ... My $Ref = \@skipper; ... ... } # $Ref 去 Out Of Scope At This 尖

=EN In particular, a reference held in a subroutine's private (lexical) variable goes away at the end of the subroutine.

=CN In Particular, a Reference Held In a Subroutine's Private (Lexical) Variable 去 Away At The End Of The Subroutine.

=EN Whether we change the value, or the variable itself goes away, Perl notes it as an appropriate reduction in the number of references to the data.

=CN Whether We Change The Value, Or The Variable Itself 去 Away, Perl 备忘 It As An 恰当的 减少 In The Number Of References To The Data.

=EN Perl recycles the memory for the array only when all references (including the name of the array) go away.

=CN Perl recycles The Memory For The Array Only When All References (Including The Name Of The Array) Go Away.

=EN In this case, Perl only reclaims memory when @skipper and all the references we created to it disappear.

=CN In This Case, Perl Only reclaims Memory When @skipper And All The References We Created To It 失踪.

=EN Such memory is available to Perl for other data later in this program invocation, and generally Perl doesn't give it back to the operating system.

=CN Such Memory Is Available To Perl For Other Data 更晚 In This Program 调用, And Generally Perl Doesn't Give It Back To The Operating System.

=EN What If That Was the Name?

=CN What If That Was The Name?

=EN Typically, all references to a variable are gone before the variable itself.

=CN Typically, All References To a Variable Are 不见了 Before The Variable Itself.

=EN But what if one of the references outlives the variable name?

=CN But What If One Of The References outlives The Variable Name?

=EN For example, consider this code:

=CN For Example, Consider This Code:

=EN my $ref;

=CN My $Ref;

=EN # prints jacket\n }

=CN # Prints 短外套\n }

=EN print "$ref->[2]\n"; # still prints jacket\n

=CN Print "$Ref->[2]\n"; # Still Prints 短外套\n

=EN Immediately after we declare the @skipper array, we have one reference to the five-element list.

=CN Immediately After We Declare The @skipper Array, We Have One Reference To The five-Element List.

=EN After $ref is initialized, we'll have two, down to the end of the block.

=CN After $Ref Is 初始化, We'我 Have Two, 向下 To The End Of The Block.

=EN When the block ends, the @skipper name disappears.

=CN When The Block Ends, The @skipper Name disappears.

=EN However, this was only one of the two ways to access the data!

=CN However, This Was Only One Of The Two Ways To Access The Data!

=EN Thus, the five-element list is still in memory, and $ref still points to that data.

=CN Thus, The five-Element List Is Still In Memory, And $Ref Still 分 To That Data.

=EN At this point, the five-element list is in an anonymous array, which is a fancy term for an array without a name.

=CN At This 尖, The five-Element List Is In An Anonymous Array, Which Is a 幻想 期限 For An Array Without a Name.

=EN Until the value of $ref changes, or $ref itself disappears, we can still use all the dereferencing strategies we used prior to when the name of the array disappeared.

=CN Until The Value Of $Ref Changes, Or $Ref Itself disappears, We Can Still Use All The dereferencing 策略 We Used 较早的 To When The Name Of The Array disappeared.

=EN In fact, it's still a fully functional array that we can shrink or grow just as we do any other Perl array:

=CN In Fact, It's Still a Fully Functional Array That We Can 收缩 Or Grow Just As We Do Any Other Perl Array:

=EN push @$ref, 'sextant'; # add a new provision print "$ref->[-1]\n"; # prints sextant\n

=CN Push @$Ref, 'sextant'; # 增添 a New 准备 Print "$Ref->[-1]\n"; # Prints sextant\n

=EN We can even increase the reference count at this point:

=CN We Can Even 增加 The Reference 计算 At This 尖:

=EN my $copy_of_ref = $ref;

=CN My $copy_of_ref = $Ref;

=EN or equivalently:

=CN Or 设置:

=EN my $copy_of_ref = \@$ref;

=CN My $copy_of_ref = \@$Ref;

=EN The data stays alive until we destroy the last reference:

=CN The Data 停留 活着的 Until We 破坏 The Last Reference:

=EN $ref = undef; # not yet... $copy_of_ref = undef; # poof!

=CN $Ref = Undef; # Not 仍然... $copy_of_ref = Undef; # poof!

=EN Reference Counting and Nested Data Structures The data remains alive until we destroy the last reference, even if that reference lives within a larger active data structure.

=CN Reference Counting And Nested Data Structures The Data 剩余 活着的 Until We 破坏 The Last Reference, Even If That Reference 生活 Within a larger 活跃的 Data Structure.

=EN Suppose an array element is itself a reference.

=CN Suppose An Array Element Is Itself a Reference.

=EN Recall the example from Chapter 4:

=CN Recall The Example From Chapter 4:

=EN my @skipper = qw(blue_shirt hat jacket preserver sunscreen); my @skipper_with_name = ('The Skipper', \@skipper);

=CN My @skipper = Qw(blue_shirt 帽子 短外套 preserver sunscreen); My @skipper_with_name = ('The Skipper', \@skipper);

=EN my @professor = qw(sunscreen water_bottle slide_rule batteries radio); my @professor_with_name = ('The Professor', \@professor);

=CN My @教授 = Qw(sunscreen water_bottle slide_rule batteries 无线电); My @professor_with_name = ('The Professor', \@教授);

=EN my @gilligan = qw(red_shirt hat lucky_socks water_bottle); my @gilligan_with_name = ('Gilligan', \@gilligan);

=CN My @gilligan = Qw(red_shirt 帽子 lucky_socks water_bottle); My @gilligan_with_name = ('Gilligan', \@gilligan);

=EN my @all_with_names = (

=CN My @all_with_names = (

=EN Imagine for a moment that the intermediate variables are all part of a subroutine:

=CN Imagine For a Moment That The 中间的 Variables Are All Part Of a Subroutine:

=EN my @all_with_names;

=CN My @all_with_names;

=EN sub initialize_provisions_list {

=CN Sub initialize_provisions_list {

=EN # set global

=CN # Set Global

=EN We set the value of @all_with_names to contain three references.

=CN We Set The Value Of @all_with_names To Contain Three References.

=EN Inside the subroutine we have named arrays with references to arrays first placed into other named arrays.

=CN Inside The Subroutine We Have Named Arrays With References To Arrays First Placed Into Other Named Arrays.

=EN Eventually, the values end up in the global @all_with_names.

=CN Eventually, The Values End Up In The Global @all_with_names.

=EN However, as the subroutine returns, the names for the six arrays disappear.

=CN However, As The Subroutine Returns, The Names For The six Arrays 失踪.

=EN Each array has had one other reference taken to it, making the reference count temporarily two, and then back to one as the name disappears.

=CN Each Array Has Had One Other Reference Taken To It, 制作 The Reference 计算 temporarily Two, And Then Back To One As The Name disappears.

=EN Because the reference count is not yet zero, the data continues to live on, although it is now referenced only by elements of @all_with_names.

=CN Because The Reference 计算 Is Not 仍然 零, The Data 继续 To 居住生存 On, Although It Is Now 参考 Only By Elements Of @all_with_names.

=EN Rather than assign the global variable, we can rewrite this without @all_with_names and return the list directly:

=CN Rather Than Assign The Global Variable, We Can 重写 This Without @all_with_names And Return The List 直接地:

=EN sub get_provisions_list {

=CN Sub get_provisions_list {

=EN my @all_with_names = get_provisions_list( );

=CN My @all_with_names = get_provisions_list( );

=EN Here, we create the value that we'll eventually store in @all_with_names as the last expression evaluated in the subroutine.

=CN Here, We Create The Value That We'我 最终 商店 In @all_with_names As The Last Expression 评估 In The Subroutine.

=EN The subroutine returns a three-element list.

=CN The Subroutine Returns a Three-Element List.

=EN As long as the named arrays within the subroutine have had at least one reference taken of them, and it is still part of the return value, the data remains alive.[*] If we alter or discard the references in @all_with_names, Perl reduces the reference count for the corresponding arrays.

=CN As Long As The Named Arrays Within The Subroutine Have Had At Least One Reference Taken Of Them, And It Is Still Part Of The Return Value, The Data 剩余 活着的.[*] If We 改变 Or 丢弃 The References In @all_with_names, Perl reduces The Reference 计算 For The 相应的 Arrays.

=EN If that means the reference count has become zero (as in this example), Perl also eliminates the arrays themselves.

=CN If That Means The Reference 计算 Has 变成 零 (As In This Example), Perl Also eliminates The Arrays 他们、它们自己.

=EN Because the arrays inside @all_with_names also contain a reference (such as the reference to @skipper), Perl reduces that reference count by one.

=CN Because The Arrays 里面 @all_with_names Also Contain a Reference (Such As The Reference To @skipper), Perl reduces That Reference 计算 By One.

=EN Again, that reduces the reference count to zero, freeing that memory as well, in a cascading effect.

=CN Again, That reduces The Reference 计算 To 零, freeing That Memory As Well, In a 层叠式 Effect.

=EN [*] Compare this with having to return an array from a C function.

=CN [*] Compare This With Having To Return An Array From a C Function.

=EN We must either return a pointer to a static memory space, making the subroutine nonreentrant, or we must malloc new memory space, requiring the caller to know to free the data.

=CN We Must Either Return a Pointer To a Static Memory Space, 制作 The Subroutine nonreentrant, Or We Must malloc New Memory Space, 需要 The Caller To Know To Free The Data.

=EN Perl just does the right thing.

=CN Perl Just Does The Right Thing.

=EN Removing the top of a tree of data generally removes all the data contained within.

=CN Removing The 顶 Of a 树 Of Data Generally Removes All The Data 包含 Within.

=EN The exception is when we make additional copies of the references of the nested data.

=CN The Exception Is When We Make Additional Copies Of The References Of The 嵌套的 Data.

=EN For example, if we copy Gilligan's provisions:

=CN For Example, If We Copy Gilligan's provisions:

=EN my $gilligan_stuff = $all_with_names[2][1];

=CN My $gilligan_stuff = $all_with_names[2][1];

=EN then when we remove @all_with_names, we still have one live reference to what was formerly @gilligan, and the data from there downward remain alive.

=CN Then When We 移开 @all_with_names, We Still Have One 居住生存 Reference To What Was 从前 @gilligan, And The Data From There 向下的 依旧的 活着的.

=EN The bottom line is simply: Perl does the right thing.

=CN The 底部 Line Is Simply: Perl Does The Right Thing.

=EN If we still have a reference to data, we still have the data.

=CN If We Still Have a Reference To Data, We Still Have The Data.

=EN When Reference Counting Goes Bad Reference counting as a way to manage memory has been around for a long time.

=CN When Reference Counting Goes Bad Reference counting As a Way To 管理 Memory Has Been Around For a Long Time.

=EN A really long time.

=CN A Really Long Time.

=EN The downside of reference counting is that it breaks when the data structure is not a directed graph that is, when some parts of the structure point back in to other parts in a looping way.

=CN The downside Of Reference counting Is That It 打破 When The Data Structure Is Not a 执导 图象 That Is, When Some 部分 Of The Structure 尖 Back In To Other 部分 In a looping Way.

=EN For example, suppose each of two data structures contains a reference to the other (see Figure 5-1):

=CN For Example, 猜想 Each Of Two Data Structures 包含 a Reference To The Other (See Figure 5-1):

=EN my @data1 = qw(one won); my @data2 = qw(two too to);

=CN My @data1 = Qw(One Won); My @data2 = Qw(Two Too To);

=EN push @data2, \@data1; push @data1, \@data2;

=CN Push @data2, \@data1; Push @data1, \@data2;

=EN When the references in a data structure form a loop, Perl's reference-counting system may not be able to recognize and recycle the no-longer-needed memory space

=CN When The References In a Data Structure Form a Loop, Perl's Reference-counting System May Not Be Able To 认出 And recycle The No-长-Needed Memory Space

=EN At this point, we have two names for the data in @data1: @data1 itself and @{$data2[3]}, and two names for the data in @data2: @data2 itself and @{$data1[2]}.

=CN At This 尖, We Have Two Names For The Data In @data1: @data1 Itself And @{$data2[3]}, And Two Names For The Data In @data2: @data2 Itself And @{$data1[2]}.

=EN We've created a loop.

=CN We'Ve Created a Loop.

=EN In fact, we can access won with an infinite number of names, such as $data1[2][3][2][3][2][3][1].

=CN In Fact, We Can Access Won With An 无限大的 Number Of Names, Such As $data1[2][3][2][3][2][3][1].

=EN What happens when these two array names go out of scope?

=CN What Happens When These Two Array Names Go Out Of Scope?

=EN Well, the reference count for the two arrays goes down from two to one, but not zero.

=CN Well, The Reference 计算 For The Two Arrays 去 向下 From Two To One, But Not 零.

=EN And because it's not zero, Perl thinks there might still be a way to get to the data, even though there isn't!

=CN And Because It's Not 零, Perl Thinks There Might Still Be a Way To Get To The Data, Even Though There Isn't!

=EN Thus, we've created a memory leak.

=CN Thus, We'Ve Created a Memory 漏.

=EN A memory leak in a program causes the program to consume more and more memory over time.

=CN A Memory 漏 In a Program Causes The Program To 消费 More And More Memory 在 Time.

=EN At this point, you're right to think that example is contrived.

=CN At This 尖, You'Re Right To 想 That Example Is contrived.

=EN Of course we would never make a looped data structure in a real program!

=CN Of Course We Would Never Make a looped Data Structure In a Real Program!

=EN Actually, programmers often make these loops as part of doubly linked lists, linked rings, or a number of other data structures.

=CN Actually, Programmers Often Make These loops As Part Of doubly Linked Lists, Linked rings, Or a Number Of Other Data Structures.

=EN The key is that Perl programmers rarely do so because the most important reasons to use those data structures don't apply in Perl.

=CN The Key Is That Perl Programmers 难得 Do So Because The Most Important Reasons To Use Those Data Structures Don't 应用 In Perl.

=EN Most of that deals with managing memory and connecting discontiguous memory blocks, which Perl does for us.

=CN Most Of That deals With managing Memory And connecting discontiguous Memory Blocks, Which Perl Does For Us.

=EN If you've used other languages, you may have noticed programming tasks that are comparatively easy in Perl.

=CN If You'Ve Used Other Languages, You May Have Noticed Programming Tasks That Are 比较地 Easy In Perl.

=EN For example, it's easy to sort a list of items or to add or remove items, even in the middle of the list.

=CN For Example, It's Easy To Sort a List Of 物品 Or To 增添 Or 移开 物品, Even In The 当中 Of The List.

=EN Those tasks are difficult in some other languages, and using a looped data structure is a common way to get around the language's limitations.

=CN Those Tasks Are 困难的 In Some Other Languages, And Using a looped Data Structure Is a Common Way To Get Around The 语言's limitations.

=EN Why mention it here?

=CN Why 提及 It Here?

=EN Well, even Perl programmers sometimes copy an algorithm from another programming language.

=CN Well, Even Perl Programmers Sometimes Copy An 算法 From 另一个 Programming 语言.

=EN There's nothing inherently wrong with doing this, although it would be better to decide why the original author used a "loopy" data structure and then recode the algorithm to use Perl's strengths.

=CN There's Nothing 固有的 错误的 With Doing This, Although It Would Be Better To Decide Why The Original 作者 Used a "loopy" Data Structure And Then recode The 算法 To Use Perl's strengths.

=EN Perhaps you should use a hash instead, or perhaps the data should go into an array that will be sorted later.

=CN Perhaps You Should Use a Hash Instead, Or 也许 The Data Should Go Into An Array That Will Be 分类 更晚.

=EN Some upcoming version of Perl is likely to use garbage collection in addition to, or instead of, referencing counting.[*] Until then, we must be careful not to create circular references or, if we do, break the circle before the variables go out of scope.

=CN Some upcoming Version Of Perl Is Likely To Use 垃圾 Collection In 增加 To, Or Instead Of, referencing counting.[*] Until Then, We Must Be Careful Not To Create 圆圈的 References Or, If We Do, 打破 The 圆 Before The Variables Go Out Of Scope.

=EN For example, the following code doesn't leak:

=CN For Example, The Following Code Doesn't 漏:

=EN [*] Just don't ask us about it.

=CN [*] Just Don't 问 Us About It.

=EN We wrote this book a long time before you got a chance to read it, so we didn't exactly know the details back then.

=CN We 写 This 书 a Long Time Before You Got a Chance To Read It, So We Didn't Exactly Know The Details Back Then.

=EN  # at the end:

=CN  # At The End:

=EN We eliminated the reference to @data2 from within @data1, and vice versa.

=CN We eliminated The Reference To @data2 From Within @data1, And 坏事 versa.

=EN Now the data have only one reference each, which all go to zero references at the end of the block.

=CN Now The Data Have Only One Reference Each, Which All Go To 零 References At The End Of The Block.

=EN In fact, we can clear out either one and not the other, and it still works nicely.

=CN In Fact, We Can 清楚的 Out Either One And Not The Other, And It Still Works 好.

=EN Chapter 13 shows how to create weak references, which can help with many of these problems.

=CN Chapter 13 Shows How To Create 弱的 References, Which Can Help With Many Of These 问题.

=EN Creating an Anonymous Array Directly In the get_provisions_list routine earlier, we created a half dozen array names that we used only so that we could take a reference to them immediately afterward.

=CN Creating An Anonymous Array Directly In The get_provisions_list Routine Earlier, We Created a 一半 一打 Array Names That We Used Only So That We Could Take a Reference To Them 立即 后来.

=EN When the subroutine exited, the array names all went away, but the references remained.

=CN When The Subroutine Exited, The Array Names All 去 Away, But The References remained.

=EN While creating temporarily named arrays would work in the simplest cases, creating such names becomes more complicated as the data structures become more detailed.

=CN While Creating temporarily Named Arrays Would Work In The simplest Cases, Creating Such Names Becomes More 错综复杂的 As The Data Structures 变成 More Detailed.

=EN We'd have to keep thinking of names of arrays just so we could forget them shortly thereafter.

=CN We'd Have To 保持 思想 Of Names Of Arrays Just So We Could 忘记 Them 立刻 此后.

=EN We can reduce the namespace clutter by narrowing down the scope of the various array names.

=CN We Can Reduce The Namespace clutter By narrowing 向下 The Scope Of The 各种各样的 Array Names.

=EN Rather than declaring them within the scope of the subroutine, we can create a temporary block:

=CN Rather Than 宣布 Them Within The Scope Of The Subroutine, We Can Create a temporary Block:

=EN my @skipper_with_name; {

=CN My @skipper_with_name; {

=EN At this point, the second element of @skipper_with_name is a reference to the array formerly known as @skipper.

=CN At This 尖, The Second Element Of @skipper_with_name Is a Reference To The Array 从前 Known As @skipper.

=EN However, that name is no longer relevant.

=CN However, That Name Is No 长 相关的.

=EN This is a lot of typing to simply say "the second element should be a reference to an array containing these elements."

=CN This Is a 许多 Of 打字 To Simply Say "The Second Element Should Be a Reference To An Array Containing These Elements."

=EN We can create such a value directly using the anonymous array constructor, which is yet another use for square brackets:

=CN We Can Create Such a Value 直接地 Using The Anonymous Array 构造函数, Which Is 仍然 另一个 Use For 正方形 支架:

=EN my $ref_to_skipper_provisions =

=CN My $ref_to_skipper_provisions =

=EN The square brackets take the value within (evaluated in a list context); establish a new, anonymous array initialized to those values; and (here's the important part) return a reference to that array.

=CN The 正方形 支架 Take The Value Within (评估 In a List Context); 建立 a New, Anonymous Array 初始化 To Those Values; And (Here's The Important Part) Return a Reference To That Array.

=EN It's as if we had said:

=CN It's As If We Had Said:

=EN my $ref_to_skipper_provisions; {

=CN My $ref_to_skipper_provisions; {

=EN Here we don't need to come up with a temporary name, and we don't need the extra noise of the temporary block.

=CN Here We Don't Need To 来到 Up With a temporary Name, And We Don't Need The Extra Noise Of The temporary Block.

=EN The result of a square-bracketed anonymous array constructor is an array reference, which fits wherever a scalar variable fits.

=CN The Result Of a 正方形-bracketed Anonymous Array 构造函数 Is An Array Reference, Which fits 无论哪里 a Scalar Variable fits.

=EN Now we can use it to construct the larger list:

=CN Now We Can Use It To Construct The larger List:

=EN Of course, we didn't actually need that scalar temporary, either.

=CN Of Course, We Didn't Actually Need That Scalar temporary, Either.

=EN We can put a scalar reference to an array as part of a larger list:

=CN We Can Put a Scalar Reference To An Array As Part Of a larger List:

=EN my @skipper_with_name = (

=CN My @skipper_with_name = (

=EN Now let's walk through this.

=CN Now Let's 步行 通过 This.

=EN We've declared @skipper_with_name, the first element of which is the Skipper's name string, and the second element is an array reference, obtained by placing the five provisions into an array and taking a reference to it.

=CN We'Ve Declared @skipper_with_name, The First Element Of Which Is The Skipper's Name String, And The Second Element Is An Array Reference, Obtained By placing The five provisions Into An Array And Taking a Reference To It.

=EN So @skipper_with_name is only two elements long, just as before.

=CN So @skipper_with_name Is Only Two Elements Long, Just As Before.

=EN Don't confuse the square brackets with the parentheses here.

=CN Don't 混淆 The 正方形 支架 With The Parentheses Here.

=EN They each have their distinct purpose.

=CN They Each Have Their 不同的 Purpose.

=EN If we replace the square brackets with parentheses, we end up with a six-element list.

=CN If We 归还原处 The 正方形 支架 With Parentheses, We End Up With a six-Element List.

=EN If we replace the outer parentheses (on the first and last lines) with square brackets, we construct an anonymous array that's two elements long and then take the reference to that array as the only element of the ultimate @skipper_with_name array.[*] So, in summary, if we have this syntax:

=CN If We 归还原处 The 外部的 Parentheses (On The First And Last Lines) With 正方形 支架, We Construct An Anonymous Array That's Two Elements Long And Then Take The Reference To That Array As The Only Element Of The 最终的 @skipper_with_name Array.[*] So, In 概要, If We Have This Syntax:

=EN [*] In classrooms, we've seen that too much indirection (or not enough indirection) tends to contribute to the most common mistakes made when working with references.

=CN [*] In classrooms, We'Ve Seen That Too Much indirection (Or Not Enough indirection) tends To 捐献 To The Most Common mistakes Made When Working With References.

=EN my $fruits; {

=CN My $fruits; {

=EN we can replace it with:

=CN We Can 归还原处 It With:

=EN my $fruits = ['pineapple', 'papaya', 'mango'];

=CN My $fruits = ['菠萝', 'papaya', 'mango'];

=EN Does this work for more complicated structures?

=CN Does This Work For More 错综复杂的 Structures?

=EN Anytime we need an element of a list to be a reference to an array, we can create that reference with an anonymous array constructor.

=CN Anytime We Need An Element Of a List To Be a Reference To An Array, We Can Create That Reference With An Anonymous Array 构造函数.

=EN In fact, we can also nest them in our provisions list:

=CN In Fact, We Can Also 巢 Them In Our provisions List:

=EN Walking through this from the outside in, we have a return value of three elements.

=CN Walking 通过 This From The Outside In, We Have a Return Value Of Three Elements.

=EN Each element is an array reference, pointing to an anonymous two-element array.

=CN Each Element Is An Array Reference, 指向 To An Anonymous Two-Element Array.

=EN The first element of each array is a name string, while the second element is a reference to an anonymous array of varying lengths naming the provisionsall without having to come up with temporary names for any of the intermediate layers.

=CN The First Element Of Each Array Is a Name String, While The Second Element Is a Reference To An Anonymous Array Of 不同 长度 Naming The provisionsall Without Having To 来到 Up With temporary Names For Any Of The 中间的 层.

=EN To the caller of this subroutine, the return value is identical to the previous version.

=CN To The Caller Of This Subroutine, The Return Value Is 同一的 To The Previous Version.

=EN However, from a maintenance point of view, the reduced clutter of not having all the intermediate names saves screen and brain space.

=CN However, From a 保养 尖 Of 视域, The 减少 clutter Of Not Having All The 中间的 Names saves 屏 And 脑子 Space.

=EN We can show a reference to an empty anonymous array using an empty anonymous array constructor.

=CN We Can Show a Reference To An Empty Anonymous Array Using An Empty Anonymous Array 构造函数.

=EN For example, if we add one "Mrs. Howell" to that travel list, as someone who has packed rather light, we'd simply insert:

=CN For Example, If We 增添 One "Mrs. Howell" To That 旅行 List, As Someone Who Has packed Rather 光, We'd Simply 插入:

=EN This is a single element of the larger list.

=CN This Is a Single Element Of The larger List.

=EN This item is a reference to an array with two elements, the first of which is the name string, and the second of which is itself a reference to an empty anonymous array.

=CN This 条款 Is a Reference To An Array With Two Elements, The First Of Which Is The Name String, And The Second Of Which Is Itself a Reference To An Empty Anonymous Array.

=EN The array is empty because Mrs. Howell hasn't packed anything for this trip.

=CN The Array Is Empty Because Mrs. Howell hasn't packed Anything For This 旅行.

=EN Creating an Anonymous Hash Similar to creating an anonymous array, you can also create an anonymous hash.

=CN Creating An Anonymous Hash Similar To Creating An Anonymous Array, You Can Also Create An Anonymous Hash.

=EN Consider the crew roster from Chapter 4:

=CN Consider The （飞机等的）全体人员 roster From Chapter 4:

=EN my %gilligan_info = (

=CN My %gilligan_info = (

=EN my %skipper_info = (

=CN My %skipper_info = (

=EN my @crew = (\%gilligan_info, \%skipper_info);

=CN My @（飞机等的）全体人员 = (\%gilligan_info, \%skipper_info);

=EN The variables %gilligan_info and %skipper_info are just temporaries we needed to create the hashes for the final data structure.

=CN The Variables %gilligan_info And %skipper_info Are Just temporaries We Needed To Create The Hashes For The 最终的 Data Structure.

=EN We can construct the reference directly with the anonymous hash constructor, which is yet another meaning for curly braces, as we'll see.

=CN We Can Construct The Reference 直接地 With The Anonymous Hash 构造函数, Which Is 仍然 另一个 Meaning For 卷曲的 牙套, As We'我 See.

=EN We can replace this:

=CN We Can 归还原处 This:

=EN my $ref_to_gilligan_info;

=CN My $ref_to_gilligan_info;

=EN with the anonymous hash constructor:

=CN With The Anonymous Hash 构造函数:

=EN my $ref_to_gilligan_info = {

=CN My $ref_to_gilligan_info = {

=EN The value between the open and closing curly braces is an eight-element list.

=CN The Value Between The Open And closing 卷曲的 牙套 Is An eight-Element List.

=EN The eight-element list becomes a four-element anonymous hash (four key/value pairs).

=CN The eight-Element List Becomes a 四-Element Anonymous Hash (四 Key/Value 双).

=EN Perl takes a reference to this hash and returns as a single scalar value, which we assign to the scalar variable.

=CN Perl Takes a Reference To This Hash And Returns As a Single Scalar Value, Which We Assign To The Scalar Variable.

=EN Thus, we can rewrite the roster creation as:

=CN Thus, We Can 重写 The roster 创造 As:

=EN my $ref_to_skipper_info = {

=CN My $ref_to_skipper_info = {

=EN my @crew = ($ref_to_gilligan_info, $ref_to_skipper_info);

=CN My @（飞机等的）全体人员 = ($ref_to_gilligan_info, $ref_to_skipper_info);

=EN As before, we can now avoid the temporary variables and insert the values directly into the top-level list:

=CN As Before, We Can Now Avoid The temporary Variables And 插入 The Values 直接地 Into The 顶-Level List:

=EN my @crew = (

=CN My @（飞机等的）全体人员 = (

=EN Note we use trailing commas on the lists when the element is not immediately next to the closing brace, bracket, or parenthesis.

=CN Note We Use 落后 逗号 On The Lists When The Element Is Not 立即 下一次 To The closing 支撑, 括号, Or parenthesis.

=EN This is a nice style element to adopt because it allows for easy maintenance.

=CN This Is a Nice Style Element To 采用 Because It Allows For Easy 保养.

=EN We can add or rearrange lines quickly, or comment out lines without destroying the integrity of our list.

=CN We Can 增添 Or rearrange Lines 快, Or Comment Out Lines Without 破坏 The 完整性 Of Our List.

=EN Now @crew is identical to the value it had before, but we no longer need to invent names for the intermediate data structures.

=CN Now @（飞机等的）全体人员 Is 同一的 To The Value It Had Before, But We No 长 Need To 发明 Names For The 中间的 Data Structures.

=EN As before, the @crew variable contains two elements, each of which is a reference to a hash containing keyword-based information about a particular crew member.

=CN As Before, The @（飞机等的）全体人员 Variable 包含 Two Elements, Each Of Which Is a Reference To a Hash Containing Keyword-基于 Information About a Particular （飞机等的）全体人员 Member.

=EN The anonymous hash constructor always evaluates its contents in a list context and then constructs a hash from key/value pairs, just as if we had assigned that list to a named hash.

=CN The Anonymous Hash 构造函数 Always 评价 Its Contents In a List Context And Then Constructs a Hash From Key/Value 双, Just As If We Had Assigned That List To a Named Hash.

=EN Perl returns a reference to that hash as a single value that fits wherever a scalar fits.

=CN Perl Returns a Reference To That Hash As a Single Value That fits 无论哪里 a Scalar fits.

=EN Now, a word from our parser: because blocks and anonymous hash constructors both use curly braces in roughly the same places in the syntax tree, the compiler has to make ad hoc determinations about which of the two you mean.

=CN Now, a 字 From Our Parser: Because Blocks And Anonymous Hash 构造函数 Both Use 卷曲的 牙套 In 大约地 The Same Places In The Syntax 树, The Compiler Has To Make 广告 hoc determinations About Which Of The Two You Mean.

=EN If the compiler ever decides incorrectly, you might need to provide a hint to get what you want.

=CN If The Compiler 曾经 decides incorrectly, You Might Need To Provide a 暗示 To Get What You Want.

=EN To show the compiler that you want an anonymous hash constructor, put a plus sign before the opening curly brace: +{ ... }.

=CN To Show The Compiler That You Want An Anonymous Hash 构造函数, Put a Plus Sign Before The 开始 卷曲的 支撑: +{ ... }.

=EN To be sure to get a block of code, just put a semicolon (representing an empty statement) at the beginning of the block: {; ... }.

=CN To Be Sure To Get a Block Of Code, Just Put a semicolon (代表 An Empty Statement) At The 开端 Of The Block: {; ... }.

=EN Autovivification Let's look again at the provisions list.

=CN Autovivification Let's Look Again At The provisions List.

=EN Suppose we were reading the data from a file, in this format:

=CN Suppose We Were 读书 The Data From a File, In This Format:

=EN We indent provisions with some whitespace, following a non-indented line with the person's name.

=CN We （书写）缩行 provisions With Some Whitespace, Following a Non-indented Line With The 人's Name.

=EN Let's construct a hash of provisions.

=CN Let's Construct a Hash Of provisions.

=EN The keys of the hash will be the person's name, and the value will be an array reference to an array containing a list of provisions.

=CN The Keys Of The Hash Will Be The 人's Name, And The Value Will Be An Array Reference To An Array Containing a List Of provisions.

=EN Initially, we might gather the data using a simple loop:

=CN Initially, We Might 聚集 The Data Using a Simple Loop:

=EN my %provisions; my $person;

=CN My %provisions; My $人;

=EN while (<>) {

=CN While (<>) {

=EN # a person's name (no leading whitespace)

=CN # a 人's Name (No 领先的 Whitespace)

=EN # a provision

=CN # a 准备

=EN First, we declare the variables for the resulting hash of provisions and the current person.

=CN First, We Declare The Variables For The 造成 Hash Of provisions And The Current 人.

=EN For each line that we read, we determine if it's a person or a provision.

=CN For Each Line That We Read, We 决心 If It's a 人 Or a 准备.

=EN If it's a person, we remember the name and create the hash element for that person.

=CN If It's a 人, We 记得 The Name And Create The Hash Element For That 人.

=EN The unless exists test ensures that we won't delete someone's provision list if his list is split in two places in the datafile.

=CN The Unless Exists Test ensures That We Won't Delete Someone's 准备 List If 他的 List Is Split In Two Places In The datafile.

=EN For example, suppose that "The Skipper" and "sextant" (note the leading whitespace) are at the end of the datafile in order to list an additional data item.

=CN For Example, 猜想 That "The Skipper" And "sextant" (Note The 领先的 Whitespace) Are At The End Of The datafile In Order To List An Additional Data 条款.

=EN The key is the person's name, and the value is initially a reference to an empty anonymous array.

=CN The Key Is The 人's Name, And The Value Is 最初 a Reference To An Empty Anonymous Array.

=EN If the line is a provision, push it to the end of the correct array, using the array reference.

=CN If The Line Is a 准备, Push It To The End Of The 正确的 Array, Using The Array Reference.

=EN This code works fine, but it actually says more than it needs to.

=CN This Code Works Fine, But It Actually 说 More Than It Needs To.

=EN Because we can leave out the line that initializes the hash element's value to a reference to an empty array:

=CN Because We Can 出发 Out The Line That 初始化 The Hash Element's Value To a Reference To An Empty Array:

=EN ## $provisions{$person} = [ ] unless exists $provisions{$person};

=CN ## $provisions{$人} = [ ] Unless Exists $provisions{$人};

=EN What happens when we try to store that blue shirt for the Skipper?

=CN What Happens When We Try To 商店 That 蓝色的 衬衣 For The Skipper?

=EN While looking at the second line of input, we'll end up with this effect:

=CN While 看 At The Second Line Of Input, We'我 End Up With This Effect:

=EN push @{ $provisions{'The Skipper'} }, "blue_shirt";

=CN Push @{ $provisions{'The Skipper'} }, "blue_shirt";

=EN At this point, $provisions{"The Skipper"} doesn't exist, but we're trying to use it as an array reference.

=CN At This 尖, $provisions{"The Skipper"} Doesn't Exist, But We'Re 尝试 To Use It As An Array Reference.

=EN To resolve the situation, Perl automatically inserts a reference to a new empty anonymous array into the variable and continues the operation.

=CN To 决定 The 形势, Perl Automatically inserts a Reference To a New Empty Anonymous Array Into The Variable And 继续 The Operation.

=EN In this case, the reference to the newly created empty array is dereferenced, and we push the blue shirt to the provisions list.

=CN In This Case, The Reference To The 新 Created Empty Array Is dereferenced, And We Push The 蓝色的 衬衣 To The provisions List.

=EN This process is called autovivification.

=CN This 程序 Is Called autovivification.

=EN Any nonexistent variable, or a variable containing undef, which we dereference while looking for a variable location (technically called an lvalue context), is automatically stuffed with the appropriate reference to an empty item, and Perl allows the operation to proceed.

=CN Any nonexistent Variable, Or a Variable Containing Undef, Which We 废弃 While 看 For a Variable 地点 (technically Called An 左值 Context), Is Automatically 塞 With The 恰当的 Reference To An Empty 条款, And Perl Allows The Operation To 前进.

=EN This is actually the same behavior we've probably been using in Perl all along.

=CN This Is Actually The Same Behavior We'Ve Probably Been Using In Perl All 沿着.

=EN Perl creates new variables as needed.

=CN Perl Creates New Variables As Needed.

=EN Before that statement, $provisions{"The Skipper"} didn't exist, so Perl created it.

=CN Before That Statement, $provisions{"The Skipper"} Didn't Exist, So Perl Created It.

=EN Then @{ $provisions{"The Skipper"} } didn't exist, so Perl created it as well.

=CN Then @{ $provisions{"The Skipper"} } Didn't Exist, So Perl Created It As Well.

=EN For example, this works:

=CN For Example, This Works:

=EN my $not_yet; # new undefined variable @$not_yet = (1, 2, 3);

=CN My $not_yet; # New Undefined Variable @$not_yet = (1, 2, 3);

=EN Here, we dereference the value $not_yet as if it were an array reference.

=CN Here, We 废弃 The Value $not_yet As If It Were An Array Reference.

=EN But since it's initially undef, Perl acts as if we had said:

=CN But Since It's 最初 Undef, Perl 徒 As If We Had Said:

=EN my $not_yet; $not_yet = [ ]; # inserted through autovivification @$not_yet = (1, 2, 3);

=CN My $not_yet; $not_yet = [ ]; # 插入 通过 autovivification @$not_yet = (1, 2, 3);

=EN In other words, an initially empty array becomes an array of three elements.

=CN In Other Words, An 最初 Empty Array Becomes An Array Of Three Elements.

=EN This autovivification also works for multiple levels of assignment:

=CN This autovivification Also Works For Multiple levels Of Assignment:

=EN my $top; $top->[2]->[4] = 'lee-lou';

=CN My $顶; $顶->[2]->[4] = 'lee-lou';

=EN Initially, $top contains undef, but because we dereference it as if it were an array reference, Perl inserts a reference to an empty anonymous array into $top.

=CN Initially, $顶 包含 Undef, But Because We 废弃 It As If It Were An Array Reference, Perl inserts a Reference To An Empty Anonymous Array Into $顶.

=EN Perl then accesses the third element (index value 2), which causes Perl to grow the array to be three elements long.

=CN Perl Then Accesses The 第三 Element (Index Value 2), Which Causes Perl To Grow The Array To Be Three Elements Long.

=EN That element is also undef, so Perl stuffs it with a reference to another empty anonymous array.

=CN That Element Is Also Undef, So Perl stuffs It With a Reference To 另一个 Empty Anonymous Array.

=EN We then spin out along that newly created array, setting the fifth element to lee-lou.

=CN We Then 自转 Out 沿着 That 新 Created Array, Setting The fifth Element To lee-lou.

=EN Autovivification and Hashes Autovivification also works for hash references .

=CN Autovivification And Hashes Autovivification Also Works For Hash References .

=EN If we dereference a variable containing undef as if it were a hash reference, a reference to an empty anonymous hash is inserted, and the operation continues.

=CN If We 废弃 a Variable Containing Undef As If It Were a Hash Reference, a Reference To An Empty Anonymous Hash Is 插入, And The Operation 继续.

=EN One place this comes in very handy is in a typical data reduction task.

=CN One Place This 来 In Very 方便的 Is In a 典型的 Data 减少 工作.

=EN For example, let's say the Professor gets an island-area network up and running (perhaps using Coco-Net or maybe Vines) and now wants to track the traffic from host to host.

=CN For Example, Let's Say The Professor Gets An 岛屿-Area 网络 Up And 连续的 (也许 Using Coco-Net Or 或许 Vines) And Now 要 To 径赛 The 交通 From 一大群 To 一大群.

=EN He begins logging the number of bytes transferred to a log file, giving the source host, the destination host, and the number of transferred bytes:

=CN He begins logging The Number Of 字节 transferred To a 原木 File, Giving The Source 一大群, The 终点 一大群, And The Number Of transferred 字节:

=EN professor.hut gilligan.crew.hut 1250 professor.hut lovey.howell.hut 910 thurston.howell.hut lovey.howell.hut 1250 professor.hut lovey.howell.hut 450 professor.hut laser3.copyroom.hut 2924 ginger.girl.hut professor.hut 1218 ginger.girl.hut maryann.girl.hut 199 ...

=CN professor.hut gilligan.crew.小屋 1250 professor.hut lovey.howell.小屋 910 thurston.howell.小屋 lovey.howell.小屋 1250 professor.hut lovey.howell.小屋 450 professor.hut laser3.copyroom.小屋 2924 ginger.girl.小屋 professor.hut 1218 ginger.girl.小屋 maryann.girl.小屋 199 ...

=EN Now the Professor wants to produce a summary of the source host, the destination host, and the total number of transferred bytes for the day.

=CN Now The Professor 要 To Produce a 概要 Of The Source 一大群, The 终点 一大群, And The 总 Number Of transferred 字节 For The 一天.

=EN Tabulating the data is as simple as:

=CN Tabulating The Data Is As Simple As:

=EN my %total_bytes; while (<>) {

=CN My %total_bytes; While (<>) {

=EN Let's see how this works on the first line of data.

=CN Let's See How This Works On The First Line Of Data.

=EN We'll be executing:

=CN We'我 Be 执行:

=EN $total_bytes{'professor.hut'}{'gilligan.crew.hut'} += 1250;

=CN $total_bytes{'professor.hut'}{'gilligan.crew.小屋'} += 1250;

=EN Because %total_bytes is initially empty, Perl doesn't find the first key of professor.hut, but it establishes an undef value for the dereferencing as a hash reference.

=CN Because %total_bytes Is 最初 Empty, Perl Doesn't 寻找 The First Key Of professor.hut, But It establishes An Undef Value For The dereferencing As a Hash Reference.

=EN (Keep in mind that an implicit arrow is between the two sets of curly braces here.)

=CN (Keep In Mind That An Implicit 箭 Is Between The Two Sets Of 卷曲的 牙套 Here.)

=EN Perl sticks a reference to an empty anonymous hash in that element, which it then immediately extends to include the element with a key of gilligan.crew.hut.

=CN Perl sticks a Reference To An Empty Anonymous Hash In That Element, Which It Then 立即 Extends To Include The Element With a Key Of gilligan.crew.小屋.

=EN Its initial value is undef, which acts like a zero when you add 1250 to it, and the result of 1250 is inserted back into the hash.

=CN Its Initial Value Is Undef, Which 徒 Like a 零 When You 增添 1250 To It, And The Result Of 1250 Is 插入 Back Into The Hash.

=EN Any later data line that contains this same source host and destination host will re-use that same value, adding more bytes to the running total.

=CN Any 更晚 Data Line That 包含 This Same Source 一大群 And 终点 一大群 Will Re-Use That Same Value, Adding More 字节 To The 连续的 总.

=EN But each new destination host extends a hash to include a new initially undef byte count, and each new source host uses autovivification to create a destination host hash.

=CN But Each New 终点 一大群 Extends a Hash To Include a New 最初 Undef 字节 计算, And Each New Source 一大群 Uses autovivification To Create a 终点 一大群 Hash.

=EN In other words, Perl does the right thing, as always.

=CN In Other Words, Perl Does The Right Thing, As Always.

=EN Once we've processed the file, it's time to display the summary.

=CN Once We'Ve processed The File, It's Time To 陈列 The 概要.

=EN First, we determine all the sources:

=CN First, We 决心 All The 来源:

=EN for my $source (keys %total_bytes) { ...

=CN For My $Source (Keys %total_bytes) { ...

=EN Now, we should get all destinations.

=CN Now, We Should Get All destinations.

=EN The syntax for this is a bit tricky.

=CN The Syntax For This Is a Bit 巧妙的.

=EN We want all keys of the hash, resulting from dereferencing the value of the hash element, in the first structure:

=CN We Want All Keys Of The Hash, 造成 From dereferencing The Value Of The Hash Element, In The First Structure:

=EN for my $source (keys %total_bytes) {

=CN For My $Source (Keys %total_bytes) {

=EN For good measure, we should probably sort both lists to be consistent:

=CN For Good 尺寸, We Should Probably Sort Both Lists To Be 始终如一的:

=EN for my $source (sort keys %total_bytes) {

=CN For My $Source (Sort Keys %total_bytes) {

=EN This is a typical data-reduction report generation strategy.[*] Simply create a hash-of-hashrefs (perhaps nested even deeper, as you'll see later), using autovivification to fill in the gaps in the upper data structures as needed, and then walk through the resulting data structure to display the results.

=CN This Is a 典型的 Data-减少 报告 Generation 战略.[*] Simply Create a Hash-Of-hashrefs (也许 嵌套的 Even deeper, As You'我 See 更晚), Using autovivification To 装满 In The gaps In The Upper Data Structures As Needed, And Then 步行 通过 The 造成 Data Structure To 陈列 The Results.

=EN Exercises You can find the answers to these exercises in "Answers for Chapter 5" in the Appendix.

=CN Exercises You Can 寻找 The answers To These exercises In "Answers For Chapter 5" In The Appendix.

=EN Exercise 1 [5 min] Without running it, can you see what's wrong with this piece of a program?

=CN Exercise 1 [5 min] Without 连续的 It, Can You See What's 错误的 With This 件 Of a Program?

=EN If you can't see the problem after a minute or two, see whether trying to run it will give you a hint of how to fix it.

=CN If You Can't See The Problem After a 分钟 Or Two, See Whether 尝试 To Run It Will Give You a 暗示 Of How To 固定 It.

=EN my %passenger_1 = {

=CN My %passenger_1 = {

=EN my %passenger_2 = {

=CN My %passenger_2 = {

=EN my @passengers = (\%passenger_1, \%passenger_2);

=CN My @passengers = (\%passenger_1, \%passenger_2);

=EN Exercise 2 [40 min] The Professor's datafile (mentioned earlier in this chapter) is available as coconet.dat in the files you can download from the O'Reilly web site.

=CN Exercise 2 [40 min] The Professor's datafile (Mentioned Earlier In This 章) Is Available As coconet.dat In The Files You Can download From The O'Reilly 网 场所.

=EN There may be comment lines (beginning with a pound sign); be sure to skip them.

=CN There May Be Comment Lines (开端 With a 英镑 Sign); Be Sure To 跳过 Them.

=EN (That is, your program should skip them.

=CN (That Is, Your Program Should 跳过 Them.

=EN You might find a helpful hint if you read them!)

=CN You Might 寻找 a 有用的 暗示 If You Read Them!)

=EN Modify the code from this chapter so that each source machine's portion of the output shows the total number of bytes from that machine.

=CN Modify The Code From This 章 So That Each Source 机器's 一份 Of The 出产 Shows The 总 Number Of 字节 From That 机器.

=EN List the source machines in order from most to least data transferred.

=CN List The Source Machines In Order From Most To Least Data transferred.

=EN Within each group, list the destination machines in order from most to least data transferred to that target from the source machine.

=CN Within Each Group, List The 终点 Machines In Order From Most To Least Data transferred To That 目标 From The Source 机器.

=EN The result should be that the machine that sent the most data will be the first source machine in the list, and the first destination should be the machine to which it sent the most data.

=CN The Result Should Be That The 机器 That 打发 The Most Data Will Be The First Source 机器 In The List, And The First 终点 Should Be The 机器 To Which It 打发 The Most Data.

=EN The Professor can use this printout to reconfigure the network for efficiency.

=CN The Professor Can Use This printout To reconfigure The 网络 For Efficiency.

