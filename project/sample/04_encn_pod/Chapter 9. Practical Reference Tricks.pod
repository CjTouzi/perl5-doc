=EN This chapter looks at optimizing sorting and dealing with recursively defined data.

=CN This 章 Looks At optimizing sorting And 交往 With Recursively Defined Data.

=EN Review of Sorting Perl's built-in sort operator sorts text strings in their natural text order, by default.[*] This is fine if we want to sort text strings:

=CN Review Of Sorting Perl's Built-In Sort Operator 各样 正文 Strings In Their 自然的 正文 Order, By Default.[*] This Is Fine If We Want To Sort 正文 Strings:

=EN [*] My friends call that the "ASCIIbetical" ordering.

=CN [*] My 朋友 Call That The "美国信息交换标准码betical" 订购.

=EN Normally, modern Perl doesn't use ASCII; instead, it uses a default sort order, depending on the current locale and character set.

=CN Normally, Modern Perl Doesn't Use 美国信息交换标准码; Instead, It Uses a Default Sort Order, Depending On The Current 本地 And Character Set.

=EN See the perllocale (not perllocal!) manpage.

=CN See The perllocale (Not perllocal!) manpage.

=EN my @sorted = sort qw(Gilligan Skipper Professor Ginger Mary_Ann);

=CN My @分类 = Sort Qw(Gilligan Skipper Professor Ginger Mary_Ann);

=EN but gets pretty messy when we want to sort numbers:

=CN But Gets 精致的 messy When We Want To Sort 编号:

=EN my @wrongly_sorted = sort 1, 2, 4, 8, 16, 32;

=CN My @wrongly_sorted = Sort 1, 2, 4, 8, 16, 32;

=EN The resulting list is 1, 16, 2, 32, 4, 8.

=CN The 造成 List Is 1, 16, 2, 32, 4, 8.

=EN Why didn't sort order these properly?

=CN Why Didn't Sort Order These Properly?

=EN It treats each item as a string and sorts them in string order.

=CN It treats Each 条款 As a String And 各样 Them In String Order.

=EN Any string that begins with 3 sorts before any string that begins with 4.

=CN Any String That begins With 3 各样 Before Any String That begins With 4.

=EN If we don't want the default sorting order, we don't need to write an entire sorting algorithm, which is good news since Perl already has a good one of those.

=CN If We Don't Want The Default sorting Order, We Don't Need To Write An 完全的 sorting 算法, Which Is Good 新闻 Since Perl Already Has a Good One Of Those.

=EN But no matter what sorting algorithm we use, at some point we have to look at item A and item B and decide which one comes first.

=CN But No Matter What sorting 算法 We Use, At Some 尖 We Have To Look At 条款 A And 条款 B And Decide Which One 来 First.

=EN That's the part we'll write: code to handle just two items.

=CN That's The Part We'我 Write: Code To Handle Just Two 物品.

=EN Perl will do the rest.

=CN Perl Will Do The 休息.

=EN By default, as Perl orders the items, it uses a string comparison.

=CN By Default, As Perl orders The 物品, It Uses a String 比较.

=EN We can specify a new comparison using a sort block that we place between the sort keyword and the list of things to sort.[] Within the sort block, $a and $b stand in for two of the items sort will compare.

=CN We Can Specify a New 比较 Using a Sort Block That We Place Between The Sort Keyword And The List Of Things To Sort.[] Within The Sort Block, $a And $b 站立 In For Two Of The 物品 Sort Will 比较.

=EN If we're sorting numbers, then $a and $b will be two numbers from our list.

=CN If We'Re sorting 编号, Then $a And $b Will Be Two 编号 From Our List.

=EN [] We can also used a name subroutine that sort invokes for each comparison.

=CN [] We Can Also Used a Name Subroutine That Sort invokes For Each 比较.

=EN The sort block must return a coded value to indicate the sort order.

=CN The Sort Block Must Return a coded Value To 指明 The Sort Order.

=EN If $a comes before $b in our desired sorting order, it should return -1; it should return +1 if $b comes before $a; if the order doesn't matter, it should return 0.

=CN If $a 来 Before $b In Our Desired sorting Order, It Should Return -1; It Should Return +1 If $b 来 Before $a; If The Order Doesn't Matter, It Should Return 0.

=EN The order might not matter, for example, if it's a case-insensitive sort comparing "FRED" to "Fred", or if it's a numeric sort comparing 42 to 42.[*]

=CN The Order Might Not Matter, For Example, If It's a Case-insensitive Sort comparing "FRED" To "Fred", Or If It's a 数值 Sort comparing 42 To 42.[*]

=EN [*] Actually, we can use any negative or positive number in place of -1 and +1, respectively.

=CN [*] Actually, We Can Use Any 否定的 Or 明确的 Number In Place Of -1 And +1, 各自.

=EN Recent Perl versions include a default sorting engine that is stable, so zero returns from the sort block cause the relative ordering of $a and $b to reflect their order in the original list.

=CN Recent Perl Versions Include a Default sorting 发动机 That Is 稳固的, So 零 Returns From The Sort Block 原因 The 亲戚 订购 Of $a And $b To 反射 Their Order In The Original List.

=EN Older versions of Perl didn't guarantee such stability, and a future version might not use a stable sort, so don't rely on it.

=CN Older Versions Of Perl Didn't 保证 Such 稳定性, And a Future Version Might Not Use a 稳固的 Sort, So Don't 依靠 On It.

=EN For example, to sort those numbers in their proper order, we can use a sort block comparing $a and $b, like so:

=CN For Example, To Sort Those 编号 In Their 合适的 Order, We Can Use a Sort Block comparing $a And $b, Like So:

=EN my @numerically_sorted = sort {

=CN My @numerically_sorted = Sort {

=EN Now we have a proper numeric comparison, so we have a proper numeric sort.

=CN Now We Have a 合适的 数值 比较, So We Have a 合适的 数值 Sort.

=EN Of course, this is far too much typing, so we can use the spaceship operator instead:

=CN Of Course, This Is Far Too Much 打字, So We Can Use The 太空船 Operator Instead:

=EN my @numerically_sorted = sort { $a <=> $b } 1, 2, 4, 8, 16, 32;

=CN My @numerically_sorted = Sort { $a <=> $b } 1, 2, 4, 8, 16, 32;

=EN The spaceship operator returns -1, 0, and +1, according to the rules we laid out.

=CN The 太空船 Operator Returns -1, 0, And +1, 按照 To The 规则 We 铺设 Out.

=EN A descending sort is simple in Perl:[]

=CN A descending Sort Is Simple In Perl:[]

=EN [] As of version 5.8.6, Perl recognizes the reverse sort and does it without generating the temporary, intermediate list.

=CN [] As Of Version 5.8.6, Perl recognizes The 颠倒的 Sort And Does It Without Generating The temporary, 中间的 List.

=EN my @numerically_descending =

=CN My @numerically_descending =

=EN But there is more than one way to do it.

=CN But There Is More Than One Way To Do It.

=EN The spaceship operator is nearsighted; and can't see which one of its parameters comes from $a and which from $b; it sees only which value is to its left and which is to its right.

=CN The 太空船 Operator Is nearsighted; And Can't See Which One Of Its Parameters 来 From $a And Which From $b; It 看到 Only Which Value Is To Its Left And Which Is To Its Right.

=EN If we reverse the position of $a and $b, the spaceship will sort everything in the opposite order:

=CN If We 颠倒的 The Position Of $a And $b, The 太空船 Will Sort Everything In The 对立的 Order:

=EN In every place the previous sort expression returned -1, this expression returns +1, and vice versa.

=CN In Every Place The Previous Sort Expression Returned -1, This Expression Returns +1, And 坏事 versa.

=EN Thus, the sort is in the opposite order, and so it doesn't need a reverse.

=CN Thus, The Sort Is In The 对立的 Order, And So It Doesn't Need a 颠倒的.

=EN It's also easy to remember because if $a is to the left of $b, we get out the lower items first, just like a and b would be in the resulting list.

=CN It's Also Easy To 记得 Because If $a Is To The Left Of $b, We Get Out The Lower 物品 First, Just Like a And b Would Be In The 造成 List.

=EN Which way is better?

=CN Which Way Is Better?

=EN When should we use a reverse sort, and when should we switch $a and $b?

=CN When Should We Use a 颠倒的 Sort, And When Should We Switch $a And $b?

=EN Well, in most cases it shouldn't matter much for efficiency, so it's probably best to optimize for clarity and use reverse.

=CN Well, In Most Cases It 应该't Matter Much For Efficiency, So It's Probably Best To 最佳化 For 清晰 And Use 颠倒的.

=EN For a more complex comparison, however, a single reverse may not be up to the task.

=CN For a More 综合的 比较, However, a Single 颠倒的 May Not Be Up To The 工作.

=EN Like the spaceship operator, we can indicate a string sort with cmp, although this is rarely used alone because it is the default comparison.

=CN Like The 太空船 Operator, We Can 指明 a String Sort With cmp, Although This Is 难得 Used 单独的 Because It Is The Default 比较.

=EN The cmp operator is most often used in more complex comparisons, as we'll show shortly.

=CN The cmp Operator Is Most Often Used In More 综合的 comparisons, As We'我 Show 立刻.

=EN Sorting with Indices In the same way we used indices to solve a few problems with grep and map back in Chapter 2, we can also use indices with sort to get some interesting results.

=CN Sorting With Indices In The Same Way We Used indices To 解答 a Few 问题 With Grep And Map Back In Chapter 2, We Can Also Use indices With Sort To Get Some Interesting Results.

=EN For example, let's sort the list of names from earlier:

=CN For Example, Let's Sort The List Of Names From Earlier:

=EN my @sorted = sort qw(Gilligan Skipper Professor Ginger Mary_Ann); print "@sorted\n";

=CN My @分类 = Sort Qw(Gilligan Skipper Professor Ginger Mary_Ann); Print "@分类\n";

=EN which necessarily results in:

=CN Which Necessarily Results In:

=EN But what if we wanted to look at the original list and determine which element of the original list now appears as the first, second, third, and so on, element of the sorted list?

=CN But What If We 想要 To Look At The Original List And 决心 Which Element Of The Original List Now Appears As The First, Second, 第三, And So On, Element Of The 分类 List?

=EN For example, Ginger is the second element of the sorted list and was the fourth element of the original list.

=CN For Example, Ginger Is The Second Element Of The 分类 List And Was The 第四 Element Of The Original List.

=EN How do we determine that the second element of the final list was the fourth element of the original list?

=CN How Do We 决心 That The Second Element Of The 最终的 List Was The 第四 Element Of The Original List?

=EN Well, we can apply a bit of indirection.

=CN Well, We Can 应用 a Bit Of indirection.

=EN Let's not sort the actual names but rather the indices of each name:

=CN Let's Not Sort The Actual Names But Rather The indices Of Each Name:

=EN my @input = qw(Gilligan Skipper Professor Ginger Mary_Ann); my @sorted_positions = sort { $input[$a] cmp $input[$b] } 0..$#input; print "@sorted_positions\n";

=CN My @Input = Qw(Gilligan Skipper Professor Ginger Mary_Ann); My @sorted_positions = Sort { $Input[$a] cmp $Input[$b] } 0..$#Input; Print "@sorted_positions\n";

=EN This time, $a and $b aren't the elements of the list, but the indices.

=CN This Time, $a And $b 还't The Elements Of The List, But The indices.

=EN So instead of comparing $a to $b, we use cmp to compare $input[$a] to $input[$b] as strings.

=CN So Instead Of comparing $a To $b, We Use cmp To 比较 $Input[$a] To $Input[$b] As Strings.

=EN The result of the sort are the indices, in an order defined by the corresponding elements of @input.

=CN The Result Of The Sort Are The indices, In An Order Defined By The 相应的 Elements Of @Input.

=EN This prints 0 3 4 2 1, which means that the first element of the sorted list is element 0 of the original list, Gilligan.

=CN This Prints 0 3 4 2 1, Which Means That The First Element Of The 分类 List Is Element 0 Of The Original List, Gilligan.

=EN The second element of the sorted list is element 3 of the original list, which is Ginger, and so on.

=CN The Second Element Of The 分类 List Is Element 3 Of The Original List, Which Is Ginger, And So On.

=EN Now we can rank information rather than just move the names around.

=CN Now We Can 军衔 Information Rather Than Just Move The Names Around.

=EN Actually, we have the inverse of the rank.

=CN Actually, We Have The 相反的 Of The 军衔.

=EN We still don't know, for a given name in the original list, which position it occupies in the output list.

=CN We Still Don't Know, For a Given Name In The Original List, Which Position It occupies In The 出产 List.

=EN But with a bit more magic, we can get there as well:

=CN But With a Bit More Magic, We Can Get There As Well:

=EN my @input = qw(Gilligan Skipper Professor Ginger Mary_Ann); my @sorted_positions = sort { $input[$a] cmp $input[$b] } 0..$#input; my @ranks; @ranks[@sorted_positions] = (0..$#sorted_positions); print "@ranks\n";

=CN My @Input = Qw(Gilligan Skipper Professor Ginger Mary_Ann); My @sorted_positions = Sort { $Input[$a] cmp $Input[$b] } 0..$#Input; My @ranks; @ranks[@sorted_positions] = (0..$#sorted_positions); Print "@ranks\n";

=EN The code prints 0 4 3 1 2.

=CN The Code Prints 0 4 3 1 2.

=EN This means that Gilligan is position 0 in the output list, Skipper is position 4, Professor is position 2, and so on.

=CN This Means That Gilligan Is Position 0 In The 出产 List, Skipper Is Position 4, Professor Is Position 2, And So On.

=EN The positions here are 0-based, so add 1 to get "human" ordinal values.

=CN The 位置 Here Are 0-基于, So 增添 1 To Get "人的" ordinal Values.

=EN One way to cheat is to use 1..@sorted_positions instead of 0..$#sorted_positions, so a way to dump it all out looks like:

=CN One Way To Cheat Is To Use 1..@sorted_positions Instead Of 0..$#sorted_positions, So a Way To 倾倒 It All Out Looks Like:

=EN my @input = qw(Gilligan Skipper Professor Ginger Mary_Ann); my @sorted_positions = sort { $input[$a] cmp $input[$b] } 0..$#input; my @ranks; @ranks[@sorted_positions] = (1..@sorted_positions); for (0..$#ranks) {

=CN My @Input = Qw(Gilligan Skipper Professor Ginger Mary_Ann); My @sorted_positions = Sort { $Input[$a] cmp $Input[$b] } 0..$#Input; My @ranks; @ranks[@sorted_positions] = (1..@sorted_positions); For (0..$#ranks) {

=EN This results in:

=CN This Results In:

=EN Gilligan sorts into position 1 Skipper sorts into position 5 Professor sorts into position 4 Ginger sorts into position 2 Mary_Ann sorts into position 3

=CN Gilligan 各样 Into Position 1 Skipper 各样 Into Position 5 Professor 各样 Into Position 4 Ginger 各样 Into Position 2 Mary_Ann 各样 Into Position 3

=EN This general technique can be convenient if we need to look at our data in more than one way.

=CN This General 技术 Can Be 便利的 If We Need To Look At Our Data In More Than One Way.

=EN Perhaps we keep many records in order by a numeric code for efficiency reasons, but we occasionally want to view them in alphabetical order as well.

=CN Perhaps We 保持 Many Records In Order By a 数值 Code For Efficiency Reasons, But We Occasionally Want To 视域 Them In alphabetical Order As Well.

=EN Or maybe the data items themselves are impractical to sort, such as a month's worth of server logs.

=CN Or 或许 The Data 物品 他们、它们自己 Are 不可行的 To Sort, Such As a 月份's worth Of server logs.

=EN Sorting Efficiently As the Professor tries to maintain the community computing facility (built entirely out of bamboo, coconuts, and pineapples, and powered by a certified Perl-hacking monkey), he continues to discover that people are leaving entirely too much data on the single monkey-powered filesystem and decides to print a list of offenders.

=CN Sorting Efficiently As The Professor 试 To Maintain The 团体 computing 方便 (Built 完全地 Out Of 竹, coconuts, And pineapples, And powered By a certified Perl-破解 猴子), 他 继续 To 发现 That People Are 离开 完全地 Too Much Data On The Single 猴子-powered filesystem And decides To Print a List Of offenders.

=EN The Professor has written a subroutine called ask_monkey_about( ), which, given a castaway's name, returns the number of pineapples of storage they use.

=CN The Professor Has Written a Subroutine Called ask_monkey_about( ), Which, Given a castaway's Name, Returns The Number Of pineapples Of 贮藏 They Use.

=EN We have to ask the monkey because he's in charge of the pineapples.

=CN We Have To 问 The 猴子 Because 他's In 收费 Of The pineapples.

=EN An initial naive approach to find the offenders from greatest to least might be something like:

=CN An Initial 天真的 接近 To 寻找 The offenders From greatest To Least Might Be Something Like:

=EN my @castaways =

=CN My @castaways =

=EN In theory, this would be fine.

=CN In 理论, This Would Be Fine.

=EN For the first pair of names (Gilligan and Skipper), we ask the monkey "How many pineapples does Gilligan have?" and "How many pineapples does Skipper have?"

=CN For The First 对 Of Names (Gilligan And Skipper), We 问 The 猴子 "How Many pineapples Does Gilligan Have?" And "How Many pineapples Does Skipper Have?"

=EN We get back two values from the monkey and use them to order Gilligan and Skipper in the final list.

=CN We Get Back Two Values From The 猴子 And Use Them To Order Gilligan And Skipper In The 最终的 List.

=EN However, at some point, we have to compare the number of pineapples that Gilligan has with another castaway as well.

=CN However, At Some 尖, We Have To 比较 The Number Of pineapples That Gilligan Has With 另一个 castaway As Well.

=EN For example, suppose the pair is Ginger and Gilligan.

=CN For Example, 猜想 The 对 Is Ginger And Gilligan.

=EN We ask the monkey about Ginger, get a number back, and then ask the monkey about Gilligan...again.

=CN We 问 The 猴子 About Ginger, Get a Number Back, And Then 问 The 猴子 About Gilligan...Again.

=EN This will probably annoy the monkey a bit, since we already asked earlier.

=CN This Will Probably 烦扰 The 猴子 a Bit, Since We Already 问 Earlier.

=EN But we need to ask for each value two, three, or maybe even four times, just to put the seven values into order.

=CN But We Need To 问 For Each Value Two, Three, Or 或许 Even 四 Times, Just To Put The seven Values Into Order.

=EN This can be a problem because it irritates the monkey.

=CN This Can Be a Problem Because It irritates The 猴子.

=EN How do we keep the number of monkey requests to a minimum?

=CN How Do We 保持 The Number Of 猴子 Requests To a 最少量?

=EN Well, we can build a table first.

=CN Well, We Can Build a Table First.

=EN We use a map with seven inputs and seven outputs, turning each castaway item into a separate array reference, with each referenced array consisting of the castaway name and the pineapple count reported by the monkey:

=CN We Use a Map With seven inputs And seven outputs, Turning Each castaway 条款 Into a Separate Array Reference, With Each 参考 Array consisting Of The castaway Name And The 菠萝 计算 reported By The 猴子:

=EN my @names_and_pineapples = map {

=CN My @names_and_pineapples = Map {

=EN At this point, we asked the monkey seven questions in a row, but that's the last time we have to talk to the monkey!

=CN At This 尖, We 问 The 猴子 seven Questions In a 划船, But That's The Last Time We Have To 谈话 To The 猴子!

=EN We now have everything we need to finish the task.

=CN We Now Have Everything We Need To 结束 The 工作.

=EN For the next step, we sort the arrayrefs, ordering them by the monkey-returned value:

=CN For The 下一次 脚步, We Sort The arrayrefs, 订购 Them By The 猴子-Returned Value:

=EN my @sorted_names_and_pineapples = sort {

=CN My @sorted_names_and_pineapples = Sort {

=EN In this subroutine, $a and $b are still two elements from the list of things to be sorted.

=CN In This Subroutine, $a And $b Are Still Two Elements From The List Of Things To Be 分类.

=EN When we're sorting numbers, $a and $b are numbers; when we're sorting references, $a and $b are references.

=CN When We'Re sorting 编号, $a And $b Are 编号; When We'Re sorting References, $a And $b Are References.

=EN We dereference them to get to the corresponding array itself, and pick out item 1 from the array (the monkey's pineapple value).

=CN We 废弃 Them To Get To The 相应的 Array Itself, And 拣 Out 条款 1 From The Array (The 猴子's 菠萝 Value).

=EN Because $b appears to the left of $a, it'll be a descending sort as well.

=CN Because $b Appears To The Left Of $a, It'我 Be a descending Sort As Well.

=EN (We want a descending sort because the Professor wants the first name on the list to be the person who uses the most pineapples.)

=CN (We Want a descending Sort Because The Professor 要 The First Name On The List To Be The 人 Who Uses The Most pineapples.)

=EN We're almost done, but what if we just wanted the top names, rather than the names and pineapple counts?

=CN We'Re Almost Done, But What If We Just 想要 The 顶 Names, Rather Than The Names And 菠萝 计数?

=EN We merely need to perform another map to transform the references back to the original data:

=CN We 仅仅 Need To 执行 另一个 Map To 转变 The References Back To The Original Data:

=EN my @names = map $_->[0], @sorted_names_and_pineapples;

=CN My @Names = Map $_->[0], @sorted_names_and_pineapples;

=EN Each element of the list ends up in $_, so we'll dereference that to pick out the element 0 of that array, which is just the name.

=CN Each Element Of The List Ends Up In $_, So We'我 废弃 That To 拣 Out The Element 0 Of That Array, Which Is Just The Name.

=EN Now we have a list of names, ordered by their pineapple counts, and the monkey's off our backs, all in three easy steps.

=CN Now We Have a List Of Names, ordered By Their 菠萝 计数, And The 猴子's Off Our backs, All In Three Easy 步骤.

=EN The Schwartzian Transform The intermediate variables between each of these steps were not necessary, except as input to the next step.

=CN The Schwartzian Transform The 中间的 Variables Between Each Of These 步骤 Were Not 必要的, Except As Input To The 下一次 脚步.

=EN We can save ourselves some brainpower by just stacking all the steps together:

=CN We Can Save 我们自己 Some brainpower By Just stacking All The 步骤 Together:

=EN my @names =

=CN My @Names =

=EN Because the map and sort operators are right to left, we have to read this construct from the bottom up.

=CN Because The Map And Sort Operators Are Right To Left, We Have To Read This Construct From The 底部 Up.

=EN Take a list of @castaways, create some arrayrefs by asking the monkey a simple question, sort the list of arrayrefs, and then extract the names from each arrayref.

=CN Take a List Of @castaways, Create Some arrayrefs By 问 The 猴子 a Simple Question, Sort The List Of arrayrefs, And Then 取出 The Names From Each Arrayref.

=EN This gives us the list of names in the desired order.

=CN This Gives Us The List Of Names In The Desired Order.

=EN This construct is commonly called the Schwartzian Transform, which was named after Randal (but not by Randal), thanks to a Usenet posting he made many years ago.

=CN This Construct Is 通常 Called The Schwartzian Transform, Which Was Named After Randal (But Not By Randal), 感谢int To a Usenet posting 他 Made Many Years 以前.

=EN The Schwartzian Transform has since proven to be a very nice thing to have in our bag of sorting tricks.

=CN The Schwartzian Transform Has Since proven To Be a Very Nice Thing To Have In Our 袋子 Of sorting 把戏.

=EN If this transform looks like it might be too complex to memorize or come up with from first principles, it might help to look at the flexible and constant parts:

=CN If This 转变 Looks Like It Might Be Too 综合的 To 记住 Or 来到 Up With From First 原则, It Might Help To Look At The 柔韧的 And Constant 部分:

=EN my @output_data =

=CN My @output_data =

=EN The basic structure maps the original list into a list of arrayrefs, computing the expensive function only once for each; sorts those array refs, looking at the cached value of each expensive function invocation;[*] and then extracts the original values back out in the new order.

=CN The 基本的 Structure 地图 The Original List Into a List Of arrayrefs, computing The Expensive Function Only Once For Each; 各样 Those Array 裁判, 看 At The cached Value Of Each Expensive Function 调用;[*] And Then extracts The Original Values Back Out In The New Order.

=EN All we have to do is plug in the proper two operations, and we're done.

=CN All We Have To Do Is 塞子 In The 合适的 Two 操作, And We'Re Done.

=EN For example, to use the Schwartzian Transform to implement a case-insensitive sort, we could use code like this:[]

=CN For Example, To Use The Schwartzian Transform To 实行 a Case-insensitive Sort, We Could Use Code Like This:[]

=EN [*] An expensive operation is one that takes a relatively long time or a relatively large amount of memory.

=CN [*] An Expensive Operation Is One That Takes a 比较地 Long Time Or a 比较地 Large 数量 Of Memory.

=EN [] This is an efficient way to do this only if the uppercasing operation is sufficiently expensive, which it might be if our strings tend to be very long or if we have a large enough number of them.

=CN [] This Is An Efficient Way To Do This Only If The uppercasing Operation Is 充分地 Expensive, Which It Might Be If Our Strings 趋向 To Be Very Long Or If We Have a Large Enough Number Of Them.

=EN For a small number of not-long strings, a simple my @output_data = sort { "\U$a" cmp "\U$b"} @input_data is probably more efficient.

=CN For a Small Number Of Not-Long Strings, a Simple My @output_data = Sort { "\U$a" cmp "\U$b"} @input_data Is Probably More Efficient.

=EN If in doubt, benchmark.

=CN If In 怀疑, benchmark.

=EN Multi-Level Sort with the Schwartzian Transform If we need to sort on more than one criterion, the Schwartzian Transform is still up to the task.

=CN Multi-Level Sort With The Schwartzian Transform If We Need To Sort On More Than One criterion, The Schwartzian Transform Is Still Up To The 工作.

=EN This code skeleton has a three-level sort comparison, using three computed values saved in the anonymous array (alongside the original data item to be sorted, which always comes first).

=CN This Code 骨架 Has a Three-Level Sort 比较, Using Three computed Values Saved In The Anonymous Array (在 The Original Data 条款 To Be 分类, Which Always 来 First).

=EN Recursively Defined Data While the data we've processed with references up to this point has been rather fixed structure, sometimes we have to deal with hierarchical data, which is often defined recursively.

=CN Recursively Defined Data While The Data We'Ve processed With References Up To This 尖 Has Been Rather Fixed Structure, Sometimes We Have To 处理 With 层次 Data, Which Is Often Defined Recursively.

=EN For Example One, consider an HTML table that has rows containing cellsand some of those cells may also contain entire tables.

=CN For Example One, Consider An HTML Table That Has rows Containing cellsand Some Of Those cells May Also Contain 完全的 Tables.

=EN Example Two could be a visual representation of a filesystem consisting of directories containing files and other directories.

=CN Example Two Could Be a 视觉的 表示 Of a filesystem consisting Of directories Containing Files And Other directories.

=EN Example Three is a company organization chart, which has managers with direct reports, some of whom may be managers themselves.

=CN Example Three Is a 公司 组织 图表, Which Has managers With Direct Reports, Some Of 谁（宾格） May Be managers 他们、它们自己.

=EN And Example Four is a more complex organization chart, which can contain instances of the HTML tables of Example One, the filesystem representations of Example Two, or even entire organization charts . . . .

=CN And Example Four Is a More 综合的 组织 图表, Which Can Contain 实例 Of The HTML Tables Of Example One, The filesystem 陈述 Of Example Two, Or Even 完全的 组织 charts . . . .

=EN We can use references to acquire, store, and process such hierarchical information.

=CN We Can Use References To 求得, 商店, And 程序 Such 层次 Information.

=EN Frequently, the routines to manage the data structures end up as recursive subroutines.

=CN Frequently, The Routines To 管理 The Data Structures End Up As 递归 Subroutines.

=EN Recursive algorithms deal with the unlimited complexity of their data by beginning with a base case and building upon that.[*] The base case considers what to do in the simplest case: when the leaf node has no branches, when the array is empty, when the counter is at zero.

=CN Recursive algorithms 处理 With The 无限的 复杂性 Of Their Data By 开端 With a Base Case And 建筑物 Upon That.[*] The Base Case considers What To Do In The simplest Case: When The 叶子 node Has No 分支, When The Array Is Empty, When The Counter Is At 零.

=EN In fact, it's common to have more than one base case in various branches of a recursive algorithm.

=CN In Fact, It's Common To Have More Than One Base Case In 各种各样的 分支 Of a 递归 算法.

=EN A recursive algorithm with no base case is an infinite loop.

=CN A 递归 算法 With No Base Case Is An 无限大的 Loop.

=EN [*] Recursive functions should all have a base, or trivial case, where they don't need to recurse and that all other recursions can eventually reach.

=CN [*] Recursive Functions Should All Have a Base, Or 琐碎的 Case, Where They Don't Need To recurse And That All Other recursions Can 最终 到达.

=EN That is, unless we have a lot of time on our hands to let the function recurse forever.

=CN That Is, Unless We Have a 许多 Of Time On Our 手 To Let The Function recurse 永远.

=EN A recursive subroutine has a branch from which it calls itself to handle a portion of the task, and a branch that doesn't call itself to handle the base cases.

=CN A 递归 Subroutine Has a 树枝 From Which It Calls Itself To Handle a 一份 Of The 工作, And a 树枝 That Doesn't Call Itself To Handle The Base Cases.

=EN In Example One above, the base case could be a table cell that is empty.

=CN In Example One Above, The Base Case Could Be a Table 细胞 That Is Empty.

=EN There could also be base cases for empty tables and table rows.

=CN There Could Also Be Base Cases For Empty Tables And Table rows.

=EN In Example Two, base cases would be needed for files, and perhaps for empty directories.

=CN In Example Two, Base Cases Would Be Needed For Files, And 也许 For Empty directories.

=EN For example, a recursive subroutine handling the factorial function, which is one of the simplest recursive functions, might look like:

=CN For Example, a 递归 Subroutine 处理 The factorial Function, Which Is One Of The simplest 递归 Functions, Might Look Like:

=EN sub factorial {

=CN Sub factorial {

=EN Here we have a base case where $n is less than or equal to 1, which does not invoke the recursive instance, along with a recursive case for $n greater than 1, which calls the routine to handle a portion of the problem (i.e., compute the factorial of the next lower number).

=CN Here We Have a Base Case Where $n Is 更少的 Than Or Equal To 1, Which Does Not 调用 The 递归 例子, 沿着 With a 递归 Case For $n 更大的 Than 1, Which Calls The Routine To Handle a 一份 Of The Problem (i.e., 计算 The factorial Of The 下一次 Lower Number).

=EN This task would probably be solved better using iteration rather than recursion, even though the classic definition of factorial is often given as a recursive operation.

=CN This 工作 Would Probably Be 解决 Better Using 迭代 Rather Than 递归, Even Though The 经典作品 Definition Of factorial Is Often Given As a 递归 Operation.

=EN Building Recursively Defined Data Suppose we wanted to capture information about a filesystem, including the filenames and directory names, and their included contents.

=CN Building Recursively Defined Data Suppose We 想要 To 俘获 Information About a filesystem, Including The filenames And Directory Names, And Their 包括 Contents.

=EN Represent a directory as a hash, in which the keys are the names of the entries within the directory, and values are undef for plain files.

=CN Represent a Directory As a Hash, In Which The Keys Are The Names Of The Entries Within The Directory, And Values Are Undef For 明白的 Files.

=EN A sample /bin directory looks like:

=CN A 样品 /bin Directory Looks Like:

=EN my $bin_directory = {

=CN My $bin_directory = {

=EN Similarly, the Skipper's home directory might also contain a personal bin directory (at something like ~skipper/bin) that contains personal tools:

=CN Similarly, The Skipper's 家 Directory Might Also Contain a 私人的 bin Directory (At Something Like ~skipper/bin) That 包含 私人的 Tools:

=EN my $skipper_bin = {

=CN My $skipper_bin = {

=EN Nothing in either structure tells where the directory is located in the hierarchy.

=CN Nothing In Either Structure 告诉 Where The Directory Is Located In The 层次.

=EN It just represents the contents of some directory.

=CN It Just Represents The Contents Of Some Directory.

=EN Go up one level to the Skipper's home directory, which is likely to contain a few files along with the personal bin directory:

=CN Go Up One Level To The Skipper's 家 Directory, Which Is Likely To Contain a Few Files 沿着 With The 私人的 bin Directory:

=EN my $skipper_home = {

=CN My $skipper_home = {

=EN Ahh, notice that we have three files, but the fourth entry bin doesn't have undef for a value but rather the hash reference created earlier for the Skipper's personal bin directory.

=CN Ahh, Notice That We Have Three Files, But The 第四 Entry bin Doesn't Have Undef For a Value But Rather The Hash Reference Created Earlier For The Skipper's 私人的 bin Directory.

=EN This is how we indicate subdirectories.

=CN This Is How We 指明 subdirectories.

=EN If the value is undef, it's a plain file; if it's a hash reference, we have a subdirectory, with its own files and subdirectories.

=CN If The Value Is Undef, It's a 明白的 File; If It's a Hash Reference, We Have a 子目录, With Its Own Files And subdirectories.

=EN Of course, we can have combined these two initializations:

=CN Of Course, We Can Have Combined These Two initializations:

=EN Now the hierarchical nature of the data starts to come into play.

=CN Now The 层次 自然 Of The Data Starts To 来到 Into 玩.

=EN Obviously, we don't want to create and maintain a data structure by changing literals in the program.

=CN Obviously, We Don't Want To Create And Maintain a Data Structure By Changing literals In The Program.

=EN We should fetch the data by using a subroutine.

=CN We Should 去取来 The Data By Using a Subroutine.

=EN Write a subroutine that returns undef for a given pathname if the path is a file, or a hash reference of the directory contents if the path is a directory.

=CN Write a Subroutine That Returns Undef For a Given pathname If The Path Is a File, Or a Hash Reference Of The Directory Contents If The Path Is a Directory.

=EN The base case of looking at a file is the easiest, so let's write that:

=CN The Base Case Of 看 At a File Is The easiest, So Let's Write That:

=EN sub data_for_path {

=CN Sub data_for_path {

=EN If the Skipper calls this on .cshrc, he'll get back an undef value, indicating that a file was seen.

=CN If The Skipper Calls This On .cshrc, 他'我 Get Back An Undef Value, 指示 That a File Was Seen.

=EN Now for the directory part.

=CN Now For The Directory Part.

=EN We need a hash reference, which we declare as a named hash inside the subroutine.

=CN We Need a Hash Reference, Which We Declare As a Named Hash 里面 The Subroutine.

=EN For each element of the hash, we call ourselves to populate the value of that hash element.

=CN For Each Element Of The Hash, We Call 我们自己 To populate The Value Of That Hash Element.

=EN It goes something like this:

=CN It 去 Something Like This:

=EN  # files or symbolic links

=CN  # Files Or Symbolic 链接

=EN The base cases in this recursive algorithm are the files and symbolic links.

=CN The Base Cases In This 递归 算法 Are The Files And Symbolic 链接.

=EN This algorithm wouldn't correctly traverse the filesystem if it followed symbolic links to directories as if they were true (hard) links, since it could end up in a circular loop if the symlink pointed to a directory that contained the symlink.[*] It would also fail to correctly traverse a malformed filesystemthat is, one in which the directories form a ring rather than a tree structure, say.

=CN This 算法 Wouldn't 正确地 横断 The filesystem If It 跟着 Symbolic 链接 To directories As If They Were True (硬的) 链接, Since It Could End Up In a 圆圈的 Loop If The symlink 尖的 To a Directory That 包含 The symlink.[*] It Would Also 失败 To 正确地 横断 a malformed filesystemthat Is, One In Which The directories Form a 鸣 Rather Than a 树 Structure, Say.

=EN Although malformed filesystems may not often be an issue, recursive algorithms in general are vulnerable to errors in the structure of the recursive data.

=CN Although malformed filesystems May Not Often Be An 发行发布, 递归 algorithms In General Are 晚受损害的 To Errors In The Structure Of The 递归 Data.

=EN [*] Not that any of us have ever done that and wondered why the program took forever.

=CN [*] Not That Any Of Us Have 曾经 Done That And wondered Why The Program took 永远.

=EN The second time really wasn't our fault anyway, and the third time was just bad luck.

=CN The Second Time Really Wasn't Our 缺点 不管怎样, And The 第三 Time Was Just 坏的 运气.

=EN That's our story and we're sticking to it.

=CN That's Our 故事 And We'Re sticking To It.

=EN For each file within the directory being examined, the response from the recursive call to data_for_path is undef.

=CN For Each File Within The Directory Being Examined, The 答复 From The 递归 Call To data_for_path Is Undef.

=EN This populates most elements of the hash.

=CN This populates Most Elements Of The Hash.

=EN When the reference to the named hash is returned, the reference becomes a reference to an anonymous hash because the name immediately goes out of scope.

=CN When The Reference To The Named Hash Is Returned, The Reference Becomes a Reference To An Anonymous Hash Because The Name 立即 去 Out Of Scope.

=EN (The data itself doesn't change, but the number of ways in which we can access the data changes.)

=CN (The Data Itself Doesn't Change, But The Number Of Ways In Which We Can Access The Data Changes.)

=EN If there is a subdirectory, the nested subroutine call uses readdir to extract the contents of that directory and returns a hash reference, which is inserted into the hash structure created by the caller.

=CN If There Is a 子目录, The 嵌套的 Subroutine Call Uses Readdir To 取出 The Contents Of That Directory And Returns a Hash Reference, Which Is 插入 Into The Hash Structure Created By The Caller.

=EN At first, it may look a bit mystifying, but if we walk through the code slowly, we'll see it's always doing the right thing.

=CN At First, It May Look a Bit mystifying, But If We 步行 通过 The Code 慢慢地, We'我 See It's Always Doing The Right Thing.

=EN Test the results of this subroutine by calling it on . (the current directory) and inspecting the result:

=CN Test The Results Of This Subroutine By Calling It On . (The Current Directory) And inspecting The Result:

=EN use Data::Dumper; print Dumper(data_for_path('.'));

=CN Use Data::Dumper; Print Dumper(data_for_path('.'));

=EN Obviously, this will be more interesting if our current directory contains subdirectories.

=CN Obviously, This Will Be More Interesting If Our Current Directory 包含 subdirectories.

=EN Displaying Recursively Defined Data The Dumper routine of Data::Dumper displays the output nicely, but what if we don't like the format being used?

=CN Displaying Recursively Defined Data The Dumper Routine Of Data::Dumper displays The 出产 好, But What If We Don't Like The Format Being Used?

=EN We can write a routine to display the data.

=CN We Can Write a Routine To 陈列 The Data.

=EN Again, for recursively defined data, a recursive subroutine is usually the key.

=CN Again, For Recursively Defined Data, a 递归 Subroutine Is Usually The Key.

=EN To dump the data, we need to know the name of the directory at the top of the tree, because that's not stored within the structure:

=CN To 倾倒 The Data, We Need To Know The Name Of The Directory At The 顶 Of The 树, Because That's Not Stored Within The Structure:

=EN sub dump_data_for_path {

=CN Sub dump_data_for_path {

=EN  # plain file

=CN  # 明白的 File

=EN For a plain file, dump the pathname; for a directory, $data is a hash reference.

=CN For a 明白的 File, 倾倒 The pathname; For a Directory, $Data Is a Hash Reference.

=EN Let's walk through the keys and dump the values:

=CN Let's 步行 通过 The Keys And 倾倒 The Values:

=EN  # plain file

=CN  # 明白的 File

=EN For each element of the directory, we pass a path consisting of the incoming path followed by the current directory entry, and the data pointer is either undef for a file or a subdirectory hash reference for another directory.

=CN For Each Element Of The Directory, We Pass a Path consisting Of The Incoming Path 跟着 By The Current Directory Entry, And The Data Pointer Is Either Undef For a File Or a 子目录 Hash Reference For 另一个 Directory.

=EN We can see the results by running:

=CN We Can See The Results By 连续的:

=EN Again, this is more interesting in a directory that has subdirectories, but the output should be similar to:

=CN Again, This Is More Interesting In a Directory That Has subdirectories, But The 出产 Should Be Similar To:

=EN find . -print

=CN 寻找 . -Print

=EN from the shell prompt.

=CN From The 壳 及时的.

=EN Exercises You can find the answers to these exercises in "Answers for Chapter 9" in the Appendix.

=CN Exercises You Can 寻找 The answers To These exercises In "Answers For Chapter 9" In The Appendix.

=EN Exercise 1 [15 min] Using the glob operator, a naive sort of every name in the /bin directory by their relative sizes might be written as:

=CN Exercise 1 [15 min] Using The Glob Operator, a 天真的 Sort Of Every Name In The /bin Directory By Their 亲戚 sizes Might Be Written As:

=EN my @sorted = sort { -s $a <=> -s $b } glob "/bin/*";

=CN My @分类 = Sort { -s $a <=> -s $b } Glob "/bin/*";

=EN Rewrite this using the Schwartzian Transform technique.

=CN Rewrite This Using The Schwartzian Transform 技术.

=EN If you don't have many files in the /bin directory, perhaps because you don't have a Unix machine, change the argument to glob as needed.

=CN If You Don't Have Many Files In The /bin Directory, 也许 Because You Don't Have a Unix 机器, Change The Argument To Glob As Needed.

=EN Exercise 2 [15 min] Read up on the Benchmark module, included with Perl.

=CN Exercise 2 [15 min] Read Up On The Benchmark Module, 包括 With Perl.

=EN Write a program that will answer the question "How much does using the Schwartzian Transform speed up the task of Exercise 1?"

=CN Write a Program That Will Answer The Question "How Much Does Using The Schwartzian Transform 速度 Up The 工作 Of Exercise 1?"

=EN Exercise 3 [10 min] Using a Schwartzian Transform, read a list of words, and sort them in "dictionary order."

=CN Exercise 3 [10 min] Using a Schwartzian Transform, Read a List Of Words, And Sort Them In "词典 Order."

=EN Dictionary order ignores all capitalization and internal punctuation.

=CN Dictionary Order 忽略了 All 资本化 And Internal 准时.

=EN Hint: the following transformation might be useful:

=CN Hint: The Following 转化 Might Be Useful:

=EN my $string = 'Mary-Ann'; $string =~ tr/A-Z/a-z/; # force all lowercase $string =~ tr/a-z//cd; # strip all but a-z from the string print $string; # prints "maryann"

=CN My $String = 'Mary-Ann'; $String =~ Tr/A-Z/a-z/; # Force All lowercase $String =~ Tr/a-z//cd; # Strip All But a-z From The String Print $String; # Prints "maryann"

=EN Be sure you don't mangle the data!

=CN Be Sure You Don't mangle The Data!

=EN If the input includes the Professor and the skipper, the output should have them listed in that order, with that capitalization.

=CN If The Input 包括 The Professor And The skipper, The 出产 Should Have Them Listed In That Order, With That 资本化.

=EN Exercise 4 [20 min] Modify the recursive directory dumping routine so it shows the nested directories through indentation.

=CN Exercise 4 [20 min] Modify The 递归 Directory 倾销 Routine So It Shows The 嵌套的 directories 通过 indentation.

=EN An empty directory should show up as:

=CN An Empty Directory Should Show Up As:

=EN sandbar, an empty directory

=CN sandbar, An Empty Directory

=EN while a nonempty directory should appear with nested contents, indented two spaces:

=CN While a nonempty Directory Should Appear With 嵌套的 Contents, indented Two spaces:

=EN uss_minnow, with contents:

=CN uss_minnow, With Contents:

=EN sub navigation_turn_toward_port {

=CN Sub navigation_turn_toward_port {

=EN Yes, every scalar, array, hash, filehandle, or subroutine now has to have a navigation_ prefix in front of it to guarantee that the names won't collide with any potential users of the library.

=CN Yes, Every Scalar, Array, Hash, Filehandle, Or Subroutine Now Has To Have a navigation_ 前缀 In Front Of It To 保证 That The Names Won't 猛烈碰撞 With Any 潜在的 Users Of The Library.

=EN Obviously, for that old sailor, this ain't gonna float his boat.

=CN Obviously, For That Old 水手, This 西班牙't 会 浮 他的 小船.

=EN What do we do instead?

=CN What Do We Do Instead?

