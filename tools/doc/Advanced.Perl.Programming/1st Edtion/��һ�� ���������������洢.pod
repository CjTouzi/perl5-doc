第一章 数据引用与匿名存储
主要有两方面的不同将用于创建真正复杂系统的编程语言，与普通的教学语言区别开来。那些更加健壮的编程语言具有以下特点：

不必使用变量名就能够动态地为数据分配存储空间。我们称之为匿名数据结构。
可以指向任何数据结构，无论他是静态分配还是动态分配的。

COBOL语言在这方面是一个例外；尽管他缺少这些特性，但还是获得了商业上的巨大成功。可这也是你为什么不会用他来开发法飞行控制系统的原因。请看下面的句子描述的是一个详单简单的家谱。

23岁的Marge与24岁的John结婚。
Jason，John的兄弟，在MIT学习计算机科学，他刚刚19岁。
他们的父母Robert和Mary，都是60岁，他们居住在佛罗里达。
Mary和Marge的妈妈Agnes，是童年时的小伙伴。

你此刻会在脑海中描述出一张以圆圈代表人物，之间用箭头连接来表达关系的网络。试想一下你会如何用自己喜爱的编程语言来表述此类信息。如果你是一位C（或Algol，Pascal，C++）程序员，你或许会使用一种动态数据结构来存储每个人的个人数据（如姓名，年龄，地点等），然后用指针来表达人与人之间的关系。

指针，简言之，就是一个保存其他数据地址的变量。这个地址可以是机器地址，在C语言中就是这样，也可以是一种更高抽象层次的实体，比如名字或数组偏移量。

C语言对这两方面的支持极其高效。你使用malloc来动态分配存储空间，而使用指针来引用动态或静态分配的内存。虽然这样使用非常高效。然而你却要花费大量的时间来和内存管理细节打交道，认真仔细的创建和修改数据之间复杂的关系，还要注意去除由于无效指针（指那些所指向的内存已被释放或超出作用域的指针）所引发的一系列致命错误。因此虽然写出来的程序效率会高一些，而程序员都不会这样。

Perl对这两种概念都支持的相当好。他允许你创建匿名数据结构，而且还提供了一种称作“引用（reference）”的类似于C语言指针的基本数据类型。正像C语言指针可以指向数据甚至函数地址一样，Perl的引用同样可以指向常规数据类型（如标量变量，数组和散列表）和其他类型的实体，如子例程，typeglob和文件句柄。但和C语言不同，Perl的引用不允许用来操纵无类型的原始内存。

从提高程序员效率的角度来看，Perl要更胜一筹。正如我们前面所见到的，你可以使用更少的代码来创建复杂的数据结构。因为和C语言不同，Perl为你省去了许多不必要的工作。比如下面这行代码：
	$line[19] = "hello";
他创建了一个20个元素的数组，然后将最后一个元素赋值为一个字符串。同样的工作在C语言中要花费好多行的代码。同等重要的是，你不必再考虑内存分配问题。Perl将确保一块数据当且仅当没有任何引用的情况下才被释放（这就确保了内存泄漏不会发生），而当有其他数据仍在指向它时不被释放（不会再有无效指针情况的发生）。
当然，仅仅因为了有这些，并不能使Perl成为实现航空调度系统一类复杂应用的首选语言。然后对于众多不是过分复杂的应用来说（不只是一次性的脚本程序）。Perl要比使用其他编程语言容易的多。

在本章你将学习以下内容：
。如何创建标量变量，数组和散列表的引用，如何利用引用来存取（间接访问）。
。如何创建和引用匿名数据结构。
。Perl如何使大家不用理会内存管理细节的内部机制。

对已有变量的引用
如果你有C语言编程背景的话（这对理解本章内容并不是必需的），就会知道有两种方法可以用来初始化C语言中的指针。你可以使用已有变量，如：
	int a, *p;
	p = &a;  /* p 中现在包含a的地址 */
此处的内存是静态分配的，也就是说由编译器分配的。另外你可以使用malloc(3)来运行中分配内存并获取指向他的地址：

	p = malloc(sizeof(int));

这块动态分配的内存并没有名字（与哪些拥有变量名的存储空间不同），他只能够间接的通过指针来访问。也就是“匿名存储”这一叫法产生的原因。

Perl提供对静态和动态分配存储的引用。在这一节，我们要仔细的学习前者。这样我们将能够对引用和匿名存储这两个概念分别进行学习。

运行效率

通过使用引用，我们可以高效的向子例程中传入或传出大量数据。
然而，传递标量变量的引用一般在性能上绝不是最优的。我经常看到这样的例子，程序员在从文件中一行行读数据时，为了把拷贝操作降到最少，常这么来写；

	while ($ref_line = GetNextLine()) {
		......
		......
	}
	sub GetNextLine() {
		my $line = <F>;
		exit(0) unless defined($line);
		......
		return \$line;  # 为避免拷贝操作，以引用的方式返回
	}
	
GetNextLine为了避免拷贝操作，将所读取的行以引用的方式返回。

你也许会很吃惊，这种策略竟然对于提高应用的整体性能微不足道。因为大多数时间都用在读文件数据并操纵 $line 上面了。而同时，使用GetNextLine就必须使用一种间接($$ref_line)的方式，而不是更为直接了当的$line.

附带说一句，你可以使用标准库中被称为基准测试(Benchmark)的模块来比较一下两种不同代码实现方式所花费的时间，如下所示：

use Benchmark;
timethis(100, "GetNextLine()"); # 执行GetNextLine 100此并计算

所花费的时间在该模块中定义了一个称作timethis的子例程，他以一段代码为参数并执行你所设定的次数，然后打印出花费的时间，我们将在第六章“模块”中讲解use语句。

巧的是，上面的这个例子中演示了一种微软Windows编程人员所熟悉的惯例，那就是“匈牙利记号”。每个变量名都根据其类型加上前缀（"r"代表引用，"rh"表示对散列表的引用，“i”表示整数，“d”表示双精度浮点数等等）。下面的这种写法立刻就可以看出存在问题：

$$rh_collections[0] = 10;  # 警告：‘rh’被用作数组了

你有一个变量，名为 $rh_collections 。根据命名习惯（前缀rh）这或许是一个指向散列表的引用。但你却把他当作指向数组的引用来使。当然Perl会产生运行例外来警告你（第二行不是指向数组的引用“），你在写程序时通过检查程序代码就可以发现此类错误。而且要比在代码测试阶段花大力气覆盖所有代码路径来找出运行时错误容易的多。

内部工作细节

现在我们来看看Perl在内部是如何管理内存的。你可以跳过本节，不会存在连贯的问题。
变量在逻辑上表示为名字与数值之间的联系。
数组或散列表并不仅仅是数字或字符串的集合。他是标量变量值的集合，这种区别很重要。
一个数组拥有一个代表所有标量变量值集合的值。数组中每个元素又有一个标量变量值。这类似于将一群狮子当作一个整体来看待（这也是我们使用单数形式的原因），拥有与单个狮子不同的整体属性。

值得注意的是尽管名字总是指向数值，而数值并不一定必须要求要有名字指向它，正如我们在匿名数组和散列表的举例说明中看到的。

引用计数
为了提供简单和透明的内存管理，无论是否有名字，Perl为每个数值保留一个引用计数（reference count）。让我们在前面的例子中增加这一内容。

引用计数表示指向变量值的个数。因为总存在一个从名字指向其数值的连接，所以变量的引用技术应该至少为一。当你获取了一个指向该变量的引用时，相应值的引用计数将被持续递增。

需要强调的一点是，尽管我们习惯于将$ra 看成指向$a ，但他实际上指向$a 的值，$ra 甚至不知道自己指向的值是否在符号表中有对应项。引用变量的值是另外一个标量变量值的地址，即使是$a 的值变了，其地址也不会改变。

Perl将自动删除哪些引用计数为零的值。当变量（有名的值）超出作用域时，名字与值之间的连接被自动删除，值的引用计数递减。在通常引用计数为1的情况下，该值将被删去（或称作垃圾收集，grabage collected). 为了保证效率，Perl

这种引用计数有时被称为“穷人的垃圾收集法”，用以对比在诸如LISP,Java和Smalltalk（尽管早起版本的Smalltalk使用引用计数）中使用的更为复杂的技术。问题就在于引用计数需要耗费空间。考虑到你的应用中的每个数据都要一个额外的整数与之关联，这加起来并不是一个小数目。

而且还存在循环引用的问题。举一个最简单的例子：

其他语言中的引用
Tcl
Tcl不提供动态创建匿名数据结构的功能

Python
Python除了在基础数据类型的处理上与Java不同外，其他方面都很相似。所有的对象都以引用形式传递。就是说如果将一个具有链表值的变量赋值给另一个变量，

C/C++
程序员要担负起所有内存管理的责任

Java
除基础数据类型如int和float外的一切，均已引用方式传递。
拥有和C++一样多的数据类型，没有内存管理的烦扰，对大型的应用编程来说很有吸引力。


