1-2,4-12,14-20,22-26,28-66,68-88,90-110,112-144,146-212,214-230,232-256,258-270,272-312,314-328,330-334,336-343,345

第一章 引言：成为大师
成为大师的含义
本书适合的读者
如何阅读本书
你应该已经知道的内容
本书涵盖的内容
本书没有涵盖的内容

第二章 高级正则表达式
引用正则表达式
非捕获分组，(?:PATTERN)
易读的正则式，/x和(?#)
全局匹配
前后查找
解读正则表达式
最后的思考
总结
深入阅读

第三章 安全编程技术
不好的数据会浪费你的一整天
污点检测
去除数据的污点
system和exec命令的列表形式
总结
深入阅读

第四章 调试Perl程序
避免浪费太多的时间
世界上最好的调试器
perl5db.pl
备选的调试器
其他的调试器
总结
深入阅读

第五章 剖析Perl程序
找到罪魁祸首
通用的方法
Profiling DBI
Devel::FProf
实现自己的剖析程序
剖析测试套件
总结
深入阅读

第六章  Perl基准测试
基准测试理论
测量时间
比较代码
不要放弃思考
内存使用
perlbench工具
总结
深入阅读

第七章 清理Perl程序
好的风格
perltidy
去除扰乱
Perl::Critic
总结
深入阅读

第八章 符号表和typeglob
软件包变量和词法变量
符号表
总结
深入阅读

第九章 动态子程序
把子程序作为数据使用
创建和替换具名子程序
符号引用
遍历子程序列表
处理流水线
方法列表
把子程序作为参数使用
自动加载的方法
作为对象使用的哈希表
自动切分
总结
深入阅读

第十章 修改模块和临时调整模块
选择正确的解决办法
替换模块的部分内容
派生子类
对子程序进行封装
总结
深入阅读

第十一章 配置Perl程序
不要做的事情
更好的方法
命令行开关
配置文件
有不同名字的脚本程序
交互和非交互程序
perl的Config模块
总结
深入阅读

第十二章 检查和汇报错误
Perl错误处理的基础知识
汇报模块的错误
异常
总结
深入阅读

第十三章 日志
记录错误和其他信息
Log3perl
总结
深入阅读

第十四章 数据持久化
扁平结构的文件
Storable
DBM文件
总结
深入阅读

第十五章 使用Pod
Pod格式
转换Pod
测试Pod
总结
深入阅读

第十六章
二进制数
位操作
位向量
函数vec
记录事情
总结
深入阅读

第十七章 奇妙的绑定变量
似是而非
在用户层面
拉开帷幕
标量
数组
哈希表
文件句柄
总结
深入阅读

第十八章 以模块的形式编写程序
主要问题
回到过去
谁在调用函数
测试程序
发布程序
总结
深入阅读

附录A 深入阅读
附录B brian的解决任何Perl问题的指导手册

第一章 引言 成为大师 Introduction：Becoming a Master

这本书并不会把你变成Perl大师。要想成为Perl大师须要靠自我努力，你必须写大量的Perl程序，尝试各种新的东西，还要犯很多的错误。在这本书中我只是在帮你走上正确的道路，而作为Perl大师，你应当能够解答自己和他人的问题。

在行会的全盛时期，工匠们在学习手艺的过程中，无论是实质上还是象征上都遵循着某条道路。他们从学徒开始，先做一些繁琐的工作直至他们掌握的足够多的技巧成为更值得信任的熟练工(journuyman)。熟练工拥有更大的责任，但是依然在一个工人的大师手下工作。在掌握了足够的技艺之后，他须要完成一件作品(master work)来证明他的能力。如果其他的大师认为这件作品达到了足够的水平，他就成为了一个公认的大师。

熟练工和大师也会旅行到（虽然有些人不同意这是journeyman一词的来源）其他大师那里，学习新的技术和技巧。每个大师都知道一些别人不知道的东西，或许是故意隐藏的，也许是从不同的途径得到的，熟练工的一部分教育来自多位大师。

与其他大师和熟练工的交流也是大师教育的延续。他可以从其他更有经验的大师那里学习，也会在教熟练工的进程中（间接的）学到熟练工的老师的技巧。

学徒遵循的道路会影响他所能学到的东西。有机会跟从多位大师的学徒会接触到更多的视角和教学的方法，从而把这些变成自己的风格。来自某些大师的奇特的方法会被其他大师的方法所中和。从而使学徒得到一个平衡的视角。此外，不管是要成为木匠还是泥瓦匠，不同的大师把这些技巧用于不同的目的，从而给学徒提供了了解不同的应用和处事方式的机会。

不幸的是，我们没有行会。大部分Perl程序员都是靠他们自己来学习Perl（作为Perl教员，我很遗憾的这样说），编写程序，从来没有机会得到指导。这也是我入门的方式。我当时购买了《Learning Perl》的第一版，完全靠自己看完了全书。当时我是周围的人中唯一了解Perl的人。我已经开始反复研究他了，而大部分人只是简单地使用别人做好的东西。不久之后，我发现了讨论列表comp.lang.perl.misc并开始回答我能够回答的问题。这就像是布置给自己的家庭作业一样。我的技巧得到了提高。我得到了几乎即时的反馈，有好的也有坏的，这些又促使我学到了更多Perl的知识。后来，我的工作
第二章 高级正则表达式变成了整天用Perl写程序，虽然我是哪个公司中唯一一个那样的人。我一直坚持在comp.lang.perl.misic上回答问题。

最后，我引起了Randal Schwartz的注意，并在他的翅膀的庇护下开始了我的Perl学徒生涯。他邀请我加入StonehengeConsulting Services并成为一名Perl教员。从此，我开始了教授Perl的职业生涯。讲课，意味着找出你所有知道的东西兵解释给别人，这是学习的最佳方法。之后不久，我开始写一些和Perl教学有关的文章。


正则表达式，简称正则式，是Perl文本处理的核心，毫无疑问也是使Perl如此流行的众多特性中的一个。所有的Perl程序员都经历过一个尝试把所有的东西都用正则式表示的阶段，有的甚至觉得还不够有挑战性，把所有的都用一个正则式来表示。Perl的正则式的特性远远超过了我能够和希望在本章中介绍的范围。所有这里我只涵盖一些高级特性。我认为这些是最有用的，希望其他的Perl程序员能够掌握而无须查阅perlre--正则表达式手册。

引用正则表达式
我们不必在变成的时候就知道所有的模式，Perl允许在正则式中插入变量。变量的值可以通过硬编码指定，从用户输入得到或从其他途径得到。这里是一个和grep有同样功能的Perl小程序。他从命令行得到第一个参数作为while循环中的正则表达式。这兵没有什么同特别的，我们在《Learning Perl》中曾演示过，我们把 $regex 中的字符串用作匹配的模式，Perl在解析到匹配操作符时会对他进行编译.

	#!/usr/bin/perl
	# perl-grep.pl
	
	my $regex = shift @ARGV;
	print "Regx is [$regx]\n";
	while ( <> ) {
		print "\n" if (m/$regx/); 
	}

第四章 调试 Perl 程序
Perl标准发布版带有一个调试器--perl5db.pl, 虽然它只是一个Perl程序。不过，正因为它只是一个程序，我们可以以它为基础写一个自己的调试器来满足需求，也可以用perl5db.pl提供的接口来配置它的行为。不过，这仅仅只是一个开始。我们还可以写自己的调试器，或者从其他的Perl大师写的众多调试器中选择一个使用。

避免浪费太多的时间

首先，我要给你们介绍一下Perl提供的两个非常有用的调试助手：strict 和 warnings.
我的大部分麻烦都是小程序带来的。对于小程序，我觉得不需要strict, 结果犯了很多strict模式能够发现的愚蠢的错误，我在跟踪 Perl 能够立刻发现的问题上花的时间大大超过了应该花的时间。对我来说，常见的错误是最难调试的，从大师身上学到的经验：即使是很小的程序也不要关掉strict 或 warnings。

既然我介绍了这个，很可能你会在本章的例子中寻找它---那么请假装示例里有这些代码。为了让本书更加便宜。我在示例中省略了他们从来剪掉了半页篇幅。如果你不喜欢这个想法，也可以假设每次运行程序时我们都从命令行打开了strict和warnings:

	$perl -Mstrict -Mwarnings program

此外，尽管不愿意承认，更多的时候我遇到的是另外一个问题。我编辑的程序和运行的程序是在同一台机上上吗？我在很多机器上都有登录帐号，而我最喜欢的终端程序是支持标签页的，所以我可以在一个窗口中有多个回话。从软件仓库中取出源代码兵在任意地点工作也非常容易。所有这些时髦的功能结合在一起使我可以在一个标签页中编辑一个文件；而在另一个中运行它，感觉就像同一台机器上一样。如果我改变了一些东西而程序的输出或它的行为没有变化，我往往要花很多时间才能发现运行的程序和编辑的程序不在同一台机器上。这个时间比你想象的要长很多。这听起来很傻，不过它确实发生了。请不要在调试的时候忽略任何事情！

这是一个比较有趣的故事。我希望通过它来说明一点：在调试的时候，谦卑是维护代码的程序员的一个主要的美德。调试时最好的赌注是假设问题是自己造成的。这样做，就不会把任何因素排除在外，或者试图怪罪其他的东西--我经常在各种 Perl讨论区中看到标题为“Perl的可能的问题”的帖子。事实证明，当首先怀疑自己时，我往往是对的。附录B是我的一个解决问题的指导手册，即使不能解决问题，至少它能够帮助人们找出问题所在。

世界上最好的调试器

不管我用过多少不同的调试器或集成开发环境，我仍然认为简明的print是最好的调试器。我可以把源代码载入调试器，设置好输入和断点，观察发生的事情；更多的时候会插入几个print，直接像通常那样运行程序。我在变量周围加上了括号，以便于发现任何的空白字符：
	
	print "The value of var before is [$var]\n";
	#... 会改变 $var的 一些操作
	print "The value of var after is [$var]\n";

其实也可以不同print。我们可以用 warn 做同样的事情，他会把输出发送到标准错误输出中。

	warn "The value of var before is [$var]";
	#... 会改变$var的一些操作
	warn "The value of var after is [$var]";

由于没有在warn消息末尾使用换行符，输出会告诉我们warn所在的文件名和行号：
	
	The value of var before is [$var] at program.pl line 123.

对于复杂的数据结构，我们可以用 Data::Dumper 来显示它。它能够很好地处理哈希表和数组。在这里，我们用不同的字符--尖括号来分分隔来自Data::Dumper的输出：

	use Data::Dumper qw(Dumper);
	warn "The value of the hash is <\n" . Dumper( \%hash ) . "\n>\n";

这些warn语句显示出了warn语句的行号。其实这不是很有用--我们已经知道warn在哪里了，是我们把它发在那里的！我们真正希望知道的是当出问题的时候他是从哪里调用的。考虑下面这个返回两个数字的商的子程序divide。由于某种原因，代码的某个地方调用该子程序时导致了除零操作：

	sub divide {
		my( $numerator, $denominator ) = @_;
		return $numerator / $denominator;
	}

Perl 会非常清楚的告诉我们代码的时候位置出了问题：
	
	Illegal division by zero at program.pl line 123.

我们可以在子程序中加入一些调试代码，使用warn检查参数的值：

	sub divide {
		my($numerator, $denominator) = @_;
		warn "N: [$numerator] D: [$denominator]";

		return $numerator / $denominator;
	}

代码的很多地方可能会调用divide，所以我们真正想知道的是哪个调用出了问题。上面的这个warn语句除了显示出参数之外并没有多大帮助。

尽管把print称为世界上最好的调试工具，我真正使用的是 print 的另一种形式--Perl标准发布版Carp模块的carp函数。他和warn类似，不过他能够报告调用子程序的代码的文件名和行号：

	#!/usr/bin/perl
	use Carp qw(carp);

	printf "%.2f\n", divide(3 ,4);
	printf "%.2f\n", divide(1, 0);
	printf "%.2f\n", divide(5, 4);

	sub divide {
		my($numerator, $denominator) = @_;
		carp "N: [$numerator] D: [$denominator]";

		return $numerator / $denominator;
	}

这次的输出信息变得有用多了。我们不仅得到了错误信息，而且还得到了调用的代码行的信息及调用子程序的参数。可以看到第4行的调用没有问题，而第5行的调用是Perl结束程序之前执行的最后一个调用：

	$ perl show-args.pl
	N: [3] D: [4] at show-args.pl line 11
					main::divide(3, 4) called at show-args.pl line 4
	0.75
	N: [1] D: [0] at show-args.pl line 11
					main::divide(1, 0) called at show-args.pl line 5
	Illegal division by zero at show-args.pl line 13

函数carp比warn提供了更详尽的输出。如果想用die做同样的事情，我们可以用croak函数它能够提供和carp一样详尽的输出，不过croak会和die一样终止程序。

随心所欲 Do Whatever I Want

我们可以通过干预 %SIG 来改变warn 和 die 函数。我喜欢用他们来分析代码，不过从来不用它们为代码添加新的功能。它们只是我的调试工具箱的一部分。
伪键__WARN__和 __DIE__ 指向的函数会在调用 warn 和 die 时运行。我们可以使用具名或者匿名子程序的引用指定要运行的函数：

	$SIG{__DIE__} = \&my_die_handler;
	$SIG{__DIE__} = sub { print "I'm about to die!" }

利用这个功能，无须遍历所有的代码，就可以把所有的die调用变成提示信息更丰富的 croak 调用。在下面的例子中，我们在子程序调用前加上了&并去掉括号，这样Perl会把当前的参数列表传递给下一个程序，也就是 croak:

	use Carp;
	$SIG{__DIE__} = sub { &Carp::croak };

	die "I'm going now!"; # really calls croak now

如果只希望对部分代码使用这个功能，可以用 local 限定作用的范围(因为 %SIG 是一个永远在 main::中的特殊变量）。我们的重定义在跳出作用域之前会一直有效：

		local $SIG{__DIE__} = sub { &Carp::croak };

运行修改后的程序时，这两个函数会执行相应的操作：warn会让程序继续运行，而die会进行异常处理并最终终止程序。

应为croak会显示出堆栈的每一层，而我们是从一个匿名的子程序中调用他的，所以会在输出中看到一个虚构的子程序名：

	use Carp;
	print "Starting program...\n";
	$SIG{__DIE__} = sub {
		local $Carp::CarpLevel = 0;
		&Carp::croak;
	};
	foo(); # program dies here
	sub foo { bar() }
	sub bar { die "Dying from bar!\n"; }

在堆栈踪迹中，可以看到bar()和foo()之后有一个__ANON__调用：

	Starting program...
	Dying from bar!
	at die.pl line 12
			main::__ANON__('Dying from bar!\x{a}') called at die.pl line 20
			main::bar() called at die.pl line 18
			main::boo() called at die.pl line 16

下面我们修改一下匿名子程序，调整 croad 开始汇报的位置。我们把$carp::CarpLevel 的值设定为希望跳过的层次，在这个例子中是 1 ：



