=EN 3.3. Functional Interfaces
=CN 3.3. 函数接口 
=EN To load a module, we use the Perl built-in use. We’re not going to go into all of the details here, but we’ll get to those in Chapters 10 and 15. At the moment, we just want to use the module. Let’s start with File::Basename, that same module from the core distribution. To load it into our script, we say:
=CN 为了调用一个模块，我们可以用Perl内置的use语句。 这里我们不打算更深入的了解细节问题，我们会在第10章和第15章来说这个问题。 目前，我们只要能调用模块就可以了。 我们就发行版的核心模块中的File::Basename模块开始说吧。要把它调入我们的脚本，我们用：
=EN When we do this, File::Basename introduces three subroutines, fileparse, basename, and dirname,[*] into our script.[+] From this point forward, we can say:
=CN 当我们写上如上的代码后，File::Basename 向你的脚本引入了三个子例程［＋］：fileparse,basename和dirname.[*] 自此之后，我们就可以用如下语句了：
=EN [*] As well as a utility routine, fileparse_set_fstype.
=CN [*] 以及实用例程, fileparse_set_fstype.
=EN [+] Actually, it imports them into the current package, but we haven’t told you about those yet.
=CN [+]事实上他们被它引入当前的包，只不过我们没有告诉你这些而已。
=EN as if we had written the basename and dirname subroutines ourselves, or (nearly) as if they were built-in Perl functions. These routines pick out the filename and the directory parts of a pathname. For example, if $some_full_path were D:\Projects\Island Rescue\plan7.rtf (presumably, the program is running on a Windows machine), then $basename would be plan 7.rtf and the $dirname would be D:\Projects\Island Rescue.
=CN 就象我们曾经在我们自己代码里写过basename和dirname这两个子例程一样，或者他们就像是Perl的内置函数似的。这些例程的功能是从一个路径名中抽出文件名和目录名。比如，如果变量$some_full_path的内容是D:\Projects\Island Rescue\plan7.rtf(我们假定是在Windows环境下)，那么$basename的内容将会是plan7.rtf而$dirname的内容将会是D:\Projects\Island Rescue。
=EN The File::Basename module knows what sort of system it’s on, and thus its functions figure out how to correctly parse the strings for the different delimiters we might encounter.
=CN File::Basename会自己“感知”它所处的是哪种操作系统，并且因此针对所遇到的操作系统，用不同的分隔符来解析字串。
=EN However, suppose we already had a dirname subroutine. We’ve now overwritten it with the definition provided by File::Basename! If we had turned on warnings, we would have seen a message stating that; but otherwise, Perl really doesn’t care.
=CN 然而， 假定我们曾经在程序里写过一个同名的dirname函数的话，那么File::Basename提供的同名函数会把你的覆盖！如果我们打开warnings报警，我们会看到一条警告信息；否则的话Perl不会关心这种情况。
