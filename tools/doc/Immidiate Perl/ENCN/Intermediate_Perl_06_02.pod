6.2. Viewing Complex Data with Data::Dumper
6.2. 用Data::Dumper模块查看复杂数据
Another way to visualize a complex data structure rapidly is to dump it. A particularly nice dumping package is included in the Perl core distribution, called Data::Dumper. Let’s replace the last half of the byte-counting program with a simple call to Data::Dumper:
use Data::Dumper;
my %total_bytes;
while (<>) {
  my ($source, $destination, $bytes) = split;
  $total_bytes{$source}{$destination} += $bytes;
}
print Dumper(\%total_bytes);
另外一个我们可以快速查看复杂数据结构的方法是用dump模块打印出来。 这个特别好用的dump模块已被收纳在Perl的核心发布中，唤作：Data::Dumper。 让我们改写前面那个字节计数的程序的后半部份，这次用Data:Dumper模块：
use Data::Dumper;
my %total_bytes;
while (<>) {
  my ($source, $destination, $bytes) = split;
  $total_bytes{$source}{$destination} += $bytes;
}
print Dumper(\%total_bytes);
The Data::Dumper module defines the Dumper subroutine. This subroutine is similar to the x command in the debugger. We can give Dumper one or more values, and Dumper turns those values into a printable string. The difference between the debugger’s x command and Dumper, however, is that the string generated by Dumper is Perl code:
myhost% perl bytecounts2 <bytecounts-in
$VAR1 = {
          ’thurston.howell.hut’ => {
                                     ‘lovey.howell.hut’ => 1250
                                   },
          ’ginger.girl.hut’ => {
                                 ‘maryann.girl.hut’ => 199,
                                 ‘professor.hut’ => 1218
                               },
          ’professor.hut’ => {
                               ‘gilligan.crew.hut’ => 1250,
                               ‘lovey.howell.hut’ => 1360
                             }
        };
myhost%
Data::Dumper模块中定义了Dumper子例程。 这个子例子与调试工具中的x命令相似。 我们可以给Dumper子例程一个或多个值， Dumper会以人看得懂的格式返回这些值的内容。然而，Dumper与调试工具中x命令的不同是Dumper输出的是Perl 代码：
myhost% perl bytecounts2 <bytecounts-in
$VAR1 = {
          ’thurston.howell.hut’ => {
                                     ‘lovey.howell.hut’ => 1250
                                   },
          ’ginger.girl.hut’ => {
                                 ‘maryann.girl.hut’ => 199,
                                 ‘professor.hut’ => 1218
                               },
          ’professor.hut’ => {
                               ‘gilligan.crew.hut’ => 1250,
                               ‘lovey.howell.hut’ => 1360
                             }
        };
myhost%
The Perl code is fairly understandable; it shows that we have a reference to a hash of three elements, with each value of the hash being a reference to a nested hash. We can evaluate this code and get a hash that’s equivalent to the original hash. However, if you’re thinking about doing this in order to have a complex data structure persist from one program invocation to the next, please keep reading.
这段Perl代码很容易理解； 它显示我们有一个指向三个元素的散列的引用，其中每个元素的值则是指向其它散列的引用的嵌套散列。 我们可以求出这代码得出的散列同原来的散列值是等同的。 但是，如果你考虑通过这个将复杂数据结构保存下来，并可以由其它的程序调用的话，别急，我们往下看就是了。
Data::Dumper, like the debugger’s x command, handles shared data properly. For example, go back to that "leaking" data from Chapter 5:
use Data::Dumper;
$Data::Dumper::Purity = 1; # declare possibly self-referencing structures
my @data1 = qw(one won);
my @data2 = qw(two too to);
push @data2, \@data1;
push @data1, \@data2;
print Dumper(\@data1, \@data2);
Data::Dumper， 同调试工具的命令行 x 命令一样，处理共享数据属性。 比如， 我们来看看先前第五章遇到的“内存泄漏”的例子：
use Data::Dumper;
$Data::Dumper::Purity = 1; # 声明允许自引用结构
my @data1 = qw(one won);
my @data2 = qw(two too to);
push @data2, \@data1;
push @data1, \@data2;
print Dumper(\@data1, \@data2);
Here’s the output from this program:
$VAR1 = [
          'one',
          'won',
          [
            'two',
            'too',
            'to',
            [  ]
          ]
        ];
$VAR1->[2][3] = $VAR1;
$VAR2 = $VAR1->[2];
下面是程序的输出结果：
$VAR1 = [
          'one',
          'won',
          [
            'two',
            'too',
            'to',
            [  ]
          ]
        ];
$VAR1->[2][3] = $VAR1;
$VAR2 = $VAR1->[2];
Notice how we’ve created two different variables now, since there are two parameters to Dumper. The element $VAR1 corresponds to a reference to @data1, while $VAR2 corresponds to a reference to @data2. The debugger shows the values similarly:
DB<1> x \@data1, \@data2
    0  ARRAY(0xf914)
 0  ’one’
 1  ’won’
 2  ARRAY(0x3122a8)
    0  ’two’
    1  ’too’
    2  ’to’
    3  ARRAY(0xf914)
       -> REUSED_ADDRESS
    1  ARRAY(0x3122a8)
 -> REUSED_ADDRESS
注意我们是怎么创建了两个不同的变量， 因为传给了Dumper两个参数。 元素$VAR1对应对@data1的引用，而$VAR2对应对@data2的引用。 调试工作对值的展示类似：
DB<1> x \@data1, \@data2
    0  ARRAY(0xf914)
 0  ’one’
 1  ’won’
 2  ARRAY(0x3122a8)
    0  ’two’
    1  ’too’
    2  ’to’
    3  ARRAY(0xf914)
       -> REUSED_ADDRESS
    1  ARRAY(0x3122a8)
 -> REUSED_ADDRESS
Note that the phrase REUSED_ADDRESS indicates that some parts of the data are actually references we’ve already seen.
注意，短语REUSED_ADDRESS标示数据的一些部份实际上已引用了我们已经看到的一些数据。


