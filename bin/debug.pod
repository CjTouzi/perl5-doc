=encoding utf8

with Perl.  You can get more documentation, tutorials and community support
online at 0.

which is a general intro for beginners and provides some background to help
you navigate the rest of Perl's extensive documentation.  Run 0 to learn more things you can do with 0.

available as manpages for use with the 0 program.

not sure where you should look for help, try the 0 switch first.  It will
often point out exactly where the trouble is.

except when it doesn't.

text files, extracting information from those text files, and printing
reports based on that information.  It quickly became a good language
for many system management tasks. Over the years, Perl has grown into
a general-purpose programming language. It's widely used for everything
from quick "one-liners" to full-scale application development.

complete) rather than beautiful (tiny, elegant, minimal).

features of C, 0, 0, and 0, so people familiar with
those languages should have little difficulty with it.  (Language
historians will also note some vestiges of 0, Pascal, and even
BASIC-PLUS.)  Expression syntax corresponds closely to C
expression syntax.  Unlike most Unix utilities, Perl does not
arbitrarily limit the size of your data--if you've got the memory,
Perl can slurp in your whole file as a single string.  Recursion is of
unlimited depth.  And the tables used by hashes (sometimes called
"associative arrays") grow as necessary to prevent degraded
performance.  Perl can use sophisticated pattern matching techniques to
scan large amounts of data quickly.  Although optimized for
scanning text, Perl also has many excellent tools for slicing
and dicing binary data.

rewrite that provides the following additional benefits:

0, and 0.

implementations)

and 0.

with integrated editor support

all Unix-like platforms.  See 0 pragma automatically turns Perl's normally terse warnings
and errors into these longer forms.

indication of the next token or token type that was to be examined.
(In a script passed to Perl via 0 switches, each
0 is counted as one line.)

messages such as "Insecure dependency".  See 0.

switch?

operations such as type casting, , and floating-point
output with .

particular stream, so does Perl.  (This doesn't apply to 
and .)

(apart from memory size), there are still a few arbitrary limits:  a
given variable name may not be longer than 251 characters.  Line numbers
displayed by diagnostics are internally stored as short integers,
so they are limited to a maximum of 65535 (higher numbers usually being
affected by wraparound).

information as output by the myconfig program in the perl source
tree, or by 0) to perlbug@perl.org .  If you've succeeded
in compiling perl, the 0 script in the 0 subdirectory
can be used to help mail in a bug report.

don't tell anyone I said that.

how many more is left as an exercise to the reader.

Impatience, and Hubris.  See the Camel Book for why. 

=encoding utf8

should use the above functions instead of those defined in ANSI C's
0.  The perl headers (in particular "perlio.h") will
0 them to the I/O mechanism selected at Configure time.

has been "tidied up a little".

treated as opaque (it is probably safe to assume it is a pointer to
something).

functions which call stdio. In this case 0 PerlIO * is a FILE *.
This has been the default implementation since the abstraction was
introduced in perl5.003_02.

some specialist applications on Unix machines ("sfio" is not widely
ported away from Unix).  Most of above are #define'd to the sfio
functions. PerlIO * is in this case Sfio_t *.

above abstraction which allows perl more control over how IO is done
as it decouples IO from the way the operating system and C library
choose to do things. For USE_PERLIO PerlIO * has an extra layer of
indirection - it is a pointer-to-a-pointer.  This allows the PerlIO *
to remain with a known value while swapping the implementation around
underneath 0. In this case all the above are true (but
very simple) functions which call the underlying implementation.

does anything "interesting".

these functions are somewhat dependent on the underlying implementation.
Where these variations are understood they are noted below.

value (usually 0 which is usually -1) and set 0 on error.

to look like "function calls" rather than variables because this makes
it easier to 0 function calls if platform cannot export data
to loaded modules, or if (say) different "threads" might have different
values.

Return 0 and set 0 if there is an error.  There may be an
implementation limit on the number of open handles, which may be lower
than the limit on the number of open files - 0 may not be set
when 0 is returned if this limit is exceeded.

does not use it. 0

used by the existing PerlIO. This may become the behaviour of this
function in the future.

so it is (currently) legal to use 0 in perl sources.

arguments and return values are different.  The  and
 signatures have been modeled on the more sane low level
 and  functions instead: The "file" argument is passed
first, there is only one "count", and the return value can distinguish
between error and 0.

positive), returns negative value and sets 0 on error.
Depending on implementation 0 may be 0 if operation was
interrupted by a signal.

interrupted by a signal.

Note that arguments have been revised to have "file" first.

to have "file" first.  Arranges that next read operation will return
the byte 0.  Despite the implied "character" in the name only
values in the range 0..0xFF are defined. Returns the byte 0 on
success or -1 (0) on error.  The number of bytes that can be
"pushed back" may vary, only 1 character is certain, and then only if
it is the last character that was read from the handle.

Despite the c in the name only byte range 0..0xFF is supported.
Returns the character read or -1 (0) on error.

whether the handle is at end of file.  For terminal devices this may
or may not be "sticky" depending on the implementation.  The flag is
cleared by , or .

whether there has been an IO error on the handle.

of "fileno" may not match Unix. Returns -1 if the handle has no open
descriptor associated with it.

'eof' flags for the "stream". Does not return a value.

underlying file.  If called with 0 this may flush all open
streams (or core dump with some USE_STDIO implementations).  Calling
on a handle open for read only, or on which last operation was a read
of some kind may lead to undefined behaviour on some USE_STDIO
implementations.  The USE_PERLIO (layers) implementation tries to
behave better: it flushes all open streams when passed 0, and
attempts to retain data on read streams either in the buffer or by
seeking the handle to the current logical position.

underlying file, or discards any buffered read data, then positions
the file descriptor as specified by 0 and 0 (sic).
This is the correct thing to do when switching between read and write
on the same handle (see issues with  above).  Offset is
of type 0 which is a perl Configure value which may not be same
as stdio's 0.

(Off_t) -1 on error.  May just return value system "knows" without
making a system call or checking the underlying file descriptor (so
use on shared file descriptors is not safe without a
). Return value is of type 0 which is a perl
Configure value which may not be same as stdio's 0.

stdio's Fpos_t they expect a "Perl Scalar Value" to be passed. What is
stored there should be considered opaque. The layout of the data may
vary from handle to handle.  When not using stdio or if platform does
not have the stdio calls then they are implemented in terms of
 and .

NULL on error.  The system will attempt to automatically delete the
file when closed.  On Unix the file is usually 0-ed just after
it is created so it does not matter how it gets closed. On other
systems the file may only be deleted if closed via 
and/or the program exits via 0.  Depending on the implementation
there may be "race conditions" which allow other processes access to
the file, though in general it will be safer in this regard than
ad. hoc. schemes.

constitutes a "line" is implementation dependent but usually means
that writing "\n" flushes the buffer.  What happens with things like
"this\nthat" is uncertain.  (Perl core uses it 0 when "dumping";
it has nothing to do with $| auto-flush.)

Obviously if PerlIO is implemented in terms of stdio there is no
problem. However in other cases then mechanisms must exist to create a
FILE * which can be passed to library code which is going to use stdio
calls.

the default at some point).  That prevents "perlio.h" from attempting
to #define stdio functions onto PerlIO functions.

arguments.  The standard typemap will be adjusted to comprehend any
changes in this area.

fopen/PerlIO_open.  If it is NULL then - for legacy support - the code
will (depending upon the platform and the implementation) either
attempt to empirically determine the mode in which 0 is open, or
use "r+" to indicate a read/write stream.

0 on the returned PerlIO *.

not the desired mode.

expecting to be compiled and linked with ANSI C 0.  The mode
argument should be a string as would be passed to fopen/PerlIO_open.
If it is NULL then - for legacy support - the FILE * is opened in same
mode as the PerlIO *.

by pushing a new :stdio "layer" onto the PerlIO *), which may affect
future PerlIO operations on the original PerlIO *.  You should not
call 0 on the file unless you call 0
to disassociate it from the PerlIO *.  (Do not use 
for doing the disassociation.)

(and will push an :stdio layer each time as well).

complete. It is removed from the list of 'exported' FILE *s, and the
associated PerlIO * should revert to its original behaviour.

using .

will create one with PerlIO_exportFILE. In either case the FILE *
should be considered as belonging to PerlIO subsystem and should
only be closed by calling 0.

"implementation" interface which allows perl to get at internals of
PerlIO.  The following calls correspond to the various FILE_xxx macros
determined by Configure - or their equivalent in other
implementations. This section is really of interest to only those
concerned with detailed perl-core behaviour, implementing a PerlIO
mapping or writing code which can make use of the "read ahead" that
has been done by the IO system in the same way perl does. Note that
any code that uses these interfaces must be prepared to do things the
traditional way if a handle does not support them.

allow perl's 0 to "bypass" normal IO mechanism.  This can
vary from handle to handle.

and a count of bytes available in the buffer.  Do not use this - use
PerlIO_fast_gets.

means no more bytes available.

pointer (dereferencing) is only safe if  has returned
a positive value.  Only positive offsets up to value returned by
 are allowed.

buffer. Should be used only to set pointer to within range implied by
previous calls to 0 and 0. The two
values 0 be consistent with each other (implementation may only
use one or the other or may require both).

Do not use this - use PerlIO_fast_gets.

if  returns true.  Currently used in only doio.c to
force count less than -1 to -1.  Perhaps should be PerlIO_set_empty or
similar.  This call may actually do nothing if "count" is deduced from
pointer and a "limit".  Do not use this - use .

to whole buffer and its size. Used by perl for 0 / 0 tests.
Other uses would be very obscure...

up to the value returned by .

number that can be read, nor the amount of memory allocated to the
buffer. Rather it is what the operating system and/or implementation
happened to 0 (or whatever) last time IO was requested.

and ":raw" are only ones allowed for other implementations and those
are silently ignored. (As of perl5.8 ":raw" is deprecated.)  Use
 below for the portable case.

0 is perl's character for the kind of IO:

the non USE_PERLIO case. (As of perl5.8 ":raw" is deprecated in favour
of passing NULL.)

and

they alter "\n" to CR,LF translation and possibly cause a special text
"end of file" indicator to be written or honoured on read. The effect
of making the call after doing any IO to the handle depends on the
implementation. (It may be ignored, affect any data which is already
buffered as well, or only apply to subsequent data.)

debugging.  No return value. Its main use is inside PerlIO where using
real printf,  etc. would recursively call PerlIO and be a
problem.

use might be

=encoding utf8

it under the terms of either:

It's here so that modules, programs, etc., that want to declare
this as their distribution license can link to it.

Package may be copied, such that the Copyright Holder maintains some
semblance of artistic control over the development of the package,
while giving the users of the package the right to use and distribute
the Package in a more-or-less customary fashion, plus the right to make
reasonable modifications.

Copyright Holder, and derivatives of that collection of files created
through textual modification.

modified, or has been modified in accordance with the wishes of the
Copyright Holder as specified below.

copyrights for the package.

of media cost, duplication charges, time of people involved, and so on.
(You will not be required to justify it to the Copyright Holder, but
only to the computing community at large as a market that must bear the
fee.)

itself, though there may be fees involved in handling the item. It also
means that recipients of the item may redistribute it under the same
conditions they received it.

Standard Version of this Package without restriction, provided that you
duplicate all of the original copyright notices and associated disclaimers.

derived from the Public Domain or from the Copyright Holder.  A Package
modified in such a way shall still be considered the Standard Version.

that you insert a prominent notice in each changed file stating how and
when you changed that file, and provided that you do at least ONE of the
following:

Freely Available, such as by posting said modifications to Usenet or an
equivalent medium, or placing the modifications on a major archive site
such as uunet.uu.net, or by allowing the Copyright Holder to include
your modifications in the Standard Version of the Package.

standard executables, which must also be provided, and provide a
separate manual page for each non-standard executable that clearly
documents how it differs from the Standard Version.

executable form, provided that you do at least ONE of the following:

together with instructions (in the manual page or equivalent) on where
to get the Standard Version.

Package with your modifications.

document the differences in manual pages (or equivalent), together with
instructions on where to get the Standard Version.

Package.  You may charge any fee you choose for support of this
Package.  You may not charge a fee for this Package itself.  However,
you may distribute this Package in aggregate with other (possibly
commercial) programs as part of a larger (possibly commercial) software
distribution provided that you do not advertise this Package as a
product of your own.  You may embed this Package's interpreter within
an executable of yours (by linking); this shall be construed as a mere
form of aggregation, provided that the complete Standard Version of the
interpreter is so embedded.

output from the programs of this Package do not automatically fall
under the copyright of this Package, but belong to whoever generated
them, and may be sold commercially, and may be aggregated with this
Package.  If such scripts or library files are aggregated with this
Package via the so-called "undump" or "unexec" methods of producing a
binary executable image, then distribution of such an image shall
neither be construed as a distribution of this Package nor shall it
fall under the restrictions of Paragraphs 3 and 4, provided that you do
not represent such an executable image as a Standard Version of this
Package.

languages) supplied by you and linked into this Package in order to
emulate subroutines and variables of the language defined by this
Package shall not be considered part of this Package, but are the
equivalent of input as in Paragraph 6, provided these subroutines do
not change the language in any way that would cause it to fail the
regression tests for the language.

permitted provided that the use of this Package is embedded; that is,
when no overt attempt is made to make this Package's interfaces visible
to the end user of the commercial distribution.  Such use shall not be
construed as a distribution of this Package.

products derived from this software without specific prior written permission.

IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.

=encoding utf8

good, some are OK, but many aren't worth your money. There is a list
of these books, some with extensive reviews, at http://books.perl.org/
. We list some of the books here, and while listing a book implies our
endorsement, don't think that not including a book means anything.

( http://safaribooksonline.com/ ).

0:

accomplish specific tasks:

Llama book, which assumes that you already know a little about
programming:

introduces the intermediate features of references, data structures,
object-oriented programming, and modules:

ACM columns from Jon Bentley. The similarity to the title of the major
Perl book (which came later) is not completely accidental:

the time of release. This poses a problem for content such as book
lists. There are probably very nice books published after this list
was included in your Perl release, and you can check the latest
released version at http://perldoc.perl.org/perlbook.html .

scale, but we've included those books because they still describe the
current way of doing things. Not everything in Perl changes every day.
Many of the beginner-level books, too, go over basic features and
techniques that are still valid today. In general though, we try to
limit this list to books published in the past five years.

=encoding utf8

other Perl object documentation may be a little daunting, such as
0, a basic reference in using objects, and 0, which
introduces readers to the peculiarities of Perl's object system in a
tutorial way.

experience. It helps if you know about subroutines (0),
references (0 et. seq.), and packages (0), so become
familiar with those first if you haven't already.

packages, and called using the full package name.  So let's create
an entire pasture:

We're counting on 0 mode, certainly not recommended
for larger programs.  And why was that necessary?  Because the name of
the package seems to be inseparable from the name of the subroutine we
want to invoke within that package.

0 in package 0.  (Here, "Class" is used in its
"category" meaning, not its "scholastic" meaning.) That's not
completely accurate, but we'll do this one step at a time.  Now let's
use it like so:

variables.  But yet, the parts are separable now.  Watch:

name, we can use a variable package name.  And this time, we've got
something that works even when 0 is enabled.

example:

without the use of symbolic coderefs.

similar structure: a 0 operator and a string that contains
common text, except for two of the words.  It'd be nice if we could
factor out the commonality, in case we decide later to change it all
to 0 instead of 0.

have to hear a bit more about what the method invocation arrow is
actually doing for us.

get to that later.)  This means that we get the class name as the
first parameter (the only parameter, if no arguments are given).  So
we can rewrite the 0 speaking subroutine as:

subroutine.  But once again, we have a lot of similar structure.  Can
we factor that out even further?  Yes, by calling another method in
the same class.

This method provides the constant text for the sound itself.

0.  This in turn selects the  method, which
returns 0.  But how different would this be for the 0?

somehow share the definition for 0 between the Cow and the
Horse?  Yes, with inheritance!

definition for 0:

with the animal-specific sound:

0.  Then Perl looks for 0.  But that's not there, so
Perl checks for the inheritance array 0.  It's there,
and contains the single name 0.

0.  And that's found, so Perl invokes that subroutine
with the already frozen argument list.

first argument).  So when we get to the step of invoking
, it'll be looking for , which
gets it on the first try without looking at 0.  Success!

Note that it's an array, not a simple single value, because on rare
occasions, it makes sense to have more than one parent class searched
for the missing methods.

search is recursive, depth-first, left-to-right in each 0 by
default (see 0 for alternatives).  Typically, each 0 has
only one element (multiple elements means multiple inheritance and
multiple headaches), so we get a nice tree of inheritance.

it's not a variable containing an explicit package name, nor is it a
lexical ("my") variable.  We can't make it a lexical variable though
(it has to belong to the package to be found by the inheritance mechanism),
so there's a couple of straightforward ways to handle that.

just employ 0 to specify that 0 should serve as the basis
for the 0 class:

doesn't immediately invoke . This is known as
"overriding". In fact, we don't even need to say that a 0 is
an 0 at all, because all of the methods needed for 0 are
completely defined for 0; this is known as "duck typing":
"If it walks like a duck and quacks like a duck, I would call it a duck"
(James Whitcomb). However, it would probably be beneficial to allow a
closer examination to conclude that a 0 is indeed an 0,
so it is actually better to define 0 with 0 as its base
(that is, it is better to "derive 0 from 0").

(though code-reuse is not actually a good reason for inheritance; good
design practices dictate that a derived class should be usable wherever
its base class is usable, which might not be the outcome if code-reuse
is the sole criterion for inheritance. Just remember that a 0
should always act like an 0).

 instead, the first parameter to 0
would automatically be 0 rather than 0, so that
the call to  in 0 would become
 rather than .

the first parameter to 0 ourselves, which is why 0
is explicitly passed: 0.

that the 0 method is a member of the 0 class; what if 0
actually inherits 0 from its own base? Because we are no longer using
 to access 0, the special method look up mechanism wouldn't be
used, so 0 wouldn't even be found!

selection. Let's assume that 0 does exist. What happens when,
at a later time, someone expands the class hierarchy by having 0
inherit from 0 instead of 0. Unless the invocation of 0
is also changed to an invocation of 0, centuries worth of taxonomical
classification could be obliterated!

maintenance nightmare. What we need is the ability to search for the right
method wih as few assumptions as possible.

for 0. This can be achieved with a modified version of the method arrow :

use all of 0's inheritance chain if it is not found immediately.
As usual, the first parameter to 0 would be 0, so we no
longer need to pass 0 explicitly to 0.

the method lookup.

invocation, then the contents of 0's 0 are used for the
search, beginning with 0. So, all of the problems can be fixed
as follows:

for a class that implements 0, and invoke the first one found.
The placeholder is called 0, because many other languages refer
to base classes as "0classes", and Perl likes to be eclectic.

be the current package.

(recursively) to locate a class (a package) that does indeed contain 0,
and that subroutine is invoked instead.

overriding, and extending. Using just what we've seen so far, we've
been able to factor out common code (though that's never a good reason
for inheritance!), and provide a nice way to reuse implementations with
variations.

and the 0 class:

0, calling back to 0 to get the specific
sound, and the output of:

If we add a subroutine, all horses automatically share it. That's
great for making horses the same, but how do we capture the
distinctions of an individual horse?  For example, suppose we want
to give our first horse a name. There's got to be a way to keep its
name separate from the other horses.

different names.

simplest reference that can hold a horse's name: a scalar reference.

data (the name). The final step is to turn this reference into a real
instance of a 0 by using the special operator 0:

the thing pointed at by the reference.  At this point, we say
0 is an instance of 0.  That is, it's a specific
horse.  The reference is otherwise unchanged, and can still be used
with traditional dereferencing operators.

of packages). So, let's get the sound that 0 makes:

reference (and thus an instance).  It then constructs an argument
list, as per usual.

blessed, in this case 0, and uses that class to locate the
subroutine. In this case, 0 is found directly (without
using inheritance). In the end, it is as though our initial line were
written as follows:

of the class as before.  We'll get 0 as the return value, and
that'll end up as the 0 variable above.

array, trying to find the method in one of the superclasses. The only
difference between a class method and an instance method is whether the
first parameter is an instance (a blessed reference) or a class name (a
string).

the instance-specific data.  In this case, let's add a way to get at
the name:

de-referenced with 0 as normal, yielding 0.

0 for instance methods and into a variable named 0 for
class methods.

likely make mistakes from time to time.  We're also violating one of
the properties of object-oriented programming, in that the "inside
guts" of a Horse are visible.  That's good if you're a veterinarian,
but not if you just like to own horses.  So, let's have the Horse
class handle the details inside a class method:

0 are 0 and 0.  The 0 operator
not only blesses 0, it also returns that reference.

the constructor's argument as the name for this particular 0.
You can use different constructors with different names for different
ways of "giving birth" to the object (like maybe recording its
pedigree or date of birth).  However, you'll find that most people
coming to Perl from more limited languages use a single constructor
named 0, with various ways of interpreting the arguments to
0.  Either style is fine, as long as you document your particular
way of giving birth to an object.  (And you 0 going to do that,
right?)

it's also the same recipe for building anything else that inherited from
0, so let's put 0 and 0 there:

its first parameter, not an instance.  When the instance is passed in,
we'll end up using a blessed scalar reference as a string, and that
shows up as we saw it just now.

or called on an instance.  The most straightforward way is with the
0 operator.  This returns a string (the classname) when used on a
blessed reference, and an empty string when used on a string (like a
classname).  Let's modify the 0 method first to notice the change:

dereference or a derived string.  Now we can use this with either an
instance or a class.  Note that I've changed the first parameter
holder to 0 to show that this is intended:

we're done!

and then the list of parameters.  So that first invocation is like:

made of many items, each of which can in turn be a reference or even
another object.  The easiest way to store these is often in a hash.
The keys of the hash serve as the names of parts of the object (often
called "instance variables" or "member variables"), and the
corresponding values are, well, the values.

any blessed reference.  We can just as easily make it a blessed hash
reference as a blessed scalar reference, as long as everything that
looks at the reference is changed accordingly.

0.  But we want to make  access the name, and
that's now messed up because it's expecting a scalar reference.  Not
to worry, because that's pretty easy to fix up.

defining them anew in 0, but then any methods added later to
0 might still mess up, and we'd have to override all of those
too. Therefore, it's never a good idea to define the data layout in a
way that's different from the data layout of the base classes. In fact,
it's a good idea to use blessed hash references in all cases. Also, this
is why it's important to have constructors do the low-level work. So,
let's redefine 0:

constructing a 0 with a certain color:

we still need to set a color, so we'll have a class-specific default color.
For a sheep, we might define it as white:

to color, so let's remove 0 and implement 0
to handle color instead:

class, we'll define a method that serves as the "default default" directly
in 0:

referenced the "structure" of the object, the rest of the methods can
remain the same, so 0 still works as before.

method or two to get and set the color.

in-place, rather than with a 0.  (This saves us a bit of time
for something that may be invoked frequently.)  And now we can fix
that color for Mr. Ed:

data, and even accessors. But that's still just the beginning of what
Perl has to offer. We haven't even begun to talk about accessors that
double as getters and setters, destructors, indirect object notation,
overloading, "isa" and "can" tests, the 0 class, and so on.
That's for the rest of the Perl documentation to cover. Hopefully, this
gets you started, though.

Perl objects, now that you've seen the basics), 0 (the
tutorial for those who already know objects), 0 (dealing
with class data), 0 (for some more tricks), and books such as
Damian Conway's excellent 0.

Class::Class, Class::Contract, Class::Data::Inheritable,
Class::MethodMaker and Tie::SecureHash

Consulting Services, Inc.

the Perl distribution, and in accordance with the licenses of the Perl
distribution; derived documents must include this copyright notice
intact.

originally appearing in the 0 course taught by instructors for Stonehenge Consulting
Services, Inc. and used with permission.

appearing in 0 and used with permission. 

=encoding utf8

appetites about such things as the use of instance variables and the
mechanics of object and class relationships.  The reader is encouraged to
consult relevant textbooks for discussion of Object Oriented definitions and
methodology.  This is not intended as a tutorial for object-oriented
programming or as a comprehensive guide to Perl's object oriented features,
nor should it be construed as a style guide.  If you're looking for tutorials,
be sure to read 0, 0, and 0.

inherited, when the type of  is valid but its package isn't what you
expect.  See rule 5.

object is probably the correct type and there's no need to become paranoid
about it.  Perl isn't a paranoid language anyway.  If people subvert the OO
or IO syntax then they probably know what they're doing and you should let
them do it.  See rule 1.

See 0.

superclass is allowed to know nothing about a subclass.

"delegation" relationship (some sort of aggregation, at least) is often more
appropriate.  See 0, 0,
and 0.

object.  This will remove the guess work about the symbol's home package.
See 0.

can cause difficult-to-find bugs.  Allow people to use the sure-thing OO
syntax, even if you don't like it.

someday.  Someone might move that method into a superclass and your code
will be broken.  On top of that you're feeding the paranoia in rule 2.

difficult for someone to override that method.  See 0.

variables.  Named parameters are also demonstrated.

superclass for inclusion in the new class.  This requires calling the
superclass's constructor and adding one's own instance variables to the new
object.

relationships between objects.

then call the overridden method.  The 0 pseudo-class allows the
programmer to call an overridden superclass method without actually knowing
where that method is defined.

(0), not to the superclasses of 0.

"using" relationship between the SDBM class and the new class Mydbm.

can use new code.  The following examples will demonstrate first how one can
hinder code reuse and then how one can promote code reuse.

call to access the "private" method .  The second example will show
that it is impossible to override the  method.

GOOP::, but this cannot happen because FOO:: explicitly calls
FOO::private::.

FOO::private.  The next example shows a reusable class FOO which allows the
method GOOP:: to be used in place of FOO::.

method needs should be available via the object or should be passed as a
parameter to the method.

methods.  A subclass may want to override that data and replace it with new
data.  When this happens the superclass may not know how to find the new
copy of the data.

method.  Let the method look in the object for a reference to the data.  The
alternative is to force the method to go hunting for the data ("Is it in my
class, or in a subclass?  Which subclass?"), and this can be inconvenient
and will lead to hackery.  It is better just to let the object tell the
method where that data is located.

blessing directly into a specified class.  Notice in this example that the
object will be a BAR not a FOO, even though the constructor is in class FOO.

they create foreign objects.  Such a class can be extended with some sort of
aggregation technique such as the "using" relationship mentioned earlier or
by delegation.

perform message-forwarding.  This will allow the Mydbm object to behave
exactly like an SDBM_File object.  The Mydbm class could now extend the
behavior by adding custom  and  methods, if this is desired.

=encoding utf8

directly from C, i.e., how to write 0.

callbacks the document uses a series of examples to show how the
interface actually works in practice.  In addition some techniques for
coding callbacks are covered.

function that will be called whenever something nasty occurs. What we
would like is to be able to specify a Perl subroutine that will be
called instead.

event driven program, such as for an X windows application.  In this case
you register functions to be called whenever specific events occur,
e.g., a mouse button is pressed, the cursor moves into a window or a
menu item is selected.

Perl in a C program, this is not the primary goal of this document.
There are other details that must be considered and are specific to
embedding Perl. For details on embedding Perl in C refer to
0.

it would be a good idea to have read the following two documents--0
and 0.

be aware of a few important definitions.

subroutines.  They are

fairly simple wrappers which make it easier to call Perl subroutines in
special cases. At the end of the day they will all call 0
to invoke the Perl subroutine.

used to pass a bit mask of options to Perl.  This bit mask operates
identically for each of the functions.  The settings available in the
bit mask are discussed in 0.

This allows you to specify the Perl subroutine to be called either as a
C string (which has first been converted to an SV) or a reference to a
subroutine. The section, 0, shows how you can make
use of 0.

expects its first parameter to be a C char* which identifies the Perl
subroutine you want to call, e.g., 0.  If the
subroutine you want to call is in another package, just include the
package name in the string, e.g., 0.

class.  The parameter 0 corresponds to the name of the method
to be called.  Note that the class that the method belongs to is passed
on the Perl stack rather than in the parameter list. This class can be
either the name of the class (for a static method) or a reference to an
object (for a virtual method).  See 0 for more information on
static and virtual methods and 0 for an example
of using 0.

stored in the 0 parameter. It also takes the usual 0
parameter.  The final parameter, 0, consists of a NULL-terminated
list of C strings to be passed as parameters to the Perl subroutine.
See 0.

items returned by the Perl subroutine. The actual items returned by the
subroutine are stored on the Perl stack.

these functions.  Even if you are expecting only a particular number of
values to be returned from the Perl subroutine, there is nothing to
stop someone from doing something unexpected--don't say you haven't
been warned.

G_SCALAR, or G_ARRAY, which indicate the call context, OR'ed together
with a bit mask of any combination of the other G_* symbols defined below.

a void context (if it executes 0 the result will be the
undefined value).

items have been returned by the Perl subroutine--in this case it will
be 0.

context flag setting for all the 0 functions.

scalar context (if it executes 0 the result will be false).

The subroutine can, of course,  ignore the 0 and return a
list anyway. If so, then only the last element of the list will be
returned.

items have been returned by the Perl subroutine - in this case it will
be either 0 or 1.

stored on the Perl stack - the section 0 shows how
to access this value on the stack.  Remember that regardless of how
many items the Perl subroutine returns, only the last one will be
accessible from the stack - think of the case where only one value is
returned as being a list with only one element.  Any other items that
were returned will not exist by the time control returns from the
0 function.  The section 0 shows an example of this behavior.

list context (if it executes 0 the result will be true).

accessible when control returns from the 0 function.

items have been returned by the Perl subroutine.

the subroutine. These items will be stored on the Perl stack.  The
section 0 gives an example of using the
G_ARRAY flag and the mechanics of accessing the returned items from the
Perl stack.

by the Perl subroutine on the stack.  If you are not interested in
these items, then setting this flag will make Perl get rid of them
automatically for you.  Note that it is still possible to indicate a
context to the Perl subroutine by using either G_SCALAR or G_ARRAY.

sure that any temporaries (i.e., parameters passed to the Perl
subroutine and values returned from the subroutine) are disposed of
yourself.  The section 0 gives details of how to
dispose of these temporaries explicitly and the section 0 discusses the specific circumstances where you
can ignore the problem and let Perl deal with it for you.

functions, it is assumed by default that parameters are to be passed to
the subroutine.  If you are not passing any parameters to the Perl
subroutine, you can save a bit of time by setting this flag.  It has
the effect of not creating the 0 array for the Perl subroutine.

straightforward, it should be used only if there is a good reason to do
so.  The reason for being cautious is that, even if you have specified
the G_NOARGS flag, it is still possible for the Perl subroutine that
has been called to think that you have passed it parameters.

can access the 0 array from a previous Perl subroutine.  This will
occur when the code that is executing the 0 function has
itself been called from another Perl subroutine. The code below
illustrates this

belongs to 0.

abnormally, e.g., by calling 0 explicitly or by not actually
existing.  By default, when either of these events occurs, the
process will terminate immediately.  If you want to trap this
type of event, specify the G_EVAL flag.  It will put an 0
around the subroutine call.

check the 0 variable as you would in a normal Perl script.

what other flags have been specified and whether an error has
occurred.  Here are all the different cases that can occur:

returned is as specified in the previous sections.

will always be 0.

will be 1 and the value on the top of the stack will be 0. This
means that if you have already detected the error by checking 0 and
you want the program to continue, you must remember to pop the 0
from the stack.

it if there was no error, and setting it to describe the error if there
was an error in the called code.  This is what you want if your intention
is to handle possible errors, but sometimes you just want to trap errors
and stop them interfering with the rest of the program.

from within destructors, asynchronous callbacks, and signal handlers.
In such situations, where the code being called has little relation to the
surrounding dynamic context, the main program needs to be insulated from
errors in the called code, even if they can't be handled intelligently.
It may also be useful to do this with code for 0 or 0
hooks, and 0 functions.

0 functions that are used to implement such code, or with
0.  This flag has no effect on the 0 functions when
G_EVAL is not used.

call as usual, and the error will not propagate beyond the call (as usual
for G_EVAL), but it will not go into 0.  Instead the error will be
converted into a warning, prefixed with the string "\t(in cleanup)".
This can be disabled using 0.  If there is no error,
0 will not be cleared.

may still set 0.

use of this flag.

executing subroutine in Perl with 0.  The equivalent test
can be made in C by using the 0 macro, which returns
0 if you have been called in a list context, 0 if
in a scalar context, or 0 if in a void context (i.e., the
return value will not be used).  An older version of this macro is
called 0; in a void context it returns 0 instead of
0.  An example of using the 0 macro is shown in
section 0.

Wherever possible, these macros should always be used when interfacing
to Perl internals.  We hope this should make the code less vulnerable
to any changes made to Perl in the future.

have made use of only the 0 function.  This has been done
to keep the code simpler and ease you into the topic.  Wherever
possible, if the choice is between using 0 and
0, you should always try to use 0.  See
0 for details.

print out the UID of the process.

the next example.

specified.

G_DISCARD is specified. Even if 0 was changed to
return some value(s), having specified G_DISCARD will mean that they
will be wiped by the time control returns from 0.

C string. In this case the subroutine name has been 'hard-wired' into the
code.

returned from 0. It will always be 0.

call a Perl subroutine, 0, which will take 2 parameters--a
string () and an integer ().  The subroutine will simply
print the first  characters of the string.

This is the purpose of the code beginning with the line 0 and
ending with the line 0.  The 0 declares a local copy
of the stack pointer.  This local copy should 0 be accessed
as 0.

where to put it. This is the purpose of the macro 0--it declares
and initializes a 0 copy of the Perl stack pointer.

have used this macro.

directly from an XSUB function. In this case it is not necessary to
use the 0 macro explicitly--it will be declared for you
automatically.

0 and 0 macros.  The purpose of these two macros, in
this context, is to count the number of parameters you are
pushing automatically.  Then whenever Perl is creating the 0 array for the
subroutine, it knows how big to make it.

stack pointer. Even if you aren't passing any parameters (like the
example shown in the section 0) you
must still call the 0 macro before you can call any of the
0 functions--Perl still needs to know that there are no
parameters.

the same as our local copy. If we didn't do this, 0
wouldn't know where the two parameters we pushed were--remember that
up to now all the stack pointer manipulation we have done is with our
local copy, 0 the global copy.

pushed onto the stack. In this case we are pushing a string and an
integer.

on how the XPUSH macros work.

we will have to tidy up the Perl stack and dispose of mortal SVs.

temporaries we create.  This means that the temporaries we get rid of
will be limited to those which were created after these calls.

the Perl subroutine (see next example), plus it will also dump the
mortal SVs we have created.  Having 0/0 at the
beginning of the code makes sure that no other mortals are destroyed.

to limit the scope of local variables.

an alternative to using these macros.

The only flag specified this time is G_DISCARD. Because we are passing
2 parameters to the Perl subroutine this time, we have not specified
G_NOARGS.

subroutine.

and simply returns their sum.

function required to call it is now a bit more complex.

array will be created and that the value returned by 0 will
still exist after the call to 0.

stack pointer. This is necessary because it is possible that the memory
allocated to the Perl stack has been reallocated during the
0 call.

always refresh the local copy using SPAGAIN whenever you make use
of the 0 functions or any other Perl internal function.

it is still good practice to check the return code from 0
anyway.

will be one. If someone modified 0 to return a list and we
didn't check for that possibility and take appropriate action the Perl
stack would end up in an inconsistent state. That is something you
0 don't want to happen ever.

In this case we wanted an integer, so 0 was used.

they return.

state before exiting the function.  This is necessary because when we
popped the return value from the stack with 0 it updated only our
local copy of the stack pointer.  Remember, 0 sets the global
stack pointer to be the same as our local copy.

parameters and the difference.

retrieving 2 values from the stack. The important thing to note is that
when using the 0 macros they come off the stack in 0
order.

context, like this

number of items returned from the Perl subroutine and their value (for
simplicity it assumes that they are integer).  So if
0 is called

list is returned from the subroutine. 0 actually made it back to
0.

list--whether it is actually desirable to do it is another matter entirely.

each directly.

after they return from 0 it is necessary to make a note
of their addresses--thus the two variables 0 and 0.

held them will very likely have been overwritten by something else by
the time control returns from 0.

the difference of its 2 parameters. If this would result in a negative
result, the subroutine calls 0.

flag.  Not specifying this flag would mean that the program would
terminate immediately at the 0 statement in the subroutine
0.

symbol table entry containing the error.  0 therefore
refers to the C equivalent of 0.

0 is true.  This is necessary because whenever a
0 function invoked with G_EVAL|G_SCALAR returns an error,
the top of the stack holds the value 0. Because we want the
program to continue after detecting this error, it is essential that
the stack be tidied up by removing the 0.

version of the call_Subtract example above inside a destructor:

0.  Here's why: the call_Subtract code got executed while perl
was cleaning up temporaries when exiting the outer braced block, and because
call_Subtract is implemented with 0 using the G_EVAL
flag, it promptly reset 0.  This results in the failure of the
outermost test for 0, and thereby the failure of the error trap.

call_Subtract reads:

subroutine to be called from C.  Most of the time though, it is more
convenient to be able to specify the name of the Perl subroutine from
within the Perl script.

can be specified as only a string.  For Perl 4 this was adequate,
but Perl 5 allows references to subroutines and anonymous subroutines.
This is where 0 is useful.

that the 0 parameter is now defined as an SV* and we use
0 instead of 0.

how you can specify the Perl subroutine.

example above) which corresponds to the Perl subroutine so that it can
be used later in the program, it not enough just to store a copy of the
pointer to the SV. Say the code above had been like this:

pointer 0 in 0, it may or may not still refer
to the Perl subroutine that was recorded in 0.  This is
particularly true for these cases:

the SV*s which corresponded to the parameters will no longer exist.
Expect an error message from Perl of the form

the version of Perl you are using)

whenever the call to 0 was made but by the time
0 gets called it now holds the number 0. Because we
saved only a pointer to the original SV in 0, any changes to
 will be tracked by the pointer 0. This means that
whenever 0 gets called, it will attempt to execute the
code which is referenced by the SV* 0.  In this case
though, it now refers to the integer 0, so expect Perl to complain
loudly.

subroutine 0 (assuming it exists) rather than 0 as was
originally requested in the call to 0.

SV.  The code below shows 0 modified to do that.

the function first checks to see if it has been called before.  If not,
then space for a new SV is allocated and the reference to the Perl
subroutine 0 is copied to the variable 0 in one
operation using 0.  Thereafter, whenever 0 is called,
the existing SV, 0, is overwritten with the new value using
0.

to it.

0.

This is because 0 will do it for you.

the constructor, 0, it declares methods, one static and one
virtual. The static method, 0, prints out simply the class
name and a version number. The virtual method, 0, prints out a
single element of the array.  Here is an all-Perl example of using it.

things are required:

for a static method

the 0 and 0 methods from C.

the method name is not passed via the stack--it is used as the first
parameter to 0.

currently executing.

(i.e., parameters passed on the stack to the 0 function or
values returned via the stack) have been freed by one of these methods:

for you automatically whenever it regains control after the callback
has terminated.  This is done by simply not using the

flag).

memory leak which can arise under very specific circumstances.  To
explain these circumstances you need to know a bit about the flow of
control between Perl and the callback routine.

an event driven program) are typical of the two main sorts of flow
control that you are likely to encounter with callbacks.  There is a
very important distinction between them, so pay attention.

follows.  You have created an interface to an external library.
Control can reach the external library like this

previously set up a Perl callback to handle this situation, so it will
get executed. Once the callback has finished, control will drop back to
Perl again.  Here is what the flow of control will be like in that
situation

control reverts back to Perl more or less immediately.

scope is.  It is only when control is back with perl on the extreme
left of the diagram that you will have dropped back to the enclosing
scope and any temporaries you have left hanging around will be freed.

will be more like this

sequence

control may 0 drop back to the surrounding scope in Perl at the
extreme left.

those temporaries for you, you might be in for a long wait.  For Perl
to dispose of your temporaries, control must drop back to the
enclosing scope at some stage.  In the event driven scenario that may
never happen.  This means that, as time goes on, your program will
create more and more temporaries, none of which will ever be freed. As
each of these temporaries consumes some memory your program will
eventually consume all the available memory in your system--kapow!

back to the enclosing Perl scope fairly quickly after the end of your
callback, then it isn't absolutely necessary to dispose explicitly of
any temporaries you may have created. Mind you, if you are at all
uncertain about what to do, it doesn't do any harm to tidy up anyway.

callback interface can be figuring out how to store the mapping between
the C callback function and the Perl equivalent.

callback is set up in an all C environment.  Typically a C API will
provide a function to register a callback.  This will expect a pointer
to a function as one of its parameters.  Below is a call to a
hypothetical function 0 which registers the C function
to get called when a fatal error occurs.

have defined 0 in your code, say something like this

registers, 0, might look like this

the global variable 0.

registered at any time. An example could be an error handler like the
code sketched out above. Remember though, repeated calls to
0 will replace the previously registered callback
function with the new one.

file i/o.  In this case you may be able to register a callback whenever
a read operation has completed. To be of any use we want to be able to
call separate Perl subroutines for each file that is opened.  As it
stands, the error handler example above would not be adequate as it
allows only a single callback to be defined at any time. What we
require is a means of storing the mapping between the opened file and
the Perl subroutine we want to be called for that file.

function 0 with a file handle 0--this assumes that it
has also provided some routine to open the file and so obtain the file
handle.

between the 0 parameter and the Perl subroutine we want called.  A
hash is a convenient mechanism for storing this mapping.  The code
below shows a possible implementation

the entry from the hash 0.

hash 0 this time. Using a hash has the distinct advantage that
it allows an unlimited number of callbacks to be registered.

parameter which allows the file handle to Perl subroutine mapping?  Say
in the asynchronous i/o package, the callback function gets passed only
the 0 parameter like this

C callback to the Perl subroutine.

series of C functions to act as the interface to Perl, thus

remember the Perl subroutine to be called. Each of the functions holds
a separate hard-wired index which is used in the function 0 to
access the 0 array and actually call the Perl subroutine.

example.

callbacks that can exist simultaneously. The only way to increase the
limit is by modifying the code to add more functions and then
recompiling.  None the less, as long as the number of functions is
chosen with some care, it is still a workable solution and in some
cases is the only one available.

for storing the mapping between C and the Perl callback

be a perfectly adequate solution.

callback what the context is, then you may need to create a sequence of C
callback interface functions, and store pointers to each in an array.

returned from Perl subroutines, it is also possible to bypass these
macros and read the stack using the 0 macro (See 0 for a
full description of the 0 macro).

problem with them is that they force you to process the returned values
in sequence. This may not be the most suitable way to process the
values in some cases. What we want is to be able to access the stack in
a random order. The 0 recoded to use 0 instead of 0.

because the 0 macro expects it to exist.  If we were in an XSUB it
would not be necessary to define 0 as it is already defined for
us.

values are not accessed in reverse order.  So 0 refers to the
first value returned by the Perl subroutine and 0
refers to the last.

anonymous subroutine.  However, our example showed a Perl script
invoking an XSUB to perform this operation.  Let's see how it can be
done inside our C code:

will be the return value as well (read more about 0 in
0).  Once this code reference is in hand, it
can be mixed in with all the previous examples we've shown.

This usually happens with a function that acts on a list of
values, such as Perl's built-in . You can pass a
comparison function to , which will then be invoked
for every pair of values that needs to be compared. The 
and  functions from 0 follow a similar
pattern.

quite substantially) by using the lightweight callback API.
The idea is that the calling context only needs to be
created and destroyed once, and the sub can be called
arbitrarily many times in between.

 for one parameter, or  and  for two parameters) rather
than via @_. (It is possible to use the @_ mechanism if you know
what you're doing, though there is as yet no supported API for
it. It's also inherently slower.)

 and  functions of List::Util 1.18. There you
will also find a header file that emulates the multicall API
on older versions of perl.

the document.

and Larry Wall.

=encoding utf8

programmers. Not everything is mentioned, but 195 features may
already be overwhelming.

people had useful suggestions. Thank you, Perl Monks.

but also took the time to count the number of listed features and make a
Perl 6 version to show that Perl will stay Perl.

=encoding utf8

much of the C standard library internally; you'll see very little use of,
for example, the 0 functions in there. This is because Perl
tends to reimplement or abstract standard library functions, so that we
know exactly how they're going to operate.

and who want to do things the Perl way; to tell them which functions
they ought to use instead of the more normal C functions.

layer. Instead of 0 types, you need to be handling 0
types.  Don't forget that with the new PerlIO layered I/O abstraction
0 types may not even be available. See also the 0
documentation for more information about the following functions:

different from their C library counterparts:

in 0 and 0.

instead of raw 0 strings:

concatenation with formatting.

should consider "poisoning" the data.  This means writing a bit
pattern into it that should be illegal as pointers (and floating point
numbers), and also hopefully surprising enough as integers, so that
any code attempting to use the data without forethought will break
sooner rather than later.  Poisoning can be done using the 
macros, which have similar arguments to :

type deals in 0s and are thus 0 Unicode aware (and hence
deprecated unless you 0 you should use them) and the other type
deal in 0s and know about Unicode properties. In the following
table, 0 is a 0, and 0 is a Unicode codepoint.

0 for converting strings representing numbers in the respective
bases into 0s.

built on doesn't actually have strtol and strtoul. But as those 2
functions are part of the 1989 ANSI C spec we suspect you'll find them
everywhere by now.

think you do, use the 0 stack in 0 instead.

=encoding utf8

far too large and diverse to provide a detailed listing. If any specific niche
has been forgotten, it is not meant as an insult but an omission for the sake
of brevity.

evidence that the Perl users apply TMTOWTDI to all endeavors, not just
programming. From websites, to IRC, to mailing lists, there is more than one
way to get involved in the community.

maintained by the Perl Foundation (0),
which tracks and provides services for a variety of other community sites.

written mostly over e-mail and today Perl's development is co-ordinated through
mailing lists. The largest repository of Perl mailing lists is located at
0.

contributors. If you don't see a certain project listed at
0, check the particular website for that project.
Most mailing lists are archived at 0.

0.

own IRC network, 0. General (not help-oriented) chat can be
found at 0. Many other more specific chats are also
hosted on the network. Information about irc.perl.org is located on the
network's website: 0. For a more help-oriented #perl,
check out 0. Perl 6 development also has a
presence in 0. Most Perl-related channels will
be kind enough to point you in the right direction if you ask nicely.

with varying activity levels.

categories: forums and news websites. There are many Perl-related
websites, so only a few of the community's largest are mentioned here.

Perl-related literature), perl.com provides current Perl news, articles, and
resources for Perl developers as well as a directory of other useful websites.

from minutes of the meetings of the Perl 6 Design team to conference
announcements with (ir)relevant discussion.

for individuals to polish, improve, and showcase their Perl skills." and "A
community which allows everyone to grow and learn from each other."

chapter is a local user group which typically holds regular in-person meetings,
both social and technical; helps organize local conferences, workshops, and
hackathons; and provides a mailing list or other continual contact method for
its members to keep in touch.

check the international Perl Mongers directory at 0.

in a variety of ways. At the workshops, subjects range from a beginner's
introduction (such as the Pittsburgh Perl Workshop's "Zero To Perl") to much
more advanced subjects.

0 mentioned above, the
0 mentioned below, and the YAPC Europe
website, 0, which is probably the best resource for
European Perl events.

do just that, hack nonstop for an extended (several day) period on a specific
project or projects. Information about hackathons can be located in the same
place as information about 0 as well as in
0.

know before attending: have a working laptop and know how to use it; check out
the involved projects beforehand; have the necessary version control client;
and bring backup equipment (an extra LAN cable, additional power strips, etc.)
because someone will forget.

put on by O'Reilly, and Yet Another Perl Conference or YAPC (pronounced
yap-see), which is localized into several regional YAPCs (North America,
Europe, Asia) in a stunning grassroots display by the Perl community. For more
information about either conference, check out their respective web pages:
OSCON 0; YAPC 0.

Open Source Developers Conference or OSDC. First held in Australia it has
recently also spread to Israel and France. More information can be found at:
0 for Australia, 0
for Israel, and 0 for France.

and Google calendar
(0) for tracking
workshops, hackathons, Perl Mongers meetings, and other events. Views
of this calendar are at 0 and
0.

heart if you don't see yours posted. To have your event or group listed,
contact brian d foy (brian@theperlreview.com).

=encoding utf8

internal form (a parse tree) which is then optimized before being
run.  Since version 5.005, Perl has shipped with a module
capable of inspecting the optimized parse tree (0), and this has
been used to write many useful utilities, including a module that lets
you turn your Perl into C source code that can be compiled into a
native executable.

("back ends") do things with the tree.  Some write it out as
semi-human-readable text.  Another traverses the parse tree to build a
cross-reference of which subroutines, formats, and variables are used
where.  Another checks your code for dubious constructs.  Yet another back
end dumps the parse tree back out as Perl source, acting as a source code
beautifier or deobfuscator.

corresponding to a Perl program, and in turn a native executable, the
0 module and its associated back ends are known as "the
compiler", even though they don't really compile anything.
Different parts of the compiler are more accurately a "translator",
or an "inspector", but people want Perl to have a "compiler
option" not an "inspector gadget".  What can you do?

it comprises, how to use the most important of the back end modules,
what problems there are, and how to work around them.

(the module that you, the user of the compiler, will sometimes
interact with) is the O module.

expressed as a number from 0 (outline for later implementation) to
10 (if there's a bug in it, we're very surprised):

6 (it works adequately, but only has a very limited number of areas
that it checks).

Status: 8 (it works nicely, but a few obscure things are missing).

Status: 8 (it works nicely, but still has a few lingering bugs).

ends.  They're presented roughly in order of maturity, so that the
most stable and proven back ends are described first, and the most
experimental and incomplete back ends are described last.

prevents Perl from executing your code once it has been compiled.
This is why all the back ends print:

breaking down declarations and uses of subroutines and variables (and
formats) by file and subroutine.  For instance, here's part of the
report from the 0 program that comes with Perl:

variable 0 is a  (lexical) variable,
0ntroduced (first declared with ) on line 1069, and used on
line 1079.  The variable 0 from the main package is used on 1086,
and so on.

to a separate file.  For instance, to save the report on
0 to the file 0:

can reformat along the way, making it useful as a deobfuscator.  The
most basic way to use it is:

your code.  You'll have to separate chunks of code from each other
with newlines by hand.  However, watch what it will do with
one-liners:

instance, you can set the size of each indent from 4 (as above) to
2 with:

programmer's bad style is another programmer's useful tool, so options
let you select what is complained about.

module, which allows a Perl program to inspect its innards.  The
back end modules all use this module to gain access to the compiled
parse tree.  You, the user of a back end module, will not need to
interact with B.

called something like this:

tree.  Its output is more customizable than the one of B::Terse or
B::Debug (and it can emulate them). This module is useful for people who
are writing their own back end, or who are learning about the Perl
internals.  It's not useful to the average programmer.

It's useful for people who are writing their own back end, or who
are learning about the Perl internals.  It's not useful to the
average programmer.

It is useful in debugging and deconstructing other people's code,
also as a pretty-printer for your own source.  See
0 for details about usage.

which, while some people frown on them, aren't necessarily bad enough
to justify a warning.  For instance, use of an array in scalar context
without explicitly saying 0 is something that Lint
can identify.  See 0 for details about usage.

file.  To get a list of the  variables used in the subroutine
 defined in the file myperlprogram:

information as B::Debug.  For comparison, 0
produced 96 lines of output from B::Debug, but only 6 from B::Terse.

or who are learning about the Perl internals.  It's not useful to the
average programmer.

formats are defined and used within a program and the modules it
loads.  See 0 for details about
usage.

state that is initialized in BEGIN{}, such as opening files, initiating
database connections etc., do not behave properly.  To work around
this, Perl has an INIT{} block that corresponds to code being executed
before your program begins running but after your program has finished
being compiled.  Execution order: BEGIN{}, (possible save of state
through compiler back-end), INIT{}, program runs, END{}.

maintained by the perl5-porters mailing list
0.

=encoding utf8

0 0 0 0

associative arrays of scalars, known as "hashes".  A scalar is a
single string (of any size, limited only by the available memory),
number, or a reference to something (which will be discussed
in 0).  Normal arrays are ordered lists of scalars indexed
by number, starting with 0.  Hashes are unordered collections of scalar
values indexed by their associated string key.

The first character of the name tells you to what sort of data
structure it refers.  The rest of the name tells you the particular
value to which it refers.  Usually this name is a single 0,
that is, a string beginning with a letter or underscore, and
containing letters, underscores, and digits.  In some cases, it may
be a chain of identifiers, separated by 0 (or by the slightly
archaic 0); all but the last are interpreted as names of packages,
to locate the namespace in which to look up the final identifier
(see 0 for details).  It's possible to substitute
for a simple identifier, an expression that produces a reference
to the value at runtime.   This is described in more detail below
and in 0.
0

these rules.  They have strange names so they don't accidentally
collide with one of your normal variables.  Strings that match
parenthesized parts of a regular expression are saved under names
containing only digits after the 0 (see 0 and 0).
In addition, several special variables that provide windows into
the inner working of Perl have names containing punctuation characters
and control characters.  These are documented in 0.
0

scalar that is part of an array or a hash.  The '$' symbol works
semantically like the English word "the" in that it indicates a
single value is expected.
0

which works much as the word "these" or "those" does in English,
in that it indicates multiple values are expected.
0

0

is optional when unambiguous, just as the word "do" is often redundant
in English.  Symbol table entries can be named with an initial '*',
but you don't really care about that yet (if ever :-).

non-variable identifiers.  This means that you can, without fear
of conflict, use the same name for a scalar variable, an array, or
a hash--or, for that matter, for a filehandle, a directory handle, a
subroutine name, a format name, or a label.  This means that 
and @foo are two different variables.  It also means that 0
is a part of @foo, not a part of .  This may seem a bit weird,
but that's okay, because it is weird.
0

"reserved" words aren't in fact reserved with respect to variable
names.  They 0 reserved with respect to labels and filehandles,
however, which don't have an initial special character.  You can't
have a filehandle named "log", for instance.  Hint: you could say
0 rather than 0.  Using
uppercase filehandles also improves readability and protects you
from conflict with future reserved words.  Case 0 significant--"FOO",
"Foo", and "foo" are all different names.  Names that start with a
letter or underscore may also contain digits and underscores.
0
0

that returns a reference to the appropriate type.  For a description
of this, see 0.

that do not start with a letter, underscore, digit or a caret (i.e.
a control character) are limited to one character, e.g.,  0 or
0.  (Most of these one character names have a predefined
significance to Perl.  For instance, 0 is the current process
id.)

0 0 0

on the requirements of the context around the operation or value.
There are two major contexts: list and scalar.  Certain operations
return list values in contexts wanting a list, and scalar values
otherwise.  If this is true of an operation it will be mentioned in
the documentation for that operation.  In other words, Perl overloads
certain operations based on whether the expected return value is
singular or plural.  Some words in English work this way, like "fish"
and "sheep".

list context to each of its arguments.  For example, if you say

operator, which responds by reading one line from STDIN and passing it
back to the integer operation, which will then find the integer value
of that line and return that.  If, on the other hand, you say

will proceed to read every line available up to the end of file, and
pass that list of lines back to the sort routine, which will then
sort those lines and return them as a list to whatever the context
of the sort was.

to determine the context for the right argument.  Assignment to a
scalar evaluates the right-hand side in scalar context, while
assignment to an array or hash evaluates the righthand side in list
context.  Assignment to a list (or slice, which is just a list
anyway) also evaluates the right-hand side in list context.

option, you may see warnings
about useless uses of constants or functions in "void context".
Void context just means the value has been discarded, such as a
statement containing only 0 or 0.  It still
counts as scalar context for functions that care whether or not
they're being called in list context.

called in a void, scalar, or list context.  Most subroutines do not
need to bother, though.  That's because both scalars and lists are
automatically interpolated into lists.  See 0
for how you would dynamically discern your function's calling
context.

0 0 0 0

scalars.  A scalar may contain one single value in any of three
different flavors: a number, a string, or a reference.  In general,
conversion from one form to another is transparent.  Although a
scalar may not directly hold multiple values, it may contain a
reference to an array or hash which in turn contains multiple values.

to declare a scalar variable to be of type "string", type "number",
type "reference", or anything else.  Because of the automatic
conversion of scalars, operations that return scalars don't need
to care (and in fact, cannot care) whether their caller is looking
for a string, a number, or a reference.  Perl is a contextually
polymorphic language whose scalars can be strings, numbers, or
references (which includes objects).  Although strings and numbers
are considered pretty much the same thing for nearly all purposes,
references are strongly-typed, uncastable pointers with builtin
reference-counting and destructor invocation.

the null string or the number 0 (or its string equivalent, "0").  The
Boolean context is just a special kind of scalar context where no
conversion to a string or a number is ever performed.
0 0 0 0 0

to as "empty" strings), a defined one and an undefined one.  The
defined version is just a string of length zero, such as 0.
The undefined version is the value that indicates that there is
no real value for something, such as when there was an error, or
at end of file, or when you refer to an uninitialized variable or
element of an array or hash.  Although in early versions of Perl,
an undefined scalar could become defined when first used in a
place expecting a defined value, this no longer happens except for
rare cases of autovivification as explained in 0.  You can
use the  operator to determine whether a scalar value is
defined (this has no meaning on arrays or hashes), and the 
operator to produce an undefined value.
0 0 0 0 0

sometimes enough to test it against both numeric 0 and also lexical
"0" (although this will cause noises if warnings are on).  That's
because strings that aren't numbers count as 0, just as they do in 0:

notations like 0 or 0 properly.  At other times, you
might prefer to determine whether string data can be used numerically
by calling the POSIX:: function or by inspecting your string
with a regular expression (as documented in 0).

of array @days by evaluating 0, as in 0.  However, this
isn't the length of the array; it's the subscript of the last element,
which is a different value since there is ordinarily a 0th element.
Assigning to 0 actually changes the length of the array.
Shortening an array this way destroys intervening values.  Lengthening
an array that was previously shortened does not recover values
that were in those elements.  (It used to do so in Perl 4, but we
had to break this to make sure destructors were called when expected.)
0 0

an array that is going to get big.  You can also extend an array
by assigning to an element that is off the end of the array.  You
can truncate an array down to nothing by assigning the null list
() to it.  The following are equivalent:

of the array.  (Note that this is not true of lists, which return
the last value, like the C comma operator, nor of built-in functions,
which return whatever they feel like returning.)  The following is
always true:
0

the value of 0 no longer need to worry about whether another
file changed its value.  (In other words, use of 0 is deprecated.)
So in general you can assume that
0

leave nothing to doubt:

hash is empty.  If there are any key/value pairs, it returns true;
more precisely, the value returned is a string consisting of the
number of used buckets and the number of allocated buckets, separated
by a slash.  This is pretty much useful only to find out whether
Perl's internal hashing algorithm is performing poorly on your data
set.  For example, you stick 10,000 things in a hash, but evaluating
%HASH in scalar context reveals 0, which means only one out
of sixteen buckets has been touched, and presumably contains all
10,000 of your items.  This isn't supposed to happen.  If a tied hash
is evaluated in scalar context, the 0 method is called (with a
fallback to 0).
0 0 0

This rounds up the allocated buckets to the next power of two:

0 0

integer formats:

between digits for legibility.  You could, for example, group binary
digits by threes (as for a Unix-style mode argument such as 0b110_100_100)
or by fours (to represent nibbles, as in 0b1010_0110) or in other groups.
0

quotes.  They work much like quotes in the standard Unix shells:
double-quoted string literals are subject to backslash and variable
substitution; single-quoted strings are not (except for 0 and
0).  The usual C-style backslash rules apply for making
characters such as newline, tab, etc., as well as some more exotic
forms.  See 0 for a list.
0

(e.g. '0xff') are not automatically converted to their integer
representation.  The  and  functions make these conversions
for you.  See 0 and 0 for more details.

on a different line than they begin.  This is nice, but if you forget
your trailing quote, the error will not be reported until Perl finds
another line containing the quote character, which may be much further
on in the script.  Variable substitution inside strings is limited to
scalar variables, arrays, and array or hash slices.  (In other words,
names beginning with $ or @, followed by an optional bracketed
expression as a subscript.)  The following code segment prints out "The
price is <>100."
0

dot (".")  as the decimal separator.  If 0 is in effect,
and POSIX:: has been called, the character used for the
decimal separator is affected by the LC_NUMERIC locale.
See 0 and 0.

disambiguate it from following alphanumerics (and underscores).
You must also do
this when interpolating a variable into a string to separate the
variable name from a following double-colon or an apostrophe, since
these would be otherwise treated as a package separator:
0

0, and a 0 variable.  The last two would be the
 and the  variables in the (presumably) non-existent package
0.

as is any simple identifier within a hash subscript.  Neither need
quoting.  Our earlier example, 0 can be written as
0 and the quotes will be assumed automatically.  But
anything more complicated in the subscript will be interpreted as an
expression.  This means for example that 0 is
equivalent to 0, not to 0.

0 0 0

of characters with the specified ordinals.  This form, known as
v-strings, provides an alternative, more readable way to construct
strings, rather than use the somewhat less readable interpolation form
0.  This is useful for representing
Unicode strings, and for comparing version "numbers" using the string
comparison operators, 0, 0, 0 etc.  If there are two or
more dots in the literal, the leading 0 may be omitted.

doing a version check.  Note that using the v-strings for IPv4
addresses is not portable unless you also use the
/ routines of the Socket package.

are not v-strings before the  operator (which is usually used
to separate a hash key from a hash value); instead they are interpreted
as literal strings ('v65').  They were v-strings from Perl 5.6.0 to
Perl 5.8.0, but that caused more confusion and breakage than good.
Multi-number v-strings like 0 and 0 continue to
be v-strings always.

0 0 0 0 0
0 0 0 0

represent the current filename, line number, and package name at that
point in your program.  They may be used only as separate tokens; they
will not be interpolated into strings.  If there is no current package
(due to an empty 0 directive), __PACKAGE__ is the undefined
value. (But the empty 0 is no longer supported, as of version
5.10.)
0 0 0 0 0 0

may be used to indicate the logical end of the script before the actual
end of file.  Any following text is ignored.

where 0 is the package that was current when the __DATA__
token was encountered.  The filehandle is left open pointing to the
contents after __DATA__.  It is the program's responsibility to
0 when it is done reading from it.  For compatibility with
older scripts written before __DATA__ was introduced, __END__ behaves
like __DATA__ in the top level script (but not in files loaded with
0 or 0) and leaves the remaining contents of the
file accessible via 0.

an example of its use.  Note that you cannot read from the DATA
filehandle in a BEGIN block: the BEGIN block is executed as soon
as it is seen (during compilation), at which point the corresponding
__DATA__ (or __END__) token has not yet been seen.

0

be treated as if it were a quoted string.  These are known as
"barewords".  As with filehandles and labels, a bareword that consists
entirely of lowercase letters risks conflict with future reserved
words, and if you use the 0 pragma or the 0 switch,
Perl will warn you about any such words.  Perl limits barewords (like
identifiers) to about 250 characters.  Future versions of Perl are likely
to eliminate these arbitrary limitations.

say

produces a compile-time error instead.  The restriction lasts to the
end of the enclosing block.  An inner block may countermand this
by saying 0.

0 0 0

by joining the elements with the delimiter specified in the 0
variable (0 if "use English;" is specified),
space by default.  The following are equivalent:

there is an unfortunate ambiguity:  Is 0 to be interpreted as
0 (where 0 is a character class for the regular
expression) or as 0 (where 0 is the subscript to array
@foo)?  If @foo doesn't otherwise exist, then it's obviously a
character class.  If @foo exists, Perl takes a good guess about 0,
and is almost always right.  If it does guess wrong, or if you're just
plain paranoid, you can force the correct interpretation with curly
braces as above.

which used to be here, that's been moved to
0.

0

(and enclosing the list in parentheses where precedence requires it):

to be a list literal is simply the value of the final element, as
with the C comma operator.  For example,

Note that the value of an actual array in scalar context is the
length of the array; the following assigns the value 3 to :

list literal, so that you can say:

you might use an approach like this:

evaluated, each element of the list is evaluated in list context, and
the resulting list value is interpolated into LIST just as if each
individual element were a member of LIST.  Thus arrays and hashes lose their
identity in a LIST--the list

followed by all the elements returned by the subroutine named SomeSub
called in list context, followed by the key/value pairs of %glarch.
To make a list reference that does 0 interpolate, see 0.

has no effect.  Thus ((),(),()) is equivalent to ().  Similarly,
interpolating an array with no elements is the same as if no
array had been interpolated at that point.

and closing parentheses are optional (except when necessary for
precedence) and lists may end with an optional comma to mean that
multiple commas within lists are legal syntax. The list 0 is a
concatenation of two lists, 0 and 0, the first of which ends
with that optional comma.  0 is 0 is 0 (And
similarly for 0 is 0 is 0 and so on.)  Not that
we'd advise you to use this obfuscation.

put the list in parentheses to avoid ambiguity.  For example:

is itself legal to assign to:

This is useful for throwing away some of the return values of a
function:

produced by the expression on the right side of the assignment:

context, because most list functions return a null list when finished,
which when assigned produces a 0, which is interpreted as FALSE.

performing an operation in list context and then counting the number of
return values, by assigning to an empty list and then using that
assignment in scalar context. For example, this code:

This happens because the pattern match is in list context (since it
is being assigned to the empty list), and will therefore return a list
of all matching parts of the string. The list assignment in scalar
context will translate that into the number of elements (here, the
number of times the pattern matched) and assign that to . Note
that simply using

only return true or false, rather than a count of matches.

in the list will soak up all the values, and anything after it will become
undefined.  This may be useful in a  or .

items to be interpreted as a key and a value:

not the case for hashes.  Just because you can subscript a list value like
a normal array does not mean that you can subscript a list value as a
hash.  Likewise, hashes included as parts of other lists (including
parameters lists and return lists from functions) always flatten out into
key/value pairs.  That's why it's good to use references sometimes.

pairs.  The  operator is mostly just a more visually distinctive
synonym for a comma, but it also arranges for its left-hand operand to be
interpreted as a string if it's a bareword that would be a legal simple
identifier.  doesn't quote compound identifiers, that contain
double colons. This makes it nice for initializing hashes:

mean that it comes out in that order.  See 0 for examples
of how to arrange for an output ordering.

time by specifying a dollar sign (0), then the
name of the array (without the leading 0), then the subscript inside
square brackets.  For example:

value from the end.  In our example, 0 would have been
5000, and 0 would have been 500.

are used. For example:

0 0 0

simultaneously using a list of subscripts.  It's more convenient
than writing out the individual elements as a list of separate
scalar values.

an array or hash slice.

slicing, a 0 construct will alter some--or even all--of the
values of the array or hash.

is returned:

is the number of elements on the right-hand side of the assignment.
The null list contains no elements, so when the password file is
exhausted, the result is 0, not 2.

instead of a '%', think of it like this.  The type of bracket (square
or curly) governs whether it's an array or a hash being looked at.
On the other hand, the leading symbol ('$' or '@') on the array or
hash indicates whether you are getting back a singular value (a
scalar) or a plural one (a list).

0 0 0

symbol table entry.  The type prefix of a typeglob is a 0, because
it represents all types.  This used to be the preferred way to
pass arrays and hashes by reference into a function, but now that
we have real references, this is seldom needed.

This assignment:

for %that, &this an alias for &that, etc.  Much safer is to use a reference.
This:

make @Here::blue an alias for @There::green, or %Here::blue an alias for
%There::green, etc.  See 0 for more examples
of this.  Strange though this may seem, this is the basis for the whole
module import/export system.

to create new filehandles.  If you need to use a typeglob to save away
a filehandle, do it this way:

in functions.

operator.  These last until their block is exited, but may be passed back.
For example:

for filehandle manipulations, although they're still needed to pass brand
new file and directory handles into or out of functions. That's because
0 only works if HANDLE has already been used as a handle.
In other words, 0 must be used to create new symbol table entries;
0 cannot.  When in doubt, use 0.

, , , , , and )
automatically create an anonymous filehandle if the handle passed to
them is an uninitialized scalar variable. This allows the constructs
such as 0 and 0 to be used to
create filehandles that will conveniently be closed automatically when
the scope ends, provided there are no other references to them. This
largely eliminates the need for typeglobs when opening filehandles
that must be passed around, as in the following example:

result is different: 0 is equivalent
to 0.
0 forbids such practice.

module or with the IO::Handle module and its ilk.  These modules
have the advantage of not hiding different types of the same name
during the .  See the bottom of 0
for an example.

a discussion of legal variable names.  See 0, 0,
and 0 for more discussion on typeglobs and
the 0 syntax. 

=encoding utf8

modules that ship with Perl, namely DB_File, GDBM_File, NDBM_File,
ODBM_File and SDBM_File.

uninstall) a single DBM Filter. The only difference between them is the
place that the filter is installed.

every time you write a key to a DBM database.

every time you write a value to a DBM database.

every time you read a key from a DBM database.

every time you read a value from a DBM database.

if not.

the key or value to be filtered. Filtering is achieved by modifying
the contents of 0. The return code from the filter is ignored.

want to make the same transformation to all keys, all values or both.

that you need to share with a third-party C application. The C application
assumes that 0 keys and values are NULL terminated. Unfortunately
when Perl writes to DBM databases it doesn't use NULL termination, so
your Perl application will have to manage NULL termination itself. When
you write to the database you will have to use something like this:

the length of existing keys/values.

in the main application code and have a mechanism that automatically
added the terminating NULL to all keys and values whenever you write to
the database and have them removed when you read from the database. As I'm
sure you have already guessed, this is a problem that DBM Filters can
fix very easily.

modules.

self-explanatory. Both "fetch" filters remove the terminating NULL,
and both "store" filters add a terminating NULL.

a DBM database it always writes the key and value as strings. So when
you use this:

"12345". If you actually want the key to be stored in the DBM database
as a C int, you will have to use 0 when writing, and 0
when reading.

DBM modules.

the contents of the key, so it wasn't necessary to install any value
filters.

=encoding utf8

the debugger.  This manpage describes low-level details concerning
the debugger's internals, which range from difficult to impossible
to understand for anyone who isn't incredibly intimate with Perl's guts.
Caveat lector.

to create debugging environments.  These hooks are not to be confused
with the 0 command described in 0, which is
usable only if a special Perl is built per the instructions in the
0 podpage in the Perl source tree.

from the package 0, the arguments that the corresponding stack
frame was called with are copied to the 0 array.  These
mechanisms are enabled by calling Perl with the 0 switch.
Specifically, the following additional features are enabled
(cf. 0 if not present) before the first line of your program.

file compiled by Perl.  The same is also true for 0ed strings
that contain subroutines, or which are currently being executed.
The  for 0ed strings looks like 0.
Code assertions in regexes look like 0.

equal to zero only if the line is not breakable.

by line number.  Individual entries (as opposed to the whole hash)
are settable.  Perl only cares about Boolean true here, although
the values used by 0 have the form
0.

which are currently being executed.  The  for 0ed strings
looks like 0 or 0.

also the case for evaluated strings that contain subroutines, or
which are currently being executed.  The  for 0ed
strings looks like 0 or 0.

C<DB::postponed(*{"_<"})> is called if the subroutine
0 exists.  Here, the  is the expanded name of
the 0d file, as found in the values of %INC.

0 is checked.  If this key exists,
0 is called if the 0 subroutine
also exists.

and whose values have the form 0.
0 has the form 0 for subroutines defined inside
0s, or 0 for those within regex code assertions.

breakpoint, the 0 subroutine is called if any of the variables
0, 0, or 0 is true.  These variables
are not 0izable.  This feature is disabled when executing
inside 0, including functions called from it
unless  is true.

 is made instead, with 0 holding the
name of the called subroutine. (This doesn't happen if the subroutine
was compiled in the 0 package.)

subroutine call is possible without it. As an example, the standard
debugger's 0 depends on the 0 variable
(it defines how many levels of recursion deep into the debugger you can go
before a mandatory break).  If 0 is not defined, subroutine
calls are not possible, even though 0 exists.

For example, the minimal "working" debugger (it actually doesn't do anything)
consists of one line:

with only the line:

encountered and waits for you to hit a newline before continuing
to the next statement.

called subroutine.  Note that 0 is being compiled into the
package 0 through the use of the 0 directive.

0 under Unix), which can set important options.
(A subroutine (0) can be defined here as well; it is executed
after the debugger completes its own initialization.)

environment variable and uses it to set debugger options. The
contents of this variable are treated as if they were the argument
of an 0 debugger command (q.v. in 0).

the debugger also maintains various magical internal variables.

holds the lines of the currently-selected file (compiled by Perl), either
explicitly chosen with the debugger's 0 command, or implicitly by flow
of execution.

equal to zero only if the line is not breakable.

contains breakpoints and actions keyed by line number in
the currently-selected file, either explicitly chosen with the
debugger's 0 command, or implicitly by flow of execution.

are settable.  Perl only cares about Boolean true here, although
the values used by 0 have the form
0.

0.

and returns a list containing information about the calling frames (all
of them, if 0 is missing).  Each entry is reference to a hash
with keys 0 (either 0, 0, or 0), 0 (subroutine
name, or info about 0), 0 (0 or a reference to
an array), 0, and 0.

formatted info about caller frames.  The last two functions may be
convenient as arguments to ,  commands.

this manpages (or in 0) are considered for internal
use only, and as such are subject to change without notice.

information.  For example, contrast this expression trace:

resulting from setting your 0 environment variable to
the value 0, and running 0 from the command line.
Examples using various values of 0 are shown to give you a feel
for the difference between settings.  Long though it may be, this
is not a complete listing, but only excerpts.

If bit 2 of 0 is set, a line is printed on exit from a
subroutine as well.  If bit 4 is set, the arguments are printed
along with the caller info.  If bit 8 is set, the arguments are
printed even if they are tied or references.  If bit 16 is set, the
return value is printed, too.

0 flag on the command line.

compile time and run time.  Since Perl 5.9.5, this pragma is lexically
scoped.

shows the size of the compiled form (in arbitrary units, usually
4-byte words) and the total number of bytes allocated for the
offset/length table, usually 4+0*8.  The next line shows the
label 0 of the first node that does a match.

information.  In the example shown, the optimizer found that the match
should contain a substring 0 at offset 1, plus substring 0
at some offset between 3 and infinity.  Moreover, when checking for
these substrings (to abandon impossible matches quickly), Perl will check
for the substring 0 before checking for the substring 0.  The
optimizer may also use the knowledge that the match starts (at the
0 0) with a character class, and no string
shorter than 7 characters can possibly match.

expression contains, and thus one does not need to enter the regex engine at
all.

0.

being 0, 0, or 0.  See the table below.

followed by 0, as in 0.

engine on strings that will not definitely match.  If the 0 flag
is set, a call to the regex engine may be avoided even when the optimizer
found an appropriate place for the match.

form of the regex.  Each line has format

Next section M-J. Dominus (mjd-perl-patch+@plover.com) 20010421

table, here split across several lines:

entries.  Each entry is a pair of integers, denoted by 0.
Entries are numbered starting with 1, so entry #1 here is 0 and
entry #12 is 0.  0 indicates that the node labeled 0
(the 0) begins at character position 1 in the
pre-compiled form of the regex, and has a length of 4 characters.
0 in position 12
indicates that the node labeled 0
(the ) begins at character position 5 in the
pre-compiled form of the regex, and has a length of 1 character.
0 in position 14
indicates that the node labeled 0
(the ) begins at character position 12 in the
pre-compiled form of the regex, and has a length of 1 character---that
is, it corresponds to the 0 symbol in the precompiled regex.

if debugging is enabled.  This means that the regex engine was never
entered and that all of the job was therefore done by the optimizer.

of the compiled regex that is currently being tested against the target string.
The format of these lines is

Other incidental information appears interspersed within.

is a saying that to estimate memory usage of Perl, assume a reasonable
algorithm for memory allocation, multiply that estimate by 10, and
while you still may miss the mark, at least you won't be quite so
astonished.  This is not absolutely true, but may provide a good
grasp of what happens.

float cannot take less than 24 bytes, a string cannot take less
than 32 bytes (all these examples assume 32-bit architectures, the
result are quite a bit worse on 64-bit architectures).  If a variable
is accessed in two of three different ways (which require an integer,
a float, or a string), the memory footprint may increase yet another
20 bytes.  A sloppy  implementation can inflate these
numbers dramatically.

you're running.

eightfold increase.  This means that the compiled form of reasonable
(normally commented, properly indented etc.) code will take
about eight times more space in memory than the code took
on disk.

(it was available only if Perl was built with 0).
The switch was used to track Perl's memory allocations and possible
memory leaks.  These days the use of malloc debugging tools like
0 or 0 is suggested instead.  See also
0.

structures is to install the Devel::Size module from CPAN: it gives
you the minimum number of bytes required to store a particular data
structure.  Please be mindful of the difference between the 
and .

memory usage by setting {PERL_DEBUG_MSTATS}.

necessary switches (this is the default), then it will print memory
usage statistics after compiling your code when , and before termination of the program when .  The report format is similar to
the following example:

your execution using the  function out of the standard
Devel::Peek module.

up to the closest bucket size available, and a bucket is taken from
the pool of buckets of that size.

Each bucket has two sizes: memory footprint and the maximal size
of user data that can fit into this bucket.  Suppose in the above
example that the smallest bucket were size 4.  The biggest bucket
would have usable size 8188, and the memory footprint would be 8192.

size.  This means that these buckets cannot (and will not) be used.
For larger buckets, the memory footprint may be one page greater
than a power of 2.  If so, the corresponding power of two is
printed in the 0 field above.

of buckets of each size between 0 and 0.  In
the first row, the sizes (memory footprints) of buckets are powers
of two--or possibly one page greater.  In the second row, if present,
the memory footprints of the buckets are between the memory footprints
of two buckets "above".

were

a 4-byte overhead, and thus an 8192-long bucket may take up to
8188-byte allocations.

(ess-broken? :-) and number of s used.  The third number is
what perl thinks about continuity of returned chunks.  So long as
this number is positive,  will assume that it is probable
that  will provide continuous memory.

smaller buckets, it is kept in separate areas.  This field gives the
total size of these areas.

If only a part of the deceased bucket is left unsubdivided, the rest
is kept as an element of a linked list.  This field gives the total
size of these chunks.

field gives the size of the yet unused part, which is ed, but
never touched.

0,
0
0,
and
0. 

=encoding utf8

pointer to existing, deeper sources of information on the subject of debugging
perl programs.

anything about using the perl debugger, though they use the language every
day.
This is for them.

straightforward when it comes to debugging perl programs, without using the
debugger at all.  To demonstrate, here's a simple script, named "hello", with
a problem:

namely it doesn't print "Hello World\n" at all;  It will on the other hand do
exactly what it was told to do, computers being a bit that way inclined.  That
is, it will print out a newline character, and you'll get what looks like a
blank line.  It looks like there's 2 variables when (because of the typo)
there's really 3:

before use by pulling in the strict module, by putting 'use strict;' after the
first line of the script.

get four error messages because one variable is referenced twice:

script looks like this:

getting this script to compile has exposed the '' (with the letter 'l')
variable, and simply changing  to  solves the problem.

dynamic variable, just before using it?

run it and all we get is a blank line again!  Hmmmm.

statements, to add a check just before we print out our data, and another just
after:

trees for some time, we get a cup of coffee and try another approach.  That
is, we bring in the cavalry by giving perl the '0' switch on the command
line:

script.  It's stopped at the first line of executable code and is waiting for
input.

just the letter '0', not the words 'quit' or 'exit':

There's a couple of ways of calling help: a simple '0' will get the summary
help list, '0' (pipe-h) will pipe the help through your pager (which is
(probably 'more' or 'less'), and finally, '0' (h-space-h) will give you
the entire help screen.  Here is the summary page:

it looks and it's very useful to know more about all of it, and fun too!

think we're using any libraries at all at the moment, but '0' will show
which modules are currently loaded, and their version number, while '0'
will show the methods, and '0' shows all subroutines (by pattern) as
shown below.  '0' and '0' show variables in the program by package
scope and can be constrained by pattern.

the 'name':

where we are, and what our data looks like. First of all let's view some code
at our present position (the first line of code in this case), via '0':

see more code, type 'v' again:

stuff to wade through, and 'l' can be very useful.  To reset your view to the
line we're about to execute, type a lone period '.':

happened yet.  So while we can print a variable with the letter '0', at
this point all we'd get is an empty (undefined) value back.  What we need to
do is to step through the next executable statement with an '0':

'0', which by the way, inserts a 'one-time-only' breakpoint at the given
line or sub routine:

before the meat of our task.  We could try to print out a couple of variables
to see what is happening:

'0' command looks promising:

which are keys, and which are values, it's just a listed array dump and, in
this case, not particularly helpful.  The trick here, is to use a 0
to the data structure:

Our quoting was perfectly valid but wrong for our purposes, with 'and jerry'
being treated as 2 separate words rather than a phrase, thus throwing the
evenly paired hash structure out of alignment.

and saved us a lot of trouble:

our expected output:

and will merrily dump out nested references, complete objects, partial objects
- just about whatever you throw at it:

it wants some form of input from STDIN, so we give it something non-committal,
a zero:

of code or regexes until the cows come home:

has a problem:

expected output.  This is what it does:

under the debugger to see what's going on.  A breakpoint is a flag, to which
the debugger will run without interruption, when it reaches the breakpoint, it
will stop execution and offer a prompt for further interaction.  In normal
use, these debugger commands are completely ignored, and they are safe - if a
little messy, to leave in production code.

line 17 as that's just as we come out of the subroutine, and we'd like to
pause there later on:

using the list 'L' command:

number, we'll use the subroutine name, followed by the now familiar 'v':

to 0 through it, we could use the '0' command, and to step
over it we would use '0' which would execute the sub, but not descend into
it for inspection.  In this case though, we simply continue down to line 29:

it's anything to do with operator precedence?  We'll try a couple of other
possibilities with our sum:

return out of the sub with an 'r':

actual program and we're finished.

the DEBUGGING flag for this one:

anchored(BOL) minlen 4

For more gory details on getting regular expressions to work, have a look at
0, 0, and to decode the mysterious labels (BOL and CURLYN,
etc. above), see 0.

helpful operating system buffering, insert a line like this, at the start of
your script:

where, they're being called, 0 has more information:

are explained in 0 and 0.

on earth to get past that 'waiting for input' prompt, when running their CGI
script from the command-line, try something like this:

and there's a 0 interface too.

options out there.  The nice thing about these is you can wave a mouse over a
variable and a dump of its data will appear in an appropriate window, or in a
popup balloon, no more tiresome typing of 'x ' :-)

0.  We can run the perl debugger 0 to inspect your
data from within the perl debugger with the 0 and 0 commands.  You can
walk through your code, set breakpoints with 0 and step through that code
with 0 or 0, continue with 0 and return from a sub with 0.  Fairly
intuitive stuff when you get down to it.

surface.  The best way to learn more is to use perldoc to find out more about
the language, to read the on-line help (0 is probably the next
place to go), and of course, experiment.

0,
0,
0,
0

=encoding utf8

0 0

0, which is a tutorial introduction to the debugger.

Perl source debugger.  This works like an interactive Perl
environment, prompting for debugger commands that let you examine
source code, set breakpoints, get stack backtraces, change the values of
variables, etc.  This is so convenient that you often fire up
the debugger all by itself just to test out Perl constructs
interactively to see what they do.  For example:
0

typical compiled environment.  Instead, the 0 flag tells the compiler
to insert source information into the parse trees it's about to hand off
to the interpreter.  That means your code must first compile correctly
for the debugger to work on it.  Then when the interpreter starts up, it
preloads a special Perl library file containing the debugger.

statement (but see below regarding compile-time statements) and ask you
to enter a debugger command.  Contrary to popular expectations, whenever
the debugger halts and shows you a line of code, it always displays the
line it's 0 to execute, rather than the one it has just executed.

(0'd) as Perl code in the current package.  (The debugger
uses the DB package for keeping its own state information.)

result any newly introduced lexical variable or any modified
capture buffer content is lost after the eval. The debugger is a
nice environment to learn Perl, but if you interactively experiment using
material which should be in the same scope, stuff it in one line.

is first stripped before further processing.  If a debugger command
coincides with some function in your own program, merely precede the
function with something that doesn't look like a debugger command, such
as a leading 0 or perhaps a 0, or by wrapping it with parentheses
or braces.

0

past your screen, precede the command with a leading pipe symbol so
that it's run through your pager, as in

0

because this is just Perl's own 0 function, this means that nested
data structures and objects are not dumped, unlike with the 0 command.

where STDOUT may be redirected to.

0

pretty-printed fashion.  Nested data structures are printed out
recursively, unlike the real 0 function in Perl.  When dumping
hashes, you'll probably prefer 'x \%h' rather than 'x %h'.
See 0 if you'd like to do this yourself.

0.

dumped only 0 levels deep, as if the 0 option had been
temporarily set to 0.

0

using a data pretty-printer (hashes show their keys and values so
you see what's what, control characters are made printable, etc.).
Make sure you don't put the type specifier (like 0) there, just
the symbol names, like this:

0

0

in the current scope or 0 scopes higher.  You can limit the
variables that you see with 0 which works exactly as it does
for the 0 and 0 commands.  Requires the 0 module
version 0.08 or higher; will warn if this isn't installed.  Output
is pretty-printed in the same style as for 0 and the format is
controlled by the same options.

0 0 0

0 0

statement, descending into subroutine calls.  If an expression is
supplied that includes function calls, it too will be single-stepped.

0

of the next statement.  If an expression is supplied that includes
function calls, those functions will be executed with stops before
each statement.

0

Dump the return value if the 0 option is set (default).

0

at the specified line or subroutine.

0

be a variable that contains a code reference.

0

0

0

executed, and print out that line.

0

is not a full pathname found in the values of %INC, it is considered
a regex.

0 and 0 access the body of the 7th 0ed string
(in the order of execution).  The bodies of the currently executed 0
and of 0ed strings that define subroutines are saved and thus
accessible.

The search is case-insensitive by default.

The search is case-insensitive by default.

0

0

0

0

See 0 for examples.

0
0

0
0

is specified, it's evaluated each time the statement is reached: a
breakpoint is taken only if the condition is true.  Breakpoints may
only be set on lines that begin an executable statement.  Conditions
don't use 0:

0
0

be a variable containing a code reference (in this case 0
is not supported).

0
0

0
0

which should be a full pathname found amongst the %INC values.

0
0

subroutine is compiled.

0
0

0
0

0

omitted, set an action on the line about to be executed.
The sequence of steps taken by the debugger is

53 is passed:

0

0

0

debugger will stop and display the old and new values.

0

0

0

0

0

0

whitespace, it should be quoted.  For example, you could set 0 to call 0 with those specific options.
You may use either single or double quotes, but if you do, you must
escape any embedded instances of same sort of quote you began with,
as well as any escaping any escapes that immediately precede that
quote but which are not meant to escape the quote itself.  In other
words, you follow single-quoting rules irrespective of the quote;
eg: 0 or 0.

1 only where it is safe to do so--that is, mostly for Boolean
options.  It is always better to assign a specific value using 0.
The 0 can be abbreviated, but for clarity probably should
not be.  Several options can be set together.  See 0
for a list of these.

A multi-line command may be entered by backslashing the newlines.

A multi-line command may be entered by backwhacking the newlines.

just given a command to return to executing the script.  A multi-line
command may be entered by backslashing the newlines (we bet you
couldn't have guessed this by now).

X<<< debugger command, >> >>>

just given a command to return to executing the script.  A multi-line
command may be entered by backslashing the newlines.

0

A multi-line command may be entered in the customary fashion.

you appear to have accidentally entered a block instead.  If that's
what you mean to do, write it as with 0 or even
0.

0

0

A multi-line command may be entered, if you can guess how: see above.

0

0

0

See 0, too.

0

0, also.  Note that the user's current shell (well,
their 0 variable) will be used, which can interfere
with proper interpretation of exit status or signal and coredump
information.

0

0 may itself contain 0 commands.

0

listed.  If 0 is omitted, list them all.

0
0

This is the only supported way to exit the debugger, though typing
0 twice might work.

off the end the script.  You may also need to set  to 0
if you want to step through global destruction.

0

your history across this, but internal settings and command-line options
may be lost.

actions, debugger options, and the Perl command-line
options 0, 0, and 0.

0

0

0

supplied.  If the Perl statement would otherwise be confused for a
Perl debugger, use a leading semicolon, too.

0

expression.  The expression may evaluated to a reference to a
blessed object, or to a package name.

0

0

viewer on the given page, or on the viewer itself if 0 is
omitted.  If that viewer is 0, the current 0 information
is used to invoke 0 using the proper MANPATH or S<0
0 option.  Failed lookups of the form 0 that match
known manpages of the form 0 will be retried.  This lets
you type 0 or 0 from the debugger.

debugger invokes 0.  Occasionally this determination is
incorrect due to recalcitrant vendors or rather more felicitously,
to enterprising users.  If you fall into either category, just
manually set the ::doccmd variable to whatever viewer to view
the Perl documentation on your system.  This may be set in an rc
file, or through direct assignment.  We're still waiting for a
working example of something along the lines of:

either interactively or from the environment or an rc file.
(./.perldb or ~/.perldb under Unix.)

0
0

default, both are set to 0, which is unfortunate.

0

with a 0 character.)  By default, 0 will be used.
Because the debugger uses your current terminal characteristics
for bold and underlining, if the chosen pager does not pass escape
sequences through unchanged, the output of some debugger commands
will not be readable when sent through the pager.

0

0 0
0

and warnings alone, because altering them can break correctly running
programs.  It will attempt to print a message when uncaught INT, BUS, or
SEGV signals arrive.  (But see the mention of signals in 0 below.)

than 0.  At a level of 1, you get backtraces upon receiving any kind
of warning (this is often annoying) or exception (this is
often valuable).  Unfortunately, the debugger cannot discern fatal
exceptions from non-fatal ones.  If 0 is even 1, then your
non-fatal exceptions are also traced and unceremoniously altered if they
came from 0 strings or from any kind of 0 within modules
you're attempting to load.  If 0 is 2, the debugger doesn't
care where they came from:  It usurps your exception handler and prints
out a trace, then modifies all exceptions with its own embellishments.
This may perhaps be useful for some tracing purposes, but tends to hopelessly
destroy any program that takes its exception handling seriously.

0

0).

0

0), then a short message is used.  This is the
mechanism used to interact with a slave editor or visual debugger,
such as the special 0 or 0 hooks, or the 0 graphical
debugger.

0

0

0

There is currently no way to disable these, which can render
some output illegible on some displays, or with some pagers.
This is considered a bug.

0

0 is false, messages are printed on entry only. (Printing
on exit might be useful if interspersed with other messages.)

and caller info.  If 0, overloaded 0 and
0d 0 is enabled on the printed arguments.  If 0, the return value from the subroutine is printed.

next option:

0

bit 4 is set.

0

commands:

0 0

0

Negative values are interpreted as infinity.  Default: infinity.

0 0

may be printed on one line.

0

0

0

0

0 0
0

is 0; one can enable double-quotish or single-quotish format
by setting it to 0 or 0, respectively.  By default, characters
with their high bit set are printed verbatim.

0

size of strings found in variables in the package.  This does not
include lexicals in a module's file scope, or lost in closures.

environment variable and parses this as the remainder of a "O ..."
line as one might enter at the debugger prompt.  You may place the
initialization options 0, 0, 0, and 0
there.

information into the file 0.  (If you interrupt it, you'd
better reset 0 to 0 if you expect to see anything.)

0

0

interrupted (or if control goes to the debugger via explicit setting of
::signal or ::single from the Perl script), it connects to a TTY
specified in the 0 option at startup, or to a tty found at
runtime using the 0 module of your choice.

with two methods: 0 and 0.  These should return filehandles to use
for debugging input and output correspondingly.  The 0 method should
inspect an argument containing the value of 0 at
startup, or 0 otherwise.  This file is not
inspected for proper ownership, so security hazards are theoretically
possible.

0

to debug applications that themselves use ReadLine.

0

programmatically by setting ::signal or ::single.

printing out the call tree with entry and exit points.  Note that
0 is equivalent to 0, and that originally,
options could be uniquely abbreviated by the first letter (modulo
the 0 options).  It is nevertheless recommended that you
always spell them out in full for legibility and future compatibility.

into a subroutine and each executed line into the file named 0.
(If you interrupt it, you would better reset 0 to something
"interactive"!)

variable settings):

itself.  Do not forget to detach your shell from the TTY in the window that
corresponds to 0, say, by issuing a command like

access with the built-in 0-like history mechanism.  For example,
0 would repeat command number 17.  The depth of the angle
brackets indicates the nesting depth of the debugger.  You could
get more than one set of brackets, for example, if you'd already
at a breakpoint and then printed the result of a function call that
itself has a breakpoint, or you step into an expression via 0 command.

definition with several statements or a format, escape the newline
that would normally end the debugger command with a backslash.
Here's an example:

commands typed into the debugger.

0 0

look like:

function was called, with 0 and 0 meaning scalar or list
contexts respectively, and 0 meaning void context (which is
actually a sort of scalar context).  The display above says
that you were in the function 0 when you ran the
stack dump, and that it was called in scalar context from line
10 of the file 0, but without any arguments at all,
meaning it was called as 0.  The next stack frame shows
that the function 0 was called in list context
from the 0 file with four arguments.  The last stack
frame shows that 0 was called in scalar context,
also from 0, but from line 4.

statement, the backtrace will contain both a 0 frame and
an 0 frame.

marked by 0 and those with actions by 0.  The line that's
about to be executed is marked by .

as your original source code.  Line directives and external source
filters can alter the code before Perl sees it, causing code to move
from its original positions or take on entirely different forms.

optionally exited) subroutines in different styles.  See 0
for incredibly long examples of these.

BEGIN, UNITCHECK and CHECK blocks or 0 statements), these will
0 be stopped by debugger, although 0s and INIT blocks
will, and compile-time statements can be traced with the 0
option set in 0).  From your own Perl code, however, you
can transfer control back to the debugger using the following
statement, which is harmless if the debugger is not running:

just typed the 0 command, whereas a value of 1 means the 0
command.  The 0  variable should be set to 1 to simulate
having typed the 0 command.

breakpoint on the 0 for the same purpose.

won't ever have to modify it yourself.  You may change the behaviour
of the debugger from within the debugger using its 0 command, from
the command line via the 0 environment variable, and
from customization files.

contains initialization code.  For instance, you could make aliases
like these (the last one is one people expect to be there):

processed before processing 0.  If 0 defines the
subroutine 0, that function is called after debugger
initialization ends.  0 may be contained in the current
directory, or in the home directory.  Because this file is sourced
in by Perl and may contain arbitrary commands, for security reasons,
it must be owned by the superuser or the current user, and writable
by no one but its owner.

@DB::typeahead. For example, your 0 file might contain:

after debugger initialization. Note that @DB::typeahead is not a supported
interface and is subject to change in future releases.

Perl library to another name and hack it to your heart's content.
You'll then want to set your 0 environment variable to say
something like this:

by directly setting internal variables or calling debugger functions.

this document (or in 0) are considered for internal
use only, and as such are subject to change without notice.

that checks for leading exclamation points.  However, if you install
the Term::ReadKey and Term::ReadLine modules from CPAN (such as
Term::ReadLine::Gnu, Term::ReadLine::Perl, ...) you will
have full editing capabilities much like those GNU  provides.
Look for these in the 0 directory on CPAN.
These do not support normal 0 command-line editing, however.

lexical variables in the current scope if the 0 module
is installed.

"^[[D"", "^H", ... when using the arrow keys and/or the backspace key.

it can interact with the Perl debugger to provide an integrated
software development environment reminiscent of its interactions
with C debuggers.

start file for making 0 act like a
syntax-directed editor that understands (some of) Perl's syntax.
See 0.

vendor-shipped 0 and the X11 window system is also available.
This works similarly to the integrated multiwindow support that
0 provides, where the debugger drives the editor.  At the
time of this writing, however, that tool's eventual location in the
Perl distribution was uncertain.

and windy version, for coloring of Perl keywords.

fall somewhat short of the mark, especially if you don't program
your Perl as a C programmer might.

0 0 0

invoke your script with a colon and a package argument given to the
0 flag.  Perl's alternative debuggers include the Perl profiler,
0, which is included with the standard Perl
distribution.  To profile your Perl program in the file 0,
just type:

information to a file called 0.  A tool like 0,
also supplied with the standard Perl distribution, can be used to
interpret the information in that profile.  More powerful profilers,
such as 0 are available from the CPAN:  see 0
for details.

0
0 0

regular expression engine works. In order to understand this typically
voluminous output, one must not only have some idea about how regular
expression matching works in general, but also know how Perl's regular
expressions are internally compiled into an automaton. These matters
are explored in some detail in
0.

0

but this is a fairly advanced concept that requires some understanding
of how memory allocation works.
See 0 for the details.

0,
0,
0,
0,
0,
0,
and
0.

, the -S option causes perl to search  for it, so you don't
have to type the path or 0.

that were not compiled by Perl, such as those from C or C++ extensions.

or 0), the stack backtrace will not show the original values.

command-line switch, because it itself is not free of warnings.

from your keyboard or a socket) and haven't set up your own 0
handler, then you won't be able to CTRL-C your way back to the debugger,
because the debugger's own 0 handler doesn't understand that
it needs to raise an exception to  out of slow syscalls. 

=encoding utf8

the 5.14.0 release.

0, which describes differences between 5.10.0 and
5.12.0.

releases of 5.12.x.  Those are indicated with the 5.12.x version in
parentheses.

official end of support for Perl 5.10.  Users of Perl 5.10 or earlier
should consider upgrading to a more recent release of Perl.

0,
with one exception noted below.
See 0 for details on the new
release.  Perl does not support any Unicode provisional properties,
including the new ones for this release.

which is a symbol that looks like a bell, and is used in Japanese cell
phones.  This conflicts with the long-standing Perl usage of having
0 mean the ASCII 0 character, U+0007.  In Perl 5.14,
0 continues to mean U+0007, but its use generates a
deprecation warning message unless such warnings are turned off.  The
new name for U+0007 in Perl is 0, which corresponds nicely
with the existing shorthand sequence for it, 0.  0
means U+0007, with no warning given.  The character at U+1F514 has no
name in 5.14, but can be referred to by 0.
In Perl 5.16, 0 will refer to U+1F514; all code
that uses 0 should be converted to use 0,
0, or 0.  Under its scope, all string operations executed and
regular expressions compiled (even if executed outside its scope) have
Unicode semantics.  See 0.
However, see 0,
below.

0 for details).  If there is any
possibility that your code will process Unicode strings, you are
0 encouraged to use this subpragma to avoid nasty surprises.

character names listed by Unicode, such as NBSP, SHY, LRO, ZWJ, etc.; all
customary abbreviations for the C0 and C1 control characters (such as
ACK, BEL, CAN, etc.); and a few new variants of some C1 full names that
are in common usage.

of code points are given names.  C<\N{0 now recognizes these.

now know about every character in Unicode.  In earlier releases of
Perl, they didn't know about the Hangul syllables nor several
CJK (Chinese/Japanese/Korean) characters.

character, known by C<\N{0, 0, and
0.  Previously, aliases had to be to official
Unicode character names.  This made it impossible to create an alias for
unnamed code points, such as those reserved for private
use.

of C<\N{0, returning the string of characters whose Unicode
name is its parameter.  It can handle Unicode named character
sequences, whereas the pre-existing charnames:: cannot,
as the latter returns a single code point.

allow you to turn off some "utf8" warnings, while allowing
other warnings to remain on.  The three categories are:
0 when UTF-16 surrogates are encountered;
0 when Unicode non-character code points are encountered;
and 0 when code points above the legal Unicode
maximum of 0x10FFFF are encountered.

can be treated as a code point and encoded internally (as utf8)
without warnings, not just the code points that are legal in Unicode.
However, unless utf8 or the corresponding sub-category (see previous
item) of lexical warnings have been explicitly turned off, outputting
or executing a Unicode-defined operation such as upper-casing
on such a code point generates a warning.  Attempting to input these
using strict rules (such as with the 0 layer)
will continue to fail.  Prior to this release, handling was
inconsistent and in places, incorrect.

considered illegal in places by Perl, contrary to the Unicode Standard,
are now always legal internally.  Inputting or outputting them
works the same as with the non-legal Unicode code points, because the Unicode
Standard says they are (only) illegal for "open interchange".

doesn't affect any functionality in Perl and saves significant disk
space.  If you need these files, you can download them from
0.

expression now means that the subexpression does not inherit surrounding
modifiers such as 0, but reverts to the Perl defaults.  Any modifiers
following the caret override the defaults.

For example, 0 would previously be stringified as
0, but now it's stringified as 0.

stringification 0 to have to change whenever new modifiers are added.
See 0.

expressions with fixed strings containing 0.

exclusive: one only can be turned on at a time.

in the scope of 0, even if it is not.

in the scope of a 0 pragma.

0 pragmas in effect at the time
of compiling the regular expression.

the POSIX (0) character classes to the ASCII range.  Their
complements and 0 and 0 are correspondingly
affected.  Otherwise, 0 behaves like the 0 modifier, in that
case-insensitive matching uses Unicode semantics.

matching, no ASCII character can match a non-ASCII character.
For example,

(0) operators now support an 0 option that
copies the input variable, carries out the substitution on
the copy, and returns the result.  The original remains unmodified.

0 code blocks inside regular expressions.

lexical (0) variables and abnormal exiting.

till the end of the lexical scope:

contexts.  This construct allows large octal ordinals beyond the
current max of 0777 to be represented.  It also allows you to specify a
character in octal which can safely be concatenated with other regex
snippets and which won't be confused with being a backreference to
a regex capture group.  See 0.

0 and 0.

uses hexadecimal when escaping non-ASCII characters, instead of octal.

0 on an entry of 0 or 0.

may change in a future version of Perl.

containers now also accept unblessed hard references to arrays
or hashes:

or on the return value of subroutines without needing to wrap them in
0 or 0:

0 when given a literal array or hash variable, but will otherwise
force scalar context on the argument.  See 0.

declaration is in scope inside that block only.  So 0
is precisely equivalent to 0.  It also works with
a version number in the declaration, as in 0,
which is its most attractive feature.  See 0.

such as 0.

in addition to the already supported 0 and 0
syntax [perl #76296].

Perl more internally consistent: a round-trip with 0 now returns 0, just like 0.

to how 0, 0, and 0 behave.

longer at risk of being clobbered by destructor code running during unwinding.
Previously, the exception was written into 0
early in the throwing process, and would be overwritten if 0 was
used internally in the destructor for an object that had to be freed
while exiting from the outer 0.  Now the exception is written
into 0 last thing before exiting the outer 0, so the code
running immediately thereafter can rely on the value in 0 correctly
corresponding to that 0.  (0 is still also set before exiting the
0, for the sake of destructors that rely on this.)

exception thrown in its scope.  Previously, the restoration of 0 upon
unwinding would overwrite any exception being thrown.  Now the exception
gets to the 0 anyway.  So 0 is safe before a 0.

of the surrounding context.  (If the surrounding context was exception
unwinding, this used to be another way to clobber the exception being
thrown.)  Previously such an exception was
sometimes emitted as a warning, and then either was
string-appended to the surrounding 0 or completely replaced the
surrounding 0, depending on whether that exception and the surrounding
0 were strings or objects.  Now, an exception in this situation is
always emitted as a warning, leaving the surrounding 0 untouched.
In addition to object destructors, this also affects any function call
run by XS code using the 0 flag.

for 0.  If an object-based warning gets the default handling
of writing to standard error, it is stringified as before with the
filename and line number appended.  But a 0 handler now
receives an object-based warning as an object, where previously it
was passed the result of stringifying the object.

addition to altering the POSIX name via 0, as Perl has done
since version 4.000.  Now system utilities that read the legacy process
name such as 0, 0, and 0 recognize the name you set when
assigning to 0.  The string you supply is truncated at 16 bytes;
this limitation is imposed by Linux.

up with their own seed-generating mechanism.  Instead, they can use 
and stash the return value for future use.  One example is a test program with
too many combinations to test comprehensively in the time available for
each run.  It can test a random subset each time and, should there be a failure,
log the seed used for that run so this can later be used to produce the same results.

function, now understand the C90 size modifiers "hh" (0), "z"
(0), and "t" (0).  Also, when compiled with a C99
compiler, Perl now understands the size modifier "j" (0)
(but this is not portable).

introspection of the current phase of the Perl interpreter.  It's explained in
detail in 0 and in
0.

equivalent to 0, which expands
internally to 0.
Perl now allows prefixing the module name with 0, with the same
semantics as 0; that is:

0 and calls 
if that method exists.

and calls  if that method exists.

0 module's 0 method whilst still loading it for debugging.

be resolved and 0 has not been loaded, Perl now loads 0
via 0 and attempts method resolution again:

legacy approach of manually loading an 0 parent class for partial
method support still works as expected:

including implementations of the 0 and
0 functions, along with related constants and a
handful of new functions.  See 0.

the package the subroutine being entered or left was compiled in.

create custom properties by defining subroutines whose names begin with
"In" or "Is".  However, Perl did not actually enforce that naming
restriction, so 0 could call foo:: if it existed.  The documented
convention is now enforced.

user-defined property.  It simply dies instead [perl #82616].

regular expression matching under Unicode rules.  One example is
0 which matches the sequence 0.

when inverted.  Because of this, Perl 5.14 does not use multi-character 0
matching in inverted character classes.

nor what 0 matches under 0.  0 isn't 0, but
Unicode says that 0 is what 0 matches under 0.  So
which one "wins"? Do you fail the match because the string has 0 or
accept it because it has an 0 followed by another 0?

but due to bugs, it mostly did not work.

differently than they behave in all other doublequote-like contexts.
Since 5.10.1, Perl has issued a deprecation warning when this happens.
Now, these literals behave the same in all doublequote-like contexts,
namely to be equivalent to 0-0, with no deprecation
warning.

conventional meaning.  They slurp whole input files; previously, this
was documented only for 0.

0 construct to represent characters in octal instead.

differently under 0 case-insensitive matching.  Doing so can lead
to unexpected results and potential security holes.  For example

matching rules (although there were several bugs with this).  Now
matching under 0 gives the same results as non-0 matching except
for those few properties where people have come to expect differences,
namely the ones where casing is an integral part of their meaning, such
as 0 and 0, both of which match
the same code points as matched by 0.
Details are in 0.

must be changed to read the new boolean parameter passed to them, which
is non-zero if case-insensitive matching is in effect and 0 otherwise.
See 0.

that the pattern is meant for matching according to Unicode rules, the way
C<\N{0 does.

interpolated into a new regular expression compiled outside a
0, and vice-versa.

the localeness of the surrounding regex, losing whatever state it
originally had.  This is considered a bug fix, but may trip up code that
has come to rely on the incorrect behaviour.

0.  Code relying on the old stringification will fail.
This is so that when new modifiers are added, such code won't
have to keep changing each time this happens, because the stringification
will automatically incorporate the new modifiers.

can avoid the whole issue by using (for perls since 5.9.5; see 0):

supported, you can use something like the following:

did not inherit pragmata (strict, warnings, etc.) if the regular expression
was compiled at run time as happens in cases like these two:

may need to be fixed to account for the correct behaviour.

now been fixed.  This fix could however potentially cause a change in
behaviour of some code.

defined in that package.

added for 5.10.0, to hide side-effects of changes to the internal storage of
hashes.  The fix drastically reduces hashes' memory overhead.

lexicals since 5.6.0, and warned for stashes and other package
variables since 5.12.0.  0 has always exposed an
implementation detail: emptying a hash by deleting all entries from it does
not make 0 false.  Hence 0 is not valid code to
determine whether an arbitrary hash is empty.  Instead, use the behaviour
of an empty 0 always returning false in scalar context.

anonymous while it was being emptied.  Consequently, any of its
subroutines referenced elsewhere would become anonymous,  showing up as
"(unknown)" in 0.  They now retain their package names such that
0 returns the original sub name if there is still a reference
to its typeglob and "foo::__ANON__" otherwise [perl #79208].

indicating that the glob is just a copy.  This allows subsequent
assignments to 0 to overwrite the glob.  The original glob,
however, is immutable.

This would result in strange behaviour in edge cases: 0
would not untie the scalar if the last thing assigned to it was a glob
(because it treated it as 0, which unties a handle).
Assignment to a glob slot (such as 0) would simply
assign 0 to 0.

has been modified to make a new immutable glob if its operand is a glob
copy.  This allows operators that make a distinction between globs and
scalars to be modified to treat only immutable globs as globs.  (0,
0 and 0 have been left as they are for compatibility's sake,
but will warn.  See 0.)

return value of 0 when that operator was passed a glob copy.  Take the
following code, for instance:

glob is made an alias to 0.  Then it is discarded.  So the second
assignment has no effect.

more detail.

"leak" into other packages.  So 0 could be used to access signals,
0 (with strict mode off) to access C's 0, etc.

such as signal handlers being wiped when modules were loaded, etc.

it).

their magic intact.  This has proven problematic for the default
scalar variable , where 0 recommends that any subroutine
that assigns to  should first localize it.  This would throw an
exception if  is aliased to a read-only variable, and could in general have
various unintentional side-effects.

only assign a new value to , but also remove all existing magic from
it as well.

multiple adjacent pairs of colons, as in 0, are now all
treated as package separators.

never been guaranteed and is subject to change in future Perl versions.

expression, or an empty list if the block was exited by 0.  Thus you
can now write:

functions:

using the 0, 0 and 0 prototypes
are parsed with higher precedence than before.  So
in the following example:

.  This happens when one of these operators is used in
an unparenthesised argument:

as numbers [perl #57706].

platforms.  It used to become "-0" on some, but "0" on others.

0 or the 0 module on CPAN.

with the 0 being treated as the start of an attribute list, ending before
the 0.  The use of 0 to mean 0 was deprecated in 5.12.0, and is
now a syntax error.  This allows future use of 0 as a new token.

using this construction, so we believe that this change will have
little impact on real-world codebases.

because of a code generator), simply avoid the error by adding a space before
the 0.

beginning of an identifier.  This means that certain accents and marks
that normally follow an alphabetic character may no longer be the first
character of an identifier.

a 0 function, newly-created threads no
longer inherit directory handles from their parent threads.  Such programs
would usually have crashed anyway [perl #75154].

child process to exit if the underlying file descriptor is still
in use by another thread.  It returns true in such cases.

children had terminated first.  However, 0 is
inherently unstable on pseudo-processes, and 0
might not get delivered if the child is blocked in a system call.

the hosting process, Perl now no longer waits for children that
have been sent a SIGTERM signal.  It is up to the parent process to
 for these children if child-cleanup processing must be
allowed to finish.  However, it is also then the responsibility of the
parent to avoid the deadlock by making sure the child process
can't be blocked on I/O.

Windows.

been fixed, standardizing on the variable names used in 0.

accidentally relying on its incorrect behaviour.

of the 0 module (which is no longer part of core Perl).  This
had the side-effect of breaking various operations on the 0 filehandle,
including /, and even simply reading from 0 after filehandles
have been flushed by a call to , backticks,  etc.

code on Windows in text mode now.  0 will (hopefully) be updated on
CPAN to automatically handle this situation [perl #28106].

its modifiers and the following word is deprecated.  For
example,  is for now still parsed
as , but will now issue a warning.

non-printable characters, but there were no restrictions (on ASCII
platforms) on what the character following the 0 could be.  Now,
a deprecation warning is raised if that character isn't an ASCII character.
Also, a deprecation warning is raised for 0 (which is the same
as simply saying 0).

(not in a bracketed character class) or a 0 is now deprecated
to allow for its future use by Perl itself.

This bundling is now deprecated for most of these files, which are now
available from CPAN.  The affected files now warn when run, if they were
installed as part of the core.

The warning is modelled on that supplied by 0 for
deprecated-in-core 0 libraries.  It points to the specific CPAN
distribution that contains the 0 libraries.  The CPAN versions, of
course, do not generate the warning.

Perl version 5.12.0.  This version of Perl (5.14) now also emits a warning
when assigning to 0 in list context.  This fixes an oversight in 5.12.0.

were always enclosed in parentheses, and as a result you could sometimes omit
parentheses around them:

parentheses like this:

are not part of expression syntax.  They are part of the statement
syntax, with the 0 statement wanting literal parentheses.
The synthetic parentheses that a 0 expression acquired were only
intended to be treated as part of expression syntax.

See 0 for more
explanation.

a warning.  This is to allow future use of 0 in new operators.
The match-once functionality is still available as 0.

acts on a filehandle if the scalar happens to hold a typeglob.

there is currently no way to tie the scalar itself when it holds
a typeglob, and no way to untie a scalar that has had a typeglob
assigned to it.

function is used on a handle without an explicit 0.

0.
This feature will be removed in Perl 5.16.  Instead use the CPAN module
0, which provides improved functionality.

future release, and should be installed from CPAN instead.  Distributions
on CPAN that require this should add it to their prerequisites.  The
core version of these module now issues a deprecation warning.

larger system, then you should carefully consider the repercussions of
core module deprecations.  You may want to consider shipping your default
build of Perl with a package for the deprecated module that
installs into 0 or 0 Perl library directories.  This will
inhibit the deprecation warnings.

to provide deprecation warnings specific to your packaging system
or distribution of Perl, consistent with how your packaging system
or distribution manages a staged transition from a release where the
installation of a single package provides the given functionality, to
a later release where the system administrator needs to know to install
multiple packages to get that same functionality.

in question from CPAN.  To install the latest version of it by role
rather than by name, just install 0.

of 0, as 0 offers significantly
improved profiling and reporting.

This should give a few percent speed increase, and eliminates nearly
all the speed penalty caused by the introduction of "safe signals"
in 5.8.0.  Signals should still be dispatched within the same
statement as they were previously.  If this does 0 happen, or
if you find it possible to create uninterruptible loops, this is a
bug, and reports are encouraged of how to recreate such issues.

implicit 0).  This change makes  5% faster than 0
on non-threaded perls, and 25% faster on threaded ones.

is used heavily by the regexp engine) was substantially refactored and
optimised -- and its documentation much improved as a free bonus.

the regex to utf8 is necessary but this isn't known when the compilation begins.

0 could end up allocating a lot more memory than needed in a
inefficient way.

when appending to a string, has been taught to round up the memory
it requests to a certain geometric progression, making it much faster on
certain platforms and configurations.  On Win32, it's now about 100 times
faster.

an interpreter struct, thread- and interpreter-local 0 variables
were defined as macros that called accessor functions (returning the
address of the value) outside the Perl core.  The intent was to allow
members within the interpreter struct to change size without breaking
binary compatibility, so that bug fixes could be merged to a maintenance
branch that necessitated such a size change.  This mechanism was redundant
and penalised well-behaved code.  It has been removed.

can under some circumstances take O(I<N0) time to free, where
0 is the number of references.  The circumstances in which this can happen
have been reduced [perl #75254]

0 assignments caused a bug and was disabled in Perl 5.12.0.

enough space for four entries.  Now this allocation is done on demand when
the subroutine is called [perl #72416].

on some systems will cause 0 to become cache-aligned.  To avoid
this memory saving causing a slowdown elsewhere, boolean use of 0
now calls 0 instead (which is equivalent), so while the fill
data when actually required are now calculated on demand, cases when
this needs to be done should be rare.

the NV slot has swapped location with STASH and MAGIC.  As all access to
SV members is via macros, this should be completely transparent.  This
change allows the space saving for PVHVs documented above, and may reduce
the memory allocation needed for PVIVs on some architectures.

they actually use, saving some space.

body they actually use, saving some space.

the typeglob backing it.  This saves about 200 bytes for every package that
uses Exporter but doesn't use this functionality.

per referent has been optimised to reduce the storage required.  In this
case it saves the equivalent of one small Perl array per referent.

core.  It has now been moved to an XS module to reduce overhead for
programs that do not use 0 or 0.

allocations, resulting in noticeably smaller object code.  Additionally,
many thread context checks have been deferred so they're done only
as needed (although this is only possible for non-debugging builds).

the 0 op would remain, resulting in a runtime op dispatch of
0, 0, etc.

the last 0 op so the peephole optimizer now eliminates the first of
a pair of 0 ops except when the first carries a label, since labels
must not be eliminated by the optimizer, and label usage isn't conclusively known
at compile time.

subset of YAML sufficient for reading and writing 0 and 0 files
included with CPAN distributions or generated by the module installation
toolchain.  It should not be used for any other general YAML parsing or
generation task.

provides a standard library to read, interpret and write CPAN distribution
metadata files (like 0 and 0 that describe a
distribution, its contents, and the requirements for building it and
installing it.  The latest CPAN distribution metadata specification is
included as 0 and notes on changes in the specification
over time are given in 0.

small, simple HTTP/1.1 client designed for simple GET requests and file
mirroring.  It has been added so that 0 and 0 can
"bootstrap" HTTP access to CPAN using pure Perl without relying on external
binaries like 0 or 0.

clients to read 0 files in CPAN distributions.

package and POD information from Perl module files.  It is a standalone module
based on 0 for use by other module installation
toolchain components.  0 has been deprecated in
favor of this module instead.

operating system names (like "dragonfly" or "MSWin32") to more generic types
with standardized names (like "Unix" or "Windows").  It has been refactored
out of 0 and 0 and consolidates such mappings into
a single location for easier maintenance.

upgrade.  See below for details.

module.  It provides a standard library to model and manipulates module
prerequisites and version constraints defined in 0.

0 from changes to 0; a fix to the tests when run in core
Perl; support for TZ files; a modification for the lzma
logic to favour 0; and a fix
for an issue with NetBSD-current and its new 0
executable.

close only filehandles they themselves opened.

tarballs without world-writable files on Windows, allowing those
archives to be uploaded to CPAN.

the contents of files in a tar archive.

outside the octet range or compiled in a 0 scope.

reduction in functionality.

0 flag as "DREFed".

[perl #80632].

change of package relative to the previous nextstate, or a change of
0 or other state and a label.  The label was previously emitted
first, but is now emitted last (5.12.1).

(5.12.3).

pattern match against implicit 0 as it was fixed in [perl #20444].

(as permitted under the 0 pragma) has also been fixed [perl #33752].

overrides and avoids using bogus 0.  To provide backtraces,
Carp relies on particular behaviour of the  builtin.
0 now detects if other code has overridden this with an
incomplete implementation, and modifies its backtrace accordingly.
Previously incomplete overrides would cause incorrect values in
backtraces (best case), or obscure fatal errors (worst case).

overriding  incorrectly (5.12.2).

load its Unicode tables, so as to avoid the "BEGIN not safe after
errors" error that ensue if there has been a syntax error
[perl #82854].

 is now random and the handling of
newlines embedded in header values has been improved.

[CPAN RT #67525].

resolves 0
and 0, both
of which related to failures to install distributions that use
0 (5.12.2).

core module dependency.  This has been fixed.

has been fixed [perl #73604].

cause the stack to change [perl #74170].

[perl #72332].

Both 0 and 0 behave as before and start
the profiler.

version of Perl.  We strongly recommend that you install and use
0 instead, as it offers significantly improved
profiling and reporting.

descriptions for messages that share their descriptions with other
messages.

[February 2011])

produces weird error messages for unsuccessful method calls on classes that
inherit from 0 [perl #84358].

always been treated: in cases when it was disallowed, all 66 are
disallowed, and in cases where it warned, all 66 warn.

headers, some constants that weren't actually error numbers have been exposed
by 0.  This has been fixed [perl #77416].

can now  for missing constants, or generate a complete 0
subroutine in XS, allowing simplification of many modules that use it
(0, 0, 0, 0, 0,
0).

constants onto the package's 0.

be escaped.  On Windows, it no longer
adds an extra 0 to file names
returned when the pattern is a relative glob with a drive specification,
like 0 [perl #71712].

Dragonfly BSD for the 0 and 0 schemes.

0 are no longer generated [perl #71710].

recognized as a delimiter in native filespecs; caret-escaped delimiters are
recognized for better handling of extended filespecs;  returns
an empty directory rather than the current directory if the input directory
name is empty; and  properly handles Unix-style input (5.12.2).

by the superuser.

recursively locking hashes that have undefined values [perl #74280].

as the documentation has always claimed.

objects (and objects in derived classes) to be removed from an 0 set
even if the underlying file descriptor is closed or invalid.

consisting of the single character "0" used to be omitted (CPAN RT #62961).

condition to be distinguished from a child process that exited with a
non-zero status [perl #72016].

documented, so duplicating 0 in a child process using its file
descriptor now works [perl #76474].

0 when
working with tainted values (CPAN RT #40727).

messages are not suppressed (CPAN RT #34182).

coefficients [perl #77640].

[perl #73534].

base64 strings.

the base64 scheme for "URL applications".

0 has been deprecated and 0 now
relies on the 0 pragma directly.  0 has
been deprecated in favor of a standalone copy called 0.
0 has been deprecated in favor of 0.

in accordance with version 2 of the CPAN distribution metadata specification,
0.  The older format 0 and 0 files are
still generated.

the 0 module.  That module never existed in core.  The scripts
generating 0 confused it with 0, which actually
is a core module as of Perl 5.8.7.

into overloaded classes [perl #71998].

0 and 0, which are now part of the Perl core.

has data to read [perl #78716].

belonging to a pluggable engine.  Now it croaks instead.

 (5.12.1).

backtrace [perl #72340].

correctly.  The 0 minor version
number changed as a result, meaning that
0 users who set 0 to a 0 value
will see errors (see 0 for more details).

during freezing [perl #80074].

implicit  added to them.

semaphores: 0 and 0, and 0.

tailoring of CJK Unified Ideographs in the order of CLDR's big5han ordering.

tailoring of CJK Unified Ideographs in the order of CLDR's gb2312han ordering.

(CJK Unified Ideographs) in the JIS X 0208 order.

in the order of CLDR's Korean ordering.

tailoring of CJK Unified Ideographs in the order of CLDR's pinyin ordering.

tailoring of CJK Unified Ideographs in the order of CLDR's stroke ordering.

module to the XS version.

returns the numeric value of the string passed it or 0 if the string
in its entirety has no "safe" numeric value.  (For more detail, and for the
definition of "safe", see 0.)

excepting that, just as with Perl 5.14, the code point at U+1F514 has no name.

decompositions are always output without requiring 0
to be installed.

and U+2B740 to U+2B81D are now properly handled.

corrected ones.

of a code point that hasn't been assigned another one.

of a code point that hasn't been assigned to another one.

work when exported (5.12.1).

packages using 0.  See 0 for more information.

0.  The result was that all tied hashes interacted with the
local symbol table.

to the constructor, querying the special key 0 failed to
identify objects connected to the local symbol table.

Win32::, Win32::.

have been corrected.

been removed from the core distribution, and if needed should be installed
from CPAN instead.

implementation of 0 shipped with 5.12.0 did not correctly issue the
warning that it was to be removed from core.

0 distributed with Perl (5.12.1).

maintenance branch: 0, 0, 0.

split mostly from the NOTES section of the 0 manpage.

modules due to a bug in the script that generates the list.  This has been
fixed [perl #74332] (5.12.1).

between EBCDIC and Latin1/ASCII.  The table was the inverse of the one
it describes, though the code that used the table worked correctly for
the specific example given.

pod have been altered to print out leading zeros to make all values
the same length.

and otherwise tweak the way Perl handles upper-, lower- and other-case
conversions on Unicode data, and how to provide scoped changes to alter
one's own code's behaviour without stomping on anybody else's.

(5.12.2).

character escapes.

has been clarified (5.12.2).

maintenance branches (5.12.1).

along with definitions of terms like "deprecation" (5.12.2).

0 was simply wrong in stating that
get-magic is not processed.  It has been corrected.

introduced after Perl 5.000 notes the first version in which it is
available.  0 also has a new section for deprecated variables to
note when they were removed.

0 affects formats.

is now much more straightforward and clear.

development process and submitting patches to Perl.  The technical content
has been moved to several new documents, 0, 0,
0, and 0.  This technical content has
been only lightly edited.

document is just a how-to on using git with the Perl source code.
Any other content that used to be in perlrepository has been moved
to 0.

0.

including warnings and fatal error messages.  For the complete list of
diagnostic messages, see 0.

handler is called, if the subroutine is a closure [perl #68560].

expression that contains a call to a user-defined character property
function, meaning 0 or 0.
See 0 and 0.

typeglob that is being freed creates a new typeglob entry containing an
object with a destructor that creates a new entry containing an object etc.

code supplied by an extension violates the
parser's API in a detectable way.

pipe is about to be closed.

mutually exclusive modifiers repeated.

exclusive modifiers.

deprecated in order to reserve its use for Perl itself in a future release.

on a Unicode surrogate or a non-Unicode character now triggers this
warning.

0 error has now been assigned the "misc" category, so that
0 will suppress it [perl #73712].

character outside the byte range if 0 is a byte-sized handle.

these more helpful messages [perl #73754]:

perl (%d)

(%d)

assigned to a variable in a condition is now withheld if the constant is
actually a subroutine or one generated by 0, since the value
of the constant may not be known at the time the program is written
[perl #77762].

 functions were implemented on a given platform, they would
all die with the message "Unsupported socket function 'gethostent' called",
with analogous messages for getnet*() and getserv*().  This has been
corrected.

through has been changed to include any literal "{" following the
two-character escape.  For example, "\q{" is now emitted instead of "\q".

if the REPLY-TO and REPLYTO variables are empty.

resulting in dropped mail; it now includes that header.

perlbug@perl.org does not accept email with a return-path that does
not resolve.  So the user's address is now passed to sendmail so it's
less likely to get stuck in a mail queue somewhere [perl #82996].

address it guesses for them (5.12.2).

and 0 options (5.12.2).

per forked process.

files  in a tar archive.  It comes with 0.

above.

under 0 and 0 rather than immediately below
0.

"ldflags_nolargefiles" values in 0 and 0 are now
set correctly.

separation.

default.

build.  The special-case handling for this situation got broken in Perl
5.11.0, and has now been repaired.

to the larger of 8192 bytes and your local BUFSIZ.  Benchmarks show that doubling
this decade-old default increases read and write performance by around
25% to 50% when using the default layers of perlio on top of unix.  To choose
a non-default size, such as to get back the old value or to obtain an even
larger value, configure with:

your page size.

with 0 has been fixed (5.12.2).

as 0 (5.12.2).

the Perl distribution.  It was officially discontinued in version 5.12.0.
It had not worked for years before that.

Perl distribution.  It was officially discontinued in an earlier version.

suite (5.12.2).

This solves most rebase errors, especially when updating on core DLL's.
See 0
for more information.

Perl now skips the 0 check for versions 7 and higher and
assumes ELF (5.12.1).

(5.12.1).

IRIX systems [perl #32380].

, , setrgid(,) and  functions, so Perl
would pretend they did not exist.

higher, as they have been fixed [perl #72990].

default config), it would work up to the installation; however, once
installed, it would be unable to find 0.  Path handling is now
treated as in the other BSD dialects.

default.

and as such can release memory back to the OS; however, Perl's use of
this malloc causes a substantial slowdown, so we now default to using
Perl's malloc instead [perl #75742].

[perl #78132] (5.12.3).

these have been fixed [perl #73630] (5.12.3).

configure.com hit the DCL symbol length limit of 1K.  We now work within
this limit when assembling the list of extensions in the core build (5.12.1).

the most common path for creating files from Perl became 0,
which has always explicitly used 0 as the permission mask.  This prevents
inheriting permissions from RMS defaults and ACLs, so to avoid that problem,
we now pass 0 to .  In theVMS CRTL, 0 has a special
meaning over and above intersecting with the current umask; specifically, it
allows Unix syscalls to preserve native default permissions (5.12.3).

and in extensions is now by default done by the C compiler rather than by
xsubpp (which could only do so for generated symbols in XS code).  You can
reenable xsubpp's symbol shortening by configuring with -Uuseshortenedsymbols,
but you'll have some work to do to get the core sources to compile.

opened for write by the 0 has been fixed (5.12.2).

0, above.

set in 0.  This improves portability when compiling
XS extensions using new compilers, but for a Perl compiled with old 32-bit
compilers.

mingw64 compiler from 0 [perl #73754].

0, 0, 0 and 0 values
in 0 and 0 were not previously being set
correctly because, with that compiler, the include and lib directories
are not immediately below 0 (5.12.2).

0 is in the PATH, due to a 0 fix.

complete.  See 0 or 0 for more details.

 at all, has been removed.  Perl supplies its own 
implementation for Windows, and the political situation that required
this part of the distribution to sometimes be omitted is long gone.

by calling the new function , and free them with
.  This will ensure compatibility with any future
changes to the internals of the 0 structure layout, and that
it is correctly allocated and initialised.

expressions.  These functions are meant to be used by XS code invoked
during Perl parsing, in a recursive-descent manner, to allow modules to
augment the standard Perl syntax.

parses a sequence of statements, up to closing brace or EOF.

parses a complete Perl statement, including optional label.

parses a statement without a label.

parses a code block.

parses a statement label, separate from statements.

L<0,
L<0, and
L<0
parse expressions at various precedence levels.

added.  See 0, 0, 0,
0, and 0 in 0 for details.

structure that Perl uses for 0.  See the functions beginning with
0 in 0.

.  See 0 for details.

implemented in XS or in Perl) so that nominated XS code will be called
at compile time (specifically as part of op checking) to change the op
tree of that subroutine.  The compile-time check function (supplied by
the extension module) can implement argument processing that can't be
expressed as a prototype, generate customised compile-time warnings,
perform constant folding for a pure function, inline a subroutine
consisting of sufficiently simple ops, replace the whole call with a
custom op, and so on.  This was previously all possible by hooking the
0 op checker, but the new mechanism makes it easy to tie the
hook to a specific subroutine.  See 0.

0 op checking have been separated out and exposed in the API.

function and the 0 structure.  This will make it easier to add new
properties of custom ops in the future.  Two new properties have been added
already, 0 and 0.

introspection mechanisms to work with custom ops
that aren't BASEOPs.  0 is a pointer to
a function that will be called for ops of this
type from 0.

detail.

supported but discouraged.

mechanism at compile time, using the new 0
function.  See 0.

0 is now available to hook into the optimizer recursing into
side-chains of the optree.

macros are equivalent to their non-0 variants, except that they ignore
get-magic.  Those ending in 0 allow one to specify whether
get-magic is processed.

been replaced with wrappers around the new functions.

API.  See 0,
0, and
0 in 0.

constructs the execution-order op chain, has been added to the API.

functions have been added to the API.

name.  The first effective name can be accessed via the 0 macro,
which is now the recommended name to use in MRO linearisations (0
being a fallback if there is no 0).

0.  These two functions are 0 part of the API.

L<0
functions have been added to the API.
They allow extension authors to find and remove magic attached to
scalars based on both the magic type and the magic virtual table, similar to how
 attaches magic of a certain type and with a given virtual table
to a scalar.  This eliminates the need for extensions to walk the list of
0 pointers of an 0 to find the magic that belongs to them.

or dynamic.

0.

incantation to use for static inline functions, if the C compiler supports
C99-style static inline.  If it doesn't, it'll give a plain 0.

inline functions.

dump all characters above ASCII in hexadecimal.  Before, one could get all
characters as hexadecimal or the Latin1 non-ASCII as octal.

but are considered experimental.

backwards compatibility has been removed.  Its use was always discouraged,
and MakeMaker contains a more specific escape hatch:

conventions (and really should be completely obsolete by now).

major releases), XS modules compiled for previous versions of Perl will no
longer work.  They need to be recompiled against the new Perl.

are recompiled and to prevent users from accidentally loading modules
compiled for old perls into newer perls.  That macro, which is called when
loading every newly compiled extension, compares the API version of the
running perl with the version a module has been compiled for and raises an
exception if they don't match.

from 0 to 0, to insulate the user from
implementation details.

the core.  (Neither an unpacked CPAN nor Google's codesearch finds any other
references to it.)

assignment to those two macros.

and CVs, which will require complete control over assignment to the
0 slot.

reference-counted.  To ensure consistent behaviour, direct assignment to
it, for example 0 is now a compile-time error.  A new macro,
0 has been introduced to run this operation
safely.  Note that modification of this field is not part of the public
API, regardless of this new macro (and despite its being listed in this section).

has been added to replace assignment to .  This is to ensure
that backreferences are handled properly.  These macros are not part of the
API.

result, the  constructor function no longer takes a parameter
stating what label is to go in the state op.

number as a parameter.

 have changed.  This is a result of Perl's now allowing
internal storage and manipulation of code points that are problematic
in some situations.  Hence, the default actions for these functions has
been complemented to allow these code points.  The new flags are
documented in 0.  Code that requires the problematic code
points to be rejected needs to change to use the new flags.  Some flag
names are retained for backward source compatibility, though they do
nothing, as they are now the default.  However the flags
0, 0, 0, and
0 have been removed, as they stem from a
fundamentally broken model of how the Unicode non-character code points
should be handled, which is now described in
0.  See also the Unicode section
under 0.

now generates a deprecation warning, and it will be removed in a future
release.

that nothing on CPAN is using it, so this should have zero impact.

to bind correctly to lexicals in the enclosing scope.  It's not possible to
fix this problem within the constraints of its parameters and return value.

its design was insufficient for reliably getting the lexical 0 at
run-time.

instead.  They directly return the right SV
representing 0, whether it's
lexical or dynamic.

which was removed in Perl 5.8.  Nowadays these macros do exactly nothing, so
they shouldn't be used anymore.

extensions defining 0 must be updated now.

has changed how it identifies the target stack frame.  This now uses
a separate variable 0, where previously it relied on
the 0 pointer in the 0 context frame that
has nominally just been discarded.  This change means that code running
during various stages of Perl-level unwinding no longer needs to take
care to avoid destroying the ghost frame.

reduction of memory usage of about 10%.  In particular, the memory used by
the scope stack to record each active lexical variable has been halved.

0 allocated memory from the same arena system as
0 bodies and 0s, with freed memory remaining bound to those arenas
until interpreter exit.  Now it allocates memory from arenas private to the
specific pointer table, and that memory is returned to the system when
0 is called.  Additionally, allocation and release are
both less CPU intensive.

noop but should still be used to ensure past and future compatibility.

0, and 0.  The old names are still available as
macros.

have been merged.  The implementation functions  and
, never part of the public API, have been merged and
moved to a static function in 0.  This shrinks the Perl binary
slightly, and should not affect any code outside the core (unless it is
relying on the order of side-effects when 0 is passed a 0 of
values).

causes the glob to be corrupted when the filehandle is printed to.  This would
cause Perl to crash whenever the glob's contents were accessed
[perl #77492].

handler.  Now it just leaks memory [perl #75556].

"closed" and "unopened" warnings categories were both enabled.  Now only
0 is necessary to trigger these warnings, as
had always been the intention.

it no longer enables crlf layers lower in the stack so as to avoid
unexpected results [perl #38456].

open the file, then 0 it), instead of simply leaving off the top
layer [perl #80764].

opening a file.  For example
this:

release [perl #82484].

0 and similar expressions
[perl #72998] (5.12.1).

fixing #74484.

[perl #2353].

[perl #39233].

UTF-8 data has been fixed [perl #75680] (5.12.2).

0 sometimes to be ignored has been removed.

same as 0, incorrectly matching a NULL character.  It also gave
incorrect warnings that the 0 and 0 were ignored.  Now 0 is the
same as 0 and gives legitimate warnings that 0 and 0 are
unrecognized escape sequences, passed-through.

(0) that is in the same scope will no longer cause match variables
to have the wrong values on subsequent iterations.  This can happen when an
array or hash subscript is interpolated in the right-hand side, as in
0 [perl #19078].

0xFF) used not to match themselves, or used to match both a character class
and its complement, have been fixed.  For instance, U+00E2 could match both
0 and 0 [perl #78464] [perl #18281] [perl #60156].

that happened to match continuation bytes in the former's UTF8
representation (like 0) would cause erroneous
warnings [perl #70998].

"foo" from matching 0 [perl #78356].

incorrect match failure in a global match (for example, 0)
[perl #68564].

0 quantifier to fail when it should have matched [perl #79152].

0 now works much more sanely when the pattern or target
string is internally encoded in UTF8.  Previously, under these
conditions the localeness was completely lost.  Now, code points
above 255 are treated as Unicode, but code points between 0 and 255
are treated using the current locale rules, regardless of whether
the pattern or the string is encoded in UTF8.  The few case-insensitive
matches that cross the 255/256 boundary are not allowed.  For
example, 0xFF does not caselessly match the character at 0x178,
LATIN CAPITAL LETTER Y WITH DIAERESIS, because 0xFF may not be LATIN
SMALL LETTER Y in the current locale, and Perl has no way of knowing
if that character even exists in the locale, much less what code
point it is.

branch has more sets of capturing parentheses than any other branch.  This
was fixed in Perl 5.10.1 for the case of a single branch, but that fix did
not take multiple branches into account [perl #84746].

regular expressions that prevented the code block in
0 from seeing the 0 sometimes
[perl #84294].

[perl #74114] (5.12.1).

the label to be associated also with the first statement inside the eval
[perl #74290] (5.12.1).

pragmata (like 0) [perl #70075] (5.12.2).

identically to 0.  Previously, 0 in a 0 block
was erroneously executing the 0 and
0 behaviour, which only 0 was documented to
provide [perl #69050].

 result in 0 set to 0 has been
fixed.  0 will now be 0 [perl #85508] (5.12.2).

0 if its argument is undefined.  An optimisation introduced in Perl
5.12.0 to make 0 faster when used as a boolean did not take
this into account, causing 0 (and 0 when
0 is undefined) to be an error, which it should be so in strict
mode only [perl #81750].

within a 0 block no longer causes the interpreter to crash
[perl #70614].

compiled [perl #83364].

such as U+387 [perl #74022].

(like 0) stopped working in 5.12.0, but has now been fixed
[perl #78634].

to be stringified, even if the hash was tied [perl #79178].

is no longer treated as a constant [perl #63540].

used to mean the same thing as
0 if any attributes were present [perl #68658].

the "Use of uninitialized value in numeric gt" warning when 0 is
undefined (since it is not part of the  expression, but the operand
of the 0) [perl #72090].

opposed to an arbitrary expression) would crash if the array did not exist.
Usually the array would be autovivified during compilation, but typeglob
manipulation could remove it, as in these two cases which used to crash:

followed by other options [perl #72434].

0 [perl #80622].  This was due to a bug in the Perl core,
not in 0 itself.

resolution orders, or lists of parent classes; aka "isa" caches) to make
method lookup faster (so 0 arrays would not have to be searched
repeatedly).  Unfortunately, this brought with it quite a few bugs.  Almost
all of these have been fixed now, along with a few MRO-related bugs that
existed before 5.10.0:

the "isa" caches were not reset or otherwise ended up listing the wrong
classes.  These have been fixed.

0) [perl #77238]

caches.

long as the glob assigned to were named 0 or the glob on either side of
the assignment contained a subroutine.

updated properly when packages are deleted or removed from the 0 of
other classes.  This allows many packages to be created and deleted without
causing a memory leak [perl #75176].

fixed:

tables (stashes), typeglobs, and subroutines.  This has the effect that
various edge cases related to deleting stashes or stash entries (for example,
<%FOO:: = ()>), and complex typeglob or code-reference aliasing, will no
longer crash the interpreter.

overwriting the glob with a scalar [perl #1804] [perl #77508].

[perl #21469].  This
means the following code will no longer crash:

works correctly, and a PVLV can hold a glob.  This would happen when a
nonexistent hash or array element was passed to a subroutine:

of a tied array or hash [perl #36051].

occur if the glob holding the global variable in question had been detached
from its original stash by, for example, 0.  This has
been fixed by disabling the reporting of variable names in those
cases.

destructors called as a result would be able to see the typeglob in an
inconsistent state, containing freed entries, which could result in a
crash.  This would affect code like this:

also means that destructors can vivify entries in the glob.  So Perl tries
again and, if the entries are re-created too many times, dies with a
"panic: gp_free ..." error message.

referenced elsewhere, the subroutine is renamed to 0 in the same
package, unless the package has been undefined, in which case the 0
package is used.  This could cause packages to be sometimes autovivified,
such as if the package had been deleted.  Now this no longer occurs.
The 0 package is also now used when the original package is
no longer attached to the symbol table.  This avoids memory leaks in some
cases [perl #87664].

0 can now be accessed with a fully qualified name.

this release.  Under 0 (which is
automatically selected by 0 and above), the internal
storage format of a string no longer affects the external semantics.
[perl #58182].

functions require utf8-encoded strings to operate.  The CPAN module
0 has been written to replace this feature without its
drawbacks, and the feature is scheduled to be removed in 5.16.

results depending on whether a string is encoded in UTF-8.  See
0.

Previously they were mostly considered illegal, except that in some
place only one of the 66 of them was known.  The Unicode Standard
considers them all legal, but forbids their "open interchange".
This is part of the change to allow internal use of any code
point (see 0).  Together, these changes resolve
[perl #38722], [perl #51918], [perl #51936], and [perl #63446].

characters that match multiple characters now works much more as
intended.  For example

What hasn't been fixed are the places where the pattern contains the
multiple characters, but the characters are split up by other things,
such as in

Standard, which asks that the matching be made upon the NFD
(Normalization Form Decomposed) of the text.  However, as of this
writing (April 2010), the Unicode Standard is currently in flux about
what they will recommend doing with regard in such scenarios.  It may be
that they will throw out the whole concept of multi-character matches.
[perl #71736].

a single 0 to be parsed incorrectly [perl #74978] (5.12.1).

[perl #73246].

is encoded internally in UTF8 no longer causes panics [perl #75898].

returned by substr, causing 0 to give
wrong answers.  With 0 set to -1, it would also produce
a "panic" error message [perl #77692].

variables.  What formerly happened was that most ops checked their
arguments for overloading 0 checking for magic, so for example
an overloaded object returned by a tied array access would usually be
treated as not overloaded [RT #57012].

too many or too few times have been fixed:

many times.

scalar happened to hold a typeglob (if a typeglob was the last thing
returned from or assigned to a tied scalar) [perl #77498].

reference already (such as from a previous FETCH) [perl #72144].

by 0 are respected by method calls) [perl #78400].

FETCH/STORE at all [perl #43789] (5.12.2).

tied scalar was used for both operands and returned a different value for
each FETCH.  For instance, if 0 returned 2 the first time and 3 the
second, then 0 would evaluate to 1.5.  This has been fixed
[perl #87708].

arguments [perl #75716].

overloading no longer cause memory corruption or crashes [perl #77084].

arguments.

overloaded.

" filehandle" from 5.6 onwards, something like  did
not handle overloading, even if 0 was an overloaded object.  This
was contrary to the documentation for 0, and meant that 
could not be used as a general overloaded iterator operator.

[perl #71286].

See 0 above [perl #76138].

an object to last longer than it should, or cause a crash if a tied
variable were freed from within a tie method.  These have been fixed
[perl #81230].

accessing the tied variable through a weak reference [perl #86328].

process ID to kill [perl #75812].

it is correctly untainted if an autoloaded method is called and the method
name was not tainted.

already die for arbitrary expressions, but not for simple scalars
[perl #82250].

when the argument is tainted.  This has been broken since perl 5.8.9
[perl #87336].

to the lines of the main program.  In the past, this sometimes worked and
sometimes did not, depending on the order in which things happened to be
arranged in memory [perl #71806].

0 has been fixed (5.12.2).

if these variables already have values when 0 is assigned to [perl #72422].

of lines of code () that the debugger (or any debugging or
profiling module) uses.  In threaded builds, they were not being updated at
all.  In non-threaded builds, the line number was ignored, so any change to
the existing line number would cause the lines to be misnumbered
[perl #79442].

frames in the parent when creating a child thread [perl #73086].

fixed [perl #77352].

crash, because the handles were not cloned, but simply passed to the new
thread, resulting in a double free.

and on systems that have a 0 function.  On other
systems, new threads simply do not inherit directory
handles from their parent threads [perl #75154].

separator), had the wrong reference count in child threads.

(and any implicit close, such as on thread exit) no longer blocks.

thread but then discovered to be orphaned (that is, their owners
are 0 cloned).  This eliminates several "scalars leaked"
warnings when joining threads.

had been broken since version 5.10.0 [perl #75656] (5.12.3).

the scope that called 0 and other scopes higher up that had the
same file name [perl #68712].

of 0 to leak out of the sort.  Taking a reference to 0 within the
sorting routine could cause a crash [perl #72334].

subroutine [perl #76026].

[perl #23790].

distance [perl #78844].

closure) now results in a "Closure prototype called" error message instead
of a crash [perl #68560].

string 0 no longer causes the variable to become writable
[perl #19135].

they were blocked before by 0 [perl #82040].

double-frees.  Now fixed [perl #76248].

0, 0,
and 0 could, when used in combination
with lvalues, result in leaking the scalar value they operate on, and cause its
destruction to happen too late.  This has now been fixed.

leaks when used on references.  This has now been fixed.

large lists [perl #48004].

[perl #69050].

contained characters beyond the octet range and the scalar assigned to
happened to be encoded as UTF8 internally [perl #72246].

0 isn't present [perl #75464] (5.12.2).

returns the "same thing" as before or random memory.

return garbage and/or freed values:

pointers to freed SVs, meaning Perl users could see corrupted state
during destruction.

the GV itself.  This makes sure that there are no dangling refs or
corrupted state during destruction.

arrays.  Hashes have not been fixed yet [perl #44225].

crash [perl #78674].

the stack, resulting in strange behaviour.  For instance,

[perl #75082].

taints 0 now if its arguments are tainted [perl #79138].

Filetests don't always expect an op on the stack, so we now use
TOPs only if we're sure that we're not 0ing the 0 filehandle.
This is indicated by 0 (as checked in ck_ftst) [perl #74542]
(5.12.1).

fixing a potential crash.   would crash because the third item
on the stack wasn't the regular expression it expected.  0 would return both the unpacked result and the checksum on the stack,
as would 0 [perl #73814] (5.12.2).

[perl #20661].

false into true [perl #45133].

resulting in loss of precision on 64-bit platforms [perl #77456].

[perl #78632].

cause 0 to confuse the order of its arguments, making it
treat the string as the precision and vice-versa [perl #83194].

syntax error on the last line of the file if it lacked a final semicolon
[perl #74006] (5.12.1).

there is a syntax error and no 0 flag, and never set it if the
0 flag is present [perl #3719].

if called via the multicall interface from within those very subroutines.
This affects modules like 0.  Calling one of its functions with an
active subroutine as the first argument could cause a crash [perl #78070].

downgrading the SV, to avoid warnings about wide characters [perl #72398].

[perl #72684].

source string) if the flags passed to it do not include SV_GMAGIC.  So it
now matches the documentation.

0 [perl #73520].

(5.12.1).

due to their arguments being swapped [perl #72704] (5.12.1).

(5.12.2).

0 is called from an XS destructor has been fixed
(5.12.2).

from earlier versions of Perl or which affect widely-used CPAN modules.

(typically introduced by 0 or implicitly by 0).  The variable
that gets set for each iteration is the package variable 0, not the
lexical 0.

take a block as their first argument, like

interrupted by a signal.

upstream and will hopefully appear on CPAN soon.

some tests in the 0 distribution on CPAN to
fail. (Specifically, 0 tests 5 and 21; 0
tests 6 and 15; 0 tests 5, 13, 21, and 29; and
0 tests 6, 15, and 23 in version
1.00 of that distribution now fail.)

implementation of 0: previous timer values would be cleared
if a timer expired but not if the timer was reset before expiring.  HP
OpenVMS Engineering have corrected the problem and will release a patch
in due course (Quix case # QXCM1001115136).

get to before the release; please watch CPAN for updates.

previously you could use them only on hashes.  See 0 for details.
This is actually a change introduced in perl 5.12.0, but it was missed from
that release's 0.

In void context it now produces a "Useless use of split" warning.
This was also a perl 5.12.0 change that missed the perldelta.

contributor/maintainer to several core Perl toolchain modules, passed
away on September 18, 2010 after a battle with lung cancer.  The community
was richer for his involvement.  He will be missed.

Perl 5.12.0 and contains nearly 550,000 lines of changes across nearly
3,000 files from 150 authors and committers.

community of users and developers.  The following people are known to
have contributed the improvements that became Perl 5.14.0:

Alastair Douglas, Alexander Alekseev, Alexander Hartmaier, Alexandr
Ciornii, Alex Davies, Alex Vandiver, Ali Polatel, Allen Smith, Andreas
König, Andrew Rodland, Andy Armstrong, Andy Dougherty, Aristotle
Pagaltzis, Arkturuz, Arvan, A. Sinan Unur, Ben Morrow, Bo Lindbergh,
Boris Ratner, Brad Gilbert, Bram, brian d foy, Brian Phillips, Casey
West, Charles Bailey, Chas. Owens, Chip Salzenberg, Chris 'BinGOs'
Williams, chromatic, Craig A. Berry, Curtis Jewell, Dagfinn Ilmari
Mannsåker, Dan Dascalescu, Dave Rolsky, David Caldwell, David Cantrell,
David Golden, David Leadbeater, David Mitchell, David Wheeler, Eric
Brine, Father Chrysostomos, Fingle Nark, Florian Ragwitz, Frank Wiegand,
Franz Fasching, Gene Sullivan, George Greer, Gerard Goossen, Gisle Aas,
Goro Fuji, Grant McLean, gregor herrmann, H.Merijn Brand, Hongwen Qiu,
Hugo van der Sanden, Ian Goodacre, James E Keenan, James Mastros, Jan
Dubois, Jay Hannah, Jerry D. Hedden, Jesse Vincent, Jim Cromie, Jirka
Hruška, John Peacock, Joshua ben Jore, Joshua Pritikin, Karl Williamson,
Kevin Ryde, kmx, Lars Dɪᴇᴄᴋᴏᴡ 迪拉斯, Larwan Berke, Leon Brocard, Leon
Timmermans, Lubomir Rintel, Lukas Mai, Maik Hentsche, Marty Pauley,
Marvin Humphrey, Matt Johnson, Matt S Trout, Max Maischein, Michael
Breen, Michael Fig, Michael G Schwern, Michael Parker, Michael Stevens,
Michael Witten, Mike Kelly, Moritz Lenz, Nicholas Clark, Nick Cleaton,
Nick Johnston, Nicolas Kaiser, Niko Tyni, Noirin Shirley, Nuno Carvalho,
Paul Evans, Paul Green, Paul Johnson, Paul Marquess, Peter J. Holzer,
Peter John Acklam, Peter Martini, Philippe Bruhat (BooK), Piotr Fusik,
Rafael Garcia-Suarez, Rainer Tammer, Reini Urban, Renee Baecker, Ricardo
Signes, Richard Möhn, Richard Soderberg, Rob Hoelz, Robin Barker, Ruslan
Zakirov, Salvador Fandiño, Salvador Ortiz Garcia, Shlomi Fish, Sinan
Unur, Sisyphus, Slaven Rezic, Steffen Müller, Steve Hay, Steven
Schubiger, Steve Peters, Sullivan Beck, Tatsuhiko Miyagawa, Tim Bunce,
Todd Rinaldo, Tom Christiansen, Tom Hukins, Tony Cook, Tye McQueen,
Vadim Konovalov, Vernon Lyon, Vincent Pit, Walt Mankowski, Wolfram
Humann, Yves Orton, Zefram, and Zsbán Ambrus.

control history.  In particular, it doesn't include the names of the
(very much appreciated) contributors who reported issues in previous
versions of Perl that helped make Perl 5.14.0 better. For a more complete
list of all of Perl's historical contributors, please see the 0
file in the Perl 5.14.0 distribution.

modules included in Perl's core. We're grateful to the entire CPAN
community for helping Perl to flourish.

recently posted to the comp.lang.perl.misc newsgroup and the Perl
bug database at http://rt.perl.org/perlbug/ .  There may also be
information at http://www.perl.org/ , the Perl Home Page.

program included with your release.  Be sure to trim your bug down
to a tiny but sufficient test case.  Your bug report, along with the
output of 0, will be sent off to perlbug@perl.org to be
analysed by the Perl porting team.

inappropriate to send to a publicly archived mailing list, then please send
it to perl5-security-report@perl.org.  This points to a closed subscription
unarchived mailing list, which includes all the core committers, who be able
to help assess the impact of issues, figure out a resolution, and help
co-ordinate the release of patches to mitigate or fix the problem across all
platforms on which Perl is supported.  Please use this address for
security issues in the Perl core 0, not for modules independently
distributed on CPAN.

on what changed.

=encoding utf8

desperation):

(W, D & S) can be controlled using the 0 pragma.

category is included with the classification letter in the description
below.

and 0 switches. Warnings may be captured by setting 0
to a reference to a routine that will be called on each warning instead
of printing it.  See 0.

with the 0 pragma or the 0 switch.

0.  In almost all cases, warnings may be selectively
disabled or promoted to fatal errors using the 0 pragma.
See 0.

lower-case.  Some of these messages are generic.  Spots that vary are
denoted with a %s or other printf-style escape.  These escapes are
ignored by the alphabetical order, as are all characters other than
letters.  To look up your message, just ignore anything that is not a
letter.

to check the return value of your  call?  See
0.

after certain types.  See 0.

keyword, and you have used the name without qualification for calling
one or the other.  Perl decided to call the builtin because the
subroutine is not imported.

before the subroutine name, or qualify the name with its package.
Alternatively, you can import the subroutine (or pretend that it's
imported with the 0 pragma).

on the operator (e.g. 0) or declare the subroutine
to be an object method (see 0 or
0).

all.  To include a 0 character in a transliteration, put it either
first or last.  (In the past, 0 was synonymous with
0, which was probably not what you would have expected.)

you thought.  Normally it's pretty easy to disambiguate it by supplying
a missing quote, operator, parenthesis pair or declaration.

bitwise and, and multiplication) 0 initial special characters
(denoting hashes, subroutines and typeglobs), and you said something
like 0 that might be interpreted as either of them.  We
assumed you meant the infix operator, but please try to make it more
clear -- in the example given, you might write 0 if you
really meant to multiply a glob by the result of calling a function.

asking for the variable 0, or it might be calling a function
named foo, and dereferencing it as an array reference.  If you wanted
the varable, you can just write 0.  If you wanted to call the
function, write 0 ... or you could just not have a variable
and a function with the same name, and save yourself a lot of trouble.

represents the name of a Perl keyword), which might be looking for
element number 2 of the array named 0, in which case please write
0, or you might have meant to pass an anonymous arrayref to
the function named foo, and then do a scalar deref on the value it
returns.  If you meant that, write 0.

to disambiguate between array subscripts and character classes.
0, for instance, will be interpreted as 0
followed by the character class 0. If an array subscript is what
you want, you can avoid the warning by changing 0
to the unsightly 0, by renaming your array to
something that does not coincide with a built-in keyword, or by
simply turning off warnings with 0.

string 0, or a call to the function 0, negated.  If you meant
the string, just write 0.  If you meant the function call,
write 0.

immediately followed by "le".  In Perl 5.14 and earlier, this is
resolved as meaning to take the result of the substitution, and see if
it is stringwise less-than-or-equal-to what follows in the expression.
Having the "le" immediately following a pattern is deprecated behavior,
so in Perl 5.16, this expression will be resolved as meaning to do the
pattern match using the rules of the current locale, and evaluate the
rhs as an expression when doing the substitution.  In 5.14, if you want
the latter interpretation, you can simply write "el" instead.

redirection, and found that STDIN was a pipe, and that you also tried to
redirect STDIN using '<'.  Only one STDIN stream to a customer, please.

redirection, and thinks you tried to redirect stdout both to a file and
into a pipe to another command.  You need to choose one or the other,
though nothing's stopping you from piping into a program or Perl script
which 'splits' output into two streams, such as

transliteration (0) operators work on scalar values.  If you apply
one of them to an array or a hash, it will convert the array or hash to
a scalar value (the length of an array, or the population info of a
hash) and then work on that scalar value.  This is probably not what
you meant to do.  See 0 and 0 for
alternatives.

subroutine with an ampersand, such as:

such as:

name, and not a subroutine call.  0 will generate this
error.

that expected a numeric value instead.  If you're fortunate the message
will identify which operator was so unfortunate.

forgot the ) that closes the argument list.  (Layers take care of transforming
data between external and internal representations.)  Perl stopped parsing
the layer list at this point and did not attempt to push this layer.
If your program didn't explicitly request the failing operation, it may be
the result of the value of the environment variable PERLIO.

spots.  This is now heavily deprecated.

must either both be scalars or both be lists.  Otherwise Perl won't
know which context to supply to the right side.

thread) exited while there were still other threads running.
Usually it's a good idea first to collect the return values of the
created threads by joining them, and only then to exit from the main
thread.  See 0.

the current set of allowed keys of a restricted hash.

the name of the package to bless the resulting object into. You've
supplied instead a reference to something: perhaps you wrote

of the reference supplied, you need to stringify it yourself, for
example by:

which is not in its key set.

declared readonly from a restricted hash.

that will be garbage collected on exit.  An SV was discovered to be
outside any of those arenas.

strings to optimize the storage and access of hash keys and other
strings.  This indicates someone tried to decrement the reference count
of a string that can no longer be found in the table.

 routine.  This indicates that something else is freeing the
SV before the  routine gets a chance, which means that the
 routine will be freeing an unreferenced scalar when it does
try to free it.

see if it would go to 0, and discovered that it had already gone to 0
earlier, and should have been freed, and in fact, probably was freed.
This could indicate that  was called too many times, or
that  was called too few times, or that the SV was
mortalized when it shouldn't have been, or that memory has been
corrupted.

impossible task.  You may be joining the wrong thread, or you may need
to move the  to some other thread.

function, or a computed expression) to the "p"  template.  This
means the result contains a pointer to a location that could become
invalid anytime, even before the end of the current statement.  Use
literals or global values as arguments to the "p"  template to
avoid this warning.

compile once already.  Perl will not try to compile this file again
unless you delete its entry from %INC.  See 0 and
0.

can do this by storing a reference to the scalar representing the last index
of an array and later assigning through that reference. For example

used as an lvalue, which is pretty strange.  Perhaps you forgot to
dereference it first.  See 0.

attribute on a code reference. The :locked attribute is obsolete, has had no
effect since 5005 threads were removed, and will be removed in a future
release of Perl 5.

attribute on an array, hash or scalar reference. The :unique attribute has
had no effect since Perl 5.8.8, and will be removed in a future release
of Perl 5.

or .  In C parlance, the correct sizes are, respectively,
0, 0, and
0.

substitution, but perl found a syntax error in the code to evaluate,
most likely an unexpected right brace '}'.

symbol has no filehandle associated with it.  Perhaps you didn't do an
, or did it in another package.

been ed in the first place. Mandatory, but can be disabled by
setting environment variable 0 to 0.

dynamic linking, like 0 and 0. It is a bug of 0
which is left unnoticed if 0 uses 0 system .

of Perl.  Check the #! line, or manually feed your script into
Perl yourself.

didn't finish the symbol.  In particular, you can't interpolate outside
of quotes, so

plugin API.

never been ed in the first place. Mandatory, but can be disabled
by setting the environment variable 0"
symbol.  Perhaps you need to predeclare a subroutine?

compiler saw no other uses of that namespace before that point.  Perhaps
you need to predeclare a package?

subroutine.  Compilation stops immediately and the interpreter is
exited.

implies a 0) after one or more compilation errors had already
occurred.  Since the intended environment for the 0 could not
be guaranteed (due to the errors), and since subsequent code likely
depends on its correct operation, Perl just gave up.

The use of backslashes is grandfathered on the right-hand side of a
substitution, but stylistically it's better to use the variable form
because other Perl programmers will expect it, and it works better if
there are more than 9 backreferences.

(4294967295) and therefore non-portable between systems.  See
0 for more on portability concerns.

check the return value of your  call?  See 0.

Check your control flow and number of arguments.

0 or 0 is now deprecated so as to reserve its use for Perl
itself in a future release.

copiable.

iterate over %ENV, it encountered a logical name or symbol definition
which was too long, so it was truncated to the string shown.

exited by calling exit.

parser saw a definition or declaration for it, and Perl could not check
that the call conforms to the prototype.  You need to either add an
early prototype declaration for the subroutine in question, or move the
subroutine definition ahead of the call to get proper prototype
checking.  Alternatively, if you are certain that you're calling the
function correctly, you may put an ampersand before the name to avoid
the warning.  See 0 1e308).
See 0.

format can only be used with positive integers.  See 0.

then tried to access that symbol via conventional Perl syntax. The access
triggers Perl to autovivify that typeglob, but it there is no legal conversion
from that type of reference to a typeglob.

be directly assigned to.

either with  or .

integer format can only be used with positive integers, and you attempted
to compress something else.  See 0.

encapsulation of objects.  See 0.

a 0 block. You probably meant to use 0 or 0.

object reference or package name contains an undefined value.  Something
like this will reproduce the error:

ordinarily finds this out from the object reference you supply, but you
didn't supply an object reference in this case.  A reference isn't an
object reference until it has been blessed.  See 0.

object reference or package name contains an expression that returns a
defined value which is neither an object reference nor a package name.
Something like this will reproduce the error:

that you can chdir to, possibly because it doesn't exist.

nosuid.

(typeglobs), can't be forced to stop being what they are.  So you can't
say things like:

or 0 block.

quotas or other plumbing problems.

"state" variables.  They must have ordinary identifiers as names.

a file in /dev, or a FIFO.  The file was ignored.

reason.

reading from a deleted (but still opened) file.  You have to say
0, or some such.

characters and Perl was unable to create a unique filename during
inplace editing with the 0 switch.  The file was ignored.

regexp to match something 0 times, just put {0}. The <-- HERE shows in the
regular expression about where the problem was discovered. See 0.

 without flags is emulated.

point.  For example, it'd be kind of silly to put a 0 on the #!
line.

or it has a very strange pointer size.  Packing and unpacking big- or
little-endian floating point values and pointers may not be possible.
See 0.

named program for the indicated reason.  Typical reasons include: the
permissions were wrong on the file, the file wasn't found in
0, the executable in question was compiled for another
architecture, or the #! line in a script points to an interpreter that
can't be run for similar reasons.  (Or maybe your system doesn't support
#! at all.)

that's what the #! line said.  If that's not what you wanted, you may
need to mention "perl" on the #! line somewhere.

found in the PATH did not have correct permissions.

is no builtin with the name 0.

could not be found. Maybe you misspelled the name of the property?
See 0
for a complete list of available properties.

possible for us to go to.  See 0.

found in the PATH.

found in the PATH, or at least not with the correct permissions.  The
script exists in the current directory, but PATH prohibits running it.

that the closing delimiter was omitted.  Because bracketed quotes count
nesting levels, the following is missing its final parenthesis:

included unseen whitespace before or after your closing tag or there
may not be a linebreak after it.  A good programmer's editor will have
a way to help you find these characters (or lack of characters).  See
0 for the full details on here-documents.

property (for example 0 matches all uppercase
letters). If you did mean to use a Unicode property, see
0
for a complete list of available properties. If you didn't
mean to use a Unicode property, escape the 0, either by 0
(just the 0) or by 0 (the rest of the string, or
until 0).

pipeline.

after five seconds.

between access checks under VMS and under the Unix model Perl assumes.
Under VMS, access checks are done by filename, rather than by bits in
the stat buffer, so that ACLs and other protections can be taken into
account.  Unfortunately, Perl assumes that the stat buffer contains all
the necessary information, and passes it, instead of the filespec, to
the access-checking routine.  It will try to retrieve the filespec using
the device name and FID present in the stat buffer, but this works only
if you haven't made a subsequent call to the CRTL  routine,
because the device name is overwritten with each call.  If this warning
appears, the name lookup failed, and the access-checking routine gave up
and returned FALSE, just to be conservative.  (Note: The access-checking
routine knows about the Perl 0 operator and file tests, so you
shouldn't ever see this warning in response to a Perl command; it arises
only if some internal code takes stat buffers lightly.)

pipe, Perl can't retrieve its name for later use.

mailbox buffers to be, and didn't get an answer.

loop.  You can't get there from here.  See 0.

a block, except that it isn't a proper block.  This usually occurs if
you tried to jump out of a  block or subroutine, which is a no-no.
See 0.

comparison sub for a , or from a similar callback (such
as the  function in List::Util).

"string" or block.

subroutine call for another.  It can't manufacture one out of whole
cloth.  In general you should be calling it out of only an AUTOLOAD
routine anyway.  See 0.

signal (sometimes known as SIGCLD) disabled.  Since disabling this
signal will interfere with proper determination of exit status of child
processes, Perl has reset the signal to its default value.  This
situation typically indicates that the parent program under which Perl
may be running (e.g. cron) is being very careless.

attempt to  an undefined, empty-string or otherwise non-numeric
process identifier.

except that there's this itty bitty problem called there isn't a current
block.  Note that an "if" or "else" block doesn't count as a "loopish"
block, as doesn't a block given to ,  or .  You can
usually double the curlies to get the same effect though, because the
inner curlies will be considered a block that loops once.  See
0.

package, but failed because the package stash has no name.

may either mean that you upgraded your version of perl to one that is
incompatible with your old dynamic extensions (which is known to happen
between major versions of perl), or (more likely) that your dynamic
extension was built against an older version of the library that is
installed on your system. You may need to rebuild your old dynamic
extensions.

lexical variable using "my" or "state".  This is not allowed.  If you want to
localize a package variable of the same name, qualify it with the
package name.

handle, because when it goes to restore the old value of whatever 
pointed to after the scope of the  is finished, it can't be sure
that  will still be a reference.

found. Perl looks for the file in all the locations mentioned in @INC,
unless the file name included the full path to the file.  Perhaps you
need to set the PERL5LIB or PERL5OPT environment variable to say where
the extra library is, or maybe the script needs to add the library name
to @INC.  Or maybe you just misspelled the name of the file.  See
0 and 0.

autoload, but there is no function to autoload.  Most probable causes
are a misprint in a function/method name or a failure to 0
the file, say, by doing 0.

for example, 0 or 0, but the 0 module was
unable to locate this library.  See 0.

functioning as a class, but that package doesn't define that particular
method, nor does any of its base classes.  See 0:nosuchlayer", "somefile").

VMS.

to change it, such as with an auto-increment.

a NULL.

such.  See 0.

buffer.

there isn't a current block.  Note that an "if" or "else" block doesn't
count as a "loopish" block, as doesn't a block given to ,  or
.  You can usually double the curlies to get the same effect
though, because the inner curlies will be considered a block that loops
once.  See 0.

filehandle, either implicitly under the 0 or 0' on
the command line for writing.

redirection, and couldn't open the file specified after '<' on the
command line for reading.

redirection, and couldn't open the file specified after '>' or '>>' on
the command line for writing.

redirection, and couldn't open the pipe into which to send data destined
for stdout.

shell's  search, the -S option causes perl to do that search, so
you don't have to type the path or 0.

from the CRTL's internal environment array and discovered the array was
missing.  You need to figure out where your CRTL misplaced its environ
or define 0 (see 0) so that environ is not
searched.

there isn't a current block.  Note that an "if" or "else" block doesn't
count as a "loopish" block, as doesn't a block given to , 
or .  You can usually double the curlies to get the same effect
though, because the inner curlies will be considered a block that
loops once.  See 0.

file.  Perl was unable to remove the original file to replace it with
the modified file.  The file was left unmodified.

probably because you don't have write permission to the directory.

to reopen it to accept binary data.  Alas, it failed.

to a subroutine reference): no such method callable via the package. If
the method name is 0, this is an internal error.

temporary or readonly values) from a subroutine used as an lvalue.  This
is not allowed.

there was no subroutine call to return out of.  See 0.

but you called the subroutine in a way that made Perl think you meant
to return only one value. You probably meant to write parentheses around
the call to the subroutine, which tell Perl that the call should be in
list context.

open already.  Bizarre.

negative number or zero. There's a Math::Complex package that comes
standard with Perl, though, if you really want to do that for the
negative numbers.

negative number.  There's a Math::Complex package that comes standard
with Perl, though, if you really want to do that.

however, redefine it while it's running, and you can even undef the
redefined subroutine while the old routine is running.  Go figure.

into a more specialized kind of SV.  The top several SV types are so
specialized, however, that they cannot be interconverted.  This message
indicates that such a conversion was attempted.

table that doesn't have a name.  Symbol tables can become anonymous
for example by undefining stashes: 0.

be a defined value.  This helps to delurk some insidious errors.

references are disallowed.  See 0.

Errno.pm module. The Errno module is expected to tie the %! hash to
provide symbolic names for 0 errno values.

byte-order at the same time, so this combination of modifiers is not
allowed.  See 0.

foreach.

is not allowed, because the magic can be tied to only one location
(namely the global variable) and it would be incredibly confusing to
have variables in your program that looked like magical variables but
weren't.

that is already inside a group with a byte-order modifier.
For example you cannot force little-endianness on a type that
is inside a big-endian group.

You mentioned  or  in the same line as the <=> or cmp operator,
and the variable had earlier been declared as a lexical variable.
Either qualify the sort variable with the package name, or rename the
lexical variable.

reference of the type needed.  You can use the  function to
test the type of the reference, if need be.

references are disallowed.  See 0.

subscript.  But to the left of the brackets was an expression that
didn't look like a hash or array reference, or anything else subscriptable.

creates a reference to its argument.  The use of backslash to indicate a
backreference to a matched substring is valid only as part of a regular
expression pattern.  Trying to do this in ordinary Perl code produces a
value that prints out looking like SCALAR(0xdecaf).  Use the  form
instead.

loop nor a 0 block. (Note that this error is issued on exit
from the 0 block, so you won't get the error if the match fails,
or if you use an explicit 0.)

references can be weakened.

with an assignment operator, which implies modifying the value itself.
Perhaps you need to copy the value to a temporary, and repeat that.

It is planned to make this fatal in all instances in Perl 5.16.  In the
cases where it isn't fatal, the character this evaluates to is
derived by exclusive or'ing the code point of this character with 0x40.

only for encoding native operating system characters (ASCII, EBCDIC,
and so on) and not for Unicode characters, so Perl behaved as if you meant

instead.

all values to fall in the interval [0, 255], so Perl behaved as if you
meant:

is only for encoding native operating system characters (ASCII, EBCDIC,
and so on) and not for Unicode characters, so Perl behaved as if you meant

instead.

below 256), but a higher value was provided instead. Perl uses the value
modulus 256 instead, as if you had provided:

value below 256), but some of the characters had a higher value. Perl
uses the character values modulus 256 instead, as if you had provided:

value below 256), but some of the characters had a higher value. Perl
uses the character values modulus 256 instead, as if you had provided:

to specify non-printable characters.  You used it with a "{" which
evaluates to ";", which is printable.  It is planned to remove the
ability to specify a semi-colon this way in Perl 5.16.  Just use a
semi-colon or a backslash-semi-colon without the "\c".

non-printable characters.  You used it for a printable one, which is better
written as simply itself, perhaps preceded by a backslash for non-word
characters.

a dirhandle.  Check your control flow.

handler is the prototype that is cloned when a new closure is created.
This subroutine cannot be called.

template code following the slash. See 0.

points, up to the limit of what is storable in an unsigned integer on
your system, but these may not be accepted by other languages/systems.
At one time, it was legal in some standards to have code points up to
0x7FFF_FFFF, but not higher.  Code points above 0xFFFF_FFFF require
larger than a 32 bit word.

code point.  For example,

Check the #! line, or manually feed your script into Perl yourself.

Perl uses this generic message when none of the errors that it
encountered were severe enough to halt compilation immediately.

situations where back-tracking is required.  Recursion depth is limited
to 32766, or perhaps less in architectures where the stack cannot grow
arbitrarily.  ("Simple" and "medium" situations are handled without
recursion and are not subject to a limit.)  Try shortening the string
under examination; looping in Perl code (e.g. with 0) rather than
in the regular expression engine; or rewriting the regular expression so
that it is simpler or backtracks less.  (See 0 for information
on 0.)

 on a variable which wasn't locked. The 
function is used to wake up another thread that is waiting in a
. To ensure that the signal isn't sent before the other thread
has a chance to enter the wait, it is usual for the signaling thread
first to wait for a lock on variable. This lock attempt will only succeed
after the other thread has entered  and thus relinquished the
lock.

 on a variable which wasn't locked. The 
function is used to wake up another thread that is waiting in a
. To ensure that the signal isn't sent before the other thread
has a chance to enter the wait, it is usual for the signaling thread
first to wait for a lock on variable. This lock attempt will only succeed
after the other thread has entered  and thus relinquished the
lock.

to check the return value of your  call?  See
0.

an overloaded constant, or when trying to find the character name
specified in the 0 escape.  Perhaps you forgot to load the
corresponding 0 or 0 pragma?  See 0 and
0.

the character name specified in the 0 escape.  Perhaps you
forgot to load the corresponding 0 pragma?
See 0.

is being dereferenced, but it amounts to the wrong type of reference.
The message indicates the type of reference that was expected. This
usually indicates a syntax error in dereferencing the constant value.
See 0 and 0.

eligible for inlining.  See 0 for
commentary and workarounds.

for inlining.  See 0 for commentary and
workarounds.

0.

expression compiler gave it.

valid magic number.

you have also specified an explicit size for the string.  See
0.

100 times more than it has returned.  This probably indicates an
infinite recursion, unless you're writing strange benchmark programs, in
which case it indicates something else.

setting the C pre-processor macro 0 to the desired value.

checks for an undefined 0 value.  If you want to see if the
array is empty, just use 0 for example.

checks for an undefined 0 value.  If you want to see if the hash
is empty, just use 0 for example.

most likely cause of this error is that you left out a parenthesis inside
of the 0 part.

discovered.

there are neither package declarations nor a 0.

long for Perl to handle.  You have to be seriously twisted to write code
that triggers this error.

But starting in 5.12, non-reasonable ones that don't look like names
are deprecated.  A reasonable name begins with an alphabetic character
and continues with any combination of alphanumerics, dashes, spaces,
parentheses or colons.

There has been a long-standing bug in Perl that causes a lexical variable
not to be cleared at scope exit when its declaration includes a false
conditional. Some people have exploited this bug to achieve a kind of
static variable. Since we intend to fix this bug, we don't want people
relying on this behavior. You can achieve a similar static effect by
declaring the variable in a separate block outside the function, eg

have lexicals that are initialized only once (see 0):

just being DESTROYed. Perl is confused, and prefers to abort rather than
to create a dangling reference.

it compiled correctly and ran its initialization code correctly.  It's
traditional to end such a file with a "1;", though any true value would
do.  See 0.

some such.

variable.  You have declared it again in the same lexical scope, which
seems superfluous.

@hash{@keys}.  On the other hand, maybe you just meant %hash and got
carried away.

you called it with no args and 0 was empty.

define a 0

See 0.

"%s found where operator expected".  It often means a subroutine or module
name is being referenced that hasn't been declared yet.  This may be
because of ordering problems in your file, or because of a missing
"sub", "package", "require", or "use" statement.  If you're referencing
something that isn't defined yet, you don't actually have to define the
subroutine or package before the current location.  You can use an empty
"sub foo;" or "package FOO;" to enter a "forward" declaration.

qualifying it as 0.  Maybe it's a typo.  See 0.

already been freed.

in a pack template.  See 0.

ugly. Your code will be interpreted as an attempt to call a method named
"elseif" for the class returned by the following block.  This is
unlikely to be what you want.

described in 0 and 0. You used 0 or 0 in
a regular expression without specifying the property name.

effective uids or gids failed.

aliased to another hash, so it doesn't reflect anymore the state of the
program's environment. This is potentially insecure.

specifications in either VMS or Unix syntax, it converts them to a
single form when it must operate on them directly.  Either you've passed
an invalid file specification to Perl, or you've found a case the
conversion routines don't handle.  Drat.

expression that contains the 0 zero-width assertion, which
is unsafe.  See 0, and 0.

0 zero-width assertion at run time, as it would when the
pattern contains interpolated values.  Since that is a security risk,
it is not allowed.  If you insist, you may still do this by using the
0 pragma or by explicitly building the pattern from an
interpolated string at run time and using that in an .  See
0.

assertion, but that construct is only allowed when the 0
pragma is in effect.  See 0.

any text. Restructure the pattern so that text is consumed.

discovered.

Perl identifier.  If you're just trying to glob a long list of
filenames, try using the  operator, or put the filenames into a
variable and glob that.

OS. See 0.

goto, or a loop control statement.

goto, or a loop control statement.

sort block or subroutine) by unconventional means, such as a goto, or a
loop control statement.  See 0.

as a goto, or a loop control statement.

as a return, a goto, or a loop control statement.

the effect of blessing the reference into the package main.  This is
usually not what you want.  Consider providing a default target package,
e.g. bless(,  || 'MyPackage');

Check the #! line, or manually feed your script into Perl yourself.

CHECK, INIT, or END subroutine.  Processing of the remainder of the
queue of such routines has been prematurely ended.

character, not another character class like 0 or 0.  The "-"
in your false range is interpreted as a literal "-".  Consider quoting the
"-", "\-".  The <-- HERE shows in the regular expression about where the
problem was discovered.  See 0.

system service or RTL routine; Perl's exit status should provide more
details.  The filename in "at %s" and the line number in "line %d" tell
you which section of the Perl source code is distressed.

PDP-11 or something?

is not possible.

which can't encode values above 63. So there is no point in asking for
a line length bigger than that. Perl will behave as if you specified
0 as the format.

it to be a read-write filehandle, you needed to open it with "+<" or
"+>" or "+>>" instead of with "<" or nothing.  If you intended only to
write the file, use ">" or ">>".  See 0.

you intended it to be a read/write filehandle, you needed to open it
with "+<" or "+>" or "+>>" instead of with ">".  If you intended only to
read from the file, use "<".  See 0.  Another possibility
is that you attempted to open filedescriptor 0 (also known as STDIN) for
output (maybe you closed STDIN earlier?).

as STDOUT or STDERR. This occurred because you closed STDOUT or STDERR
previously.

as STDIN. This occurred because you closed STDIN previously.

a literal dollar sign, or was meant to introduce a variable name that
happens to be missing.  So you have to put either the backslash or the
name.

some time before now.  Check your control flow.   operates on
filehandles.  Are you attempting to call  on a dirhandle by the
same name?

to the end of your file without finding such a line.

If it sees what it knows to be a term when it was expecting to see an
operator, it gives you this warning.  Usually it indicates that an
operator or delimiter was omitted, such as a semicolon.

because if it did, it'd feel morally obligated to return every hostname
on the Internet.

socket.  Did you forget to check the return value of your  call?

0 operator returned an invalid UIC.

forget to check the return value of your  call?  See
0.

that all variables must either be lexically scoped (using "my" or "state"),
declared beforehand using "our", or explicitly qualified to say
which package the global variable is in (using "::").

0 and .  Usually, this means that you supplied a
0 pattern that caused the external program to fail and exit with a
nonzero status.  If the message indicates that the abnormal exit
resulted in a coredump, this may also mean that your csh (C shell) is
broken.  If so, you should change all of the csh-related variables in
config.sh:  If you have tcsh, make the variables refer to it as if it
were csh (e.g.  0); otherwise, make them all
empty (except that 0 should be 0) so that Perl will
think csh is missing.  In either case, after editing config.sh, run
0 and rebuild Perl.

a term, so it's looking for the corresponding right angle bracket, and
not finding it.  Chances are you left some needed parentheses out
earlier in the line, and you really meant a "less than".

it can reliably handle and 0 probably returned the wrong
date. This warning is also triggered with nan (the special
not-a-number value).

it can reliably handle and 0 probably returned the wrong
date. This warning is also triggered with nan (the special
not-a-number value).

version of Perl, and this should not happen anyway.

unspecified destination.  See 0.

something: a template character or a ()-group.  See 0.

to have existed already, but for some reason it didn't, and had to be
created on an emergency basis to prevent a core dump.

spots.  This is now heavily deprecated.

Further error messages would likely be uninformative.

pattern without an intervening space.  If you are trying to use the 0
flags on a substitution, use 0 instead.  Otherwise, add white space
between the pattern and following word to eliminate the warning. As an
example of the latter, the two constructs:

form in Perl 5.16.  And,

(4294967295) and therefore non-portable between systems.  See
0 for more on portability concerns.

about 250 characters for simple names, and somewhat more for compound
names (like 0).  You've exceeded Perl's limits.  Future versions
of Perl are likely to eliminate these arbitrary limitations.

zero length sequence.  When such an escape is used in a character class
its behaviour is not well defined. Check that the correct escape has
been used, and the correct charname handler is in scope.

binary number.  Interpretation of the binary number stopped before the
offending digit.

would any other whitespace, which means you should never see this error
when Perl was built using standard options.  For some reason, your
version of Perl appears to have been built without this support.  Talk
to your Perl administrator.

Legal characters in prototypes are $, @, %, *, ;, [, ], &, \, and +.

you must always specify a block of code. See 0.

your logic, or you need to put a conditional in to guard against
meaningless input.

A - F, a - f in a hexadecimal number.  Interpretation of the hexadecimal
number stopped before the illegal character.

numbers don't take to this kindly.

two from 1 to 32 (or 64, if your platform supports that).

Interpretation of the octal number stopped before the 8 or 9.

following switches: 0.

internal environ array, and encountered an element without the 0
delimiter used to separate keys from values.  The element is ignored.

name or CLI symbol definition when preparing to iterate over %ENV, and
didn't see the expected delimiter between key and value, so the line was
ignored.

the indicated exception.  Since destructors are usually called by the
system at arbitrary points during execution, and often a vast number of
times, the warning is issued only once for any number of failures that
would otherwise result in the same message being repeated.

also result in this warning.  See 0.

C3-consistent, and you have enabled the C3 MRO for this class.  See the C3
documentation in 0 for more information.

Unicode code points, and encoded in EBCDIC as UTF-EBCDIC.  The UTF-EBCDIC
encoding is limited to code points no larger than 2147483647 (0x7FFFFFFF).

text. You should check the pattern to ensure that recursive patterns
either consume text or fail.

discovered.

of scalar variables in scalar context. Re-write 0 as
0 to change from list to scalar context. Constructions such
as 0 will be supported in a future perl release.

The tainting mechanism is turned on when you're running setuid or
setgid, or when you specify 0 to turn it on explicitly.  The
tainting mechanism labels all data that's derived directly or indirectly
from the user, who is considered to be unworthy of your trust.  If any
such data is used in a "dangerous" operation, you get this error.  See
0 for more information.

setgid script if 0 contains a directory that is writable by
the world.  Also, the PATH must not contain any relative directory.
See 0.

setgid script if any of 0, 0, 0,
0, 0 or 0 are derived from data
supplied (or potentially supplied) by the user.  The script must set
the path to a known value, using trustworthy data.  See 0.

expression that contains a call to a user-defined character property
function, i.e. 0 or 0.
See 0 and 0.

or 0 are too large.  The numbers must not overflow the size of
integers for your architecture.

either as a literal or as an argument to  or  is too big for
your architecture, and has been converted to a floating point number.
On a 32-bit architecture the largest hexadecimal, octal or binary number
representable without overflow is 0xFFFFFFFF, 037777777777, or
0b11111111111111111111111111111111 respectively.  Note that Perl
transparently promotes all numbers to a floating point representation
internally--subject to loss of precision errors in subsequent
operations.

size of integers for your architecture.  This is not a warning
because there is no rational reason for a version to try and use a
element larger than typically 2**32.  This is usually caused by
trying to use some odd mathematical operation as a version, like
100/9.

The <-- HERE shows in the regular expression about where the problem was
discovered.

you've called 0 and 0, to determine whether the current call
to 0 should affect the current script or a subprocess (see
0).  Somehow, this count has become scrambled, so
Perl is making a guess and treating this 0 as a request to
terminate the Perl script and execute the specified command.

<-- HERE shows in the regular expression about where the problem was
discovered.

followed by parentheses turns into a function, with all the list
operators arguments found inside the parentheses.  See
0.

by Perl or by a user-supplied handler.  See 0.

recognized by Perl or by a user-supplied handler.  See 0.

0.

didn't correspond to a single character through the conversion
from the encoding specified by the encoding pragma.
The escape was replaced with REPLACEMENT CHARACTER (U+FFFD) instead.
The <-- HERE shows in the regular expression about where the
escape was discovered.

number.  Either it is empty, or you tried to use a character other than
0 - 9 or A - F, a - f in a hexadecimal number.

where 0 is not a valid method resolution order (MRO).  Currently,
the only valid ones supported are 0 and 0, unless you have loaded
a module that is a MRO plugin.  See 0 and 0.

greater than the maximum character.  One possibility is that you forgot the
0 from your ending 0 - 0 without the curly braces can go only
up to 0.  The <-- HERE shows in the regular expression about where the
problem was discovered.  See 0.

character greater than the maximum character.  See 0.

elements of an attribute list.  If the previous attribute had a
parenthesised parameter list, perhaps that list was terminated too soon.
See 0.

than a colon or whitespace was seen between the elements of a layer list.
If the previous attribute had a parenthesised parameter list, perhaps that
list was terminated too soon.

A "strict" version number is a positive decimal number (integer or
decimal-fraction) without exponentiation or else a dotted-decimal
v-string with a leading 'v' character and at least three components.
The parenthesized text indicates which criteria were not met.
See the 0 module for more details on allowed version formats.

See 0.
(W) The given character is not a valid pack or unpack type but used to be
silently ignored.

A "lax" version number is a positive decimal number (integer or
decimal-fraction) without exponentiation or else a dotted-decimal
v-string. If the v-string has fewer than three components, it must
have a leading 'v' character.  Otherwise, the leading 'v' is optional.
Both decimal and dotted-decimal versions may have a trailing "alpha"
component separated by an underscore character after a fractional or
dotted-decimal component.  The parenthesized text indicates which
criteria were not met.  See the 0 module for more details on
allowed version formats.

the internals were modified directly in some way or an arbitrary reference
was blessed into the "version" class.

strange for a machine that supports C.

Check your control flow and number of arguments.

you cannot use IO layers.  To have PerlIO, Perl must be configured
with 'useperlio'.

neither as a system call nor an ioctl call (SIOCATMARK).

perls, has been removed as of 5.9.0 and is no longer supported. In
previous versions of perl the use of 0 enabled or disabled multi-line
matching within a string.

modifiers. You can enable 0 for a lexical scope (even a whole file)
with 0. (In older versions: when 0 was set to a true value
then all regular expressions behaved as if they were written using 0.)

perls, has been removed as of 5.9.3 and is no longer supported. You
should use the printf/sprintf functions instead.

needs to be a code reference. Either an anonymous subroutine, or a reference
to a subroutine.

unaware of.

of that name, not even if you count where you were called from.  See
0.

that name, not even if you count where you were called from.  See
0.

that name, not even if you count where you were called from.  See
0.

effective uids or gids failed.

length/code combination tried to obtain more data. This results in
an undefined value for the length. See 0.

(using 0 or similar), but tried to insert a character
that couldn't be part of the current input. This is an inherent pitfall
of the stuffing mechanism, and one of the reasons to avoid it.  Where it
is necessary to stuff, stuffing only plain ASCII is recommended.

detectable way.

to check the return value of your  call?  See
0.

than it can reliably handle and 0 probably returned the
wrong date. This warning is also triggered with nan (the special
not-a-number value).

than it can reliably handle and 0 probably returned the
wrong date. This warning is also triggered with nan (the special
not-a-number value).

handle. This restriction may be eased in a future release.

for the underlying floating point representation to store accurately,
hence the target of 0 or 0 is unchanged. Perl issues this warning
because it has already switched from integers to floating point when values
are too large for integers, and now even floating point is insufficient.
You may wish to switch to using 0 explicitly.

by that?   makes sense only on filenames.  (Perl did a 
instead on the filehandle.)

by declaring the subroutine with an lvalue attribute is not
possible. To make the subroutine an lvalue subroutine add the
lvalue attribute to the definition, or put the declaration before
the definition.

values cannot be returned in subroutines used in lvalue context.  See
0.

are permitted.  See 0.

are permitted.  See 0.

a builtin library search path, prefix2 is substituted.  The error may
appear if components are not found, or are too long.  See
"PERLLIB_PREFIX" in 0.

syntax of function prototypes is given a brief compile-time check for
obvious errors like invalid characters.  A more rigorous check is run
when the function is called.

encoding rules, even though it had the UTF8 flag on.

you thought to be in UTF-8 but it wasn't (it was for example legacy
8-bit data). To guard against this, you can use Encode::decode_utf8.

sequences are handled gracefully, but if you use 0, the flag is
set without validating the data, possibly resulting in this error
message.

rules and perl was unable to guess how to make more progress.

rules and perl was unable to guess how to make more progress.

rules and perl was unable to guess how to make more progress.

doing it Perl met a malformed Unicode surrogate.

regular expression engine didn't specifically check for that.  The <-- HERE
shows in the regular expression about where the problem was discovered.
See 0.

usually indicates that your operating system tried to deliver signals
too fast (with a very high priority), starving the perl process from
resources it would need to reach a point where it can process signals
safely. (See 0.)

interpreter, especially if the word that is being warned about is
"use" or "my".

checksumming process loses information, and you can't go the other way.
See 0.

doesn't resolve to a valid subroutine.  See 0.

by a missing delimiter on a string or pattern, because it eventually
ended earlier on the current line.

separate two digits.

supplied.

immediately after the switch, without intervening spaces.

double-quotish context.  This can also happen when there is a space
(or comment) between the 0 and the 0 in a regex with the 0 modifier.
This modifier does not change the requirement that the brace immediately
follow the 0.

"indirect object" before the argument list, this ain't one of them.

0 construction, but the command was missing or
blank.

character name.

they have a name with which they can be found.

are always mentioned with the $ in Perl, unlike in the shells, where it
can vary from one line to the next.

"%s found where operator expected".  Often the missing operator is a comma.

meaning the character (or sequence of characters) given by that
name. Thus 0 is another way of writing 0, valid in both
double-quoted strings and regular expression patterns.  In patterns,
it doesn't have the meaning an unescaped 0 does.

in patterns, namely to match a non-newline character.  (This is short
for 0, and like 0 but is not affected by the 0 regex modifier.)

by a left brace, Perl assumes the 0 meaning.  Also, if the braces
form a valid quantifier such as 0 or 0, Perl assumes that this
means to match the given quantity of non-newlines (in these examples,
3; and 5 or more, respectively).  In all other case, where there is a
0 and a matching 0, Perl assumes that a character name is desired.

mistakenly omitted, or if 0 was desired, and raises this error.
If you meant the former, add the right brace; if you meant the latter,
escape the brace with a backslash, like so: 0

ones.  As a general rule, you'll find it's missing near the place you
were last editing.

"%s found where operator expected".  Don't automatically put a semicolon on
the previous line just because you saw this message.

constant.  You didn't, of course, try "2 = 1", because the compiler
catches that.  But an easy way to do the same thing is:

is aliased to a constant in the look 0:

subscript was probably negative, even counting from end of the array
backwards.

couldn't be created for some peculiar reason.

you omitted the name of the module.  Consult 0 for full details
about 0 and 0.

can happen if you are trying to open a pipe to a command that takes a
list of arguments, but have forgotten to specify a piped open mode.
See 0 for details.

They're written like 0, as in C.

follow some unpack specification producing a numeric value.
See 0.

that yet.

sense to try to declare one with a package qualifier on the front.  Use
 if you want to localize a package variable.

If you had a good reason for having a unique name, then just mention it
again somehow to suppress the message.  The 0 declaration is
provided for this purpose.

%c, *c, &c, sub c{}, , and c (the filehandle or format) are considered
the same; if a program uses  only once but also uses any of the others it
will not trigger this warning.

character class, for the same reason that 0 in a character class loses
its specialness: it matches almost everything, which is probably not
what you want.

sequence was encountered.  This can happen in any of several ways that
bypass the lexer, such as using single-quotish context, or an extra
backslash in double-quotish:

components:

doesn't work here.  Instead use the solution above.

0 is separated by spaces from the 0, in which case, remove the spaces.

negative.  See 0.

length that is less than 0.  This is difficult to imagine.

greater than or equal to zero.

things like ** or +* or ?* are illegal. The <-- HERE shows in the regular
expression about where the problem was discovered.

0 appear to be nested quantifiers, but aren't.  See 0.

scope before it could possibly have been used.

real method in a real package, and it could not find such a context.
See 0.

setgid script to even be allowed to attempt.  Generally speaking there
will be another way to do what you want that is, if not secure, at least
securable.  See 0.

allowed to have a comma between that and the following arguments.
Otherwise it'd be just another one of the arguments.

constant to your name space with 0 or 0 while no such
importing took place, it may for example be that your operating system
does not support that particular constant. Hopefully you did use an
explicit import list for the constants you expect to see; please see
0 and 0. While an explicit import list
would probably have caught this error earlier it naturally does not
remedy the fact that your operating system still does not support that
constant. Maybe you have a typo in the constants of the symbol import
list of 0 or 0 or in the constant name at the line where
this error was triggered?

redirection, and found a '|' at the end of the command line, so it
doesn't know where you want to pipe the output from this command.

for some reason the current debugger (e.g. 0 or a 0
module) didn't define a routine to be called at the beginning of each
statement.

supply dbm nowadays, because Perl comes with SDBM.  See 0.

for some reason the current debugger (e.g. 0 or a 0
module) didn't define a 0' on the command line, but can't
find the name of the file to which to write data destined for stderr.

matching counterpart. See 0.

redirection, and found a '<' on the command line, but can't find the
name of the file from which to read data for stdin.

in the remaining packages of the MRO of this class.  If you don't want
it throwing an exception, use 0
or 0. See 0.

returns no useful value.  See 0' on the command line, but can't
find the name of the file to which to write data destined for stdout.

declarations, because that doesn't make much sense under existing
semantics.  Such syntax is reserved for future extensions.

with #! and containing the word "perl".

your system.

your system.

you haven't specified one.

but that key is not allowed by the package of the same type.  The indicated
package has restricted the set of allowed keys using the 0 pragma.

declaration, but this class doesn't exist at this point in your program.

Currently, Perl accepts 0 and 0 as valid signal hooks.

close a pipe which hadn't been opened.  This should have been caught
earlier as an attempt to close an unopened filehandle.

not recognized.  Say 0 in your shell to see the valid signal
names on your system.

subroutine), but found a reference to something else instead.  You can
use the  function to find out what kind of ref it really was.  See
also 0.

format, but this indicates you did, and that it didn't exist.

symbol table entry that looks like 0), but found a reference to
something else instead.  You can use the  function to find out what
kind of ref it really was.  See 0.

reference to something else instead.  You can use the  function to
find out what kind of ref it really was.  See 0.

a reference to something else instead.  You can use the  function
to find out what kind of ref it really was.  See 0.

another array function.  These only accept unblessed array references
or arrays beginning explicitly with 0.

a reference to something else instead.  You can use the  function
to find out what kind of ref it really was.  See 0.

subroutine), but found a reference to something else instead.  You can
use the  function to find out what kind of ref it really was.  See
also 0.

doesn't somehow point to a valid subroutine.  See 0.

supplied.  See 0.

of Perl.  Check the #! line, or manually feed your script into Perl
yourself.

timezone offset, so it's assuming that local system time is equivalent
to UTC.  If it's not, define the logical name
0 to translate to the number of seconds which
need to be added to UTC to get local time.

unexpectedly encountered that isn't octal.  The resulting value is as
indicated.

Use the  function to construct the file descriptor bitmasks for
select. See 0.

machines that means the current directory!  See 0.

pointer.

specification.  It was found to be empty, which probably means you
supplied it an uninitialized value.  See 0.

about 250 characters.  You've exceeded that length.  Future
versions of Perl are likely to eliminate this arbitrary limitation.  In
the meantime, try using scientific notation (e.g. "1e6" instead of
"1_000_000").

a number. This happens, for example with 0, with no number between
the braces.

The octal number interpretation of such numbers may be supported in a
future version.

(4294967295) and therefore non-portable between systems.  See
0 for more on portability concerns.

arguments. The arguments should come in pairs.

which is odd, because hashes come in key/value pairs.

which is odd, because hashes come in key/value pairs.

with an offset pointing outside the buffer.  This is difficult to
imagine.  The sole exceptions to this are that zero padding will
take place when going past the end of the string when either
0ing a file, or when seeking past the end of a scalar opened
for I/O (in anticipation of future reads and to imitate the behaviour
with real files).

never initialized.  You need to do an , a , or a 
call, or call a constructor from the FileHandle package.

that isn't open.  Check your control flow.  See also 0.

a symbol (glob or scalar) that already holds a dirhandle.
Although legal, this idiom might render your code confusing
and is deprecated.

a symbol (glob or scalar) that already holds a filehandle.
Although legal, this idiom might render your code confusing
and is deprecated.

handler was defined.  While some handlers can be autogenerated in terms
of other handlers, there is no default handler for any operation, unless
the 0 overloading key is specified to be true.  See 0.

semantics on a code
point that is not in Unicode, so what it should do is not defined.  Perl
has chosen to have it do nothing, and warn you.

matching in a regular expression was done on the code point.

0.

semantics on a Unicode
surrogate.  Unicode frowns upon the use of surrogates for anything but
storing strings in UTF-16, but semantics are (reluctantly) defined for
the surrogates, and they are to do nothing for this operation.  Because
the use of surrogates can be dangerous, Perl warns.

matching in a regular expression was done on the code point.

0.

was expecting an operator.  The parser has assumed you really meant to
use an operator, but this is highly likely to be incorrect.  For
example, if you say "*foo *foo" it will be interpreted as if you said
"*foo * 'foo'".

in the current lexical scope.

remaining memory (or virtual memory) to satisfy the request.  Perl has
no option but to exit immediately.

process datasize limits: in csh/tcsh use 0 and
0 (where 0 is the number of kilobytes) to check
the current limits and change them, and in ksh/bash/zsh use 0
and 0, respectively.

the largest possible memory allocation.

remaining memory (or virtual memory) to satisfy the request. However,
the request was judged large enough (compile-time default is 64K), so a
possibility to shut down by trapping this error is granted.

insufficient remaining memory (or virtual memory) to satisfy the
request.

depends on the way perl was compiled.  By default it is not trappable.
However, if compiled for this, Perl may use the contents of 0 as an
emergency pool after ing with this message.  In this case the error
is trappable 0, and the error message will include the line and file
where the failed request happened.

is most likely to be caused by a typo in the Perl program. e.g.,
0 instead of 0.

parsing, but  wouldn't give it more memory, virtual or
otherwise.

position to before the start of the packed string being built.

the string being unpacked.  See 0.

the string being unpacked. The string being unpacked was also invalid
UTF-8. See 0.

but the overloaded operation did not return a reference. See
0.

overloaded operation didn't return a compiled regexp. See 0.

package-specific handler.  That name might have a meaning to Perl itself
some day, even though it doesn't yet.  Perhaps you should use a
mixed-case attribute name, instead.  See 0.

signed integers.  See 0.

page.  See 0.

an ACL related-function, but that function is not available on this
platform.  Earlier checks mean that it should not be possible to
enter this branch on this platform.

there are in the savestack.

reference.

last(LABEL) or next(LABEL). Leaving that way a subroutine called from
an XSUB will lead very probably to a crash of the interpreter. This is
a bug that will hopefully one day get fixed.

it wasn't an eval context.

data.

data.

failure was caught.

and then discovered it wasn't a context we know how to do a goto in.

repeatedly, but each time something re-created entries in the glob. Most
likely the glob contains an object with a reference back to the glob and a
destructor that adds a new object to the glob.

but each time something added more entries to the hash. Most likely the hash
contains an object with a reference back to the hash and a destructor that
adds a new object to the hash.

it wasn't a block context.

scope.

invalid enum on the top of it.

references to an object.

and freeing temporaries and lexicals from.

and freeing temporaries and lexicals from.

and freeing temporaries and lexicals from.

and freeing temporaries and lexicals from.

data.

didn't supply the destination.

then discovered it wasn't a subroutine or eval context.

scalar's string buffer.

was string.

permitted at run time.

to even) byte length.

to even) byte length.

a detectable way.

consuming any text. Restructure the pattern so text is consumed before the
nesting limit is exceeded.

discovered.

command-line switch.  (This output goes to STDOUT unless you've
redirected it with .)

"Can't locate object method \"%s\" via package \"%s\"".  It often means
that a method requires a package that has not been loaded.

case-insensitive matching, and there is a bug in Perl in which the
built-in regular expression folding rules are not accurate.  This may
lead to incorrect results.  Please report this as a bug using the
"perlbug" utility.  (This message is marked deprecated, so that it by
default will be turned-on.)

so it was not possible to set up some or all fixed-width byte-order
conversion functions.  This is only a problem when you're using the
'<' or '>' modifiers in (un)pack templates.  See 0.

recent than the currently running version.  How long has it been since
you upgraded, anyway?  See 0.

0-shell in.  See "PERL_SH_DIR" in 0.

settings were that the LC_ALL was "En_US" and the LANG had no value.
This error means that Perl detected that you and/or your operating
system supplier and/or system administrator have set up the so-called
locale system but Perl could not use those settings.  This was not
dead serious, fortunately: there is a "default locale" called "C" that
Perl can and will use, and the script will be run.  Before you really
fix the problem, however, you will get the same error message each
time you run Perl.  How to really fix the problem can be found in
0 section 0.

process which isn't a subprocess of the current process.  While this is
fine from VMS' perspective, it's probably not what you intended.

shows in the regular expression about where the problem was discovered.
Note that the POSIX character classes do 0 have the 0 prefix
the corresponding C interfaces have: in other words, it's 0,
not 0.  See 0.

the BSD version, which takes a pid.

0 character classes, the [] are part of the construct, for example:
/[012[:alpha:]345]/.  Note that [= =] and [. .] are not currently
implemented; they are simply placeholders for future extensions and will
cause fatal errors.  The <-- HERE shows in the regular expression about
where the problem was discovered.  See 0.

beginning with "[." and ending with ".]" is reserved for future extensions.
If you need to represent those character sequences inside a regular
expression character class, just quote the square brackets with the
backslash: "\[." and ".\]".  The <-- HERE shows in the regular expression
about where the problem was discovered.  See 0.

with "[=" and ending with "=]" is reserved for future extensions.  If you
need to represent those character sequences inside a regular expression
character class, just quote the square brackets with the backslash: "\[="
and "=\]".  The <-- HERE shows in the regular expression about where the
problem was discovered.  See 0.

strings, comment characters are not ignored, but are instead treated as
literal data.  (You may have used different delimiters than the
parentheses shown here; braces are also frequently used.)

old-fashioned way, with quotes and commas:

commas aren't needed to separate the items.  (You may have used
different delimiters than the parentheses shown here; braces are also
frequently used.)

commas if you don't want them to appear in your data:

Perl guesses a reasonable buffer size, but puts a sentinel byte at the
end of the buffer just in case.  This sentinel byte got clobbered, and
Perl assumes that memory is now corrupted.  See 0.

with a numeric comparison operator, like this :

higher precedence of 0. This is probably not what you want. (If you
really meant to write this, disable the warning, or, better, put the
parentheses explicitly and write 0).

The regex 0 translates to: match the word 'foo', the output
record separator (see 0) and the letter 's' (one time or more)
followed by the word 'bar'.

0 (for example: 0).

followed by whitespace and the word 'bar' on the next line then you can use
0 (for example: 0).

but there was no array 0 in scope at the time. If you wanted a
literal @foo, then write it as \@foo; otherwise find out what happened
to the array you apparently lost track of.

list operators.  (The old open was a little of both.)  You must put
parentheses around the filehandle, or use the new "or" operator instead
of "||".

before now.  Check your control flow.

before now.  Check your control flow.

applications die in silence.  It is considered a feature of the OS/2
port.  One can easily disable this by appropriate sighandlers, see
0.  See also "Process terminated by SIGTERM/SIGINT"
in 0.

since % and @ gobble the rest of the subroutine arguments.

declared or defined with a different function prototype.

definition.

match (0 or 0), but the regular expression is also being told to
use the run-time locale, not Unicode.  Instead, use a POSIX character
class, which should know about the locale's rules.
(See 0.)

Unicode, some properties will give results that are not valid for that
subset.

locale is ISO 8859-7, the character at code point 0xD7 is the "GREEK
CAPITAL LETTER CHI".  But in Unicode that code point means the
"MULTIPLICATION SIGN" instead, and 0 always uses the Unicode
meaning.  That means that 0 won't match, but 0
should.  Only in the Latin1 locale are all the characters in the same
positions as they are in Unicode.  But, even here, some properties give
incorrect results.  An example is 0 which
is true for "LATIN SMALL LETTER Y WITH DIAERESIS", but since the upper
case of that character is not in Latin1, in that locale it doesn't
change when upper cased.

meant it literally. The <-- HERE shows in the regular expression about
where the problem was discovered. See 0.

{min,max} construct. The <-- HERE shows in the regular expression about where
the problem was discovered. See 0.

it makes no sense, such as on a zero-width assertion.  Try putting the
quantifier inside the assertion instead.  For example, the way to match
"abc" provided that it is followed by three repetitions of "xyz" is
0, not 0.

discovered.

are outside the range which can be represented by integers internally.
One possible workaround is to force Perl to use magical string increment
by prepending "0" to your numbers.

a dirhandle.  Check your control flow.

before now.  Check your control flow.

already been freed.

the desired output is compiled into Perl, which entails some overhead,
which is why it's currently left out of your copy.

believes it found an infinite loop in the 0 hierarchy.  This is a
crude check that bails out after 100 levels of 0 depth.

you see this message, something is very wrong.

with an even number of elements (for assignment to a hash). This usually
means that you used the anon hash constructor when you meant to use
parens. In any case, a hash requires key/value 0.

Doing so has no effect.

a reference count other than 1.

capturing parentheses only with strictly positive integers (normal
backreferences) or with strictly negative integers (relative
backreferences). Using 0 does not make sense.

not at least seven sets of capturing parentheses in the expression. If
you wanted to have the character with ordinal 7 inserted into the regular
expression, prepend zeroes to make it three digits long: 0

discovered.

expression, but there is no corresponding named capturing parentheses
such as 0 or . Check if the name has been
spelled correctly both in the backreference and the declaration.

discovered.

are not at least seven sets of closed capturing parentheses in the
expression before where the 0 was located.

discovered.

expression compiler gave it.

of the specified modifier.  Remove the extraneous ones.

on another one.  Perl currently doesn't allow this.  Reword the regular
expression to use the modifier you want to turn on (and place it before
the minus), instead of the one you want to turn off.

mutually exclusive modifiers.  Retain only the modifier that is
supposed to be there.

earlier.

numeric field that will never go blank so that the repetition never
terminates. You might use ^# instead.  See 0.

search list. So the additional elements in the replacement list
are meaningless.

always come last, to avoid ambiguity with subsequent unary operators.

really a dirhandle.  Check your control flow.

not all scalar variables were deallocated by the time Perl exited.
What this usually indicates is a memory leak, which is of course bad,
especially if the Perl program is intended to be long-running.

single element of an array.  Generally it's better to ask for a scalar
value (indicated by $).  The difference is that 0 always
behaves like a scalar, both when assigning to it and when evaluating its
argument, while 0 behaves like a list when you assign to it,
and provides a list context to its subscript, which can do weird things
if you're expecting only one subscript.

element as a list, you need to look into how references work, because
Perl will not magically convert between scalars and lists for you.  See
0.

element of a hash.  Generally it's better to ask for a scalar value
(indicated by $).  The difference is that 0 always behaves
like a scalar, both when assigning to it and when evaluating its
argument, while 0 behaves like a list when you assign to it,
and provides a list context to its subscript, which can do weird things
if you're expecting only one subscript.

as a list, you need to look into how references work, because Perl will
not magically convert between scalars and lists for you.  See
0.

construct.  Remember that bracketing delimiters count nesting level.
Missing the leading 0 from a variable 0 may cause this error.

construct, not just the empty search pattern.  Therefore code written
in Perl 5.9.0 or later that uses the // as the 0 can be
misparsed by pre-5.9.0 Perls as a non-terminated search pattern.

construct.

0) leading to some ambiguous constructions being wrongly
parsed. One way to disambiguate the parsing is to put parentheses around
the conditional expression, i.e. 0.

really a dirhandle.  Check your control flow.

filehandle that was either never opened or has since been closed.

the current implementation.

semicolon, or possibly some other missing operator, such as a comma.

scalar that had previously been marked as free.

before now.  Check your control flow.

shows in the regular expression about where the problem was discovered. See
0.

has not yet been written. The <-- HERE shows in the regular expression about
where the problem was discovered. See 0.

<-- HERE shows in the regular expression about where the problem was
discovered.  This happens when using the 0 construct to tell
Perl to use the default regular expression modifiers, and you
redundantly specify a default modifier.  For other
causes, see 0.

sequence and this has been omitted or incorrectly written.

parenthesis.  Embedded parentheses aren't allowed.  The <-- HERE shows in
the regular expression about where the problem was discovered. See
0.

for Perl to detect the end of the clause properly. The <-- HERE shows in
the regular expression about where the problem was discovered. See
0.

to run a CGI program (including SSI) over the web. The actual error text
varies widely from server to server. The most frequently-seen variants
are "500 Server error", "Method (something) not permitted", "Document
contains no data", "Premature end of script headers", and "Did not
produce a valid header".

user CGI is running the script under (which is probably not the user
account you tested it under), does not rely on any environment variables
(like PATH) from the user it isn't running under, and isn't in a
location where the CGI server can't find it, basically, more or less.
Please see the following for more information:

support the  system call (or equivalent), or at least Configure
didn't think so.

support the  system call (or equivalent), or at least Configure
didn't think so.

arguments, unlike POSIX , which takes a process ID and process
group ID.

support the  system call (or equivalent), or at least Configure
didn't think so.

support the  system call (or equivalent), or at least Configure
didn't think so.

forget to check the return value of your  call?  See
0.

interpreted as the != (numeric not equal) and ~ (1's complement)
operators: probably not what you intended.

0.

as in the first argument to 0.  Perl will treat the true or false
result of matching the pattern against  as the string, which is
probably not what you had in mind.

superfluous.

Perhaps you put it into the wrong package?

overload it: Perl refuses to use the object's underlying structure for
the smart match.

But before sort was a keyword, people sometimes used it as a filehandle.

or less than one element.  See 0.

the array passed to . Splicing will instead commence at the end
of the array, rather than past it. If this isn't what you want, try
explicitly pre-extending the array by assigning $#array = . See
0.

iterate more times than there are characters of input, which is what
happened.) See 0.

.  This is almost always an error, because  never returns
unless there was a failure.  You probably wanted to use 
instead, which does return.  To suppress this warning, put the  in
a block by itself.

sense to try to declare one with a package qualifier on the front.  Use
 if you want to localize a package variable.

was either never opened or has since been closed.

stubs.  Stubs should never be implicitly created, but explicit calls to
0 may break this.

shouldn't iterate more times than there are characters of input, which
is what happened.)  See the discussion of substitution in
0.

construct.  Remember that bracketing delimiters count nesting level.
Missing the leading 0 from variable 0 may cause this error.

construct.  Remember that bracketing delimiters count nesting level.
Missing the leading 0 from variable 0 may cause this error.

a string.  That is, the absolute value of the offset was larger than the
length of the string.  See 0.  This warning is fatal if
substr is used in an lvalue context (as the left hand side of an
assignment or as a subroutine argument for example).

inferior to its current type.

branches (the if-clause and the else-clause). If you want one or both to
contain alternation, such as using 0, enclose it in
clustering parentheses:

discovered. See 0.

a number, it can be only a number. The <-- HERE shows in the regular
expression about where the problem was discovered. See 0.

and effective uids or gids.

error giving more information.  (Sometimes it helps to turn on 0.)
The error message itself often tells you where it was in the line when
it decided to give up.  Sometimes the actual error is several tokens
before this, because Perl is good at understanding random input.
Occasionally the line number may be misleading, and once in a blue moon
the only way to figure out what's triggering the error is to call
0 repeatedly, chopping away half the program each time to see
if the error went away.  Sort of the cybernetic version of 0.

of Perl.  Check the #! line, or manually feed your script into Perl
yourself.

a perl4 interpreter, especially if the next 2 tokens are "use strict"
or "my " or "our ".

"shm", or "msg" but that System V IPC is not implemented in your
machine.  In some machines the functionality can exist but be
unconfigured.  Consult your system support.

before now.  Check your control flow.

know about your kind of stdio.  You'll have to use a filename instead.

for Perl to reach.  Perl is doing you a favor by refusing.

a dirhandle.  Check your control flow.

was either never opened or has since been closed.

as a compiler directive.  You may say only one of

from under another module inadvertently.  See 0.

probably because your vendor didn't supply it, probably because they
think the U.S. Government thinks it's a secret, or at least that they
will continue to pretend that it is.  And if you quote me on that, I
will deny it.

to the probings of Configure.

linkhood if the last stat that wrote to the stat buffer already went
past the symlink to get to the real file.  Use an actual filename
instead.

element of the CRTL's internal environ array, but your copy of Perl
wasn't built with a CRTL that contained the  function.  You'll
need to rebuild Perl with a CRTL that does, or redefine
0 (see 0) so that the environ array isn't the
target of the change to
%ENV which produced the warning.

suspect you're not running on Unix.

0 option (or the 0 option), but Perl was not invoked with 0 in its command line.
This is an error because, by the time Perl discovers a 0 in a
script, it's too late to properly taint everything from the environment.
So Perl gives up.

mechanism (or its local equivalent), this error can usually be fixed by
editing the #! line so that the 0 option is a part of Perl's first
argument: e.g. change 0 to 0.

0 option must appear on the command line: 0.

, or  (or their string-inlined versions), but you
specified an illegal mapping.
See 0.

system call to call, silly dilly.

0, 0 or 0 option.

not intended for use inside scripts.  Use the 0 pragma instead.

(with the same sequence of letters or numbers following). Either specify
this option on the command line, or, if your system supports it, make your
script executable and run it directly instead of passing it to perl.

when the opportunity to run them has already passed.  Perhaps you are
loading a file with 0 or 0 when you should be using 0
instead.  Or perhaps you should put the 0 or 0 inside a
BEGIN block.

Check the #! line, or manually feed your script into Perl yourself.

Check the #! line, or manually feed your script into Perl yourself.

Backslash it.   See 0.

or y/// or y[][] construct.  Missing the leading 0 from variables
0 or 0 may cause this error.

y/// or y[][] construct.

disallowed. See 0.

Configure knows about.

certain type.  Arrays must be @NAME or 0.  Hashes must be
%NAME or 0.  No implicit dereferencing is allowed--use the
{EXPR} forms as an explicit dereference.  See 0.

was not a reference to an unblessed hash or array.

use it to restrict permissions for yourself (EXPR & 0700).

many execution contexts were entered and left.

many values were temporarily localized.

many blocks were entered and left.

many mortal scalars were allocated and freed.

another package?  See 0.

Perhaps it's in a different package?  See 0.

since been undefined.

or if it was, it has since been undefined.

to have been defined yet.  See 0.

another package?  See 0.

0.  This does nothing.  It's possible that you really mean
0.

Check the #! line, or manually feed your script into Perl yourself.

representative, who probably put it there in the first place.

defined by the
Unicode standard to be non-characters. Those are legal codepoints, but are
reserved for internal use; so, applications shouldn't attempt to exchange
them.  If you know what you are doing you can turn
off this warning by 0.

not considered acceptable.  These code points, between U+D800 and
U+DFFF (inclusive), are used by Unicode only for UTF-16.  However, Perl
internally allows all unsigned integer code points (up to the size limit
available on your platform), including surrogates.  But these can cause
problems when being input or output, which is likely where this message
came from.  If you really really know what you are doing you can turn
off this warning by 0.

order.

of valid modes: , , C<<< >> >>>, ,
, C<<< +>> >>>, 0, 0, , .

system.  (Layers take care of transforming data between external and
internal representations.)  Note that some layers, such as 0,
are not supported in all environments.  If your program didn't
explicitly request the failing operation, it may be the result of the
value of the environment variable PERLIO.

iterating over it, and someone else stuck a message in the stream of
data Perl expected.  Someone's very confused, or perhaps trying to
subvert Perl's population of %ENV for nefarious purposes.

is not known. The condition must be one of the following:

discovered.  See 0.

of the 0 switch for the list of known options.

of the 0 switch for the list of known options.

after an open brace in your pattern.  Check the pattern and review
0 for details on legal verb patterns.

category that is unknown to perl at this point.

module (e.g. 0), you must have loaded this
module first.

include a closing bracket in a character class, backslash it or put it
first. The <-- HERE shows in the regular expression about where the problem
was discovered. See 0.

expressions. If you're a vi user, the % key is valuable for finding the
matching parenthesis. The <-- HERE shows in the regular expression about
where the problem was discovered. See 0.

ones, so you're probably missing a matching opening bracket.  As a
general rule, you'll find the missing one (so to speak) near the place
you were last editing.

reserved word.  It's best to put such a word in quotes, or capitalize it
somehow, or insert an underbar into it.  You might also declare it as a
subroutine.

in your Perl script (or eval) near the specified column.  Perhaps you tried
to run a compressed script, a binary program, or a directory as a Perl program.

recognized by Perl inside character classes.  The character was
understood literally, but this may change in a future version of Perl.
The <-- HERE shows in the regular expression about where the
escape was discovered.

recognized by Perl.  The character was understood literally, but this may
change in a future version of Perl.

recognized by Perl.  The character(s) were understood literally, but this may
change in a future version of Perl.
The <-- HERE shows in the regular expression about where the
escape was discovered.

recognized.  Say 0 in your shell to see the valid signal names
on your system.

think you didn't do that, check the #! line to see if it's supplying the
bad switch on your behalf.)

operation failed, PROBABLY because the filename contained a newline,
PROBABLY because you forgot to  it off.  See 0.

At least, Configure doesn't think so.

of Perl executables, some of which may support fork, some not. Try
changing the name you call Perl by to 0, 0, and so on.

declares it to be in a Unicode encoding that Perl cannot read.

least that's what Configure thought.

start of an attribute, and it wasn't a semicolon or the start of a
block.  Perhaps you terminated the parameter list of the previous
attribute too soon.  See 0.

an attribute list, but the matching closing (right) parenthesis
character was not found.  You may need to add (or remove) a backslash
character to get your parentheses to balance.  See 0.

compressed integer format and could not be converted to an integer.
See 0.

a regular expression. Fix the pattern and retry.

a term, so it's looking for the corresponding right angle bracket, and
not finding it.  Chances are you left some needed parentheses out
earlier in the line, and you really meant a "less than".

the pattern with a 0. Fix the pattern and retry.

the pattern with a 0. Fix the pattern and retry.

still valid when 0 was called.

See 0 for more information.

See 0 for more information.

meaning unless removed from the entire regexp:

where the problem was discovered. See 0.

legal, but in fact the  currently has no effect. This may change at
some point in the future, but in the meantime such code is discouraged.

meaning unless applied to the entire regexp:

where the problem was discovered. See 0.

same length as the replacelist. See 0 for more information
about the /d modifier.

nothing with the return value, such as a statement that doesn't return a
value from a block, or the left side of a scalar comma operator.  Very
often this points not to stupidity on your part, but a failure of Perl
to parse your program the way you thought it would.  For example, you'd
get this if you mixed up your C precedence with Python precedence and
said

reference when you should be using square or curly brackets, for
example, if you say

while parentheses do not.  So when a parenthesized list is evaluated in
a scalar context, the comma is treated like C's comma operator, which
throws away the left argument, which is not what you want.  See
0 for more on this.

since they are often used in statements like

about.

apart from the array, like 0 or 0. That won't
usually have any effect on the array, so is completely useless. It's
possible in principle that push(@tied_array) could have some effect
if the array is tied to a class which implements a PUSH method. If so,
you can write it as 0 to avoid this warning.

returns no useful value.  See 0.

is deprecated. See 0.

form if you wish to use an empty line as the terminator of the here-document.

separated by commas, not just aligned on a line.

{HOME} or {LOGDIR}.  chdir(undef) and chdir('') share this
behavior, but that has been deprecated.  In future versions they
will simply fail.

blank, else you might find yourself in your home directory.

modifier is not presently meaningful in substitutions.

use the /g modifier.  Currently, /c is meaningful only when /g is
used.  (This may change in the future.)

0 (applying an empty attribute list to 0).
This construct was deprecated in 5.12.0, and has now been made a syntax
error, so 0 can be reclaimed as a new operator in the future.

a space before the 0.

This error is typically caused by code like the following:

For speed and efficiency reasons, Perl internally does not do full
reference-counting of iterated items, hence deleting such an item in the
middle of an iteration causes Perl to see a freed value.

to access the filehandle slot within a typeglob.

operator.  Since 0 always tries to match the pattern
repeatedly, the 0 has no effect.

scope is deprecated and should be avoided.

subroutines are looked up as methods (using the 0 hierarchy)
even when the subroutines to be autoloaded were called as plain
functions (e.g. 0), not as methods (e.g.  or
).

methods' 0s.  However, there is a significant base of existing
code that may be using the old behavior.  So, as an interim step, Perl
currently issues an optional warning when non-methods use inherited
0s.

non-methods.  The simple fix for old code is:  In any module that used
to depend on inheriting 0 for non-methods from a base class
named 0, execute 0 during
startup.

you should remove AutoLoader from @ISA and change 0 to
0.

only C.  This usually means there's a better way to do it in Perl.

generally because there's a better way to do it, and also because the
old way has bad side effects.

it already went past any symlink you are presumably trying to look for.
The operation returned 0.  Use a filename instead.

scalar happens to hold a typeglob, which means its filehandle will
be tied. If you mean to tie a handle, use an explicit * as in
0.

there is currently no way to tie the scalar itself when it holds
a typeglob, and no way to untie a scalar that has had a typeglob
assigned to it.

expression that matches only once.  Starting this term directly with
the question mark delimiter is now deprecated, so that the question mark
will be available for use in new operators in the future.  Write 0
instead, explicitly using the 0 operator: the question mark delimiter
still invokes match-once behaviour.

using a 0 list literal where a parenthesised expression is
expected.  Historically the parser fooled itself into thinking that
0 literals were always enclosed in parentheses, and as a result
you could sometimes omit parentheses around them.  (You could never do
the 0 that you might have expected, though.)
The parser no longer lies to itself in this way.  Wrap the list literal
in parentheses, like 0.

isn't what you mean, because references in numerical context tend
to be huge numbers, and so usually indicates programmer error.

0.  This warning is not given for overloaded objects,
however, because you can overload the numification and stringification
operators and then you presumably know what you are doing.

versions of perl may use it as a keyword, so you're better off either
explicitly quoting the word in a manner appropriate for its context of
use, or using a different name altogether.  The warning can be
suppressed for subroutine names by either adding a 0 prefix, or using
a package qualifier, e.g. 0, or 0.

arguments and at least one of them is tainted.  This used to be allowed
but will become a fatal error in a future version of perl.  Untaint your
arguments.  See 0.

defined.  It was interpreted as a "" or a 0, but maybe it was a mistake.
To suppress this warning assign a defined value to your variables.

name of the variable (if any) that was undefined. In some cases it cannot
do this, so it also tells you what operation you used the undefined value
in.  Note, however, that perl optimizes your program and the operation
displayed in the warning may not necessarily appear literally in your
program.  For example, 0 is usually optimized into 0, and the warning will refer to the 0 operator,
even though there is no 0 in your program.

 or .  Versions of perl <= 5.6.1
used to allow this syntax, but shouldn't have. It is now deprecated, and will
be removed in a future version.

 or .  Versions of perl <= 5.6.1 used to
allow this syntax, but shouldn't have. It is now deprecated, and will be
removed in a future version.

Currently all but the first one are discarded when used in a regular
expression pattern bracketed character class.

currently reserved for future use, as the exact behaviour has not
been decided. (Simply returning the boolean opposite of the
modified string is usually not particularly useful.)

the standard case mapping, such as 0 gives.  This feature is being
deprecated due to its many issues, as documented in
0.
It is planned to remove this feature in Perl 5.16.  A CPAN module
providing improved functionality is being prepared.

not considered acceptable.  These code points, between U+D800 and
U+DFFF (inclusive), are used by Unicode only for UTF-16.  However, Perl
internally allows all unsigned integer code points (up to the size limit
available on your platform), including surrogates.  But these can cause
problems when being input or output, which is likely where this message
came from.  If you really really know what you are doing you can turn
off this warning by 0.

0, or 0 as a boolean value.  Each of these constructs
can return a value of "0"; that would make the conditional expression
false, which is probably not what you intended.  When using these
constructs in conditional expressions, test their values with the
0 operator.

%ENV element from a CLI symbol table, and found a resultant string
longer than 1024 characters.  The return value has been truncated to
1024 characters.

attempting to capture an outer lexical that is not currently available.
This can happen for one of two reasons. First, the outer lexical may be
declared in an outer anonymous subroutine that has not yet been created.
(Remember that named subs are created at compile time, while anonymous
subs are created at run-time.) For example,

since the anonymous subroutine hasn't been created yet. Conversely,
the following won't give a warning since the anonymous subroutine has by
now been created and is live:

gone out of scope, for example,

executed, so its  is not available for capture.

that you apparently thought was imported from another module, because
something else of the same name (usually a subroutine) is exported by
that module.  It usually means you put the wrong funny character on the
front of your variable.

known at compile time.  See 0.

current scope or statement, effectively eliminating all access to the
previous instance.  This is almost always a typographical error.  Note
that the earlier variable will still exist until the end of the scope
or until all closure referents to it are destroyed.

of Perl.  Check the #! line, or manually feed your script into
Perl yourself.

lexical variable defined in an outer named subroutine.

the outer subroutine's variable as it was before and during the *first*
call to the outer subroutine; in this case, after the first call to the
outer subroutine is complete, the inner and outer subroutines will no
longer share a common value for the variable.  In other words, the
variable will no longer be shared.

anonymous, using the 0 syntax.  When inner anonymous subs that
reference variables in outer subroutines are created, they
are automatically rebound to the current values of such variables.

or check that you are using the right verb.

argument or check that you are using the right verb.

its equivalent 0 block found an internal inconsistency with
the version number.

are being ignored.

you called it with no args and 0 was empty.

the .  This usually indicates your file system ran out of disk
space.

looks like a binary operator that could also have been interpreted as a
term or unary operator.  For instance, if you know that the rand
function has a default argument of 1.0, and you write

one.  This warning is by default on for I/O (like print).  The easiest
way to quiet this warning is simply to add the 0 layer to the
output, e.g. 0.  Another way to turn off the
warning is to add 0 but that is often closer to
cheating.  In general, you are supposed to explicitly mark the
filehandle with an encoding, see 0 and 0.

0 always matches the same amount of packed bytes that can be
determined from the template alone. This is not possible if it contains any
of the codes @, /, U, u, w or a *-length. Redesign the template.

before now.  Check your control flow.

into Unicode characters.  The bytes you read in are not legal in
this encoding, for example

the beginning of the string being (un)packed.  See 0.

the end of the string being unpacked.  See 0.

sources to your kernel, and your vendor probably doesn't give a rip
about what you want.  Your best bet is to put a setuid C wrapper around
your script.

Unfortunately, you already have a subroutine of that name declared,
which means that Perl 5 will try to call the subroutine when the
assignment is executed, which is probably not what you want.  (If it IS
what you want, put an & in front.)

not get any randomness out of your system.  This usually indicates
Something Very Wrong.

=encoding utf8

[0] [0] [0] [0]
[B<-d0]
[B<-o0]
[B<-M0]
[B<-w0]
[00]
[0]
[0 0]
PageName|ModuleName|ProgramName

in the perl installation tree or in a perl script, and displays it via
0. (In addition, if running under HP-UX,
0 will be used.) This is primarily used for the documentation for
the perl library modules.

which case you can probably just use the  command.

documentation, see the 0 page.

but it probably won't look as nice.

This may be useful if the docs don't explain a function in the detail
you need, and you'd like to inspect the code directly; perldoc will find
the file for you and simply hand it off for display.

extract the documentation of this function from 0.

the 0uestion headings in perlfaq[1-9] and print the entries matching
the regular expression.

extract the documentation of this variable from 0.

be sent right to STDOUT.

to STDOUT, but is to be saved to the specified filename.  Example:
0

class for the output format that you specify.  For example:
0.  This is actually just a wrapper around the 0 switch;
using C<-o0 just looks for a loadable class by adding
that format name (with different capitalizations) to the end of
different classname prefixes.

Pod::Perldoc::ToLaTeX Pod::Perldoc::Tolatex Pod::Perldoc::ToLatex
Pod::Perldoc::ToLATEX Pod::Simple::LaTeX Pod::Simple::latex
Pod::Simple::Latex Pod::Simple::LATEX Pod::LaTeX Pod::latex Pod::Latex
Pod::LATEX.

pod.  The class must at least provide a 0 method.
For example: 0.

or semicolons, as in 0.

0 will call
 on the formatter object before it is
used to format the object.  For this to be valid, the formatter class
must provide such a method, and the value you pass should be valid.
(So if 0 expects an integer, and you do 0,
expect trouble.)

C<-w optionname:0.  This is presumably useful in cases of on/off
features like: 0.

might be more (or less) convenient, depending on what shell you use.

whose basename matches the name given on the command line in the file
0. The 0 file should contain fully
qualified filenames, one per line.

translation. If the C<POD2::0language_code0 package isn't
installed in your system, the switch is ignored.
All available translation packages are to be found under the 0
namespace. See 0 (or 0) to see how to create new
localized 0 documentation packages and integrate them into
0.

are specified either as 0 or 0.  You may also
give a descriptive name of a page, such as 0.

a matching page, a search with the "perl" prefix is tried as well.
So "perldoc intro" is enough to find/render "perlintro.pod".

have security issues, when run as the superuser it will attempt to
drop privileges by setting the effective and real IDs to nobody's
or nouser's account, or -2 if unavailable.  If it cannot relinquish
its privileges, it will not run.

command line arguments.

0, and so on, depending on what modules you have on hand; or
the formatter class may be specified exactly with 0
or the like.

specified by the 0 (or 0 if 0 is not
defined) and 0 environment variables.
(The latter is so that embedded pods for executables, such as
0 itself, are available.)

0, 0, or 0 before trying to find a pager
on its own. (0 is not used if 0 was told to display
plain text or unformatted pod.)

even more descriptive output than the 0 switch does; the higher the
number, the more it emits.

messages of 0 operation, which is now enabled by 0.

Sean M. Burke <sburke@cpan.org>,
Kenneth Albanowski <kjahds@kjahds.com>,
Andy Dougherty  <doughera@lafcol.lafayette.edu>,
and many others.

=encoding utf8

0 0 0

prior to its 5.0 release was complex data structures.  Even without direct
language support, some valiant programmers did manage to emulate them, but
it was hard work and not for the faint of heart.  You could occasionally
get away with the 0 notation borrowed from 0 in which the
keys are actually more like a single concatenated string 0, but
traversal and sorting were difficult.  More desperate programmers even
hacked Perl's internal symbol table directly, a strategy that proved hard
to develop and maintain--to put it mildly.

may now write something like this and all of a sudden, you'd have an array
with three dimensions!

elaborate construct than meets the eye!

you sort it?  How can you pass it to a function or get one of these back
from a function?  Is it an object?  Can you save it to disk to read
back later?  How do you access whole rows or columns of that matrix?  Do
all the values have to be numeric?

of the blame for this can be attributed to the reference-based
implementation, it's really more due to a lack of existing documentation with
examples designed for the beginner.

many different sorts of data structures you might want to develop.  It
should also serve as a cookbook of examples.  That way, when you need to
create one of these complex data structures, you can just pinch, pilfer, or
purloin a drop-in example from here.

sections on each of the following:

these types of data structures.

0 0 0 0

Perl--including multidimensional arrays--is that even though they might
appear otherwise, Perl 0s and 0es are all internally
one-dimensional.  They can hold only scalar values (meaning a string,
number, or a reference).  They cannot directly contain other arrays or
hashes, but instead contain 0 to other arrays or hashes.
0 0

would a real array or hash.  For C or C++ programmers unused to
distinguishing between arrays and pointers to the same, this can be
confusing.  If so, just think of it as the difference between a structure
and a pointer to a structure.

Briefly, references are rather like pointers that know what they
point to.  (Objects are also a kind of reference, but we won't be needing
them right away--if ever.)  This means that when you have something which
looks to you like an access to a two-or-more-dimensional array and/or hash,
what's really going on is that the base type is
merely a one-dimensional entity that contains references to the next
level.  It's just that you can 0 it as though it were a
two-dimensional one.  This is actually the way almost all C
multidimensional arrays work as well.

out your array in with a simple  function, you'll get something
that doesn't look very nice, like this:

If you want to get at the thing a reference is referring to, then you have
to do this yourself using either prefix typing indicators, like
0, 0, 0, or else postfix pointer arrows,
like C<-0, C<-0, or even C<--0.

an array of arrays is either accidentally counting the number of
elements or else taking a reference to the same memory location
repeatedly.  Here's the case where you just get the count instead
of a nested array:

its element count.  If that's what you really and truly want, then you
might do well to consider being a tad more explicit about it, like this:

again and again:

After all, I just told you that you need an array of references, so by
golly, you've made me one!

in @AoA refer to the 0, and they will therefore all hold
whatever was last in @array!  It's similar to the problem demonstrated in
the following C program:

in memory!  In C, you'd have to remember to  yourself some new
memory.  In Perl, you'll want to use the array constructor 0 or the
hash constructor 0 instead.   Here's the right way to do the preceding
broken code fragments:
0 0

of what's in @array at the time of the assignment.  This is what
you want.

much harder to read:

is that when you assign something in square brackets, you know for sure
it's always a brand new reference with a new 0 of the data.
Something else could be going on in this new case with the 0
dereference on the left-hand-side of the assignment.  It all depends on
whether 0 had been undefined to start with, or whether it
already contained a reference.  If you had already populated @AoA with
references, as in

use the existing reference that was already there:

@another_array.  (Have you ever noticed how when a programmer says
something is "interesting", that rather than meaning "intriguing",
they're disturbingly more apt to mean that it's "annoying",
"difficult", or both?  :-)

or 0, and you'll be fine, although it's not always optimally
efficient.

actually work out fine:

compile-time declaration 0.  This means that the  variable is
remade afresh each time through the loop.  So even though it 0 as
though you stored the same variable reference each time, you actually did
not!  This is a subtle distinction that can produce more efficient code at
the risk of misleading all but the most experienced of programmers.  So I
usually advise against teaching it to beginners.  In fact, except for
passing arguments to functions, I seldom like to see the gimme-a-reference
operator (backslash) used much at all in code.  Instead, I advise
beginners that they (and most of the rest of us) should try to use the
much more easily understood constructors 0 and 0 instead of
relying upon lexical (or dynamic) scoping and hidden reference-counting to
do the right thing behind the scenes.

0 0

same thing:

(which look like someone swearing: 0) make them bind more
tightly than the postfix subscripting brackets or braces!  This will no
doubt come as a great shock to the C or C++ programmer, who is quite
accustomed to using 0 to mean what's pointed to by the 0
element of 0.  That is, they first take the subscript, and only then
dereference the thing at that subscript.  That's fine in C, but this isn't C.

the deref of , making it take  as a reference to an
array, and then dereference that, and finally tell you the 0 value
of the array pointed to by . If you wanted the C notion, you'd have to
write 0 to force the 0 to get evaluated first
before the leading 0 dereferencer.

some features to help you avoid its most common pitfalls.  The best
way to avoid getting confused is to start every program like this:

also disallow accidental "symbolic dereferencing".  Therefore if you'd done
this:

because you were accidentally accessing 0, an undeclared
variable, and it would thereby remind you to write instead:

0 0
0 0 0 0
0 0
0 0

printing out complex data structures.  With 5.002 or above, the
debugger includes several new features, including command line editing as
well as the 0 command to dump out complex data structures.  For
example, given the assignment to  above, here's the debugger output:

here are short code examples illustrating access of various
types of data structures.

0 0

0 0

0 0

0 0

0 0 0

many different sorts:

hashes) to a dbm file.  The first problem is that all but GDBM and
Berkeley DB have size limitations, but beyond that, you also have problems
with how references are to be represented on disk.  One experimental
module that does partially attempt to address this need is the MLDBM
module.  Check your nearest CPAN site as described in 0 for
source code to MLDBM.

Wed Oct 23 04:57:50 MET DST 1996 

=encoding utf8

on EBCDIC based computers.  We do not cover localization,
internationalization, or multi-byte character set issues other
than some discussion of UTF-8 and UTF-EBCDIC.

it doesn't.  If you want to use Perl on an EBCDIC machine, please let us know
by sending mail to perlbug@perl.org

set of
integers running from 0 to 127 (decimal) that imply character
interpretation by the display and other systems of computers.
The range 0..127 can be covered by setting the bits in a 7-bit binary
digit, hence the set is sometimes referred to as "7-bit ASCII".
ASCII was described by the American National Standards Institute
document ANSI X3.4-1986.  It was also described by ISO 646:1991
(with localization for currency symbols).  The full ASCII set is
given in the table below as the first 128 elements.  Languages that
can be written adequately with the characters in ASCII include
English, Hawaiian, Indonesian, Swahili and some Native American
languages.

from 0..2**7-1 up to 2**8-1, or 8 bit bytes (octets if you prefer).
One common one is the ISO 8859-1 character set.

International Organization for Standardization (ISO) each of which
adds characters to the ASCII set that are typically found in European
languages many of which are based on the Roman, or Latin, alphabet.

accented Latin characters.  Languages that can employ ISO 8859-1
include all the languages covered by ASCII as well as Afrikaans,
Albanian, Basque, Catalan, Danish, Faroese, Finnish, Norwegian,
Portuguese, Spanish, and Swedish.  Dutch is covered albeit without
the ij ligature.  French is covered too but without the oe ligature.
German can use ISO 8859-1 but must do so without German-style
quotation marks.  This set is based on Western European extensions
to ASCII and is commonly encountered in world wide web work.
In IBM character code set identification terminology ISO 8859-1 is
also known as CCSID 819 (or sometimes 0819 or even 00819).

large collection of single- and multi-byte coded character sets that are
different from ASCII or ISO 8859-1 and are all slightly different from each
other; they typically run on host computers.  The EBCDIC encodings derive from
8-bit byte extensions of Hollerith punched card encodings.  The layout on the
cards was such that high bits were set for the upper and lower case alphabet
characters [a-z] and [A-Z], but there were gaps within each Latin alphabet
range.

identification numbers (CCSID numbers) or code page numbers.

character sets, listed below.

are often mapped to different integer values.  Those characters
are known as the 13 "variant" characters and are:

guess which EBCDIC character set the platform uses, and adapts itself
accordingly to that platform.  If the platform uses a character set that is not
one of the three Perl knows about, Perl will either fail to compile, or
mistakenly and silently choose one of the three.
They are:

characters (i.e. ISO 8859-1) to an EBCDIC set.  0037 is used
in North American English locales on the OS/400 operating system
that runs on AS/400 computers.  CCSID 0037 differs from ISO 8859-1
in 237 places, in other words they agree on only 19 code point values.

Latin-1 characters (i.e. ISO 8859-1) to an EBCDIC set.  1047 is
used under Unix System Services for OS/390 or z/OS, and OpenEdition
for VM/ESA.  CCSID 1047 differs from CCSID 0037 in eight places.

1047 and 0037.  It is identified below as the POSIX-BC set.

character: for example, in EBCDIC the character "A" is usually assigned
the number 193.  In Unicode the character "A" is assigned the number 65.
This causes a problem with the semantics of the pack/unpack "U", which
are supposed to pack Unicode code points to characters and back to numbers.
The problem is: which code points to use for code points less than 256?
(for 256 and over there's no problem: Unicode code points are used)
In EBCDIC, for the low 256 the EBCDIC code points are used.  This
means that the equivalences

all the possible code points, pack("U",ord("A")) would in EBCDIC
equal 0 or , and unpack("U", "A") would equal
65, or 0, not 193, or ord "A".)

supported under EBCDIC, likewise for the encoding pragma.

UTF-8 is an encoding of Unicode into a sequence of 8-bit byte chunks, based on
ASCII and Latin-1.
The length of a sequence required to represent a Unicode code point
depends on the ordinal number of that code point,
with larger numbers requiring more bytes.
UTF-EBCDIC is like UTF-8, but based on EBCDIC.

This simply means that the character has the same numeric
value when encoded as when not.
(Note that this is a very different concept from 0
mentioned above.)
For example, the ordinal value of 'A' is 193 in most EBCDIC code pages,
and also is 193 when encoded in UTF-EBCDIC.
All variant code points occupy at least two bytes when encoded.
In UTF-8, the code points corresponding to the lowest 128
ordinal numbers (0 - 127: the ASCII characters) are invariant.
In UTF-EBCDIC, there are 160 invariant characters.
(If you care, the EBCDIC invariants are those characters
which have ASCII equivalents, plus those that correspond to
the C1 controls (80..9f on ASCII platforms).)

one encoded in UTF-8.

to translate from EBCDIC to Latin-1 code points.
Encode knows about more EBCDIC character sets than Perl can currently
be compiled to run on.

of PerlIO, see 0.

you to use different encodings per IO channel.  For example you may use

ISO 8859-1 (Latin-1) (in this example identical to ASCII since only ASCII
characters were printed), and
UTF-EBCDIC (in this example identical to normal EBCDIC since only characters
that don't differ between EBCDIC and UTF-EBCDIC were printed).  See the
documentation of Encode::PerlIO for details.

ignores things like the type of your filesystem (ASCII or EBCDIC).

the subsets: C0 controls (0..31), ASCII graphics (32..7e), delete (7f),
C1 controls (80..9f), and Latin-1 (a.k.a. ISO 8859-1) (a0..ff).  In the
table non-printing control character names as well as the Latin 1
extensions to ASCII have been labelled with character names roughly
corresponding to 0 albeit with
substitutions such as s/LATIN// and s/VULGAR// in all cases,
s/CAPITAL LETTER// in some cases, and s/SMALL LETTER ([A-Z])/\l/
in some other cases.  The "names" of the controls listed here are
the Unicode Version 1 names, except for the few that don't have names, in which
case the names in the Wikipedia article were used
(0).
The differences between the 0037 and 1047 sets are
flagged with ***.  The differences between the 1047 and POSIX-BC sets
are flagged with ###.  All  numbers listed are decimal.  If you
would rather see this table listing octal values then run the table
(that is, the pod version of this document since this recipe may not
work with a pod2_other_format translation) through:

might want to write:

run the table through:

ASCII + Latin-1 order then run the table through:

52 in the last line to 61, like this:

61 in the last line to 70, like this:

could use the return value of  or  to test one or more
character values.  For example:

the characters that differ between them.  For example:

of the code sets, e.g.:

from either a CCSID 0037, a 1047, or a POSIX-BC EBCDIC platform since "\r" eq
 under all of those coded character sets.  But note too that
because "\n" is  and "\r" is  on the Macintosh (which is an
ASCII platform) the second 0 test will lead to trouble there.

code page you can use the Config module like so:

another a simple list of numbers, such as in the right columns in the
above table, along with perl's tr/// operator is all that is needed.
The data in the table are in ASCII/Latin1 order, hence the EBCDIC columns
provide easy-to-use ASCII/Latin1 to EBCDIC operations that are also easily
reversed.

second numbers column from the output of recipe 2 (modified to add '\'
characters) and use it in tr/// like so:

arguments like so:

to obtain a 0 table.  The fourth numbers column of the output from
recipe 2 could provide a 0 table suitable for transcoding as
well.

desired numbers column as in recipes 4, 5 or 6, then take the output of the
first numbers column.

available from the shell or from the C library.  Consult your system's
documentation for information on iconv.

shell utility from within perl would be to:

care on EBCDIC platforms.  For example the following array
will have twenty six elements on either an EBCDIC platform
or an ASCII platform:

when operating on string or character data in a perl program running
on an EBCDIC platform than when run on an ASCII platform.  Here is
an example adapted from the one in 0:

in the ASCII table is that they can "literally" be constructed
as control characters in perl, e.g. 0 eq 0
0 eq 0, and so on.  Perl on EBCDIC platforms has been
ported to take 0 to  and 0 to , etc. as well, but the
thirty three characters that result depend on which code page you are
using.  The table below uses the standard acronyms for the controls.
The POSIX-BC and 1047 sets are
identical throughout this range and differ from the 0037 set at only
one spot (21 decimal).  Note that the 0 character
may be generated by 0 on ASCII platforms but by 0 on 1047 or POSIX-BC
platforms and cannot be generated as a 0 control character on
0037 platforms.  Note also that 0 cannot be the final element in a string
or regex, as it will absorb the terminator.   But C<\c\0 is a 0 concatenated with 0 for all 0.

character return value on an EBCDIC platform.  For example:

For example:

encoding.  Examples of usage on EBCDIC include:

print that contain ASCII encodings.  One common place
for this to occur is in the output of the MIME type header for
CGI script writing.  For example, many perl programming guides
recommend something similar to:

you should instead write that as:

by the web server in this case (such code will not be appropriate for
the Macintosh however).  Consult your web server's documentation for
further details.

will be different from their ASCII counterparts when executed
on an EBCDIC platform.  Examples include:

mixed case strings.  This is discussed in more detail below.

of sprintf would be:

[A-Z] and [a-z] have been especially coded to not pick up gap
characters.  For example, characters such as 0 0
that lie between I and J would not be matched by the
regular expression range 0.  This works in
the other direction, too, if either of the range end points is
explicitly numeric: 0 will match 0, even
though 0 is 0 and 0 is 0, and 0
is a gap character from the alphabetic viewpoint.

regular expression try matching the hex or octal code such
as 0 on EBCDIC or 0 on ASCII platforms to
have your regular expression match 0.

octal constants in regular expressions.  Consider the following
set of subs:

However, the concern may be with characters rather than code points
and on an EBCDIC platform it may be desirable for constructs such as
0 to print
out the expected message.  One way to represent the above collection
of character classification subs that is capable of working across the
four coded character sets discussed in this document is as follows:

of coded character set.  Another way to write 0 would be
to use the characters in the range explicitly:

presence of 8 bit characters) or on non ISO-Latin character sets.

byte order.  Exceptions can include CGI script writing under a
host web server where the server may take care of translation for you.
Most host web servers convert EBCDIC data to ISO-8859-1 or Unicode on
output.

are the relative positions of upper and lower case letters and the
letters compared to the digits.  If sorted on an ASCII-based platform the
two-letter abbreviation for a physician comes before the two letter
abbreviation for drive; that is:

even carried to the Latin 1 EBCDIC pages such as 0037 and 1047.
An example would be that 0 0 (203) comes
before 0 0 (235) on an ASCII platform, but
the latter (83) comes before the former (115) on an EBCDIC platform.
(Astute readers will note that the uppercase version of 0
0 is simply "SS" and that the upper case version of
0 0 is not in the 0..255 range but it is
at U+x0178 in Unicode, or 0 in a Unicode enabled Perl).

ASCII platforms versus EBCDIC platforms.  What follows are some suggestions
on how to deal with these differences.

some user education.

0 towards the character set case most employed within the data.
If the data are primarily UPPERCASE non Latin 1 then apply tr/[a-z]/[A-Z]/
then .  If the data are primarily lowercase non Latin 1 then
apply tr/[A-Z]/[a-z]/ before sorting.  If the data are primarily UPPERCASE
and include Latin-1 characters then apply:

address the 0 0 character that will remain at
code point 255 on ASCII platforms, but 223 on most EBCDIC platforms
where it will sort to a place less than the EBCDIC numerals.  With a
Unicode-enabled Perl you might try:

of the data and may not be acceptable for that reason.

connection.

it would be computationally expensive.

mapping that serve a variety of purposes.  Sorting was discussed in the
previous section and a few of the other more popular mapping techniques are
discussed next.

attempt to overcome character or protocol limitation issues.  For example
the tilde character is not on every keyboard hence a URL of the form:

of decoding such a URL under CCSID 1047:

a URL under the 1047 code page:

and apply a full s/// substitution only to the appropriate parts.

but the assignment will not be shown explicitly.  For code page 1047
you could use the @a2e_1047 or @e2a_1047 arrays just shown.

characters equivalent to their ASCII counterparts.  For example, the
following will print "Yes indeed\n" on either an ASCII or EBCDIC computer:

that the @e2a array is filled in appropriately:

the printable set using:

would look somewhat like the following (where the EBCDIC branch @e2a
array is omitted for brevity):

in the EBCDIC branch with the @e2a array and separately in the
ASCII branch without the expense of the identity map).

would look somewhat like the following (where the @a2e array is
omitted for brevity):

dates back thousands of years and was explicitly detailed by Gaius Julius
Caesar in his 0 text.  A single alphabet shift is sometimes
referred to as a rotation and the shift amount is given as a number  after
the string 'rot' or "rot".  Rot0 and rot26 would designate identity maps
on the 26-letter English version of the Latin alphabet.  Rot13 has the
interesting property that alternate subsequent invocations are identity maps
(thus rot13 is its own non-trivial inverse in the group of 26 alphabet
rotations).  Hence the following is a rot13 encoder and decoder that will
work on ASCII and EBCDIC platforms:

hashing order there may be differences between hashes as stored
on an ASCII-based platform and hashes stored on an EBCDIC-based platform.
XXX

in principle even on EBCDIC platforms.  The details are system-dependent
and discussed under the 0 section below.

on EBCDIC platforms in a manner analogous to the way that it works with
the UTF-8 internal encoding form on ASCII based platforms.

of concern to EBCDIC Perl programmers.

executables built for PowerPC AIX in OS/400; see 0.  PASE
is ASCII-based, not EBCDIC-based as the ILE.

one's code page.  See also 0.

See also the  and  manual pages.

are in 0.  {d_setlocale} is 'define' on OS/390
or z/OS.

translation difficulties.  In particular one popular nroff implementation
was known to strip accented characters to their unaccented counterparts
while attempting to view this document through the 0 program
(for example, you may see a plain 0 rather than one with a diaeresis
as in 0).  Another nroff truncated the resultant manpage at
the first occurrence of 8 bit characters.

be concatenated together properly as recipes 0, 2, 4, 5, and 6 might
seem to imply.

0, IBM SC09-2190-00, December 1996.

& Technology, 0, August/September 1999;
ISSN 1523-0309; Multilingual Computing Inc. Sandpoint ID, USA.

Fred B. Wrixon, ISBN 1-57912-040-7, Black Dog & Leventhal Publishers,
1998.

0 Robert Bemer.

with CCSID 0819 and 0037 help from Chris Leach and
Andr0 Pirard A.Pirard@ulg.ac.be as well as POSIX-BC
help from Thomas Dorner Thomas.Dorner@start.de.
Thanks also to Vickie Cooper, Philip Newton, William Raffloer, and
Joe Smith.  Trademarks, registered trademarks, service marks and
registered service marks used in this document are the property of
their respective owners. 

=encoding utf8

and 0.

you're not alone.  The cardinal rule: COMPILE THE PROGRAMS IN EXACTLY
THE SAME WAY THAT YOUR PERL WAS COMPILED.  (Sorry for yelling.)

What's that, you ask?  Perl is itself written in C; the perl library
is the collection of compiled C programs that were used to create your
perl executable (0 or equivalent).  (Corollary: you
can't use Perl from your C program unless Perl has been compiled on
your machine, or installed properly--that's why you shouldn't blithely
copy Perl executables from machine to machine without also copying the
0 directory.)

"run", and deallocate a 0 object, which is defined by
the perl library.

(version 5.002 or later), then the perl library (and 0 and
0, which you'll also need) will reside in a directory
that looks like this:

0, on my Linux box:

incantation is a bit different:

execute a 0 command and pay special attention to the "cc" and
"ccflags" information.

your machine: 0 will tell you what
to use.

(0) for your machine.  If your compiler complains
that certain functions are undefined, or that it can't locate
0, then you need to change the path following the 0.  If it
complains that it can't find 0 and 0, you need to
change the path following the 0.

Perhaps those printed by

0 module will determine all of this information for
you:

you can retrieve it from
http://www.perl.com/perl/CPAN/modules/by-module/ExtUtils/
(If this documentation came from your Perl distribution, then you're
running 5.004 or better and you already have it.)

the examples in this document, tests, additional examples and other
information you may find useful.

(the language), so I'll demonstrate embedding with 0,
included in the source distribution.  Here's a bastardized, non-portable
version of 0 containing the essentials of embedding:

0 as its final argument, 0 here is replaced by
0, which means that the current environment will be used.

tune up of the C runtime environment necessary to run Perl interpreters;
they should only be called once regardless of how many interpreters you
create or destroy. Call  before you create your first
interpreter, and  after you free your last interpreter.

provide 0 as an argument to .

 must be invoked on the C  argc, argv and env and
only once.

like perl itself:

midst of your C program, by placing the filename in 0 before
calling 0.

functions documented in 0.
In this example we'll use 0.

0) and for which I'll ignore the return value (that's the
0).  Those flags, and others, are discussed in 0.

(the beginning of the Unix epoch), and the moment I began writing this
sentence.

the PL_exit_flag PERL_EXIT_DESTRUCT_END which executes END blocks in
perl_destruct.

strings to the 0-terminated 0 list passed to
0.  For other data types, or to examine return values,
you'll need to manipulate the Perl stack.  That's demonstrated in
0.

These are 0 and 0.

snippets of Perl code from within your C program.  Your code can be as
long as you wish; it can contain multiple statements; it can employ
0, 0, and 0 to
include external Perl files.

extract variables for coercion into C types.  The following program,
0, executes three Perl strings, extracting an 0 from
the first, a 0 from the second, and a 0 from the third.

0 to create an 0, 0 to create a 0, and
0 to create a string:

store the computed value of our eval'ed expression.  It is also
possible and in most cases a better strategy to fetch the return value
from 0 instead.  Example:

variables and we've simplified our code as well.

define some functions that use it to "specialize" in matches and
substitutions: 0, 0, and 0.

in your C program might appear as "/\\b\\w*\\b/"), 
returns 1 if the string matches the pattern and 0 otherwise.

0 or 0),  modifies the string
within the 0 as according to the operation, returning the number of substitutions
made.

 evaluates 0 in a list context, and
fills in 0 with the array elements, returning the number of matches found.

been wrapped here):

something about spring-loaded columns of cafeteria plates: the last
thing you pushed on the stack is the first thing you pop off.  That'll
do for our purposes: your C program will push some arguments onto "the Perl
stack", shut its eyes while some magic happens, and then pop the
results--the return value of your Perl subroutine--off the stack.

types, with  and  and  and all their
friends.  They're described in 0 and 0.

described in 0.

make Perl's ** operator available to it (this is less useful than it
sounds, because Perl implements ** with C's 0 function).  First
I'll create a stub exponentiation function in 0:

0 that contains all the perlguts necessary to push the
two arguments into 0 and to pop the return value out.  Take a
deep breath...

applications, it's a good idea to maintain a persistent interpreter
rather than allocating and constructing a new interpreter multiple
times.  The major reason is speed: since Perl will only be loaded into
memory once.

scoping when using a persistent interpreter.  In previous examples
we've been using global variables in the default package 0.  We
knew exactly what code would be run, and assumed we could avoid
variable collisions and outrageous symbol table growth.

code from some arbitrary file.  Your server has no way of knowing what
code it's going to run.  Very dangerous.

constructed interpreter, and subsequently cleaned out with
0 afterwards, you're shielded from most namespace
troubles.

the filename into a guaranteed-unique package name, and then compile
the code into that package using 0.  In the example
below, each file will only be compiled once.  Or, the application
might choose to clean out the symbol table associated with the file
after it's no longer needed.  Using 0, We'll
call the subroutine 0 which lives in the
file 0 and pass the filename and boolean cleanup/cache
flag as arguments.

uses.  In addition, there might be 0ed subroutines and other
conditions that cause Perl's symbol table to grow.  You might want to
add some logic that keeps track of the process size, or restarts
itself after a certain number of requests, to ensure that memory
consumption is minimized.  You'll also want to scope your variables
with 0 whenever possible.

This causes problems for applications that never call perl_run. Since
perl 5.7.2 you can specify 0
to get the new behaviour. This also enables the running of END blocks if
the perl_parse fails and 0 will return the exit value.

try to make this value show up as the program name reported by "ps" by
updating the memory pointed to by the argv passed to  and
also calling API functions like  where available.  This
behaviour might not be appropriate when embedding perl and can be
disabled by assigning the value 0 to the variable 0
before  is called.

when  is assigned to if the 0 assignment is
removed.  This because perl will try to write to the read only memory
of the 0 strings.

during a session.  Such an application might sporadically decide to
release any resources associated with the interpreter.

the next interpreter is constructed.  By default, when perl is not
built with any special options, the global variable
0 is set to 0, since extra cleaning isn't
usually needed when a program only ever creates a single interpreter
in its entire lifetime.

and symbol tables are cleaned up, and global variables are reset.  The
second assignment to 0 is needed because
perl_construct resets it to 0.

same time.  This is feasible, but only if you used the Configure option
0 or the options 0 when
building perl.  By default, enabling one of these Configure options
sets the per-interpreter global variable 0 to
0, so that thorough cleaning is automatic and interpreter variables
are initialized correctly.  Even if you don't intend to run two or
more interpreters at the same time, but to run them sequentially, like
in the above example, it is recommended to build perl with the
0 option otherwise some interpreter variables may
not be initialized correctly between consecutive runs and your
application may crash.

is more appropriate if you intend to run multiple interpreters
concurrently in different threads, because it enables support for
linking in the thread libraries of your system with the interpreter.

the global state that tracks which interpreter is the "current" one on
the particular process or thread that may be running it.  It should
always be used if you have more than one interpreter and are making
perl API calls on both interpreters in an interleaved fashion.

used by a thread that did not create it (using either , or
the more esoteric ).

that 0s a Perl module (such as 0) which itself uses a C or C++ library,
this probably happened:

on its own.  A little glue will help.  Up until now you've been
calling 0, handing it NULL for the second argument:

Perl and linked C/C++ routines.  Let's take a look some pieces of 0
to see how Perl does this:

(determined during its initial configuration on your
computer or when adding a new extension),
a Perl subroutine is created to incorporate the extension's
routines.  Normally, that subroutine is named
0 and is invoked when you say 0.  In
turn, this hooks into an XSUB, 0, which creates a Perl
counterpart for each of the extension's XSUBs.  Don't worry about this
part; leave that to the 0 and extension authors.  If your
extension is dynamically loaded, DynaLoader creates 0
for you on the fly.  In fact, if you have a working DynaLoader then there
is rarely any need to link in any other extensions statically.

add -DPERL_NO_SHORT_NAMES to the compilation flags.  This means that
for example instead of writing

of the 0. )  Hiding the short forms is very useful for avoiding
all sorts of nasty (C preprocessor or otherwise) conflicts with other
software packages (Perl defines about 2400 APIs with these short names,
take or leave few hundred, so there certainly is room for conflict.)

you can always 0 in Perl.  Because you can use
each from the other, combine them as you wish.

<0, with small contributions from Tim Bunce, Tom
Christiansen, Guy Decoux, Hallvard Furuseth, Dov Grobgeld, and Ilya
Zakharevich.

The Perl Journal ( http://www.tpj.com/ ).  Doug is also the developer of the
most widely-used Perl embedding: the mod_perl system
(perl.apache.org), which embeds Perl in the Apache web server.
Oracle, Binary Evolution, ActiveState, and Ben Sugars's nsapi_perl
have used this model for Oracle, Netscape and Internet Information
Server Perl plugins.

Rights Reserved.

documentation provided the copyright notice and this permission notice are
preserved on all copies.

documentation under the conditions for verbatim copying, provided also
that they are marked clearly as modified versions, that the authors'
names and title are unchanged (though subtitles and additional
authors' names may be added), and that the entire resulting derived
work is distributed under the terms of a permission notice identical
to this one.

documentation into another language, under the above conditions for
modified versions. 

=encoding utf8

asked questions about Perl and Perl programming. It's divided by topic
into nine major sections outlined in this document.

you should have the perlfaq. You should also have the 0 tool
that lets you read the 0:

at http://perldoc.perl.org/ .

at http://faq.perl.org/ . The perlfaq-workers periodically post extracts
of the latest perlfaq to comp.lang.perl.misc.

0). The git repository notes all changes to the FAQ and
holds the latest version of the working documents and may vary
significantly from the version distributed with the latest version of
Perl. Check the repository before sending your corrections.

. The perlfaq volunteers use this
address to coordinate their efforts and track the perlfaq development.
They appreciate your contributions to the FAQ but do not have time to
provide individual help, so don't use this address to ask FAQs.

every 6 hours (or so), and the community of volunteers reviews and
updates the answers. If you'd like to help review and update the
answers, check out comp.lang.perl.misc.

to Perl 5 Porters. See 0.

so that everyone can see the work being done (and the work that needs to
be done). The mailing list serves as an official record. If you email the
authors or maintainers directly, you'll probably get a reply asking you
to post to the mailing list. If you don't get a reply, it probably means
that the person never saw the message or didn't have time to deal with
it. Posting to the list allows the volunteers with time to deal with it
when others are busy.

it, try the resources in 0.

help of Nat Torkington. The perlfaq-workers maintain current document
and the denizens of comp.lang.perl.misc regularly review and update the
FAQ. Several people have contributed answers, corrections, and comments,
and the perlfaq notes those contributions wherever appropriate.

brian d foy  wrote this version. See the
individual perlfaq documents for additional copyright information.

examples in all the perlfaq documents are in the public domain. Use
them as you see fit (and at your own risk with no warranty from anyone).

=encoding utf8

about Perl.

written by Larry Wall and a cast of thousands. It derives from the
ubiquitous C programming language and to a lesser extent from sed,
awk, the Unix shell, and at least a dozen other tools and languages.
Perl's process, file, and text manipulation facilities make it
particularly well-suited for tasks involving quick prototyping, system
utilities, software tools, system management tasks, database access,
graphical programming, networking, and world wide web programming.
These strengths make it especially popular with system administrators
and CGI script authors, but mathematicians, geneticists, journalists,
and even managers also use Perl. Maybe you should, too.

beliefs of Perl's author, Larry Wall, gave rise to the free and open
distribution policy of perl. Perl is supported by its users. The
core, the standard Perl library, the optional modules, and the
documentation you're reading now were all written by volunteers. See
the personal note at the end of the README file in the perl source
distribution for more details. See 0 (new as of 5.005)
for Perl's milestone releases.

are a rag-tag band of highly altruistic individuals committed to
producing better software for free than you could hope to purchase for
money. You may snoop on pending developments via the archives at
http://www.xray.mpe.mpg.de/mailing-lists/perl5-porters/
and http://archive.develooper.com/perl5-porters@perl.org/
or the news gateway nntp://nntp.perl.org/perl.perl5.porters or
its web interface at http://nntp.perl.org/group/perl.perl5.porters ,
or read the faq at http://dev.perl.org/perl5/docs/p5p-faq.html ,
or you can subscribe to the mailing list by sending
perl5-porters-subscribe@perl.org a subscription request
(an empty message with no subject is fine).

such thing as "GNU Perl". Perl is not produced nor maintained by the
Free Software Foundation. Perl's licensing terms are also more open
than GNU software's tend to be.

users the informal support will more than suffice. See the answer to
"Where can I buy a commercial version of perl?" for more information.

answer that fits everyone. In general, you want to use either the current
stable release, or the stable release immediately prior to that one.
Currently, those are perl5.14.x and perl5.12.x, respectively.

for you.

new warnings).

so you'll have an easier time finding help for those.

overflows, and in some cases have CERT advisories (for instance,
http://www.cert.org/advisories/CA-1997-17.html ).

you may want to wait a few months after their release and see what
problems others have if you are risk averse.

for a while, although not at the same level as the current releases.

camel carcass (according to this document). Now it's barely a skeleton
as its whitewashed bones have fractured or eroded.

it's ready. The joke is that it's scheduled for Christmas, but that we
just don't know which one. Stay tuned, but don't worry that you'll
have to change major versions of Perl; no one is going to take Perl 5
away from you.

and an experimental version. The maintenance versions are stable, and
have an even number as the minor release (i.e. perl5.10.x, where 10 is the
minor release). The experimental versions may include features that
don't make it into the stable versions, and have an odd number as the
minor release (i.e. perl5.9.x, where 9 is the minor release).

future.

of the perl interpreter as well as the version of the language. Each
major version has significant differences that earlier versions cannot
support.

1994. It can run scripts from the previous major release, Perl 4
(March 1991), but has significant differences. It introduced the
concept of references, complex data structures, and modules. The Perl
5 interpreter was a complete re-write of the previous perl sources.

replace Perl 5. It's still in development in both its syntax and
design. The work started in 2002 and is still ongoing. Some of the
most interesting features have shown up in the latest versions of Perl
5, and some Perl 5 modules allow you to use some Perl 6 syntax in your
programs. The current leading implementation of Perl 6 is Rakudo (
http://rakudo.org ).

Bergman from Fotango in 2003, and subsequently run as a project of The
Perl Foundation. It was abandoned in 2006
( http://www.nntp.perl.org/group/perl.ponie.dev/487 ).

new one that would provide a translation path from Perl 5 to Perl 6
(or anything else that targets Parrot, actually). You would have been
able to just keep using Perl 5 with Parrot, the virtual machine which
will compile and run Perl 6 bytecode.

announced Perl 6 development would begin in earnest. Perl 6 was an oft
used term for Chip Salzenberg's project to rewrite Perl in C++ named
Topaz. However, Topaz provided valuable insights to the next version
of Perl and its implementation, but was ultimately abandoned.

the crusade to make Perl a better place then read the Perl 6 developers
page at http://dev.perl.org/perl6/ and get involved.

for quite awhile after its release. Do not wait for Perl 6 to do whatever
you need to do.

--Larry Wall

are widely tested before release. Since the 5.000 release, we have
averaged only about one production release per year.

internal core of the language, but all possible efforts are made toward
backward compatibility. While not quite all Perl 4 scripts run flawlessly
under Perl 5, an update to perl should nearly never invalidate a program
written for an earlier version of perl (barring accidental bug fixes
and the rare new keyword).

like most programming languages you're likely to have experience
with, so if you've ever written a C program, an awk script, a shell
script, or even a BASIC program, you're already partway there.

the guiding mottos for Perl development is "there's more than one way
to do it" (TMTOWTDI, sometimes pronounced "tim toady"). Perl's
learning curve is therefore shallow (easy to learn) and long (there's
a whole lot you can do if you really want).

definition) an interpreted language, you can write your programs and test
them without an intermediate compilation step, allowing you to experiment
and test/debug quickly and easily. This ease of experimentation flattens
the learning curve even more.

of programming experience, an understanding of regular expressions, and
the ability to understand other people's code. If there's something you
need to do, then it's probably already been done, and a working example is
usually available for free. Don't forget Perl modules, either.
They're discussed in Part 3 of this FAQ, along with CPAN, which is
discussed in Part 2.

are good and bad is often a personal choice, so asking this question
on Usenet runs a strong risk of starting an unproductive Holy War.

set of tasks. These languages have their own newsgroups in which you
can learn about (but hopefully not argue about) them.

if you really can't stop yourself.

task, from one-line file-processing tasks to large, elaborate systems.
For many people, Perl serves as a great replacement for shell scripting.
For others, it serves as a convenient, high-level replacement for most of
what they'd program in low-level languages like C or C++. It's ultimately
up to you (and possibly your management) which tasks you'll use Perl
for and which you won't.

of it available as just another Perl function or variable using a Perl
extension written in C or C++ and dynamically linked into your main
perl interpreter. You can also go the other direction, and write your
main program in C or C++, and then link in some Perl code on the fly,
to create a powerful application. See 0.

languages dedicated to a specific problem domain that are simply more
convenient for certain kinds of problems. Perl tries to be all things
to all people, but nothing special to anyone. Examples of specialized
languages that come to mind include prolog and matlab.

application written in another language that's all done (and done
well), or you have an application language specifically designed for a
certain task (e.g. prolog, make).

embedded systems, low-level operating systems development work like
device drivers or context-switching code, complex multi-threaded
shared-memory applications, or extremely large applications. You'll
notice that perl is not itself written in Perl.

a statically typed one. You certainly won't be chastised if you don't
trust nuclear-plant or brain-surgery monitoring code to it. And Larry
will sleep easier, too--Wall Street programs not withstanding. :-)

signify the language proper and "perl" the implementation of it, i.e.
the current interpreter. Hence Tom's quip that "Nothing but perl can
parse Perl."

referred to the language as "perl", and its name appeared that way in
the title because it referred to the interpreter. In the book, Randal
Schwartz capitalised the language's name to make it stand out better
when typeset. This convention was adopted by the community, and the
second edition became 0, using the capitalized
version of the name to refer to the language.

parallelism means "awk and perl" and "Python and Perl" look good, while
"awk and Perl" and "Python and perl" do not. But never write "PERL",
because perl is not an acronym, apocryphal folklore and post-facto
expansions notwithstanding.

what you give the actors. A program is what you give the audience."

commands--that is, a chat script. Something like a UUCP or PPP chat
script or an expect script fits the bill nicely, as do configuration
scripts run by a program at its start up, such 0 or 0,
for example. Chat scripts were just drivers for existing programs,
not stand-alone programs in their own right.

interpreted and that the only question is at what level. But if you
ask this question of someone who isn't a computer scientist, they might
tell you that a 0 has been compiled to physical machine code
once and can then be run multiple times, whereas a 0 must be
translated by a program each time it's used.

unscrupulous or unknowing marketeers for their own nefarious purposes,
they have begun to take on strange and often pejorative meanings,
like "non serious" or "not real programming". Consequently, some Perl
programmers prefer to avoid them altogether.

to sign email and usenet messages starting in the late 1980s. He
previously used the phrase with many subjects ("Just another x hacker,"),
so to distinguish his JAPH, he started to write them as Perl programs:

programs to produce the same output, spinning things quickly out of
control while still providing hours of amusement for their creators and
readers.

:)

including his usenet postings and source code comments.

http://www.cpan.org/misc/lwall-quotes.txt.gz .

find something that Perl can do to solve one of their problems. That
might mean that Perl either saves them something (time, headaches, money)
or gives them something (flexibility, power, testability).

the people using that language. If you or your team can be faster,
better, and stronger through Perl, you'll deliver more value. Remember,
people often respond better to what they get out of it. If you run
into resistance, figure out what those people get out of the other
choice and how Perl might satisfy that requirement.

available and several popular operating systems come with Perl. Community
support in places such as Perlmonks ( http://www.perlmonks.com )
and the various Perl mailing lists ( http://lists.perl.org ) means that
you can usually get quick answers to your problems.

job. You're a much better advocate if your claims are reasonable and
grounded in reality. Dogmatically advocating anything tends to make
people discount your message. Be honest about possible disadvantages
to your choice of Perl since any choice has trade-offs.

other authors as noted. All rights reserved.

under the same terms as Perl itself.

domain. You are permitted and encouraged to use this code and any
derivatives thereof in your own programs for fun or for profit as you
see fit. A simple comment in the code giving credit to the FAQ would
be courteous but is not required. 

=encoding utf8

source and documentation for Perl, support, and
related matters.

development team) is distributed only in source code form. You
can find the latest releases at http://www.cpan.org/src/README.html .

all known and current Unix derivatives are supported (perl's native
platform), as are other systems like VMS, DOS, OS/2, Windows,
QNX, BeOS, OS X, MPE/iX and the Amiga.

http://www.cpan.org/ports/ directory. Because these are not part of
the standard distribution, they may and in fact do differ from the
base perl port in a variety of ways. You'll have to check their
respective release notes to see just what the differences are. These
differences can be either positive (e.g. extensions for the features
of the particular platform that are not supported in the source
release of perl) or negative (e.g. might be based upon a less current
source release of perl).

should be sacrificed to the Sun gods. But that doesn't help you.

first. Consult the Usenet FAQs for your operating system for
information on where to get such a binary version.

C compiler!) that meets your needs, though:

( http://strawberryperl.com/ ) come with a
bundled C compiler. ActivePerl is a pre-compiled version of Perl
ready-to-use.

applications, including compilers and Perl.

You really should build the whole distribution on the machine it will
eventually live on, and then type 0. Most other
approaches are doomed to failure.

the hard-coded 0 that perl looks through for libraries:

may need to move the appropriate libraries to these locations, or create
symbolic links, aliases, or shortcuts appropriately. 0 is also printed as
part of the output of

0.

It describes in detail how to cope with most idiosyncrasies that the
0 script can't work around for any given system or
architecture.

archive replicated on hundreds of machines all over the world. CPAN
contains source code, non-native ports, documentation, scripts, and
many third-party modules and extensions, designed for everything from
commercial database interfaces to keyboard/screen control to web
walking and CGI scripts. The master web site for CPAN is
http://www.cpan.org/ and there is the CPAN Multiplexer at
http://www.cpan.org/CPAN.html which will choose a mirror near you via
DNS. See http://www.perl.com/CPAN (without a slash at the end) for
how this process works. Also, http://mirror.cpan.org/ has a nice
interface to the http://www.cpan.org/MIRRORED.BY mirror directory.

to the most frequently asked questions about CPAN including how to
become a mirror.

sites. CPAN indicates the base directory of a CPAN mirror, and the
rest of the path is the path from that directory to the file. For
instance, if you're using ftp://ftp.funet.fi/pub/languages/perl/CPAN
as your CPAN site, the file 0 is downloadable as
ftp://ftp.funet.fi/pub/languages/perl/CPAN/misc/japh .

modules in the archive, one probably exists to do nearly anything you
can think of. Current categories under 0
include Perl core modules; development support; operating system
interfaces; networking, devices, and interprocess communication; data
type utilities; database interfaces; user interfaces; interfaces to
other languages; filenames, file systems, and file locking;
internationalization and locale; world wide web support; server and
daemon utilities; archiving and compression; image manipulation; mail
and news; control flow utilities; filehandle and I/O; Microsoft
Windows modules; and miscellaneous modules.

http://search.cpan.org/ for a more complete list of modules by
category.

If you have Perl installed locally, you probably have the documentation
installed as well: type 0 if you're on a system resembling Unix.
This will lead you to other important man pages, including how to set your
0. If you're not on a Unix system, access to the documentation
will be different; for example, documentation might only be in HTML format. All
proper perl installations have fully-accessible documentation.

have a proper 0 command, or it's been misinstalled. If that doesn't
work, try looking in 0 for documentation.

complete documentation in HTML and PDF format.

0 for more details.

include 0 for objects or 0 for a beginner's
approach to objects, 0 for file opening semantics,
0 for managing references, 0 for regular
expressions, 0 for threads, 0 for debugging,
and 0 for linking C and Perl together. There may be more
by the time you read this. These URLs might also be useful:

comp.lang.perl itself officially removed. While that group may still
be found on some news servers, it is unwise to use it, because
postings there will not appear on news servers which honour the
official list of group names. Use comp.lang.perl.misc for topics
which do not have a more-appropriate specific group.

perl.org at nntp://nntp.perl.org , a web interface to the same lists
at http://nntp.perl.org/group/ and these lists are also available
under the 0 hierarchy at http://groups.google.com . Other
groups are listed at http://lists.perl.org/ ( also known as
http://lists.cpan.org/ ).

http://www.perlmonks.org/ , or the Perl Beginners mailing list
http://lists.perl.org/showlist.cgi?name=beginners .

asking questions about particular problems or general advice is fine,
but asking someone to write your code for free is not very cool.

feel free to cross-post to comp.lang.perl.misc. If you want to cross-post
to alt.sources, please make sure it follows their posting standards,
including setting the Followup-To header line to NOT include alt.sources;
see their FAQ ( http://www.faqs.org/faqs/alt-sources-intro/ ) for details.

( http://www.google.com ), Google's Usenet search interface
( http://groups.google.com ), and CPAN Search ( http://search.cpan.org ).
This is faster and more productive than just posting a request.

( http://books.perl.org ).

almost completely (although it sometimes sneaks in an article about
another language). There's also 0 ( http://www.theperlreview.com ), 0 (
http://www.unixreview.com/ ), 0 (
http://www.linuxmagazine.com/ ), and Usenix's newsletter/magazine to
its members, 0 ( http://www.usenix.org/ ).

http://www.stonehenge.com/merlyn/WebTechniques/ ,
http://www.stonehenge.com/merlyn/UnixReview/ , and
http://www.stonehenge.com/merlyn/LinuxMag/ .

Perl, 0 contains tutorials, demonstrations, case
studies, announcements, contests, and much more. 0 has columns
on web development, databases, Win32 Perl, graphical programming,
regular expressions, and networking, and sponsors the Obfuscated Perl
Contest and the Perl Poetry Contests. Beginning in November 2002, 0
moved to a reader-supported monthly e-zine format in which subscribers
can download issues as PDF documents. In 2006, 0 merged with Dr.
Dobbs Journal (online edition). To read old 0 articles, see
http://www.ddj.com/ or brian d foy's index of online TPJ content
( http://www.perlmonks.org/index.pl?node_id=711609 ).

mailing lists. Consult the documentation that came with the module for
subscription information.

content.

same question at some point on c.l.p.m. It requires some time and patience
to sift through all the content but often you will find the answer you
seek.

that you can grab and carefully read to your manager. It is distributed
in releases and comes in well-defined packages. There is a very large
user community and an extensive literature. The comp.lang.perl.*
newsgroups and several of the mailing lists provide free answers to your
questions in near real-time. Perl has traditionally been supported by
Larry, scores of software designers and developers, and myriad
programmers, all working for free to create a useful thing to make life
better for everyone.

purchase order from a company whom they can sue should anything go awry.
Or maybe they need very serious hand-holding and contractual obligations.
Shrink-wrapped CDs with perl on them are available from several sources if
that will help. For example, many Perl books include a distribution of perl,
as do the O'Reilly Perl Resource Kits (in both the Unix flavor
and in the proprietary Microsoft flavor); the free Unix distributions
also all come with perl.

found an actual bug.

in the standard library (those that come with Perl), you can use the
0= 5.004). It collects
information about your installation to include with your message, then
sends the message to the right place.

use the 0 module. It has the information about
the modules (with their versions) included with each release of Perl.

http://perlpunks.de/corelist .

You can submit bugs to RT either through its web interface or by
email. To email a bug report, send it to
bug-0distribution-name0@rt.cpan.org . For example, if you
wanted to report a bug in 0, you could send a message to
bug-Business-ISBN@rt.cpan.org .

Sourceforge or Google Code tracking system, so you should check the
module documentation too.

Network, a subsidiary of O'Reilly Media. Although it retains most of
the original content from its O'Reilly Network, it is now hosted by
The Perl Foundation.

which maintains the web site ( http://www.perl.org/ ) as a general
advocacy site for the Perl language. It uses the domain to provide
general support services to the Perl community, including the hosting
of mailing lists, web sites, and other services. There are also many
other sub-domains for special topics like learning Perl, Perl news,
jobs in Perl, such as:

groups, including the hosting of mailing lists and web sites. See the
Perl Mongers website ( http://www.pm.org/ ) for more information about
joining, starting, or requesting services for a Perl user group.

http://www.cpan.org/ ), is a replicated, worldwide repository of Perl
software. See 0 in 0.

other authors as noted. All rights reserved.

under the same terms as Perl itself.

domain. You are permitted and encouraged to use this code and any
derivatives thereof in your own programs for fun or for profit as you
see fit. A simple comment in the code giving credit to the FAQ would
be courteous but is not required. 

=encoding utf8

and programming support.

someone has already written a module that can solve your problem.
Have you read the appropriate manpages?  Here's a brief index:

0 manpage, on an "empty" program, like this:

evaluated.  You can also examine the symbol table, get stack
backtraces, check variable values, set breakpoints, and other
operations typically found in symbolic debuggers.

that combines the interactive nature of a Unix shell with the power of
Perl. The goal is a full-featured shell that behaves as expected for
normal shell activity and uses Perl syntax and functionality for
control-flow statements and other things. You can get 0 at
http://sourceforge.net/projects/psh/ .

configured in perl and operated in perl. It is intended as a login shell
and development environment. It can be found at
http://pardus-larus.student.utwente.nl/~pardus/projects/zoidberg/
or your local CPAN mirror.

which aren't part of the Perl language as shell commands.  0 from
the source distribution is simplistic and uninteresting, but may still
be what you want.

that 0 understands and can use to re-install every module:

show all installed distributions, although it can take awhile to do
its magic.  The standard library which comes with Perl just shows up
as "Perl" (although you can get those with 0).

can use 0:

with 0 which is part of the standard library:

available, you can check for its documentation.  If you can
read the documentation the module is most likely installed.
If you cannot read the documentation, the module might not
have any (in rare cases):

perl finds it:

you let Perl tell you about problem areas in your code. By turning
on warnings and strictures, you can head off many problems before
they get too big. You can find out more about these in 0
and 0.

to look at values as you run your program:

0 switch. It's fully explained in 0.

0. It's on CPAN and available for free.

Brocard's 0 (which you can call with the 0 switch as 0)
gives you the programmatic hooks into everything you need to write your
own (without too much pain and suffering).

from Activestate (Windows and Mac OS X), or EPIC (most platforms).

profile your Perl programs. The 0 module comes with Perl
and you can invoke it with the 0 switch:

with the profile data. To look at the data, you can turn it into a
human-readable report with the 0 program that comes with
0.

switch to 0:

and subroutine profiling. It's available from CPAN and you also invoke
it with the 0 switch:

can turn into reports. The 0 command turns the data into
an HTML report similar to the 0 report:

fashion. You might also be interested in using the 0 to
measure and compare code snippets.

or 0, chapter 5.

create a special sort of profiler. brian d foy describes the process
in 0, "Creating a Perl Debugger",
http://www.ddj.com/184404522 , and "Profiling in Perl"
http://www.ddj.com/184404580 .

by Simon Cozens, http://www.perl.com/lpt/a/850 and "Debugging and
Profiling mod_perl Applications", by Frank Wiles,
http://www.perl.com/pub/a/2006/02/09/debug_mod_perl.html .

Programs" for 0,
http://www.stonehenge.com/merlyn/UnixReview/col49.html , and "Profiling
in Template Toolkit via Overriding" for 0,
http://www.stonehenge.com/merlyn/LinuxMag/col75.html .

for Perl programs.

to make them easier to read by trying to follow the rules of the
0. If you write Perl scripts, or spend much time reading
them, you will probably find it useful.  It is available at
http://perltidy.sourceforge.net .

you shouldn't need to reformat.  The habit of formatting your code
as you write it will help prevent bugs.  Your editor can and should
help you with this.  The perl-mode or newer cperl-mode for emacs
can provide remarkable amounts of help with most (but not all)
code, and even less programmable editors can provide significant
assistance.  Tom Christiansen and many other VI users swear by
the following settings in vi and its clones:

with control characters) and away you go.  In insert mode, ^T is
for indenting, ^D is for undenting, and ^O is for blockdenting--as
it were.  A more complete example, with comments, can be found at
http://www.cpan.org/authors/id/TOMC/scripts/toms.exrc.gz

lots of things related to generating nicely printed output of
documents.

popular editors support ctags for several different languages,
including Perl.

philosophy is the philosophy of several small tools that each do one
thing and do it well.  It's like a carpenter's toolbox.

order of preference):

editing/debugging with Eclipse.

environment (IDE) for creating, testing, and  debugging  Perl scripts;
the tool runs on Windows 9x/NT/2000/XP or later.

and Solaris), multi-language IDE has Perl support, including a regular expression
debugger and remote debugging.

and debugging Perl scripts with ActiveState's ActivePerl distribution
under Windows 95/98/NT/2000.

debugger and syntax-highlighting editor.

a native look and feel. It's open source under the Artistic License.

supports Perl development.

that comes with support for Perl.

already, and possibly an emacs too, so you may not need to download
anything. In any emacs the cperl-mode (M-x cperl-mode) gives you
perhaps the best available Perl editing mode in any editor.

with plain text, such as NotePad or WordPad. Word processors, such as
Microsoft Word or WordPerfect, typically do not work since they insert
all sorts of behind-the-scenes information, although some allow you to
save files as "Text Only". You can also download text editors designed
specifically for programming, such as Textpad (
http://www.textpad.com/ ) and UltraEdit ( http://www.ultraedit.com/ ),
among others.

environments) comes with a simple editor. Popular external editors are
BBEdit ( http://www.bbedit.com/ ) or Alpha (
http://www.his.com/~jguyer/Alpha/Alpha8.html ). MacOS X users can use
Unix editors as well.

yet another vi clone, unfortunately not available for Windows, but in
Unix platforms you might be interested in trying it out, firstly because
strictly speaking it is not a vi clone, it is the real vi, or the new
incarnation of it, and secondly because you can embed Perl inside it
to use Perl as the scripting language.  nvi is not alone in this,
though: at least also vim and vile offer an embedded Perl.

that is distributed with the Tk module on CPAN.  The ptkdb
( http://ptkdb.sourceforge.net/ ) is a Perl/Tk-based debugger that
acts as a development environment of sorts.  Perl Composer
( http://perlcomposer.sourceforge.net/ ) is an IDE for Perl/Tk
GUI creation.

powerful shell environment for Win32.  Your options include

the U/WIN environment ( http://www.research.att.com/sw/tools/uwin/ )

http://www.primate.wisc.edu/software/csh-tcsh-book/

research purposes), Cygwin is covered by the GNU General Public
License (but that shouldn't matter for Perl use).  The Cygwin, MKS,
and U/WIN all contain (in addition to the shells) a comprehensive set
of standard Unix toolkit utilities.

be sure to transfer them in ASCII mode so the ends of lines are
appropriately converted.

that behaves like a rudimentary IDE.  In contrast to the MacPerl Application
the MPW Perl tool can make use of the MPW Shell itself as an editor (with
no 32k limit).

( http://www.latenightsw.com ).

built-in support for several popular markup and programming languages,
including Perl and HTML ( http://www.his.com/~jguyer/Alpha/Alpha8.html ).

( http://web.barebones.com/ ).

see http://www.cpan.org/authors/Tom_Christiansen/scripts/toms.exrc.gz ,
the standard benchmark file for vi emulators.  The file runs best with nvi,
the current version of vi out of Berkeley, which incidentally can be built
with an embedded Perl interpreter--see http://www.cpan.org/src/misc/ .

0

perl-mode.el and support for the Perl debugger built in.  These should
come with the standard Emacs 19 distribution.

(single quote), and mess up the indentation and highlighting.  You
are probably using 0 in new Perl code anyway, so this
shouldn't be an issue.

module interface to a curses library.  A small demo can be found at the
directory http://www.cpan.org/authors/Tom_Christiansen/scripts/rep.gz ;
this program repeats a command and updates the screen as needed, rendering
0 similar to 0.

0 0 0 0 0 0 0 0

GUI toolkits have a perl interface: an incomplete list follows.

look half as bad under Windows as it used to. Some of the gui elements
still don't 'feel' quite right, though. The interface is very natural
and 'perlish', making it easy to use in small scripts that just need a
simple gui. It hasn't been updated in a while.

( http://www.wxwidgets.org ). It works under Unix, Win32 and Mac OS X,
using native widgets (Gtk under Unix). The interface follows the C++
interface closely, but the documentation is a little sparse for someone
who doesn't know the library, mostly just referring you to the C++
documentation.

interface changed significantly between versions 1 and 2 so they have
separate Perl modules. It runs under Unix, Win32 and Mac OS X (currently
it requires an X server on Mac OS, but a 'native' port is underway), and
the widgets look the same on every platform: i.e., they don't match the
native widgets. As with Wx, the Perl bindings follow the C API closely,
and the documentation requires you to read the C documentation to
understand it.

Obviously, it only runs under Win32, and uses native widgets. The Perl
interface doesn't really follow the C interface: it's been made more
Perlish, and the documentation is pretty good. More advanced stuff may
require familiarity with the C Win32 APIs, or reference to MSDN.

Mac OS X's Cocoa GUI toolkit, and as such can be used to produce native
GUIs on Mac OS X. It's not on CPAN, as it requires frameworks that
CPAN.pm doesn't know how to install, but installation is via the
standard OSX package installer. The Perl API is, again, very close to
the ObjC API it's wrapping, and the documentation just tells you how to
translate from one to the other.

appear to be maintained.

again it appears not to be much used nowadays.

can often make a dramatic difference.  Jon Bentley's book
0 (that's not a misspelling!)  has some good tips
on optimization, too.  Advice on benchmarking boils down to: benchmark
and profile to make sure you're optimizing the right part, look for
better algorithms instead of microtuning your code, and when all else
fails consider just buying faster hardware.  You will probably want to
read the answer to the earlier question "How do I profile my Perl
programs?" if you haven't done so already.

AutoSplit and AutoLoader modules in the standard distribution for
that.  Or you could locate the bottleneck and think about writing just
that part in C, the way we used to take bottlenecks in C code and
write them in assembler.  Similar to rewriting in C, modules that have
critical sections can be written in C (for instance, the PDL module
from CPAN).

0, you can often gain a 10-25% performance benefit by
rebuilding it to link with a static libc.a instead.  This will make a
bigger perl executable, but your Perl programs (and programmers) may
thank you for it.  See the 0 file in the source distribution
for more information.

storing the already-compiled form to disk.  This is no longer a viable
option, as it only worked on a few architectures, and wasn't a good
solution anyway.

throw memory at a problem.  Scalars in Perl use more memory than
strings in C, arrays take more than that, and hashes use even more.  While
there's still a lot to be done, recent releases have been addressing
these issues.  For example, as of 5.004, duplicate hash keys are
shared amongst all hashes using them, so require no reallocation.

highly beneficial.  For example, an array of a thousand booleans will
take at least 20,000 bytes of space, but it can be turned into one
125-byte bit vector--a considerable memory savings.  The standard
Tie::SubstrHash module can also help for certain types of data
structure.  If you're working with specialist data structures
(matrices, for instance) modules that implement these in C may use
less memory than equivalent Perl modules.

the system malloc or with Perl's builtin malloc.  Whichever one it
is, try using the other one and see whether this makes a difference.
Information about malloc is in the 0 file in the source
distribution.  You can find out whether you are using perl's malloc by
typing 0.

it in the first place. Good programming practices can go a long way
toward this:

by line. Or more concretely, use a loop like this:

way you do it, but it makes a huge difference when they start getting
larger.

to loop:

quotes), whereas

the only way to pass multiple lists or hashes (or both) in a single
call/return. It also avoids creating a copy of all the contents. This
requires some judgement, however, because any changes will be propagated
back to the original data. If you really want to mangle (er, modify) a
copy, you'll have to sacrifice the memory needed to make one.

using one of the DB modules to store it on disk instead of in RAM. This
will incur a penalty in access time, but that's probably better than
causing your hard disk to thrash due to massive swapping.

everything works out right.

cannot be reclaimed or reused even if they go out of scope. It is
reserved in case the variables come back into scope. Memory allocated
to global variables can be reused (within your program) by using
 and/or .

returned to the system. That's why long-running programs sometimes re-
exec themselves. Some operating systems (notably, systems that use
 for allocating large chunks of memory) can reclaim memory that
is no longer used, but on such systems, perl must be configured and
compiled to use the OS's malloc, not perl's.

or should be worrying about much in Perl.

faster or smaller, a CGI program has additional issues.  It may be run
several times per second.  Given that each time it runs it will need
to be re-compiled and will often allocate a megabyte or more of system
memory, this can be a killer.  Compiling into C 0 because the process start-up overhead is where the bottleneck is.

involves running the Apache HTTP server (available from
http://www.apache.org/ ) with either of the mod_perl or mod_fastcgi
plugin modules.

mod_perl), httpd will run with an embedded Perl interpreter which
pre-compiles your script and then executes it within the same address
space without forking.  The Apache extension also gives Perl access to
the internal server API, so modules written in Perl can do just about
anything a module written in C can.  For more on mod_perl, see
http://perl.apache.org/

module (available from http://www.fastcgi.com/ ) each of your Perl
programs becomes a permanent CGI daemon process.

and on the way you write your CGI programs, so investigate them with
care.

http://www.cpan.org/modules/by-category/15_World_Wide_Web_HTML_HTTP_CGI/ .

unsatisfactory) solutions with varying levels of "security".

the source code has to be readable in order to be compiled and
interpreted.  (That doesn't mean that a CGI script's source is
readable by people on the web, though--only by people with access to
the filesystem.)  So you have to leave the permissions at the socially
friendly 0755 level.

insecure things and relies on people not knowing how to exploit those
insecurities, it is not secure.  It is often possible for someone to
determine the insecure things and exploit them without viewing the
source.  Security through obscurity, the name for hiding your bugs
instead of fixing them, is little security indeed.

5.8 the Filter::Simple and Filter::Util::Call modules are included in
the standard distribution), but any decent programmer will be able to
decrypt it.  You can try using the byte code compiler and interpreter
described later in 0, but the curious might still be able to
de-compile it. You can try using the native-code compiler described
later, but crackers might be able to disassemble it.  These pose
varying degrees of difficulty to people wanting to get at your code,
but none can definitively conceal it (true of every language, not just
Perl).

feed the program to the perl interpreter and use the modules in
the B:: hierarchy.  The B::Deparse module should be able to
defeat most attempts to hide source.  Again, this is not
unique to Perl.

bottom line is that nothing but a restrictive license will give you
legal security.  License your software and pepper it with threatening
statements like "This is unpublished proprietary software of XYZ Corp.
Your access to it does not give you permission to use it blah blah
blah."  We are not lawyers, of course, so you should see a lawyer if
you want to be sure your license's wording will stand up in court.

for your situation though.  People usually ask this question
because they want to distribute their works without giving away
the source code, and most solutions trade disk space for convenience.
You probably won't see much of a speed increase either, since most
solutions simply bundle a Perl interpreter in the final product
(but see 0).

analog to Java's JAR.  It's freely available and on CPAN (
http://search.cpan.org/dist/PAR/ ).

you have to buy a license for them.

from ActiveState can "Turn your Perl programs into ready-to-run
executables for HP-UX, Linux, Solaris and Windows."

program for converting perl scripts to executable files.  It targets both
Windows and Unix platforms.

"extproc" handling).  For DOS one should first invent a corresponding
batch file and codify it in 0 (see the
0 file in the source distribution for more information).

will modify the Registry to associate the 0 extension with the
perl interpreter.  If you install another port, perhaps even building
your own Win95/NT Perl from the standard sources by using a Windows port
of gcc (e.g., with cygwin or mingw32), then you'll have to modify
the Registry yourself.  In addition to associating 0 with the
interpreter, NT people can use: 0 to let them
run the program 0 merely by typing 0.

Type, so that double-clicking them will invoke the MacPerl application.
Under Mac OS X, clickable apps can be made from any 0 script using Wil
Sanchez' DropScript utility: http://www.wsanchez.net/software/ .

throw the perl interpreter into your cgi-bin directory, in order to
get your programs working for a web server.  This is an EXTREMELY big
security risk.  Take the time to figure out how to do it correctly.

(These assume standard Unix shell quoting rules.)

have rather different ideas about quoting than the Unix shells under
which the one-liners were created.  On some systems, you may have to
change single-quotes to double ones, which you must 0 do on Unix
or Plan9 systems.  You might also have to change a single % to a %%.

command interpreter.  Under Unix, the first two often work. Under DOS,
it's entirely possible that neither works.  If 4DOS was the command shell,
you'd probably have better luck like this:

shell, or MPW, is much like Unix shells in its support for several
quoting variants, except that it makes free use of the Mac's non-ASCII
characters as control characters.

quotes', and `backticks`, may make one-liners easier to write.

see the two especially dedicated to web stuff in the question on
books.  For problems and questions related to the web, like "Why
do I get 500 Errors" or "Why doesn't it run from the browser right
when it runs fine on the command line", see the troubleshooting
guides and references in 0 or in the CGI MetaFAQ:

0, 0, 0, and 0 for reference.

by Damian Conway from Manning Publications, or "Intermediate Perl"
by Randal Schwartz, brian d foy, and Tom Phoenix from O'Reilly Media.

moving on to 0, 0, and 0.  If you want to
call Perl from C, then read 0, 0, and
0.  Don't forget that you can learn a lot from looking at
how the authors of existing extension modules wrote their code and
solved their problems.

you put C code directly in your Perl source. It handles all the
magic to make it work. You still have to learn at least some of
the perl API but you won't have to deal with the complexity of the
XS support files.

the tests pass, read the pods again and again and again.  If they
fail, see 0 and send a bug report with the output of
0 along with 0.

text can be found in 0. You can also use the splain program
(distributed with Perl) to explain the error messages:

turns a Perl script, typically called 0, into a Makefile.
The Unix tool 0 uses this file to manage dependencies and actions
to process and install a Perl distribution.

other authors as noted. All rights reserved.

under the same terms as Perl itself.

domain.  You are permitted and encouraged to use this code and any
derivatives thereof in your own programs for fun or for profit as you
see fit.  A simple comment in the code giving credit to the FAQ would
be courteous but is not required. 

=encoding utf8

numbers, dates, strings, arrays, hashes, and miscellaneous data issues.

Scientist Should Know About Floating-Point Arithmetic"
(0).

Digital (as in powers of two) computers cannot store all numbers
exactly.  Some real numbers lose precision in the process.  This is a
problem with how computers store numbers and affects all computer
languages, not just Perl.

conversions.

0 or 0 function.  See
0 for more details.

aren't quite what you think.

(eg, 19.9499999999999) instead of the numbers I should be getting
(eg, 19.95)?".

numbers as 0.6 and 0.2 cannot be presented exactly by floating-point
numbers.  What you think in the above as 'three' is really more like
2.9999999999999995559.

converts as a decimal number. When Perl converts a string to a number, it
ignores leading spaces and zeroes, then assumes the rest of the digits
are in base 10:

same name a Unix command that uses octal numbers as arguments on the
command line. In this example, 0 on the command line knows that
its first argument is octal because that's what it does:

Perl to treat them as octal numbers either by prefixing the digits with
a 0 or using 0:

thinks is a string, such as a command line argument in 0:

notation to ensure it matches what you think it should be. Print it
in octal  and decimal format:

certain number of digits, 0 or 0 is usually the
easiest route.

implements 0, 0, and a number of other mathematical
and trigonometric functions.

module.  With 5.004, the 0 module (part of the standard Perl
distribution) implements the trigonometric functions. Internally it
uses the 0 module and some functions can break out from
the real axis into the complex plane, for example the inverse sine of
2.

the rounding method used should be specified precisely.  In these
cases, it probably pays not to trust whichever system of rounding is
being used by Perl, but instead to implement the rounding function you
need yourself.

alternation:

this. Perl numbers whose absolute values are integers under 2**31 (on
32-bit machines) will work pretty much like mathematical integers.
Other numbers are not guaranteed.

few examples of approaches to making common conversions between number
representations.  This is intended to be representational rather than
exhaustive.

module from CPAN. The reason you might choose 0 over the
perl built-in functions is that it works with numbers of ANY size,
that it is optimized for speed on some operations, and for at least
some programmers the notation might be familiar.

the 0 notation:

are left as an exercise to the inclined reader.

used on numbers or strings.  The operators treat a string as a series
of bits and work with that (the string 0 is the bit pattern
0).  The operators work with the binary form of a number
(the number 0 is treated as the bit pattern 0).

0).  Saying 0 performs the "and" operation on strings
(yielding 0).

they have a number but really it's a string or vice versa.  To avoid this,
stringify the arguments explicitly (using 0 or 0) or convert them
to numbers explicitly (using 0) is not a false value in Perl.  You need:

or the 0 extension (also available from CPAN).

results, use:

results:

all integers in the range.  This can take a lot of memory for large
ranges.  Instead use:

loop will iterate over the range, without creating the entire range.

once at the start of your program to seed the random number generator.

call 0 more than once--you make your numbers less random,
rather than more.

(despite appearances caused by bugs in your programs :-).  The
0 article in the "Far More Than You Ever Wanted To Know"
collection in 0, courtesy
of Tom Phoenix, talks more about this.  John von Neumann said, "Anyone
who attempts to generate random numbers by deterministic means is, of
course, living in a state of sin."

provides, you should also check out the 0 module from
CPAN.  It uses the imperfections in your system's timer to generate
random numbers, but this takes quite a while.  If you want a better
pseudorandom generator than comes with your operating system, look at
"Numerical Recipes in C" at 0.

built-in to get a random number between 0 and 1. From there, you shift
that into the range that you want.

what you want to have perl figure out is a random number in the range
from 0 to the difference between your 0 and 0.

random number between 0 and 5 that you can then add to 10.

that. It selects a random integer between the two given
integers (inclusive), For example: 0.

by the 0 function. Without an
argument 0 uses the current time.

week of the year.

a time in epoch seconds for the argument to 0.

0 that returns an object:

extended in a non-standard way to use a 0 format, which they
sometimes claim is the "century". It isn't, because on most such
systems, this is only the first two digits of the four-digit year, and
thus cannot be used to determine reliably the current century or
millennium.

Life isn't always that simple though.

with a version that returns an object. It also overloads the comparison
operators so you can compare them directly:

0 object:

0, or 0 modules can help you.

you can split it up and pass the parts to 0 in the standard
0 module.  Otherwise, you should look into the 0,
0, and 0 modules from CPAN.

which can convert a date/time to a Julian Day:

Julian day):

that you really want to find a Julian day, though, as many people have
different ideas about Julian days (see http://www.hermetic.ch/cal_stud/jdn.htm
for instance):

0 0 0 0 0
0 0 0 0
0

work with calendars instead of times. The 0 module makes it
simple, and give you the same time of day, only the day before,
despite daylight saving time changes:

function.

dates, but that assumes that days are twenty-four hours each.  For
most people, there are two days a year when they aren't: the switch to
and from summer time throws this off. For example, the rest of the
suggestions will be wrong sometimes:

of the standard distribution, so you might think that you could do
something like this:

object, and 0 exports the 0 constant that is a
set number of seconds. This means that it always gives the time 24
hours ago, which is not always yesterday. This can cause problems
around the end of daylight saving time when there's one day that is 25
hours long.

answer for those same special cases:

from creating Y2K problems on their own. See the documentation for
0 for its proper use.

03:14:08 January 19, 2038, when a 32-bit based time would overflow. You
still might get a warning on a 32-bit 0:

running projects:

though.

want to accept. Besides the specific examples that we cover in the
perlfaq, you can also look at the modules with "Assert" and "Validate"
in their names, along with other modules such as 0.

as 0, 0, 0,
and 0.

with in 0.  Shell escapes with the backslash (0)
character are removed with

runs of characters) and replace them with a single instance. In this
substitution, we find a character in 0. The memory parentheses
store the matched character in the back-reference 0 and we use
that to require that the same thing immediately follow it. We replace
that part of the string with the character in 0.

example, the search list side of our 0 contains nothing, but
the 0 option complements that so it contains everything. The
replacement list also contains nothing, so the transliteration is
almost a no-op since it won't do any replacements (or more exactly,
replace the character with itself). However, the 0 option squashes
duplicated and consecutive characters in the string so a character
does not show up next to itself

thing to read, it does work. In each of these examples, we call the
function inside the braces used to dereference a reference. If we
have more than one return value, we can construct and dereference an
anonymous array. In this case, we call the function in list context.

more work. We can really have any code we like inside the braces, so
we simply have to end with the scalar reference, although how you do
that is up to you, and you can use code inside the braces. Note that
the use of parens creates a list context, so we need 0 to
force the scalar context on the function:

the reference yourself.

specify a variable name, in this case 0, to set up a tied hash that
does the interpolation for you. It has several other methods to do this
as well.

which also forces scalar context.

matter how complicated.  To find something between two single
characters, a pattern like 0 will get the intervening
bits in . For multiple ones, then something more like
0 would be needed. But none of these deals with
nested patterns.  For balanced expressions using 0, 0, 0 or
 as delimiters, use the CPAN module Regexp::Common, or see
0.  For other cases, you'll have to write a
parser.

modules or oddities that will make your life a lot easier.  There are
the CPAN modules 0, 0, and
0; and the 0 program. Starting from perl 5.8
the 0 is part of the standard distribution.

pull out the smallest nesting parts one at a time:

expression engine do it for you.  This is courtesy Dean Inada, and
rather has the nature of an Obfuscated Perl Contest entry, but it
really does work:

0.

distribution).

newlines.  0 doesn't justify the lines (flush-right).

easily done by making a shell alias, like so:

capabilities.

To get the first character, for example, start at position 0
and grab the string of length 1.

argument which is the replacement string.

to change the fifth occurrence of 0 or 0 into
0 or 0, case insensitively.  These
all assume that  contains the string to be altered.

loop, keeping count of matches.

repetition count and repeated pattern like this:

count of a certain single character (X) within a string, you can use the
0 function like so:

if you are trying to count multiple character substrings within a
larger string, 0 won't work.  What you can do is wrap a 
loop around a global pattern match.  For example, let's count negative
integers:

result to a scalar, producing a count of the number of matches.

0 0 0 0

for you.

are in there? Wait for it... wait for it.... If you answered 5
you're right. Perl words are groups of 0, but that's not what
you want to capitalize. How is Perl supposed to know not to capitalize
that 0 after the apostrophe? You could try a regular expression:

0 and get on with the next problem. :)

0, 0, and 0, among others.

comma-separated into its different fields. You can't use 0
because you shouldn't split if the comma is inside quotes.  For
example, take a data line like this:

problem.  Thankfully, we have Jeffrey Friedl, author of
0, to handle these for us.  He
suggests (assuming your string is contained in 0):

quotation-mark-delimited field, escape them with backslashes (eg,
0.

Perl distribution) lets you say:

replace all the leading or trailing whitespace with nothing. You
can do that with a pair of substitutions:

out the combined statement is slower than the separate ones. That
might not matter to you, though:

beginning or the end of the string since the anchors have a lower
precedence than the alternation. With the 0 flag, the substitution
makes all possible matches, so it gets both. Remember, the trailing
newline matches the 0, and  the 0 anchor can match to the
absolute end of the string, so the newline disappears too. Just add
the newline to the output, which has the added benefit of preserving
"blank" (consisting entirely of whitespace) lines which the 0
would remove all by itself:

logical line in the string by adding the 0 flag (for
"multi-line"). With the 0 flag, the 0 matches 0 an
embedded newline, so it doesn't remove it. This pattern still removes
the newline at the end of the string:

since the first part of the alternation can match the entire string
and replace it with nothing. If you need to keep embedded blank lines,
you have to do a little more work. Instead of matching any whitespace
(since that includes a newline), just match the other whitespace:

to pad the string, 0 or 0 contains the string to be padded,
and 0 contains the padding character. You can use a single
character string constant instead of the 0 variable if you
know what it is in advance. And in the same way you can use an integer in
place of 0 if you know the pad length in advance.

or right with blanks and on the left with zeroes and it will not
truncate the result. The 0 function can only pad strings on the
right with blanks and it will truncate the result to a maximum length of
0.

one of the following methods.  They all generate a pad string with the
0 operator and combine that with 0. These methods do
not truncate 0.

use 0 to extract a single column.

some other delimiter, as long as whitespace or the delimiter cannot
appear as part of the data.

that format is a bit more complicated. Use one of the modules that
handle that format, such as 0, 0, or
0.

0 with the A (ASCII) format. By using a number after the format
specifier, you can denote the column width. See the 0 and 0
entries in 0 for more details.

spaces. If you have space separated data, you may want 0 instead.

matching, you might also try the 0, and
0, and 0 modules.

such as 0 or 0 Toolkit, do that instead. You
might even be able to get the job done with 0 or 0:

full templating system, I'll use a string that has two Perl scalar
variables in it. In this example, I want to expand 0 and 0
to their variable's values:

0 flag.  The first 0 evaluates 0 on the replacement side and
turns it into 0. The second /e starts with 0 and replaces
it with its value. 0, then, turns into 'Fred', and that's finally
what's left in the string:

undefined variable names with the empty string. Since I'm using the
0 flag (twice even!), I have all of the same security problems I
have with 0 in its string form. If there's something odd in
0, perhaps something like 0, then
I could get myself in trouble.

a hash instead of evaluating variable names. Using a single 0, I
can check the hash to ensure the value exists, and if it doesn't, I
can replace the missing value with a marker, in this case 0 to
signal that I missed something:

stringification--coercing numbers and references into strings--even
when you don't want them to be strings.  Think of it this way:
double-quote expansion is used to produce new strings.  If you already
have a string, why do you need more?

the simpler and more direct:

the thing in the scalar is actually neither a string nor a number, but
a reference:

that actually do care about the difference between a string and a
number, such as the magical 0 autoincrement operator or the
 function.

can do this:

If you want that indented also, you'll have to quote
in the indentation.

follows.  It expects to be called with a here document as its argument.
It looks to see whether each line begins with a common substring, and
if so, strips that substring off.  Otherwise, it takes the amount of leading
whitespace found on the first line and removes that much off each
subsequent line.

indentation correctly preserved:

holds a variable collection of scalars. An array can supply its collection
for list operations, so list operations also work on arrays:

or subtracts some scalars, only work on arrays. These can't work on a
list, which is fixed. Array operations include 0, 0,
0, 0, and 0.

can change a list element. However, the list element is the variable, not
the data. You're not changing the list element, but something the list
element refers to. The list element itself doesn't change: it's still
the same variable.

a scalar to get the number of elements in the array. This only works
for arrays, though:

get a quite different result. Although it looks like you have a list
on the righthand side, Perl actually sees a bunch of scalars separated
by a comma:

context. The comma operator (yes, it's an operator!) in scalar
context evaluates its lefthand side, throws away the result, and
evaluates it's righthand side and returns the result. In effect,
that list-lookalike assigns to 0 it's rightmost value. Many
people mess this up because they choose a list-lookalike whose
last element is also the count they expect:

array name. The 0 sigil means "exactly one item", while the 0
sigil means "zero or more items". The 0 gets you a single scalar,
while the 0 gets you a list.

denotes the variable type.

to return the item in index 1 (or undef if there is no item there).
If you intend to get exactly one element from the array, this is the
form you should use.

You can pull out multiple elements simultaneously by specifying
additional indices as a list, like 0.

context to the righthand side. This can lead to unexpected results.
For instance, if you want to read a single line from a filehandle,
assigning to a scalar value is fine:

lines as a list. The first line goes into 0 and the rest
of the lines mysteriously disappear:

you use an array slice with a single index.

"hash keys".

create the hash then extract the keys. It's not important how you
create that hash: just that you use 0 to get the unique
elements.

0. In list context it returns the unique elements,
preserving their order in the list. In scalar context, it returns the
number of unique elements.

before. Use a hash to keep track. The first time the loop sees an
element, that element has no key in 0. The 0 statement
creates the key and immediately uses its value, which is 0, so
the loop continues to the 0 and increments the value for that
key. The next time the loop sees that same element, its key exists in
the hash 0 the value for that key is true (since it's not 0 or
0), so the next skips that iteration and the loop goes to the
next element.

same thing.

used a hash, not a list or array, to store your data.  Hashes are
designed to answer this question quickly and efficiently.  Arrays aren't.

and later, you can use the smart match operator to check that an item is
contained in an array or a hash:

are going to make this query many times over arbitrary string values,
the fastest way is probably to invert the original array and maintain a
hash whose keys are the first array's values:

been a good idea to keep the blues all in a hash in the first place.

array.  This kind of an array will take up less space:

quite a lot of space by using bit strings instead:

of the original list or array.  They only pay off if you have to test
multiple values against the same array.

the function 0 for this purpose.  It works by stopping once it
finds the element. It's written in C for speed, and its Perl equivalent
looks like this subroutine:

(which returns the number of items that passed its condition) to traverse the
entire list. This does have the benefit of telling you how many matches it
found, though.

list context.

element is unique in a given array:

in either A or in B but not in both.  Think of it as an xor operation.

with the least amount of work:

stringwise comparison, and does not distinguish defined versus
undefined empty strings.  Modify if you have other needs.

like this one.  It uses the CPAN module 0:

two different answers:

while the second reports that they do not.  Which you prefer is left as
an exercise to the reader.

use the 0 function in the 0 module, which comes
with Perl 5.8. This example finds the first element that contains
"Perl".

same thing.  Once you find the element, you stop the loop with last.

and check the array element at each index until you find one
that satisfies the condition.

if you just want to add or remove items. You can use array operations
such as 0, 0, 0, 0, or 0 to do
that.

want to "shard" an array so you have have many small arrays instead of
a single big array. You can keep arrays longer than Perl's largest
array index, lock smaller arrays separately in threaded programs,
reallocate less memory, or quickly insert elements in the middle of
the chain.

Linked Lists" ( http://www.slideshare.net/lembark/perly-linked-lists ),
although you can just use his 0 module.

0 0 0 0
0 0

index modulo the number of elements in the array:

next element of the circular array:

circular arrays:

Scalar-List-Utils 1.03 or later installed, you can say:

unlike the 0 which takes a list and returns
a new shuffled list.

randomly picking another element to swap the current element with

times, you just invented a quadratic algorithm; that is, O(N**2).
This does not scale, although Perl is so efficient that you probably
won't notice this until you have rather largish arrays.

one list into another:

hash, you can use the 0 function.  As of Perl 5.6
the values are not copied, so if you modify  (in this
case), you modify the value.

so older perl code often contains constructions such as
0 instead of 0 where
the hash is to be modified.

0 0 0 0
0 0

array, try the 0 module (also on CPAN). It's
written in XS code and is very efficient:

words on each line of input. The algorithm embodied in the
0 function is discussed in Volume 4 (still unpublished) of
Knuth's 0 and will work on any list:

0 functions which efficiently find all unique permutations
of an array, even if it contains duplicate values, modifying it in-place:
if its elements are in reverse-sorted order then the array is reversed,
making it sorted, and it returns false; otherwise the next
permutation is returned.

you can enumerate all the permutations of 0 like this:

sort 0 into 0.  , used above, is
the numerical comparison operator.

want to sort on, then don't do it inside the sort function.  Pull it
out first, because the sort BLOCK can be called many times for the
same element.  Here's an example of how to pull out the first word
after the first number on each item, and then sort those words
case-insensitively.

that's come to be known as the Schwartzian Transform:

above.

To Know" collection in http://www.cpan.org/misc/olddoc/FMTEYEWTK.tgz for
more about this approach.

operations.

(which would mean that you're wasting a lot of space). To convert an
array of bits to a string, use 0 to set the right bits. This
sets 0 to have bit N set only if 0 was set:

instance, if you had 16 entries in 0, 0 only needs two
bytes to store them (not counting the scalar variable overhead).

your 0 array:

(Courtesy of Tim Bunce and Winfried Koenig.)

from Benjamin Goldberg:

small integers and "big int" math.

functions, not on aggregates (arrays and hashes).  See 0
in the 5.004 release or later of Perl for more detail.

can get a list of keys, then go through each key, or grab a one
key-value pair at a time.

all of the keys of the hash and gives them back to you as a list. You
can then get the value through the particular key you're processing:

process the hash elements. For instance, you can sort the keys so you
can process them in lexical order:

to deal with the keys that start with 0, you can select just
those using 0:

keys. To save some memory, you can grab one key-value pair at a time using
0, which returns a pair you haven't seen yet:

ordering matters to you, you'll have to stick with the 0 method.

delete keys of the hash while you're using it without possibly
skipping or re-processing some pairs after Perl internally rehashes
all of the elements. Additionally, a hash has only one iterator, so if
you use 0, 0, or 0 on the same hash, you can reset
the iterator and mess up your processing. See the 0 entry in
0 for more details.

0 0 0

if both hashes contain keys that are the same and if you want to leave
the original hashes as they were.

to a new hash (0), then add the keys from the other hash
(0 to the new hash. Checking that the key already exists in
0 gives you a chance to decide what to do with the
duplicates:

technique; just change the 0 to 0.

could just use a hash slice to add one hash to another. In this case, values
from 0 replace values from 0 when they have keys in common:

most recently returned without worrying about it.  If you delete or add
other keys, the iterator may skip or double up on them since perl
may rearrange the hash table.  See the
entry for 0 in 0.

to use:

one of the associated keys.   This may or may not worry you.  If it does
worry you, you can always reverse the hash into a hash of arrays instead:

0, but a bit simpler in the common cases.

have many entries you have in a hash:

a bit different. You have to check each value. A 0 is handy:

you like. If you want the count of the keys with vowels in them,
you just test for that instead:

of matching items, just use it in list context instead:

see strange results if you use this between uses of other hash operators
such as 0.

keys to the sort function which then compares them ASCIIbetically (which
might be affected by your locale settings). The output list has the keys
in ASCIIbetical order. Once we have the keys, we can go through them to
create a report which lists the keys in ASCIIbetical order.

comparing the keys, we can compute a value with them and use that
value as the comparison.

the 0 sequence in a double-quoted string to make everything
lowercase. The 0 block then compares the lowercased
values to determine in which order to put the keys.

you may want to look at the Schwartzian Transform to cache the
computation results.

to look it up. We still get out a list of keys, but this time they
are ordered by their value.

we can provide a secondary sort on the hash key.

0

0 hash bindings as documented in 0. The 0 module from CPAN might also be
instructive. Although this does keep your hash sorted, you might not
like the slowdown you suffer from the tie interface. Are you sure you
need to do this? :)

second is the value.  The key will be coerced to a string,
although the value can be any kind of scalar: string,
number, or reference.  If a key 0 is present in
%hash, 0 will return true.  The value
for a given key can be 0, in which case
0 will be 0 while 0
will return true.  This corresponds to (0, 0)
being in the hash.

For example, there isn't the concept of undef with hashes
that are tied to DBM* files. It also means that  and
 do the same thing with a DBM* file, and what they
end up doing is not what they do with ordinary hashes.

simply reset the iterator used by 0 without doing anything else,
use one of them in void context:

the "removing duplicates" problem described above.  For example:

get the MLDBM (which uses Data::Dumper) module from CPAN and layer
it on top of either DB_File or GDBM_File. You might also try DBM::Deep, but
it can be a bit slow.

0 create the key.

Since you could assign directly to 0, Perl had to be ready to
make that assignment so it created the hash key ahead of time:

creates the hash key only when you make the assignment:

because it's a weird side effect), you can pass a hash slice instead.
Perl 5.004 didn't make this a special case:

Examples of complex data structures are given in 0 and
0.  Examples of structures and object-oriented classes are
in 0.

When you try to do that, perl turns the reference into its stringified
form (for instance, 0). From there you can't get
back the reference from the stringified form, at least without doing
some extra work on your own.

the referenced variable  goes out of scope, and that it is entirely
possible for Perl to subsequently allocate a different variable at
the same address. This will mean a new variable might accidentally
be associated with the value for an old.

against the reference for lookup later, you can use the core
Hash::Util::Fieldhash module. This will also handle renaming the
keys if you use multiple threads (which causes all variables to be
reallocated at new addresses, changing their stringification), and
garbage-collecting the entries when the referenced variable goes out
of scope.

each hash entry, you can use the Tie::RefHash module, which does the
required work for you.

you want to check three keys deep, you might naïvely try this:

0 you've created the structure you needed to check for 0:

easiest way is to just turn it off. The lexical 0
pragma is available on CPAN. Now you don't add to the hash:

subroutine can tell you not only if the keys exist but also get the
value:

before you move onto the next level. This is essentially what
0 does for you:

On Windows or DOS, however, you have to use 0 for binary
files to avoid conversions for line endings. In general, you should
use 0 any time you want to work with binary data.

If you want to deal with multibyte characters, however, there are
some gotchas.  See the section on Regular Expressions.

"Infinity", you probably just want to use a regular expression:

0 (distributed with 5.8) provides access to perl's
internal function 0 for determining whether a
variable looks like a number. 0 exports functions that
validate data types using both the above and other regular
expressions. Thirdly, there is 0 which has regular
expressions to match various types of numbers. Those three modules are
available from the CPAN.

function for converting strings to doubles (and also 0
for longs). Its semantics are somewhat cumbersome, so here's a
0 wrapper function for more convenient access. This function
takes a string and returns the number it found, or 0 for input
that isn't a C float. The 0 function is a front end to
0 if you just want to say, "Is this a float?"

instead.

See 0.  More generically, you should consult the 0
or 0 modules from CPAN.  Starting from Perl 5.8 0 is part
of the standard distribution.  Here's one example using 0's 0
and 0 functions:

for printing out data structures.  The 0 module on CPAN (or the
5.8 release of Perl), provides a function called 0 that recursively
copies its argument.

It will be deeply copied.  Because 0 takes and returns references,
you'd have to add extra punctuation if you had a hash of arrays that
you wanted to copy.

be very careful to consider the consequences of doing this: adding
methods to every object is very likely to have unintended
consequences. If possible, it would be better to have all your object
inherit from some common base class, or to use an object system like
Moose that supports roles.

If you're doing a lot of float or double processing, consider using
the 0 module from CPAN instead--it makes number-crunching easy.

other authors as noted. All rights reserved.

under the same terms as Perl itself.

are hereby placed into the public domain.  You are permitted and
encouraged to use this code in your own programs for fun
or for profit as you see fit.  A simple comment in the code giving
credit would be courteous but is not required. 

=encoding utf8

formats, and footers.

0 0 0 0

at http://perl.plover.com/FAQs/Buffering.html .

bit of output. By saving up output, it makes fewer expensive system calls.
For instance, in this little bit of code, you want to print a dot to the
screen for every line you process to watch the progress of your program.
Instead of seeing a dot for every line, Perl buffers the output and you
have a long wait before you see a row of 50 dots all at once:

case, 0. You can set the special variable 0 to a true value
(mnemonic: making your filehandles "piping hot"):

filehandle has its own copy of its value. If you want to merge
standard output and standard error for instance, you have to unbuffer
each (although STDERR might be unbuffered by default):

your filehandle a 0 layer, which is unbuffered:

and 0 in 0, and the 0 module documentation.

call the 0 method to change the settings of the
filehandle:

the buffer any time you want without auto-buffering

0

file involves reading and printing the file to the point you want to
make the change, making the change, then reading and printing the rest
of the file. Perl doesn't provide random access to lines (especially
since the record input separator, 0, is mutable), although modules
such as 0 can fake it.

file, printing its lines, then closing the file:

or delete lines.

the loop that prints the existing lines.

the 0 loop. In this case, the code finds all lowercased
versions of "perl" and uppercases them. The happens for every line, so
be sure that you're supposed to do that on every line!

useful. First read and print the lines up to the one you  want to
change. Next, read the single line you want to change, change it, and
print it. After that, read the rest of the lines and print those:

skips comment lines, and the 0 stops all processing once it
encounters either 0 or 0.

to skip the lines you don't want to show up in the output. This
example skips every fifth line:

rather than processing line-by-line, you can slurp it in (as long as
you can fit the whole thing in memory!):

too. If you can, however, avoid reading the entire file at once. Perl
won't give that memory back to the operating system until the process
finishes.

following changes all 'Fred' to 'Barney' in 0, overwriting
the file with the new contents. With the 0 switch, Perl wraps a
0 loop around the code you specify with 0, and 0 turns
on in-place editing. The current line is in 0. With 0, Perl
automatically prints the value of 0 at the end of the loop. See
0 for more details.

input line number, then only perform the operation when the test
passes:

before Perl prints 0:

line prints at the end of the loop:

It's just like 0 except that it doesn't print 0 at the end of
the loop, so you have to do that yourself. In this case, print 0
first, then print the line that you want to add.

0 0 0

simply read them and count them:

already does that with the 0 variable, which is the current line
number from the last filehandle read:

like one of these:

you, you might just read chunks of data and count the number of
newlines:

might change that 0 to a 0 so you can count the number of
times the input record separator, 0, shows up:

fastest, even with the extra interprocess overhead. Ensure that you
have an untainted filename though:

0 0

file then start at the beginning and print the number of lines
(minus the last N) to a new file.

without making more than one pass over the file, or how to do it
without a lot of copying. The easy concept is the hard reality when
you might have millions of lines in your file.

the file. That module provides an object that wraps the real filehandle
to make it easy for you to move around the file. Once you get to the
spot you need, you can get the actual filehandle and work with it as
normal. In this case, you get the file position at the end of the last
line you want to keep and truncate the file to that point:

the input record separator to a regular expression.

the lines through a tied array. You can use normal array operations
to modify your file, including setting the last index and using
0.

0 0

the behavior of ; see 0 for more details. By
modifying the appropriate variables directly, you can get the same
behavior within a larger program. For example:

leaving a backup of the original data from each file in a new
0 file.

0 0 0

true copy across file systems, and it does its magic in
a portable fashion.

open the original file, open the destination file, then print
to the destination file as you read the original. You also have to
remember to copy the permissions, owner, and group to the new file.

0

with 0 in place of the file name. In Perl 5.8 or later, the
0 function creates an anonymous temporary file:

don't have a modern enough Perl installed, use the 0
class method from the IO::File module to get a filehandle opened for
reading and writing. Use it if you don't need to know the file's name:

process ID and/or the current time-value. If you need to have many
temporary files in one process, use a counter:

0 0

0. This is faster than using
0 when taking many, many strings. It is
slower for just a few.

some fixed-format input lines, in this case from the output of a normal,
Berkeley-style ps:

Storing the keys in an array makes it easy to operate on them as a
group or loop over them with 0. It also avoids polluting the program
with global variables and using symbolic references.

0 0 0

as references if you pass it an uninitialized scalar variable.
You can then pass these references just like any other scalar,
and use them in the place of named handles.

If you access them directly, they aren't simple scalars and you
need to give 0 a little help by placing the filehandle
reference in braces. Perl can only figure it out on its own when
the filehandle reference is a simple scalar.

which you may see in older code.

check out the Symbol or IO::Handle modules.

0

in a place that a filehandle is expected. Here are ways
to get indirect filehandles:

create an anonymous filehandle and store that in a scalar variable.

Perl is expecting a filehandle, an indirect filehandle may be used
instead. An indirect filehandle is just a scalar variable that contains
a filehandle. Functions like 0, 0, 0, or
the  diamond operator will accept either a named filehandle
or a scalar variable containing one:

the function in two ways:

(They might also work with strings under some circumstances, but this
is risky.)

before using it. That is because only simple scalar variables, not
expressions or subscripts of hashes or arrays, can be used with
built-ins like 0, 0, or the diamond operator. Using
something other than a simple scalar variable as a filehandle is
illegal and won't even compile:

an expression where you would place the filehandle:

complicated code there. This sends the message out to one of two places:

calls doesn't work for the diamond operator. That's because it's a
real operator, not just a function with a comma-less argument. Assuming
you've been storing typeglobs in your structure as we did above, you
can use the built-in function named 0 to read a record just
as  does. Given the initialization shown above for @fd, this
would work, but only because  requires a typeglob. It doesn't
work with objects or strings, which might be a bug we haven't fixed yet.

related to whether they're strings, typeglobs, objects, or anything else.
It's the syntax of the fundamental operators. Playing the object
game doesn't help you at all here.

0

techniques to make it possible for the intrepid hacker.

0

filehandle to a string, which Perl has been able to do since Perl 5.6:

filehandle, even though formats are designed to work with bareword filehandles
since the default format names take the filehandle name. However, you can
control this with some Perl special per-filehandle variables: 0, which
names the top-of-page format, and 0 which shows the line format. You have
to change the default filehandle to set these variables:

you use have to scope in the format. That most likely means you'll want to
localize some package variables:

accumulator variable 0, but you lose a lot of the value of formats
since 0 won't handle paging and so on. You end up reimplementing
formats when you use them.

0 0 0 0

calling open with a reference to that string instead of the filename.
This file handle can then be used to read from or write to the string:

functionality.

0

It handles locale information for those of you who want to insert
full stops instead (or anything else that they want to use,
really).

0 0

Versions of Perl older than 5.6 require that you have a shell
installed that groks tildes. Later versions of Perl have this feature
built in. The 0 module (available from CPAN) gives more
portable glob functionality.

0 0 0 0 0

0 gives you read-write access:

doesn't exist:

either. The "+" doesn't change this.

all assume that you've pulled in the constants from 0:

be an atomic operation over NFS. That is, two processes might both
successfully create or unlink the same file! Therefore O_EXCL
isn't as exclusive as you might wish.

0

In Perl versions earlier than v5.6.0, the internal  operator forks
 to do the actual glob expansion, but
csh can't handle more than 127 items and so gives the error message
0. People who installed tcsh as csh won't
have this problem, but their users may be surprised by it.

yourself with  and patterns, or use a module like File::KGlob,
one that doesn't use the shell to do globbing.

0

than relying on an external resource. As such, memory issues with
0 aren't a problem in modern perls.

0

trailing blanks in filenames and infers the mode from certain leading
characters (or a trailing "|"). In older versions of Perl this was the
only version of  and so it is prevalent in old code and books.

should use the three-argument form of  which does not treat any
characters in the filename as special.

0 0 0 0

functional equivalent, this works:

You just copy to the new file to the new name (checking return
values), then delete the old one. This isn't really the same
semantically as a 0, which preserves meta-information like
permissions, timestamps, inode info, etc.

0 0 0

 if that exists,  if it doesn't (on perl version 5.004 and
later), and  if neither of the two previous system calls exists.
On some systems, it may even use a different form of native locking.
Here are some gotchas with Perl's :

close equivalent) exists.

filehandle be open for writing (or appending, or read/writing).

systems), so you'd need to force the use of  when you build Perl.
But even this is dubious at best. See the flock entry of 0
and the 0 file in the source distribution for information on
building Perl to do this.

it waits indefinitely until the lock is granted, and that its locks are
0. Such discretionary locks are more flexible, but
offer fewer guarantees. This means that files locked with  may
be modified by programs that do not also use . Cars that stop
for red lights get on well with each other, but not with cars that don't
stop for red lights. See the perlport manpage, your port's specific
documentation, or your system-specific local manpages for details. It's
best to assume traditional behavior if you're writing portable programs.
(If you're not, you should as always feel perfectly free to write
for your own system's idiosyncrasies (sometimes called "features").
Slavish adherence to portability concerns shouldn't get in the way of
your getting your job done.)

0 if you have it (new for 5.6).

0

which must be done in one. That's why computer hardware provides an
atomic test-and-set instruction. In theory, this "ought" to work:

over NFS, so this won't work (at least, not every time) over the net.
Various schemes involving  have been suggested, but
these tend to involve busy-wait, which is also less than desirable.

0 0

They don't count number of hits, they're a waste of time, and they serve
only to stroke the writer's vanity. It's better to pick a random number;
they're more realistic.

0 0

the example appending code from "perldoc -f flock" everything will be
OK even if the OS you are on doesn't implement append mode correctly
(if such a system exists). So if you are happy to restrict yourself to
OSs that implement 0 (and that's not really much of a
restriction) then that is what you should do.

implement appending (i.e. not Win32) then you can omit the 0
from the code in the previous answer.

that does implement append mode correctly (a local filesystem on a
modern Unix for example), and you keep the file in block-buffered mode
and you write less than one buffer-full of output between each manual
flushing of the buffer then each bufferload is almost guaranteed to be
written to the end of the file in one chunk without getting
intermingled with anyone else's output. You can also use the
0 function which is simply a wrapper around your system's
0 system call.

the system-level 0 operation before completion. There is also
a possibility that some STDIO implementations may call multiple system
level 0s even if the buffer was empty to start. There may be
some systems where this probability is reduced to zero, and this is
not a concern when using 0 instead of your system's STDIO.

0

simple as this works:

like this:

Don't forget them or you'll be quite sorry.

0 0

written, or had its meta-data (owner, etc) changed, you use the 0,
0, or 0 file test operations as documented in 0.
These retrieve the age of the file (measured against the start-time of
your program) in days as a floating point number. Some platforms may
not have all of these times. See 0 for details. To retrieve
the "raw" time in seconds since the epoch, you would call the stat
function, then use 0, 0, or
0 to convert this into human-readable form.

(part of the standard distribution in version 5.004 and later):

in theory, independent of the current locale. See 0
for details.

0 0

By way of example, here's a little program that copies the
read and write times from its first argument to all the rest
of them.

effect as  on files that 0.

on a file at the expected level of precision. For example, the
FAT and HPFS filesystem are unable to create dates on files with
a finer granularity than two seconds. This is a limitation of
the filesystems, not of .

0

you can use the IO::Tee or Tie::FileHandle::Multiplex modules.

to each filehandle.

0 0

do so one line at a time:

memory as an array of lines and then processing it one element at a time,
which is often--if not almost always--the wrong approach. Whenever
you see someone do this:

once. It's just not a scalable solution.

CPAN, you can virtually load the entire file into a
string without actually storing it in memory:

Since you don't necessarily have to load the data, mmap-ing can be
very fast and may not increase your memory footprint.

fun to use the standard 0 module, or the 0 module's
0 bindings, which allow you to tie an array to a file so that
accessing an element of the array actually accesses the corresponding
line in the file.

module to do it in one one simple and efficient step:

close the file at block exit. If the file is already open, just use this:

and reads that many bytes into the buffer 0.

0

set it to 0 to eliminate empty paragraphs (0,
for instance, gets treated as two paragraphs and not three), or
0 to accept empty paragraphs.

S<0 is one paragraph, but 0 is two.

0 0

it won't (easily) work on a terminal device. For STDIN, either use
the Term::ReadKey module from CPAN or use the sample code in
0.

interface (POSIX), you can use the following code, which you'll note
turns off echo processing as well.

include also support for non-portable systems as well.

extension from CPAN. As we mentioned earlier, it now even has limited
support for non-portable (read: not open systems, closed, proprietary,
not POSIX, not Unix, etc.) systems.

comp.unix.* for things like this: the answer is essentially the same.
It's very system-dependent. Here's one solution that works on BSD
systems:

also the FIONREAD ioctl call to be looked at. The 0 tool that
comes with Perl tries to convert C include files to Perl code, which
can be 0d. FIONREAD ends up defined as a function in the
0 file:

0 the include files by hand:

pipes, and tty devices work, but 0 files.

0 0 0 0

but it does clear the end-of-file condition on the handle, so that the
next  makes Perl try again to read something.

then you need something more like this:

from 0, which resets the error and end-of-file states
on the handle.

0

to call  should do the trick. For example:

an alias. That means if you close an aliased handle, all
aliases become inaccessible. This is not true with
a copied one.

0 0 0

filehandle (perhaps you used 0), you can use the
0 function from the 0 module:

used for things that Perl opened itself, even if it was a dup of a
numeric descriptor as with 0 above. But if you really have
to, you may be able to do this:

0

Remember that within double quoted strings ("like\this"), the
backslash is an escape character. The full list of these is in
0. Unsurprisingly, you don't
have a file called "c:(tab)emp(formfeed)oo" or
"c:(tab)emp(formfeed)oo.exe" on your legacy DOS filesystem.

Since all DOS and Windows versions since something like MS-DOS 2.0 or so
have treated 0 and 0 the same in a path, you might as well use the
one that doesn't clash with Perl--or the POSIX shell, ANSI C and C++,
awk, Tcl, Java, or Python, just to mention a few. POSIX paths
are more portable, too.

0

Unix globbing semantics. You'll need 0 to get all (non-hidden)
files. This makes  portable even to legacy systems. Your
port may include proprietary globbing functions as well. Check its
documentation for details.

0 article in the "Far More Than You Ever Wanted To
Know" collection in http://www.cpan.org/misc/olddoc/FMTEYEWTK.tgz .

permissions on a file say what can happen to the data in that file.
The permissions on a directory say what can happen to the list of
files in that directory. If you delete a file, you're removing its
name from the directory (so the operation depends on the permissions
of the directory, not of the file). If you try to write to the file,
the permissions of the file govern whether you're allowed to.

0

the file, there are a couple of things that you can do.

in. You can find a proof of this method in 0, Volume 2, Section 3.4.2, by Donald E. Knuth.

for that algorithm:

file as an array. Simply access a random array element.

you print the array, you are probably interpolating the array in
double quotes:

interpolate an array in a double quote context, Perl joins the
elements with spaces (or whatever is in 0, which is a space by
default):

the elements of 0 simply become part of the list to
0:

a newline. You expect to print one element per line, but notice that
every line after the first is indented:

don't want to put anything between your array elements, don't use the
array in double quotes. You can send it to print without them:

work to traverse a directory structure. It comes with Perl. You simply
call the 0 subroutine with a callback subroutine and the
directories you want to traverse:

many ready-to-use subroutines that you can use with 0.

create the callback subroutine using something closer to the syntax of
the 0 command-line utility:

a similar interface, but does the traversal for you too:

If the directory is not empty (so, no files or subdirectories), you
either have to empty it yourself (a lot of work) or use a module to
help you.

which can take care of all of the hard work for you:

0 subroutine.

recursively) in portable Perl, you'll either need to write something yourself
or find a good CPAN module such as  0.

other authors as noted. All rights reserved.

under the same terms as Perl itself.

domain. You are permitted and encouraged to use this code and any
derivatives thereof in your own programs for fun or for profit as you
see fit. A simple comment in the code giving credit to the FAQ would
be courteous but is not required. 

=encoding utf8

littered with answers involving regular expressions. For example,
decoding a URL and checking whether something is a number are handled
with regular expressions, but those answers are found elsewhere in
this document (in 0: "How do I decode or create those %-encodings
on the web" and 0: "How do I determine whether a scalar is
a number/whole/integer/float", to be precise).

0 0
0 0

understandable.

comments.

(except in a character class and a few other places), and also allows you to
use normal comments there, too. As you can imagine, whitespace and comments
help a lot.

describing the meaning of each part of the pattern.

characters, they can be delimited by almost any character. 0
describes this. For example, the 0 above uses braces as
delimiters. Selecting another delimiter can avoid quoting the
delimiter within the pattern:

0 0 0

at (probably), or else you aren't using the correct modifier(s) on
your pattern (possibly).

it to happen automatically while reading input, you'll want to set $/
(probably to '' for paragraphs or 0 for the whole file) to
allow you to read more than one line at a time.

you might want to use: 0 allows dot to include newline, and 0
allows caret and dollar to match next to a newline, not just at the
end of the string. You do need to make sure that you've actually
got a multiline string in there.

line breaks (but not paragraph ones). For this example, we don't need
0 because we aren't using dot in a regular expression that we want
to cross line boundaries. Neither do we need 0 because we aren't
wanting caret or dollar to match at any point inside the record next
to newlines. But it's imperative that $/ be set to something other
than the default, or else we won't actually ever have a multiline
record read in.

be mangled by many mailers):

0

0):

run up against the problem described in the question in this section
on matching balanced text.

0 0 0 0 0 0
0

regular expressions. The 0 and 0 modules
are good starts, although each namespace has other parsing modules
specialized for certain tasks and different ways of doing it. Start at
CPAN Search ( http://search.cpan.org ) and wonder at all the work people
have done for you already! :)

containing multiple levels of balanced text, but sometimes it isn't
balanced text, as in an empty tag (, for instance). Even then,
things can occur out-of-order. Just when you think you've got a
pattern that matches your input, someone throws you a curveball.

toward a right answer but constantly being disappointed, besieged by
bug reports, and weary from the inordinate amount of time you have to
spend reinventing a triangular wheel, then there are several things
you can try before you give up in frustration:

0 0
0

do this.

a buffer. After you add to the buffer, you check if you have a
complete line (using your regular expression).

c flag and the \G anchor, if you do not mind your entire file
being in memory at the end.

0 0
0 0

properties of bitwise xor on ASCII strings.

longer than the original, you can use this code, by Jeff Pinyan:

if you prefer a more C-like solution, the following script makes the
substitution have the same case, letter by letter, as the original.
(It also happens to run about 240% slower than the Perlish solution runs.)
If the substitution has more characters than the string being substituted,
the case of the last character is used for the rest of the substitution.

0

from the current locale.

0

documented in 0.

the characters in \w without the digits and the underscore.
As a regex, that looks like 0. Its complement,
the non-alphabetics, is then everything in \W along with
the digits and the underscore, or 0.

0 0 0

regular expressions unless the delimiter is a single quote. Remember,
too, that the right-hand side of a 0 substitution is considered
a double-quoted string (see 0 for more details). Remember
also that any regex special characters will be acted on unless you
precede the substitution with \Q. Here's an example:

single character, the regex 0 here has matched the <Pl> in the
original string.

regular character, so that 0 matches a 0 followed by a dot.

0 0

0) tells Perl to compile the regular expression only once.
This is only useful when the pattern contains a variable. Perls 5.6
and later handle this automatically if the pattern does not change.

and the regular expression quoting operator 0 are double-quotish
constructs, you can interpolate variables into the pattern. See the
answer to "How can I quote a variable to use in a regex?" for more
details.

prints the lines of input that match it:

for each iteration, even if 0 had not changed. The 0
would prevent this by telling Perl to compile the pattern the first
time, then reuse that for subsequent iterations:

if the variable hasn't changed, so you probably don't need the 0
option. It doesn't hurt, but it doesn't help either. If you want any
version of Perl to compile the regular expression only once even if
the variable changes (thus, only using its initial value), you still
need the 0.

yourself if Perl is recompiling a regular expression. The 0 pragma (comes with Perl 5.005 and later) shows the details.
With Perls before 5.6, you should see 0 reporting that its
compiling the regular expression on each iteration. With Perl 5.6 or
later, you should only see 0 report that for the first iteration.

For example, this one-liner

certain kinds of C programs, in particular, those with what appear to be
comments in quoted strings. For that, you'd need something like this,
created by Jeffrey Friedl and later modified by Fred Curtis.

whitespace and comments. Here it is expanded, courtesy of Fred Curtis.

using a continuation character:

0 0
0 0 0
0 0 0 0

is in the Perl standard library since Perl 5.8. It has a variety of
functions to deal with tricky text. The 0 module can
also help by providing canned patterns you can use.

using recursive patterns. Before Perl 5.10, you had to resort to
various tricks such as using Perl code in 0 sequences.

capture all of the text within angle brackets, including the text in
nested angle brackets. This sample text has two "major" groups: a
group with one level of nesting and a group with two levels of
nesting. There are five total groups in angle brackets:

Perl 5.10) regular expression features. These are covered in 0
and this example is a modified version of one in that documentation.

longest match and does not backtrack. That's important since you want
to handle any angle brackets through the recursion, not backtracking.
The group  finds one or more non-angle brackets without
backtracking.

particular capture group given by 0. In the following regex,
the first capture group finds (and remembers) the balanced text, and
you need that same pattern within the first buffer to get past the
nested text. That's the recursive part. The 0 uses the pattern
in the outer capture group as an independent part of the regex.

brackets even if they are in other angle brackets too. Each time you
get a balanced match, remove its outer delimiter (that's the one you
just matched so don't match it again) and add it to a queue of strings
to process. Keep doing that until you get no matches:

first and the nested matches so up later:

0 0

Technically speaking, it's actually the quantifiers (0, 0, 0,
0) that are greedy rather than the whole pattern; Perl prefers local
greed and immediate gratification to overall greed. To get non-greedy
versions of the same quantifiers, use (0, 0, 0, 0).

encountered "y ". The 0 quantifier effectively tells the regular
expression engine to find a match as quickly as possible and pass
control on to whatever is next in line, as you would if you were
playing hot potato.

0

chunks of consecutive non-whitespace characters.

might consider

pretend that by word you mean chunk of alphabetics, hyphens, or
apostrophes, rather than the non-whitespace chunk idea of a word given
in the previous question:

regular expression:

sort a hash (optionally by value instead of key)?".

0 0

0 0
0

match against an array of regular expression objects:

every expression.

avoid compiling a regular expression every time you want to match it.
In this example, perl must recompile the regular expression for every
iteration of the 0 loop since it has no way to know what
0 will be:

expression, but doesn't apply it. When you use the pre-compiled
version of the regex, perl does less work. In this example, I inserted
a 0 by Jeffrey Friedl. He explains how regular
expressions engine work and why some patterns are surprisingly
inefficient. Once you understand how perl applies regular expressions,
you can tune them for individual situations.

0

word character, \w, and something that isn't a word character. That
thing that isn't a word character might be \W, but it can also be the
start or end of the string.

and it's not the stuff between words we use to create sentences.

meaning that it doesn't represent a character in the string, but a
condition at a certain position.

boundary before the "P" and after the "l". As long as something other
than a word character precedes the "P" and succeeds the "l", the
pattern will match. These strings match /\bPerl\b/.

non-word characters surrounded by word characters. These strings
match the pattern /\b'\b/.

should not be a word boundary.

and after the "m". These patterns match /\Bam\B/:

0 0 0 0 0 0

program, it provides them on each and every pattern match. That means
that on every pattern match the entire string will be copied, part of it
to $`, part to $&, and part to $'. Thus the penalty is most severe with
long strings and patterns that match often. Avoid $&, $', and $` if you
can, but if you can't, once you've used them at all, use them at will
because you've already paid the price. Remember that some algorithms
really appreciate them. As of the 5.005 release, the $& variable is no
longer "expensive" the way the other two are.

$`, $& and $'. These arrays contain pointers to the beginning and end
of each match (see perlvar for the full story), so they give you
essentially the same information, but without the risk of excessive
string copying.

0 to do the same job but without the global performance
penalty. Perl 5.10 only sets these variables if you compile or execute the
regular expression with the 0 modifier.

0

string where the last match left off. The regular
expression engine cannot skip over any characters to find
the next match with this anchor, so 0 is similar to the
beginning of string anchor, 0. The 0 anchor is typically
used with the 0 flag. It uses the value of 0
as the position to start the next match. As the match
operator makes successive matches, it updates 0 with the
position of the next character past the last match (or the
first character of the next match, depending on how you like
to look at it). Each string has its own 0 value.

in a string like "1122a44" and stop matching when you
encounter non-digits. You want to match 0 and 0 but
the letter <a> shows up between 0 and 0 and you want
to stop at 0. Simply matching pairs of digits skips over
the 0 and still matches 0.

start with the 0. The regular expression cannot match
there since it does not find a digit, so the next match
fails and the match operator returns the pairs it already
found.

still need the 0 flag.

and the next match on the same string starts at the beginning.

in 0 and 0. Subsequent matches start where the last
successful match ended (the value of 0) even if a match on the
same string has failed in the meantime. In this case, the match after
the 0 loop starts at the 0 (where the last match stopped),
and since it does not use any anchor it can skip over the 0 to find
0.

when you want to try a different match if one fails,
such as in a tokenizer. Jeffrey Friedl offers this example
which works in 5.004 or later.

of digits followed by a word boundary. This match has to
start at the place the last match left off (or the beginning
of the string on the first match). Since 0 uses the 0 flag, if the string does not match that
regular expression, perl does not reset  and the next
match starts at the same position to try a different
pattern.

0 0 0

(deterministic finite automata) of the  program, they are in
fact implemented as NFAs (non-deterministic finite automata) to allow
backtracking and backreferencing. And they aren't POSIX-style either,
because those guarantee worst-case behavior for all cases. (It seems
that some people prefer guarantees of consistency, even when what's
guaranteed is slowness.) See the book "Mastering Regular Expressions"
(from O'Reilly) by Jeffrey Friedl for all the details you could ever
hope to know on these matters (a full citation appears in
0).

0

This means you're making Perl go to the trouble of building a list that
you then just throw away. If the list is large, you waste both time and space.
If your intent is to iterate over the list, then use a for loop for this
purpose.

But since 5.8.1, this has been fixed, and map is context aware - in void
context, no lists are constructed.

0 0
0 0 0

support. Perl 5.8 or later is recommended. Supported multibyte
character repertoires include Unicode, and legacy encodings
through the Encode module. See 0, 0,
and 0.

0 module, and character conversions using the
0 and 0 modules. If you are using
Japanese encodings, you might try using the jperl 5.005_03.

Friedl, whose article in issue #5 of The Perl Journal talks about
this very matter.

ASCII uppercase letters encode single Martian letters (i.e. the two
bytes "CV" make a single Martian letter, as do the two bytes "SG",
"VS", "XX", etc.). Other bytes represent single characters, just like
ASCII.

nine characters 'I', ' ', 'a', 'm', ' ', 'CV', 'SG', 'XX', '!'.

doesn't know about Martian, so it'll find the two bytes "GX" in the "I
am CVSGXX!" string, even though that character isn't there: it just
looks like it is because "SG" is next to "XX", but there's no real
"GX". This is a big problem.

Goldberg, who uses a zero-width negative look-behind assertion.

otherwise. If you don't like using (?<!), a zero-width negative
look-behind assertion, you can replace (?<![A-Z]) with (?:^|[^A-Z]).

but this usually can be worked around.

0 0 0 0 0
0, 0

anything else that works with regular expressions). We can put the
pattern in a variable for later use.

your variable just like a double quoted string. In this case, you
read the regular expression as user input and store it in 0.
Once you have the pattern in 0, you use that variable in the
match operator.

special, and the pattern still has to be valid or Perl will complain.
For instance, in this pattern there is an unpaired parenthesis.

as the start of a memory match. When it doesn't find the closing
parenthesis, it complains:

First, if you don't want any of the characters in the string to be
special, you can escape them with 0 before you use the string.

and 0 sequences. The 0 tells Perl where to start escaping
special characters, and the 0 tells it where to stop (see 0
for more details).

0 for more details). It quotes and perhaps compiles the pattern,
and you can apply regular expression flags to the pattern.

around the whole thing.

other authors as noted. All rights reserved.

under the same terms as Perl itself.

are hereby placed into the public domain. You are permitted and
encouraged to use this code in your own programs for fun
or for profit as you see fit. A simple comment in the code giving
credit would be courteous but is not required. 

=encoding utf8

clearly fit into any of the other sections.

perly.y in the source distribution if you're particularly brave.  The
grammar relies on very smart tokenizing code, so be prepared to
venture into toke.c as well.

The work of parsing perl is distributed between yacc, the lexer, smoke
and mirrors."

you're likely to encounter that aren't
really type specifiers:

nor the name of the handle.  It is the  operator applied
to the handle FILE.  It reads one line (well, record--see
L<perlvar/) from the handle FILE in scalar context, or 0 lines
in list context.  When performing open, close, or any other operation
besides  on files, or even when talking about the handle, do
0 use the brackets.  These are correct: 0, 0 and "copying from STDIN to FILE".

probably should be (and must be under 0).  But a hash key
consisting of a simple word and the left-hand
operand to the  operator both
count as though they were quoted:

list.  Good style (see 0) says to put them in except for
one-liners:

you need:

allows fine control of what warning are produced.
See 0 for more details.

You turn off the categories you want to ignore and you can still
get other categories of warnings.  See 0 for the
complete details, including the category names and hierarchy.

in 0) controls runtime warnings for a block:

use  on 0, only .

0 is a good place to learn more about extensions.

precedence in Perl as they do in C.  The problem is with operators that C
doesn't have, especially functions that give a list context to everything
on their right, eg. print, chmod, exec, and so on.  Such functions are
called "list operators" and appear as such in the precedence table in
0.

super low precedence 0 operator:

deliberately have precedence lower than that of list operators for
just such situations as the one above.

binds more tightly even than unary minus, making 0 produce a
negative not a positive four.  It is also right-associating, meaning
that 0 is two raised to the ninth power, not eight squared.

produces an lvalue.  This assigns  to either  or , depending
on the trueness of :

anonymous) hash reference.  See 0 and 0 for details.
Here's an example:

in all the gory details. 0 gives a brief
overview of the process along with a couple of suggestions
about style.

your module, you'll need h2xs.  h2xs will create the module
distribution structure and the initial interface files
you'll need.  0 and 0 explain the details.

ExtUtils::ModuleMaker and Module::Starter, can help you
create a skeleton module distribution.

for CPAN" ( http://apress.com/book/bookDisplay.html?bID=14 )
which is the best hands-on guide to creating module
distributions.

module maintainer either make you a co-maintainer or transfer
the module to you.

the PAUSE admins at modules@perl.org can help. The PAUSE admins
treat each case individually.

already have one: http://pause.perl.org

current maintainer. The PAUSE admins will also try to reach the
maintainer.

intention to take over the module.

the current maintainer is on holiday. If there's no response to
private communication or the public post, a PAUSE admin can transfer
it to you.

0 0

Perl doesn't get more formal than that and lets you set up the package
just the way that you like it (that is, it doesn't set up anything for
you).

creation, including 0 (Barnyard Object Oriented Tutorial),
0 (Tom's Object Oriented Tutorial), 0 (Bag o'
Object Tricks), and 0.

from CPAN (or included with Perl since release 5.8.0).
See also 0.

hard-to-explain meaning. Usually, closures are implemented in Perl as
anonymous subroutines with lasting references to lexical variables
outside their own scopes. These lexicals magically refer to the
variables that were around when the subroutine was defined (deep
binding).

have the return value of a function be itself a function, as you can
in Perl. Note that some languages provide anonymous functions but are
not capable of providing proper closures: the Python language, for
example.  For more information on closures, check out any textbook on
functional programming.  Scheme is a language that not only supports
but encourages closures.

technically a closure because it refers to no lexicals outside its own
scope.  Using a closure gives you a 0 with some
customization slots left out to be filled later.

returned anonymous function contains a reference to a lexical variable
outside the scope of that function itself.  Such a reference requires
that Perl return a proper closure, thus locking in for all time the
value that the lexical had when the function was created.

0 is always 555 plus whatever  you pass in.  The 
in the closure sticks around.

you want to pass in a bit of code into a function:

, there would have been no way for the
hypothetical  function to access the lexical variable
 back in its caller's scope.

named subroutine, e.g. a counter that gets initialized at creation
time of the sub and can only be modified from within the sub.
This is sometimes used with a BEGIN block in package files to make
sure a variable doesn't get meddled with during the lifetime of the
package:

0.

your version of perl. ;)

of a variable.  It is caused by scoping through  and 
interacting with either closures or aliased  iterator variables
and subroutine arguments.  It used to be easy to inadvertently lose a
variable's value this way, but now it's much harder.  Take this code:

doesn't pick up a fresh copy of the 0 whose value is <foo>. The output
shows that inside the subroutine the value of 0 leaks through when it
shouldn't, as in this output:

0 for this particular question, and 0 for
information on references.

reference to an existing or anonymous variable or function:

which you treat as any other scalar.

These are "typeglobs"--see 0
and especially 0 for more information.

for it to match against. You construct the pattern with the 0
operator:

method call, and arguments:

(part of the standard perl distribution).

declaration creates the lexical variable that persists between calls
to the subroutine:

out of scope. In this example, you define the subroutine 0, and
it uses the lexical variable 0. Since you wrap this in a BEGIN
block, 0 is defined at compile-time, but also goes out of
scope at the end of the BEGIN block. The BEGIN block also ensures that
the subroutine and the value it uses is defined at compile-time so the
subroutine is ready to use just like any other subroutine, and you can
put this code in the same place as other subroutines in the program
text (i.e. at the end of the code, typically). The subroutine
0 still has a reference to the data, and is the only way you
can access the value (and each time you do, you increment the value).
The data in chunk of memory defined by 0 is private to
0.

because only one function remembered its reference. You could define
multiple functions while the variable is in scope, and each function
can share the "private" variable. It's not really "static" because you
can access it outside the function while the lexical variable is in
scope, and even create references to it. In this example,
0 and 0 share the variable. One
function adds to the value and the other simply returns the value.
They can both access 0, and since it has gone out of scope,
there is no other way to access it.

A file is also a scope, so a lexical variable defined in the file
cannot be seen from any other file.

The discussion of closures in 0 may help you even though we
did not use anonymous subroutines in this answer. See
0 for details.

and assigns a new value for the duration of the subroutine 0.  This is done
at run-time, so is called dynamic scoping.   always affects global
variables, also called package variables or dynamic variables.

subroutine.  This is done at compile-time, so it is called lexical or
static scoping.   always affects private variables, also called
lexical variables or (improperly) static(ly scoped) variables.

because  only has that value within the block of the 
function, and it is hidden from the called subroutine.

variables.  It gives a global variable a temporary value.   is
what you're looking for if you want private variables.

0 for excruciating details.

::var. Note that the notation $::var is 0 the dynamic 
in the current package, but rather the one in the "main" package, as
though you had written ::var.

dynamic variable into the current lexical scope.

are the same ones that were in scope when the subroutine was created.
In shallow binding, they are whichever variables with the same names
happen to be in scope when the subroutine is called.  Perl always uses
deep binding of lexical variables (i.e., those created with ).
However, dynamic variables (aka global, local, or package variables)
are effectively shallowly bound.  Consider this just one more reason
not to use them.  See the answer to 0.

of 0.  The <FH> read operation, like so many of Perl's
functions and operators, can tell which context it was called in and
behaves appropriately.  In general, the  function can help.
This function does nothing to the data itself (contrary to popular myth)
but rather tells its argument to behave in whatever its scalar fashion is.
If that function doesn't have a defined scalar behavior, this of course
doesn't help you (such as with ).

merely omit the parentheses:

issue is the same here:

then you'll have to import the new definition from a different
module.  See 0.

then you'll want to use the 0 pragma, documented
in 0.

see 0.

the prototype of 0 and passes it the current value of the argument
list, 0. Here's an example; the 0 subroutine calls 0,
which prints its arguments list:

does not use the current 0 and respects the subroutine prototype. Changing
the example to put parentheses after the call to 0 changes the program:

whose main job it is to call other subroutines for you. For further
details, see 0.

prior to 5.10, the general answer is to use 0:

lined up in a way to make it look more like a switch statement.
We'll do a multiway conditional based on the type of reference stored
in :

For example, let's say you wanted to test which of many answers you were
given, but in a case-insensitive way that also allows abbreviations.
You can use the following technique if the strings all start with
different characters or if you want to arrange the matches so that
one takes precedence over another, as 0 has precedence over
0 here:

used to get switch and case. Its use is now discouraged, because it's
not fully compatible with the native switch of Perl 5.10, and because,
as it's implemented as a source filter, it doesn't always work as intended
when complex syntax is involved.

0, lets you capture calls to
undefined functions and methods.

under 0, you can promote the warning to an error.

misspelled the method name, or the object is of the wrong type.  Check
out 0 for details about any of the above cases.  You may
also use 0 to find out the class 0 was
blessed into.

indirect object syntax (eg, 0) on a class name
before Perl has seen that such a package exists.  It's wisest to make
sure your packages are all defined before you start using them, which
will be taken care of if you use the 0 statement instead of
0.  If not, make sure to use arrow notation (eg.,
) instead.  Object notation is explained in
0.

the perils of indirect objects in 0.

0, as documented in 0. You can only use the
special literals as separate tokens, so you can't interpolate them
into strings like you can with variables:

diagnostics as 0 does, use the 0 built-in:

always be in some package.

into, which might not be the current package. For that, use 0
from 0, part of the Standard Library since Perl 5.8:

into, however, as long as it claims to inherit from that class:

inheritance to see if the object can handle a role. For that, you can
use 0, which comes from 0:

to surround those lines with Pod directives. You have to put these
directives at the beginning of the line and somewhere where Perl
expects a new statement (so not in the middle of statements like the #
comments). You end the comment with 0, ending the Pod section:

leave the commented code in the source. If a Pod parser comes along,
you're multiline comment is going to show up in the Pod translation.
A better way hides it from Pod parsers as well.

If the Pod parser doesn't want to handle it, it just ignores it. Label
the comments with 0. End the comment using 0 with the
same label. You still need the 0.  That means that if  is a lexical variable created
with  in the above example, the code wouldn't work at all: you'd
accidentally access the global and skip right over the private lexical
altogether.  Global variables are bad because they can easily collide
accidentally and in general make for non-scalable and confusing code.

They are not true references and consequently are not reference-counted
or garbage-collected.

variable is a bad idea is that the question often stems from a lack of
understanding of Perl data structures, particularly hashes.  By using
symbolic references, you are just using the package's symbol-table hash
(like 0) instead of a user-defined hash.  The solution is to
use your own hash or a real reference instead.

Sometimes this comes up in reading strings from the user with variable
references and wanting to expand them to the values of your perl
program's variables.  This is also a bad idea because it conflates the
program-addressable namespace and the user-addressable one.  Instead of
reading a string and expanding it to the actual contents of your program's
own variables:

variable references actually refer to entries in that hash:

you don't need to use a dollar sign.  You could use your own scheme to
make it less confusing, like bracketed percent symbols, etc.

contain the name of a variable is that they don't know how to build
proper data structures using hashes.  For example, let's say they
wanted two hashes in their program: %fred and %barney, and that they
wanted to use another scalar variable to refer to those by name.

problems enumerated above.  It would be far better to write:

when you really must refer to the symbol table.  This may be because it's
something that one can't take a real reference to, such as a format name.
Doing so may also be important for method calls, since these always go
through the symbol table for resolution.

can play around with the symbol table.  For example:

but the real code in the closure actually was compiled only once.

the symbol table directly.  This doesn't matter for formats, handles, and
subroutines, because they are always global--you can't use  on them.
For scalars, arrays, and hashes, though--and usually for subroutines--
you probably only want to use hard references.

actual message may vary depending on your platform, shell, and locale
settings.

line in your perl script (the "shebang" line) does not contain the
right path to perl (or any other program capable of running scripts).
Sometimes this happens when you move the script from one machine to
another and each machine has a different path to perl--/usr/bin/perl
versus /usr/local/bin/perl for instance. It may also indicate
that the source machine has CRLF line terminators and the
destination machine has LF only: the shell tries to find
/usr/bin/perl<CR>, but can't.

script executable.

explicitly:

your PATH, which might also mean that the location of perl is not
where you expect it so you need to adjust your shebang line.

other authors as noted. All rights reserved.

under the same terms as Perl itself.

are hereby placed into the public domain.  You are permitted and
encouraged to use this code in your own programs for fun
or for profit as you see fit.  A simple comment in the code giving
credit would be courteous but is not required. 

=encoding utf8

system interaction.  Topics include interprocess communication (IPC),
control over the user-interface (keyboard, screen and pointing
devices), and most anything else not related to data manipulation.

operating system (eg, 0, 0, ...).  These should
contain more detailed information on the vagaries of your perl.

indication of the name of the operating system (not its release
number) that your perl binary was built for.

0 0 0 0 0

command and never to return. If that's not what you want to do, don't
use 0. :)

going, look at a piped 0, 0, or 0.

("mice") is system-dependent.  Try the following modules:

in this section of the perlfaq.

the recipient has a color-aware display device.  If you
know that they have an ANSI terminal that understands
color, you can use the 0 module from CPAN:

On many systems, you can just use the 0 command as shown in
0, but as you see, that's already getting you into
portability snags.

should be more efficient than shelling out to 0 for each key.
It even includes limited support for Windows.

and can use it to build and install a CPAN module.  Here's a solution
using the standard 0 module, which is already on your system
(assuming your system supports POSIX).

to manipulate the POSIX termios structures.

0 module from CPAN, passing it an argument of -1 to indicate
not to block:

that tells the terminal to clear the screen. Once you have that
sequence, output it when you want to clear the screen.

sequence. Import the 0 function (or the 0 tag):

to deal with the low-level details of terminal control. The 0
method returns the string for the given capability:

an object for the output filehandle you want to affect, call the
0 method:

it in backticks to capture whatever it outputs so you can use it
later:

you can use it to fetch the width and height in characters
and in pixels:

illustrative:

FAQ for that.)

terminal into "no echo" mode, then just read the password normally.
You may do this with an old-style 0 function, POSIX terminal
control (see 0 or its documentation the Camel Book), or a call
to the 0 program, with varying degrees of portability.

from CPAN, which is easier to use and in theory more portable.

the case of Unix, the serial ports will be accessible through files in
/dev; on other systems, device names will doubtless differ.
Several problem areas common to all device interaction are the
following:

you follow the correct protocol.  Unpredictable behavior can result
from multiple processes reading from one device.

you'll have to open it for update (see 0 for
details).  You may wish to open it without running the risk of
blocking by using 0 and 0 from the
0 module (part of the standard perl distribution).  See
0 for more on this approach.

than a "\n".  In some ports of perl, "\r" and "\n" are different from
their usual (Unix) ASCII values of "\015" and "\012".  You may have to
give the numeric values you want directly, using octal ("\015"), hex
("0x0D"), or as a control-character specification ("\cM").

still no unified scheme for terminating a line that is portable
between Unix, DOS/Win, and Macintosh, except to terminate 0 line
ends with "\015\012", and strip what you don't need from the output.
This applies especially to socket I/O and autoflushing, discussed
next.

you'll want to autoflush that filehandle.  You can use 0
and the 0 variable to control autoflushing (see L<perlvar/
and 0, or 0, "How do I flush/unbuffer an
output filehandle?  Why must I do this?"):

of code just because you're afraid of a little 0 variable:

socket I/O between Unix and Macintosh.  You'll need to hard code your
line terminators, in that case.

arrange for an alarm handler to provide a timeout (see
0).  If you have a non-blocking open, you'll likely
have a non-blocking read, which means you may have to use a 4-arg
0 to determine whether I/O is ready on that device (see
0.

Zawinski , after much gnashing of teeth and
fighting with 0, 0, POSIX's 0 business,
and various other functions that go bump in the night, finally came up
with this:

bound to get you talked about.

password system employs one-way encryption.  It's more like hashing
than encryption.  The best you can do is check whether something else
hashes to the same string.  You can't turn a hash back into the
original string. Programs like Crack can forcibly (and intelligently)
try to guess passwords, but don't (can't) guarantee quick success.

proactively check when they try to change their password (by modifying
, for example).

have to wait for it to finish before your program moves on to other
tasks. Process management depends on your particular operating system,
and many of the techniques are in 0.

0, 0, 0,
0, 0, 0, and
0. There are many other modules you might use, so
check those namespaces for other options too.

system call where you put an 0 on the end of the command:

this is the same thing that many of the modules will do for you).

share the same STDIN, STDOUT and STDERR filehandles.  If both try to
access them at once, strange things can happen.  You may want to close
or reopen these for the child.  You can get around this with
0ing a pipe (see 0) but on some systems this
means that the child process cannot outlive the parent.

SIGCHLD is sent when the backgrounded process finishes.  SIGPIPE is
sent when you write to a filehandle whose child process has closed (an
untrapped SIGPIPE can cause your program to silently die).  This is
not an issue with 0.

first child, and the init daemon will 0 for your grandchild once
it exits.

Zombies are not an issue with 0.

generates a signal which is sent to your terminal's currently
foregrounded process group, which you then trap in your process.
Signals are documented in 0 and the
section on "Signals" in the Camel.

to handle the signal.  After perl catches the signal, it looks in 0
for a key with the same name as the signal, then calls the subroutine
value for that key.

would catch the signal and possibly run a Perl function that you had set
in 0.  This violated the rules of signal handling at that level
causing perl to dump core. Since version 5.8.0, perl looks at 0
0 the signal has been caught, rather than while it is being caught.
Previous versions of this answer were incorrect.

properly, the 0 functions described in 0 should in
theory provide (read-only) access to entries in the shadow password
file.  To change the file, make a new shadow password file (the format
varies from system to system--see 0 for specifics) and use
0 to install it (see 0 for more details).

able to set the system-wide date and time by running the 0
program.  (There is no way to set the time and date on a per-process
basis.)  This mechanism will work for Unix, MS-DOS, Windows, and NT;
the VMS equivalent is 0.

probably get away with setting an environment variable:

0 0 0 0

function provides, the easiest way is to use the 0 function as
documented in 0.  Try the 0 and
the 0 modules (available from CPAN, and starting from
Perl 5.8 0 is part of the standard distribution).

0 0 0 0

Perl 5.8) measures time with the 0 system call, which
returns the time in microseconds since the epoch. If you can't install
0 for older Perls and you are on a Unixish system, you
may be able to call 0 directly. See
0.

0 block is called when the program or thread ends. See the 0
manpage for more details about 0 blocks.

to finish its output without filling up the disk:

though, so if you use 0 blocks you should also use

can use 0 as 0 and 0 as 0. For
details of this, see the section on signals, especially the time-out
handler for a blocking 0 in 0 or the
section on "Signals" in 0.

many CPAN modules that handle exceptions, such as 0.

0 module available from CPAN.

standard socket constants.  Since these were constant across all
architectures, they were often hardwired into perl code.  The proper
way to deal with this is to "use Socket" to get the correct values.

values are different.  Go figure.

to "Where can I learn about linking C with Perl? [h2xs, xsubpp]".
However, if the function is a system call, and your system supports
0, you can use the 0 function (documented in
0).

CPAN as well--someone may already have written a module to do it. On
Windows, try 0.  On Macs, try 0.  If no module
has an interface to the C function, you can inline a bit of C in your
Perl source with 0.

standard perl distribution.  This program converts 0 directives
in C header files to files containing subroutine definitions, like
0, which you can use as arguments to your functions.
It doesn't work perfectly, but it usually gets most of the job done.
Simple files like 0, 0, and 0 were fine,
but the hard ones like 0 nearly always need to be hand-edited.
Here's how to install the *.ph files:

sanity you probably ought to use 0 (also part of the standard perl
distribution).  This tool converts C header files to Perl extensions.
See 0 for how to get started with 0.

ought to use 0.  See 0 and 0 for
more information (in brief, just use 0 instead of a plain
0 to rebuild perl with a new static extension).

scripts inherently insecure.  Perl gives you a number of options
(described in 0) to work around such systems.

an easy-to-use approach that internally uses 0, 0, and
0 to do the job.  Make sure you read the deadlock warnings in
its documentation, though (see 0).  See
0 and
0

distribution), but be warned that it has a different order of
arguments from 0 (see 0).

runs a command and returns exit status information (as a 16 bit value:
the low 7 bits are the signal the process died from, if any, and
the high 8 bits are the actual exit value).  Backticks (``) run a
command and return what it sent to STDOUT.

script's STDOUT and STDERR, unless the 0 command redirects them.
Backticks and 0 read 0 the STDOUT of your command.

Goldberg provides some sample code:

redirect them to temp files, let the command run, then read the temp
files:

should work just as well, without deadlocking:

stdout immediately, rather than waiting for the program to finish.

duplicate of STDOUT:

in your Perl program and avoid calling the shell to do the redirection.
This doesn't work:

going at the time of the 0.  The backticks then make STDOUT go to
a string, but don't change STDERR (which still goes to the old
STDOUT).

backticks, not 0!  Details on why Perl's 0 and backtick
and pipe opens all use the Bourne shell are in the
0 article in the "Far More Than You Ever Wanted To
Know" collection in http://www.cpan.org/misc/olddoc/FMTEYEWTK.tgz .  To
capture a command's STDERR and STDOUT together:

but leave its STDOUT to come out our old STDERR:

to redirect them separately to files, and then read from those files
when the program is done:

processes file descriptor redirections in strictly left to right order.

temporary file.  The second command sends only the old standard output
there, and the old standard error shows up on the old standard out.

metacharacters, perl 0s, then 0s a shell to decode the
metacharacters and eventually run the desired program.  If the program
couldn't be run, it's the shell that gets the message, not Perl. All
your Perl program can find out is whether the shell itself could be
successfully started.  You can still capture the shell's STDERR and
check it for error messages.  See 0 elsewhere in this document, or use the
0 module.

runs the command directly, without using the shell, and can correctly
report whether the command started.

way to write maintainable code.  Perl has several operators for
running external commands.  Backticks are one; they collect the output
from the command for use in your program.  The 0 function is
another; it doesn't do this.

of your code that you wanted to collect the output of the command.
Why send a clear message that isn't true?

correctly.  Even if you wrote

of waiting until the program has completed to print it out. It also
checks the return value.

processing may take place, whereas backticks do not.

like this:

Just like the list forms of 0 and 0, no shell
escapes happen.

list. Further examples of this can be found in 0.

even possible.  Even though Perl emulates 0, you'll still be
stuck, because Windows does not have an argc/argv-style API.

perlio, which is the default. Some (maybe all?) stdios set error and
eof flags that you may need to clear. The 0 module defines
0perl converter
nigh-on impossible to write.  By rewriting it, you'll think about what
you're really trying to do, and hopefully will escape the shell's
pipeline datastream paradigm, which while convenient for some matters,
causes many inefficiencies.

(available from CPAN).
http://www.cpan.org/scripts/netstuff/telnet.emul.shar will also help
for emulating the telnet protocol, but 0 is quite
probably easier to use.

the initial telnet handshaking, then the standard dual-process
approach will suffice:

standard perl distribution), which never really got finished.  If you
find it somewhere, 0.  These days, your best bet is to
look at the Expect module available from CPAN, which also requires two
other modules from CPAN, 0 and 0.

avoid people seeing passwords, for example) then you should rewrite
your program so that critical information is never given as an
argument.  Hiding the arguments won't make your program completely
secure.

variable  as documented in 0.  This won't work on all
operating systems, though.  Daemon programs like sendmail place their
state there, as in:

different process from the shell it was started from.  Changes to a
process are not reflected in its parent--only in any children
created after the change.  There is shell magic that may allow you to
fake it by 0ing the script's output in your shell; check out the
comp.unix.questions FAQ for details.

to the process (see 0).  It's common to first send a TERM
signal, wait a little bit, and then send a KILL signal to finish it off.

its tty), then the following process is reported to work on most
Unixish systems.  Non-Unix users should check their Your_OS::Process
module for other solutions.

for details.  Or better yet, you can just use the 0
function, so you don't have to worry about process groups.

tty.

perform these actions for you.

only a guess.

your filehandles is connected to a terminal, you can try the 0
file test:

real person on the other side. With the 0 module, another
program can pretend to be a person. The program might even come close
to passing the Turing test.

answer. Its 0 function returns an output filehandle;
that filehandle points to standard output if the module thinks the
session is interactive. Otherwise, the filehandle is a null handle
that simply discards the output:

prompts or reading your output.

distribution, you can check the environment. The CPAN
Testers, for instance, set the value of 0:

handler, as documented in 0 and the section on
"Signals" in the Camel.  You may instead use the more flexible
0 module available from CPAN.

Check the documentation for your specific version of Perl.

0 0 0

After 10 seconds of time spent running on the CPU (not "wall" time),
the process will be sent a signal (XCPU on some systems) which, if not
trapped, will cause the process to terminate.  If that signal is
trapped, then after 10 more seconds (20 seconds in total) the process
will be killed with a non-trappable signal.

details.

SIGCHLD is received, or else use the double-fork technique described
in 0.

servers and types, including Oracle, DB2, Sybase, mysql, Postgresql,
ODBC, and flat files.  The DBI module accesses each database type
through a database driver, or DBD.  You can see a complete list of
available drivers on CPAN: http://www.cpan.org/modules/by-module/DBD/ .
You can read more about DBI on http://dbi.perl.org .

0, and others found on CPAN Search: http://search.cpan.org .

sample code) and then have a signal handler for the INT signal that
passes the signal on to the subprocess.  Or you can check for it:

non-blocking reads (most Unixish systems do), you need only to use the
0 or 0 flag from the 0 module in conjunction with
0:

and that something else may output error messages.  The script might
emit its own warnings and error messages.  Most of the time you cannot
tell who said what.

perl outputs its warnings by defining a custom warning and die functions.

bash).  That may look like perl forgot it has a 0 function,
but my shebang line is not the path to perl, so the shell runs the
script, and I get the error.

you need to figure out the problem.

works at compile time so all of the compilation errors and warnings
get the "Perl:" prefix too.

some people who may know all of them, you probably don't.  However, they
all should be in the 0 manpage. If you don't find the error in
there, it probably isn't a perl error.

for you.  Use the diagnostics pragma with turns perl's normal messages
into longer discussions on the topic.

might not be perl's message.

the 0 command that comes with Perl. You can give it a list of modules
to install:

tell 0 to install 0 (the full stop):

you can do.

all dependencies on your own, you follow one of two possible build
paths.

code and their build and installation sequences may be more complicated.
Check any 0 or 0 files that you may find.

and runs the file, it doesn't do anything else. The 0 statement
is the same as a 0 run at compile-time, but Perl also calls the
0 method for the loaded package. These two are the same:

import list. Both of these still happen at compile-time:

for 0 must be a bareword. That is, 0 cannot load files
by name, although 0 can:

be 0, which you can download from CPAN. It sets various
installation settings for you, and uses those same settings within
your programs.

for your particular situation.

when generating Makefiles:

automatically install in your private library directory when you use
the CPAN.pm shell:

0.  See 0 for details on how to run your newly
installed modules.

differently from the PREFIX and LIB settings that older versions of
0 advocated. INSTALL_BASE does not support
installing modules for multiple versions of Perl or different
architectures under the same directory. You should consider whether you
really want that and, if you do, use the older PREFIX and LIB
settings. See the 0 documentation for more details.

for any other directory. You might <use lib> if you know the directory
at compile time:

anything else (such as a 0), you can get the current working
directory with the 0 module, which comes with Perl:

script name. That might hold a relative path, but 0 can turn
it into an absolute path. Once you have the

directory of the currently running script and puts it in 0, which
you can then use to construct the right library path:

modules using 0's settings then use the module in your
program:

environment variables, run-time switches, and in-code statements:

architectures.  The 0 pragmatic module was first
included with the 5.002 release of Perl.

constants.  Sometimes it is built using 0 when Perl is installed,
but other times it is not.  Modern programs 0 instead.

other authors as noted. All rights reserved.

under the same terms as Perl itself.

are hereby placed into the public domain.  You are permitted and
encouraged to use this code in your own programs for fun
or for profit as you see fit.  A simple comment in the code giving
credit would be courteous but is not required. 

=encoding utf8

and a few on the web.

a program ("CGI script") and a web server (HTTPD). It is not specific
to Perl, and has its own FAQs and tutorials, and usenet group,
comp.infosystems.www.authoring.cgi

http://www.ietf.org/rfc/rfc3875

programmers are strongly advised to use the 0 module, to take care
of the details for them.

specification) and HTTP response headers (defined in the HTTP
specification, RFC2616) is intentional, but can sometimes be confusing.

script, and the "Non Parsed Header" (NPH) script. Check your server
documentation to see what it supports. "Parsed Header" scripts are
simpler in various respects. The CGI specification allows any of the
usual newline representations in the CGI response (it's the server's
job to create an accurate HTTP response based on it). So "\n" written in
text mode is technically correct, and recommended. NPH scripts are more
tricky: they must put out a complete and accurate set of HTTP
transaction response headers; the HTTP specification calls for records
to be terminated with carriage-return and line-feed; i.e., ASCII \015\012
written in binary mode.

systems. 0 selects an appropriate newline representation
(0) and sets binmode as appropriate.

some of them might be related to Perl. Try going through the troubleshooting
guide on Perlmonks:

normal 0 module's 0, 0, and 0 functions with
more verbose and safer versions.  It still sends them to the normal
server error log.

placed in a 0 block to catch compile-time warnings as well:

which is nice for your own debugging, but might confuse the end user.

will try to take care of this to avoid the dreaded server 500 errors.
Normal warnings still go out to the server error log (or wherever
you've sent them with 0) with the application name and date
stamp prepended.

from CPAN.  Another mostly correct
way is to use 0 which not only removes HTML but also
attempts to do a little simple formatting of the resulting plain text.

, but that fails in many cases because the tags
may continue over line breaks, they may contain quoted angle-brackets,
or HTML comments may be present.  Plus, folks forget to convert
entities--like 0 for example.

program in
http://www.cpan.org/authors/Tom_Christiansen/scripts/striphtml.gz
.

a solution:

on text like this:

0 which handles anchors, images, objects,
frames, and many other tags that can contain a URL.  If you need
anything more complex, you can create your own subclass of
0 or 0.  You might even use
0 as an example for something specifically
suited to your needs.

you a lot of processing time if you know that the input is simple.  One
solution from Tom Christiansen runs 100 times faster than most
module-based approaches but only extracts URLs from anchors where the first
attribute is HREF and there are no other attributes.

forms.  You allow the web surfer to specify a file to send to your web
server.  To you it looks like a download, and to the user it looks
like an upload.  No matter what you call it, you do it with what's
known as 0 encoding.  The 0 module (which
comes with Perl as part of the Standard Library) supports this in the
0 method, which isn't the same as the 0
method.

examples and details.

the HTML form widgets. See the 0 documentation for more
examples.

resources and give their content back to you as a string:

0 module to create your own user-agent (e.g. browser)
to get the job done. If you want to simulate an interactive web
browser, you can use the 0 module.

and forms or a web site, you can use 0.  See its
documentation for all the details.

the form using the 0 method:

the content appropriately.

0 0 0 0 0

in RFC 2396, Section 2. This encoding replaces the reserved character
with the hexadecimal representation of the character's number from
the US-ASCII table. For instance, a colon, 0, becomes 0.

using 0. You shouldn't have to process the URI yourself,
either on the way in or the way out.

never try to encode an already-composed URI. You need to escape the
components separately then put them together. To encode a string, you
can use the 0 module. The 0 function
returns the escaped string:

reserved characters with their encodings. A global substitution
is one way to do it:

server). This is one of the two different kinds of CGI "Location:"
responses which are defined in the CGI specification for a Parsed Headers
script. The other kind (an absolute URLpath) is resolved internally to
the server without any HTTP redirection. The CGI specifications do not
allow relative URLs in either case.

with a complete URL. This redirection is handled by the web browser.

redirection is handled by the local web server.

shown separately, for clarity), using either a complete URL or
an absolute URLpath.

your web server.  The configuration is different for different sorts
of web servers--apache does it differently from iPlanet which does
it differently from IIS.  Check your web server documentation for
the details for your particular server.

consistent OO interface to these files, regardless of how they're
stored.  Databases may be text, dbm, Berkeley DB or any database with
a DBI compatible driver.  0 supports files used by the
"Basic" and "Digest" authentication schemes.  Here's an example:

you add some client-side checks, people may disable them or bypass
them completely. For instance, someone might use a module such as
0 to access your CGI program. If you want to prevent data that
try to use SQL injection or other sorts of attacks (and you should
want to), you have to not trust any data that enter your program.

If you are using the 0 module, use placeholder to fill in data.
If you are running external programs with 0 or 0, use
the list forms. There are many other precautions that you should take,
too many to list here, and most of them fall under the category of not
using any data that you don't intend to use. Trust no one.

from 0:

maintain all the Received lines.  A more complete approach is to use
the 0 module from CPAN (part of the 0 package).

it's easy, and it actually does quite a bit of work to
ensure things happen correctly.  It handles GET, POST, and
HEAD requests, multipart forms, multivalued fields, query
string and message body combinations, and many other things
you probably don't want to think about.

parses the input and makes each value available through the
0 function.

of the same thing.  Other CGI::* modules on CPAN might work better
for you, too.

another program) and then run into one of the many "gotchas"
of the task.  It's much easier and less hassle to use 0.

on the other end to answer you, you cannot fully answer part 0, but
either the 0 or the 0 module will do
both part 0 and part 0 as far as you can in real-time.

according to the mail header standard with a simple regular expression,
you can have problems, because there are deliverable addresses that
aren't RFC-2822 (the latest mail header standard) compliant, and
addresses that aren't deliverable which, are compliant.  However,  the
following will match valid RFC-2822 addresses that do not have comments,
folding whitespace, or any other obsolete or non-essential elements.
This 0 matches the address itself:

the RFC2822 specification.  However, because it is impossible to be
sure that such a correctly formed address is actually the correct way
to reach a particular person or even has a mailbox associated with it,
you must be very careful about how you use this.

enter their address twice, just as you normally do to change a
password. This usually weeds out typos. If both versions match, send
mail to that address with a personal message. If you get the message
back and they've followed your directions, you can be reasonably
assured that it's real.

(personal ID number).  Record the address and PIN (best that it be a
random one) for later processing. In the mail you send, ask them to
include the PIN in their reply.  But if it bounces, or the message is
included via a "vacation" script, it'll be there anyway.  So it's
best to ask them to mail back a slight alteration of the PIN, such as
with the characters reversed, one added or subtracted to each digit, etc.

the MIME/QP encoding.  Decoding BASE64 becomes as simple as:

decoding of BASE64 encoded attachments and content directly from email
messages.

a more direct approach is to use the 0 function's "u"
format after minor transliterations:

0 module (which is part of the standard perl distribution),
you can probably try using something like this:

that the company's mail system will not accept, so you should ask for
users' mail addresses when this matters.  Furthermore, not all systems
on which Perl runs are so forthcoming with this information as is Unix.

0 function that tries to guess the mail address of the user.
It makes a more intelligent guess than the code above, using information
given when the module was installed, but it could still be incorrect.
Again, the best way is often just to ask the user.

of a single dot as "end of message".  The 0 option says to use the
headers to decide who to send the message to, and 0 says to put
the message into the queue.  This last option means your message won't
be immediately delivered, so leave it out if you want immediate
delivery.

called 0) directly or simply opening up port 25 have having an
intimate conversation between just you and the remote SMTP daemon,
probably 0.

0, but less reliable.  Avoid raw SMTP commands.  There
are many reasons to use a mail transport agent like 0.  These
include queuing, MX records, and security.

Create a multipart message (i.e., one with attachments).

SMTP via 0.

0 package) or the 0 module from CPAN (part
of the 0 package), often a module is overkill.  Here's a
mail sorter.

0

in perl5.7.3, can get you the fully qualified domain name (FQDN), the host
name, or the domain name.

perl5.6, can also get the hostname.

to turn the name into a number. To turn that number into the dotted octet
form (a.b.c.d) that most people expect, use the 0 function
from the 0 module, which also comes with perl.

This can make tasks like fetching the newsgroup list as simple as

can work with FTP just like it can with many other protocols. 0
makes it quite easy to fetch a file:

the 0 module (in the Standard Library since Perl 5.8). It's
documentation has examples showing you just how to do that.

http://search.cpan.org/search?query=RPC&mode=all ).

other authors as noted. All rights reserved.

under the same terms as Perl itself.

are hereby placed into the public domain.  You are permitted and
encouraged to use this code in your own programs for fun
or for profit as you see fit.  A simple comment in the code giving
credit would be courteous but is not required. 

=encoding utf8

0. Source filters alter the program text of a module
before Perl sees it, much as a C preprocessor alters the source text of
a C program before the compiler sees it. This article tells you more
about what source filters are, how they work, and how to write your
own.

program source to prevent casual piracy. This isn't all they can do, as
you'll soon learn. But first, the basics.

read it from a file into memory for parsing and compilation. If that
script itself includes other scripts with a 0 or 0
statement, then each of those scripts will have to be read from their
respective files as well.

individual file as a 0. A source stream is created when
the Perl parser opens a file, it continues to exist as the source code
is read into memory, and it is destroyed when Perl is finished parsing
the file. If the parser encounters a 0 or 0 statement in
a source stream, a new and distinct stream is created just for that
file.

source from a Perl script file on the left into the Perl parser on the
right. This is how Perl normally operates.

given time, only one will be active.

modifies a source stream before it reaches the parser. A source filter
changes our diagram like this:

pipeline. Say you have a shell script stored in the compressed file
0. The simple pipeline command below runs the script without
needing to create a temporary file to hold the uncompressed file.

a source filter is just a special kind of module. Like all Perl
modules, a source filter is invoked with a use statement.

execution. As it happens, the source filters distribution comes with a C
preprocessor filter module called Filter::cpp.

Line numbers have been added to allow specific lines to be referenced
easily.

file. Before the parser processes any of the lines from the file, the
source stream looks like this:

module. All source filters work this way. The use statement is compiled
and executed at compile time, before any more of the file is read, and
it attaches the cpp filter to the source stream behind the scenes. Now
the data flow looks like this:

stream, it feeds those lines through the 0 source filter before
processing them. The 0 filter simply passes each line through the
real C preprocessor. The output from the C preprocessor is then
inserted back into the source stream by the filter.

module with use:

to the text of the file that used it (0). Although the use
statement on line 3 will pass through the cpp filter, the module that
gets included (0) will not. The source streams look like this
after line 3 has been parsed and before line 4 is parsed:

from 0. This stream will remain active until all of 0
has been parsed. The source stream for 0 will still exist,
but is inactive. Once the parser has finished reading Fred.pm, the
source stream associated with it will be destroyed. The source stream
for 0 then becomes active again and the parser reads line 4
and subsequent lines from 0.

you can reuse the same filter in as many files as you like.

possible to stack a uudecode filter and an uncompression filter like
this:

file. The uudecode filter appeared before the uncompress filter, so the
source file will be uudecoded before it's uncompressed.

in C, use an external program as a filter, or write the filter in Perl.
I won't cover the first two in any great detail, so I'll get them out
of the way first. Writing the filter in Perl is most convenient, so
I'll devote the most space to it.

completely in C. The external module you create interfaces directly
with the source filter hooks provided by Perl.

the implementation of your filter. The big disadvantage is the
increased complexity required to write the filter - not only do you
need to understand the source filter hooks, but you also need a
reasonable knowledge of Perl guts. One of the few times it is worth
going to this trouble is when writing a source scrambler. The
0 filter (which unscrambles the source before Perl parses it)
included with the source filter distribution is an example of a C
source filter (see Decryption Filters, below).

obscurity." Regardless of how well you write a decryption filter and
how strong your encryption algorithm is, anyone determined enough can
retrieve the original source code. The reason is quite simple - once
the decryption filter has decrypted the source back to its original
form, fragments of it will be stored in the computer's memory as Perl
parses it. The source might only be in memory for a short period of
time, but anyone possessing a debugger, skill, and lots of patience can
eventually reconstruct your program.

difficult for the potential cracker. The most important: Write your
decryption filter in C and statically link the decryption module into
the Perl binary. For further tips to make life difficult for the
potential cracker, see the file 0 in the source filters
distribution.

executable in the language of your choice. The separate executable
reads from standard input, does whatever processing is necessary, and
writes the filtered data to standard output. 0 is an
example of a source filter implemented as a separate executable - the
executable is the C preprocessor bundled with your C compiler.

task: 0 and 0. Both allow you to run any
external executable. Both use a coprocess to control the flow of data
into and out of the external executable. (For details on coprocesses,
see Stephens, W.R., "Advanced Programming in the UNIX Environment."
Addison-Wesley, ISBN 0-210-56317-7, pages 441-445.) The difference
between them is that 0 spawns the external command
directly, while 0 spawns a shell to execute the external
command. (Unix uses the Bourne shell; NT uses the cmd shell.) Spawning
a shell allows you to make use of the shell metacharacters and
redirection facilities.

small performance penalty is incurred. For example, if you execute the
small example above, a separate subprocess will be created to run the
Unix 0 command. Each use of the filter requires its own subprocess.
If creating subprocesses is expensive on your system, you might want to
consider one of the other options for creating source filters.

source filter is to write it completely in Perl. To distinguish this
from the previous two techniques, I'll call it a Perl source filter.

to study. Here is a complete source filter that performs rot13
decoding. (Rot13 is a very simple encryption scheme used in Usenet
postings to hide the contents of offensive posts. It moves every letter
forward thirteen places, so that A becomes N, B becomes O, and Z
becomes M.)

same basic structure as the example above.

number of functions into your filter's namespace. The filter shown
above uses two of these functions, 0 and
0.

stream by defining the 0 function. If you know Perl well
enough, you know that 0 is called automatically every time a
module is included with a use statement. This makes 0 the ideal
place to both create and install a filter object.

other Perl object. Our example uses an anonymous array, but this isn't
a requirement. Because this example doesn't need to store any context
information, we could have used a scalar or hash reference just as
well. The next section demonstrates context data.

with the 0 function. This takes a filter object as a
parameter (0 in this case) and installs it in the source stream.

type of Perl source filter, all the filtering is done in a method
called 0. (It is also possible to write a Perl source filter
using a closure. See the 0 manual page for more
details.) It's called every time the Perl parser needs another line of
source to process. The 0 method, in turn, reads lines from
the source stream using the 0 function.

returns a status value greater than zero and appends the line to 0.
A status value of zero indicates end-of-file, less than zero means an
error. The filter function itself is expected to return its status in
the same way, and put the filtered line it wants written to the source
stream in 0. The use of 0 accounts for the brevity of most Perl
source filters.

the source file in rot13 format. The script below, 0, does
just that.

that shows off a few more features.

during development, but you didn't want it available in the released
product. Source filters offer a solution. In order to keep the example
simple, let's say you wanted the debugging output to be controlled by
an environment variable, 0. Debugging code is enabled if the
variable exists, otherwise it is disabled.

and 0 markers only when the 0 environment variable
exists. That means that when 0 does exist, the code above
should be passed through the filter unchanged. The marker lines can
also be passed through as-is, because the Perl parser will see them as
comment lines. When 0 isn't set, we need a way to disable the
debug code. A simple way to achieve that is to convert the lines
between the two markers into comments:

use of context data in the filter object. The filter object is based on
a hash reference, and is used to keep various pieces of context
information between calls to the filter function. All but two of the
hash fields are used for error reporting. The first of those two,
Enabled, is used by the filter to determine whether the debugging code
should be given to the Perl parser. The second, InTraceBlock, is true
when the filter has encountered a 0 line, but has not yet
encountered the following 0 line.

essence of the filter is as follows:

doesn't know Perl. It can be fooled quite easily:

amount of code.

might even have a possible use for them. If you feel like playing with
source filters but need a bit of inspiration, here are some extra
features you could add to the Debug filter.

all-or-nothing, it would be much more useful to be able to control
which specific blocks of debugging code get included. Try extending the
syntax for debug blocks to allow each to be identified. The contents of
the 0 environment variable can then be used to control which
blocks get included.

nested. That isn't difficult either.

Currently Perl subroutines have fairly limited support for formal
parameter lists. You can specify the number of parameters and their
type, but you still have to manually take them out of the 0 array
yourself. Write a source filter that allows you to have a named
parameter list. Such a filter would turn this:

full-blown Perl macro preprocessor as a source filter. Borrow the
useful features from the C preprocessor and any other macro processors
you know. The tricky bit will be choosing how much knowledge of Perl's
syntax you want your filter to have.

When using these source filters you cannot rely on this handle, nor expect
any particular kind of behavior when operating on it.  Filters based on
Filter::Util::Call (and therefore Filter::Simple) do not alter the 0
filehandle.

Source Filters distribution) is part of the standard Perl distribution.
Also included is a friendlier interface called Filter::Simple, by
Damian Conway.

copyright 1998 The Perl Journal. It appears courtesy of Jon Orwant and
The Perl Journal.  This document may be distributed under the same terms
as Perl itself. 

=encoding utf8

of the same name.  On most Unix-like platforms where the  system
call is available, Perl's  simply calls it.

available, Perl can be built to emulate  at the interpreter level.
While the emulation is designed to be as compatible as possible with the
real  at the level of the Perl program, there are certain
important differences that stem from the fact that all the pseudo child
"processes" created this way live in the same real process as far as the
operating system is concerned.

limitations of the  emulation.  Note that the issues discussed here
are not applicable to platforms where a real  is available and Perl
has been configured to use it.

What this means in general is that running  will actually clone the
running interpreter and all its state, and run the cloned interpreter in
a separate thread, beginning execution in the new thread just after the
point where the  was called in the parent.  We will refer to the
thread that implements this child "process" as the pseudo-process.

transparent.  The parent returns from the  with a pseudo-process
ID that can be subsequently used in any process-manipulation functions;
the child returns from the  with a value of 0 to signify that
it is the child pseudo-process.

It can be used to identify pseudo-processes within a particular
session.  Note that this value is subject to recycling if any
pseudo-processes are launched after others have been -ed on.

to %ENV affect the virtual environment, and are only visible within that
pseudo-process, and in any processes (or pseudo-processes) launched from
it.

Modifications to the current directory using  are only visible within
that pseudo-process, and in any processes (or pseudo-processes) launched from
it.  All file and directory accesses from the pseudo-process will correctly
map the virtual working directory to the real working directory appropriately.

These calls will properly wait for the termination of the pseudo-process
and return its status.

passing it the ID returned by .  This should not be used except
under dire circumstances, because the operating system may not
guarantee integrity of the process resources when a running thread is
terminated.  Note that using 0 on a
pseudo- may typically cause memory leaks, because the thread
that implements the pseudo-process does not get a chance to clean up
its resources.

signal will not be delivered while the pseudo-process is blocked by a
system call, e.g. waiting for a socket to connect, or trying to read
from a socket with no data available.  Starting in Perl 5.14 the
parent process will not wait for children to exit once they have been
signalled with 0 to avoid deadlock during process
exit.  You will have to explicitly call  to make sure the
child has time to clean-up itself, but you are then also responsible
that the child is not blocking on I/O either.

executable in a separate process and waits for it to complete before
exiting with the same exit status as that process.  This means that the
process ID reported within the running executable will be different from
what the earlier Perl  might have returned.  Similarly, any process
manipulation functions applied to the ID returned by  will affect the
waiting pseudo-process that called , not the real process it is
waiting for after the .

END blocks will still be called after the external process returns.

-ing for any outstanding child pseudo-processes.  Note that this means
that the process as a whole will not exit unless all running pseudo-processes
have exited.  See below for some limitations with open filehandles.

any handles in one process does not affect the others.  See below for
some limitations.

emulation are simply threads in the same process.  This means that any
process-level limits imposed by the operating system apply to all
pseudo-processes taken together.  This includes any limits imposed by the
operating system on the number of open file, directory and socket handles,
limits on disk space usage, limits on memory size, limits on CPU utilization
etc.

using some external means) all the pseudo-processes are killed as well,
and the whole process exits.

pseudo-process started by it will wait for their respective pseudo-children
to complete before they exit.  This means that the parent and every
pseudo-child created by it that is also a pseudo-parent will only exit
after their pseudo-children have exited.

for any child that has been signalled with 0
to avoid a deadlock in case the child is blocking on I/O and
never receives the signal.

within a BEGIN block.  The forked copy will run the contents of the
BEGIN block, but will not continue parsing the source stream after the
BEGIN block.  For example, consider the following code:

cloning and restarting the stacks used by the Perl parser in the
middle of a parse.

the files can be closed independently in the parent and child, but beware
that the -ed handles will still share the same seek pointer.  Changing
the seek position in the parent will change it in the child and vice-versa.
One can avoid this by opening files that need distinct seek pointers
separately in the child.

from a child process will flush and close open filehandles in the parent,
thereby corrupting the filehandles.  On these systems, calling 0
is suggested instead.  0 is available in Perl through the
0 module.  Please consult your system's manpages for more information
on this.

reach the end of the stream.  It will then  back to the
original location and all future  requests will be fulfilled
from the cache buffer.  That means that neither the directory handle held
by the parent process nor the one held by the child process will see
any changes made to the directory after the  call.

force  to read the directory again either.  Only a newly
opened directory handle will reflect changes to the directory.

implemented.  This limitation can be easily worked around in new code
by creating a pipe explicitly.  The following example shows how to
write to a forked child:

not work correctly.  Such XSUBs will either need to maintain locks to
protect simultaneous access to global data from different pseudo-processes,
or maintain all their state on the Perl symbol table, which is copied
naturally when  is called.  A callback mechanism that provides
extensions an opportunity to clone their state will be provided in the
near future.

application which embeds a Perl interpreter and calls Perl APIs that can
evaluate bits of Perl code.  This stems from the fact that the emulation
only has knowledge about the Perl interpreter's own data structures and
knows nothing about the containing application's state.  For example, any
state carried on the application's own call stack is out of reach.

calling into non-thread-safe libraries may not work reliably when
calling .  As Perl's threading support gradually becomes more
widely adopted even on platforms with a native , such extensions
are expected to be fixed for thread-safety.

0 because the  and  functions treat this number as
being special.  The tacit assumption in the current implementation is that
the system never allocates a thread ID of 0 for user threads.  A better
representation for pseudo-process IDs will be implemented in future.

and  operators are apparently not duplicated accurately in
pseudo-processes.  This only happens in some situations, but where it
does happen, it may result in deadlocks between the read and write ends
of pipe handles, or inability to send or receive data across socket
handles.

by ActiveState, with funding from Microsoft Corporation.

0gsar@activestate.com0.

=encoding utf8

0 0 0

facilitate this, Perl helps you code up your output page close to how it
will look when it's printed.  It can keep track of things like how many
lines are on a page, what page you're on, when to print page headers,
etc.  Keywords are borrowed from FORTRAN:  to declare and 
to execute; see their entries in 0.  Fortunately, the layout is
much more legible, more like BASIC's PRINT USING statement.  Think of it
as a poor man's .
0

executed, so they may occur at any point in your program.  (Usually it's
best to keep them all together though.) They have their own namespace
apart from all the other "types" in Perl.  This means that if you have a
function named "Foo", it is not the same thing as having a format named
"Foo".  However, the default name for the format associated with a given
filehandle is the same as the name of the filehandle.  Thus, the default
format for STDOUT is named "STDOUT", and the default format for filehandle
TEMP is named "TEMP".  They just look the same.  They aren't.

column 1 is used to terminate a format.  FORMLIST consists of a sequence
of lines, each of which may be one of three types:

literal text. These lines do not undergo any kind of variable interpolation.
Field definitions are made up from a set of characters, for starting and
extending a field to its desired width. This is the complete set of
characters for field definitions:
0
0 0    0 0 0 0
0 0 0 0

indicating what we'll call, respectively, a "regular" or "special" field.
The choice of pad characters determines whether a field is textual or
numeric. The tilde operators are not part of a field.  Let's look at
the various possibilities in detail.

0

"0", "0", or "|" characters to specify a non-numeric field with,
respectively, left justification, right justification, or centering.
For a regular field, the value (up to the first newline) is taken and
printed according to the selected justification, truncating excess characters.
If you terminate a text field with "...", three dots will be shown if
the value is truncated. A special text field may be used to do rudimentary
multi-line text block filling; see 0 for details.

0 0

right justification. An optional "." defines the position of the
decimal point. With a "0" (zero) instead of the first "#", the
formatted number will be padded with leading zeroes if necessary.
A special numeric field is blanked out if the value is undefined.
If the resulting value would exceed the width specified the field is
filled with "#" as overflow evidence.

0

values; it should (but need not) appear by itself on a line. A final
line feed is chomped off, but all other characters are emitted verbatim.

0

scalar variable. Perl puts the first line (up to the first "\n") of the
text into the field, and then chops off the front of the string so that
the next time the variable is referenced, more of the text can be printed.
The variable will 0 be restored.

0

the picture fields.  The expressions providing the values must be
separated by commas.  They are all evaluated in a list context
before the line is processed, so a single list expression could produce
multiple list elements.  The expressions may be spread out to more than
one line if enclosed in braces.  If so, the opening brace must be the first
token on the first line.  If an expression evaluates to a number with a
decimal part, and if the corresponding picture specifies that the decimal
part should appear in the output (that is, any picture except multiple "#"
characters 0 an embedded "."), the character used for the decimal
point is determined by the current LC_NUMERIC locale if 0 is in
effect.  This means that, if, for example, the run-time environment happens
to specify a German locale, "," will be used instead of the default ".".  See
0 and 0 for more information.

0

arbitrary expression, the value supplied must be a scalar variable
that contains a text string.  Perl puts the next portion of the text into
the field, and then chops off the front of the string so that the next time
the variable is referenced, more of the text can be printed.  (Yes, this
means that the variable itself is altered during execution of the 
call, and is not restored.)  The next portion of text is determined by
a crude line-breaking algorithm. You may use the carriage return character
(0) to force a line break. You can change which characters are legal
to break on by changing the variable 0 (that's
 if you're using the English module) to a
list of the desired characters.

with the same scalar variable to print out a block of text. You might wish
to end the final field with the text "...", which will appear in the output
if the text was too long to appear in its entirety.

0

suppress such lines by putting a "~" (tilde) character anywhere in the
line.  The tilde will be translated to a space upon output.

0

the line will be repeated until all the fields on the line are exhausted,
i.e. undefined. For special (caret) text fields this will occur sooner or
later, but if you use a text field of the at variety, the  expression you
supply had better not give the same value every time forever! (0
is a simple example that would work.)  Don't use a regular (at) numeric
field in such lines, because it will never go blank.

0 0 0

same name as the current filehandle with "_TOP" concatenated to it.
It's triggered at the top of each page.  See 0.

channel, but you'll have to handle 0 (0)
yourself.

0
0

and the current top of form format name is in 0 (0).
The current output page number is stored in 0 (0),
and the number of lines on the page is in 0 (0).
Whether to autoflush output on this handle is stored in 0
(0).  The string output before each top of page (except
the first) is stored in 0 (0).  These variables are
set on a per-filehandle basis, so you'll need to  into a different
one to affect them:

when you see it.  You can at least use a temporary variable to hold
the previous filehandle: (this is a much better approach in general,
because not only does legibility improve, you now have an intermediary
stage in the expression to single-step the debugger through):

module.  Now, you can access these special variables using lowercase
method names instead:

not caret fields), you can farm out more sophisticated processing
to other functions, like  or one of your own.  For example:

of the page, however wide it is."  You have to specify where it goes.
The truly desperate can generate their own format on the fly, based
on the current number of columns, and then  it:

0 0

there is no corresponding mechanism to automatically do the same thing
for a footer.  Not knowing how big a format is going to be until you
evaluate it is one of the major problems.  It's on the TODO list.

by checking  before each  and print the footer
yourself if necessary.

(see 0) and always  to MYSELF instead of STDOUT.
Have your child process massage its STDIN to rearrange headers and footers
however you like.  Not very convenient, but doable.

0

and access 0 is in effect when the format is declared, the locale is used
to specify the decimal point character in formatted output.  Formatted
output cannot be controlled by 0 at the time when 
is called. See 0 for further discussion of locale handling.

each control character is substituted by a space. (But remember the
special meaning of 0 when using fill mode.) This is done to avoid
misalignment when control characters "disappear" on some output media. 

=encoding utf8

0

They fall into two major categories: list operators and named unary
operators.  These differ in their precedence relationship with a
following comma.  (See the precedence table in 0.)  List
operators take more than one argument, while unary operators can never
take more than one argument.  Thus, a comma terminates the argument of
a unary operator, but merely separates the arguments of a list
operator.  A unary operator generally provides a scalar context to its
argument, while a list operator may provide either scalar or list
contexts for its arguments.  If it does both, scalar arguments
come first and list argument follow, and there can only ever
be one such list argument.  For instance,  has three scalar
arguments followed by a list, whereas  has four scalar
arguments.

list (and provide list context for elements of the list) are shown
with LIST as an argument.  Such a list may consist of any combination
of scalar arguments or list values; the list values will be included
in the list as if each individual element were interpolated at that
point in the list, forming a longer single-dimensional list value.
Commas should separate literal elements of the LIST.

parentheses around its arguments.  (The syntax descriptions omit the
parentheses.)  If you use parentheses, the simple but occasionally
surprising rule is this: It 0 like a function, therefore it 0 a
function, and precedence doesn't matter.  Otherwise it's a list
operator or unary operator, and precedence does matter.  Whitespace
between the function and left parenthesis doesn't count, so sometimes
you need to be careful:

example, the third line above produces:

unary nor list operators.  These include such functions as 0
and 0.  For example, 0 always means
0.

nonabortive failure is generally indicated in a scalar context by
returning the undefined value, and in a list context by returning the
empty list.

the behavior of an expression in list context to its behavior in scalar
context, or vice versa.  It might do two totally different things.
Each operator and function decides which sort of value would be most
appropriate to return in scalar context.  Some operators return the
length of the list that would have been returned in list context.  Some
operators return the first value in the list.  Some operators return the
last value in the list.  Some operators return a count of successful
operations.  In general, they do what you want, unless you want
consistency.
0

first glance appear to be a list in scalar context.  You can't get a list
like 0 into being in scalar context, because the compiler knows
the context at compile time.  It would generate the scalar comma operator
there, not the list construction version of the comma.  That means it
was never a list to start with.

of the same name (like , , , etc.) return
true when they succeed and 0 otherwise, as is usually mentioned
in the descriptions below.  This is different from the C interfaces,
which return 0 on failure.  Exceptions to this rule include 0,
0, and 0.  System calls also set the special 0
variable on failure.  Other functions do not, except accidentally.

kinds of keyword-headed expression.  These may look like functions, but
may also look completely different.  The syntax following the keyword
is defined entirely by the extension.  If you are an implementor, see
0 for the mechanism.  If you are using such
a module, see the module's documentation for details of the syntax that
it defines.

0

functions, like some keywords and named operators)
arranged by category.  Some functions appear in more
than one place.

0 0 0

0, 0, 0, 0, 0, 0, 0,
0, 0, 0, 0, 0, 0, 0

0 0 0

0 0 0 0

0, 0, 0

0

0

0

0 0 0 0

0, 0, 0, 0, 0, 0, 0,
0, 0, 0, 0, 0, 0, 0,
0, 0, 0, 0, 0, 0,
0, 0

0 0 0 0 0 0

0, 0, 0, 0, 0, 0,
0, 0, 0, 0, 0, 0,
0, 0, 0

0

0, 0, 0, 0, 0, 0, 0

See 0 and 0.)

0

0.)

0, 0, 0, 0, 0

0 0 0

0, 0, 0, 0, 0, 0,
0, 0, 0

0

0 0 0

0, 0

0 0

0, 0, 0, 0, 0, 0,
0, 0

0 0 0 0 0 0

0, 0, 0, 0

0 0 0 0 0  0 0

0, 0, 0, 0, 0,
0, 0, 0

0 0 0 0 0 0 0

0, 0, 0, 0,
0, 0, 0,
0, 0, 0, 0,
0, 0, 0

0 0

0

0, 0, 0, 0, 0, 0, 0,
0, 0, 0, 0, 0, 0, 0, 0, 0,
0, 0, 0, 0*, 0, 0, 0, 0,
0, 0, 0, 0

operator, which can be used in expressions.

0 0 0

system calls.  In non-Unix environments, the functionality of some
Unix system calls may not be available, or details of the available
functionality may differ slightly.  The Perl functions affected
by this are:

0, 0, 0, 0, 0,
0, 0, 0, 0, 0,
0, 0, 0, 0, 0, 0,
0, 0, 0, 0, 0,
0, 0, 0, 0,
0, 0, 0, 0,
0, 0, 0, 0, 0,
0, 0, 0, 0, 0, 0,
0, 0, 0, 0, 0, 0, 0,
0, 0, 0, 0, 0,
0, 0, 0, 0,
0, 0, 0, 0, 0,
0, 0, 0,
0, 0, 0, 0, 0,
0, 0, 0, 0,
0, 0, 0

0 and other available platform-specific documentation.

000000000000000
000000000000

operator takes one argument, either a filename, a filehandle, or a dirhandle,
and tests the associated file to see if something is true about it.  If the
argument is omitted, tests 0, except for 0, which tests STDIN.
Unless otherwise documented, it returns 0 for true and 0 for false, or
the undefined value if the file doesn't exist.  Despite the funny
names, precedence is the same as any other named unary operator.  The
operator may be any of:

0 still works as expected, however: only single letters
following a minus are interpreted as file tests.

above. That is, an opening parenthesis after the operator does not affect
how much of the following code constitutes the argument. Put the opening
parentheses before the operator to separate it from code that follows (this
applies only to operators with higher precedence than unary operators, of
course):

0, 0, 0, and 0 is by default based solely on the mode
of the file and the uids and gids of the user.  There may be other
reasons you can't actually read, write, or execute the file: for
example network filesystem access controls, ACLs (access control lists),
read-only filesystems, and unrecognized executable formats.  Note
that the use of these six specific operators to verify if some operation
is possible is usually a mistake, because it may be open to race
conditions.

0, 0, and 0 tests always return 1, and 0 and 0 return 1
if any execute bit is set in the mode.  Scripts run by the superuser
may thus need to do a  to determine the actual mode of the file,
or temporarily set their effective uid to something else.

produce more accurate results than the bare  mode bits.
When under 0 the above-mentioned filetests
test whether the permission can(not) be granted using the
 family of system calls.  Also note that the 0 and 0 may
under this pragma return true even if there are no execute permission
bits set (nor any extra execute permission ACLs).  This strangeness is
due to the underlying system calls' definitions. Note also that, due to
the implementation of 0, the 0 special
filehandle won't cache the results of the file tests when this pragma is
in effect.  Read the documentation for the 030%)
are found, it's a 0 file; otherwise it's a 0 file.  Also, any file
containing a zero byte in the first block is considered a binary file.  If 0
or 0 is used on a filehandle, the current IO buffer is examined
rather than the first block.  Both 0 and 0 return true on an empty
file, or a file at EOF when testing a filehandle.  Because you have to
read a file to do the 0 test, on most occasions you want to use a 0
against the file first, as in 0.

the special filehandle consisting of a solitary underline, then the stat
structure of the previous file test (or stat operator) is used, saving
a system call.  (This doesn't work with 0, and you need to remember
that  and 0 leave values in the stat structure for the
symbolic link, not the real file.)  (Also, if the stat buffer was filled by
an 0 call, 0 and 0 will reset it with the results of 0).
Example:

test operators, in a way that 0 is equivalent to
0. (This is only fancy fancy: if you use
the return value of 0 as an argument to another filetest
operator, no special magic will happen.)

0 0

If VALUE is omitted, uses 0.

0

does.  Returns the packed address if it succeeded, false otherwise.
See the example in 0.

be set for the newly opened file descriptor, as determined by the
value of $^F.  See 0.

0
0
0

specified number of wallclock seconds has elapsed.  If SECONDS is not
specified, the value stored in 0 is used. (On some machines,
unfortunately, the elapsed time may be up to one second less or more
than you specified because of how seconds are counted, and process
scheduling may delay the delivery of the signal even further.)

previous timer, and an argument of 0 may be supplied to cancel the
previous timer without starting a new one.  The returned value is the
amount of time remaining on the previous timer.

(from CPAN, and starting from Perl 5.8 part of the standard
distribution) provides .  You may also use Perl's four-argument
version of  leaving the first three arguments undefined, or you
might be able to use the 0 interface to access  if
your system supports it. See 0 for details.

0 may be internally implemented on your system with 0.

0/0 pair.  You can't rely on the alarm causing the system call to
fail with 0 set to 0 because Perl sets up signal handlers to
restart system calls on some systems.  Using 0/0 always works,
modulo the caveats given in 0.

0 0 0 0

function, or use the familiar relation:

your  manpage for more information.

0

does.  Returns true if it succeeded, false otherwise.  NAME should be a
packed address of the appropriate type for the socket.  See the examples in
0.

0 0 0 0 0

mode on systems where the run-time libraries distinguish between
binary and text files.  If FILEHANDLE is an expression, the value is
taken as the name of the filehandle.  Returns true on success,
otherwise it returns 0 and sets 0 (errno).

is necessary when you're not working with a text file.  For the sake
of portability it is a good idea always to use it when appropriate,
and never to use it when it isn't appropriate.  Also, people can
set their I/O to be by default UTF-8 encoded Unicode, not bytes.

like images, for example.

directives. The directives alter the behaviour of the filehandle.
When LAYER is present, using binmode on a text file makes sense.

suitable for passing binary data. This includes turning off possible CRLF
translation and marking it as bytes (as opposed to Unicode characters).
Note that, despite what may be implied in 0 (the
Camel, 3rd edition) or elsewhere, 0 is 0 simply the inverse of 0.
Other layers that would affect the binary nature of the stream are
0 disabled. See 0, 0, and the discussion about the
PERLIO environment variable.

form 0, are called I/O 0.  The 0 pragma can be used to
establish default I/O layers.  See 0

0 just marks the data as UTF-8 without further checking,
while 0 checks the data for actually being valid
UTF-8. More details can be found in 0.

is done on the filehandle.  Calling  normally flushes any
pending buffered output data (and perhaps pending input data) on the
handle.  An exception to this is the 0 layer that
changes the default character encoding of the handle; see 0.
The 0 layer sometimes needs to be called in
mid-stream, and it doesn't flush the stream.  The 0
also implicitly pushes on top of itself the 0 layer because
internally Perl operates on UTF8-encoded Unicode characters.

system all work together to let the programmer treat a single
character (0) as the line terminator, irrespective of the external
representation.  On many operating systems, the native text file
representation matches the internal representation, but on some
platforms the external representation of 0 is made up of more than
one character.

character to end each line in the external representation of text (even
though that single character is CARRIAGE RETURN on Mac OS and LINE FEED
on Unix and most VMS files). In other systems like OS/2, DOS and the
various flavors of MS-Windows your program sees a 0 as a simple 0,
but what's stored in text files are the two characters 0.  That
means that, if you don't use  on these systems, 0
sequences on disk will be converted to 0 on input, and any 0 in
your program will be converted back to 0 on output.  This is what
you want for text files, but it can be disastrous for binary files.

special end-of-file markers will be seen as part of the data stream.
For systems from the Microsoft family this means that, if your binary
data contain 0, the I/O subsystem will regard it as the end of
the file, unless you use .

but also when using , , ,  and 
(see 0 for more details).  See the 0 and 0 variables
in 0 for how to manually set your input and output
line-termination sequences.

0

in the CLASSNAME package.  If CLASSNAME is omitted, the current package
is used.  Because a 0 is often the last thing in a constructor,
it returns the reference for convenience.  Always use the two-argument
version if a derived class might inherit the function doing the blessing.
See 0 and 0 for more about the blessing (and blessings)
of objects.

Namespaces with all lowercase names are considered reserved for
Perl pragmata.  Builtin types have all uppercase names. To prevent
confusion, you may wish to avoid such package names as well.  Make sure
that CLASSNAME is a true value.

for more information.

0 0 0 0

returns the caller's package name if there 0 a caller (that is, if
we're in a subroutine or 0 or 0) and the undefined value
otherwise.  In list context, returns

print a stack trace.  The value of EXPR indicates how many call frames
to go back before the current one.

call, but an 0.  In such a case additional elements  and
0 are set: 0 is true if the frame is created by a
0 or 0 statement,  contains the text of the
0 statement.  In particular, for an 0 statement,
 is 0, but  is undefined.  (Note also that
each 0 statement creates a 0 frame inside an 0
frame.)   may also be 0 if this particular
subroutine happens to have been deleted from the symbol table.
0 is true if a new instance of 0 was set up for the frame.
0 and 0 contain pragmatic hints that the caller was
compiled with.  The 0 and 0 values are subject to change
between versions of Perl, and are not meant for external use.

caller was compiled, or 0 if 0 was empty. Do not modify the values
of this hash, as they are the actual values stored in the optree.

detailed information: it sets the list variable 0 to be the
arguments with which the subroutine was invoked.

0 had a chance to get the information.  That means that 0
might not return information about the call frame you expect it to, for
.  In particular, 0 might have information from the
previous time 0 was called.

debugging or generating backtraces, and should not be relied upon. In
particular, as 0 contains aliases to the caller's arguments, Perl does
not take a copy of 0, so 0 will contain modifications the
subroutine makes to 0 or its contents, not the original values at call
time. 0, like 0, does not hold explicit references to its
elements, so under certain cases its elements may have become freed and
reallocated for other variables or temporary values. Finally, a side effect
of the current implementation is that the effects of 0 can
0 be undone (but not 0 or other splicing, and not if a
reference to 0 has been taken, and subject to the caveat about reallocated
elements), so 0 is actually a hybrid of the current state and
initial state of 0. Buyer beware.

0
0
0

changes to the directory specified by 0, if set; if not,
changes to the directory specified by 0. (Under VMS, the
variable 0 is also checked, and used if it is set.) If
neither is set, 0 does nothing. It returns true on success,
false otherwise. See the example under 0.

directory handle as the argument.  On systems that don't support ,
passing handles raises an exception.

0 0 0

list must be the numerical mode, which should probably be an octal
number, and which definitely should 0 be a string of octal digits:
0 is okay, but 0 is not.  Returns the number of files
successfully changed.  See also 0, if all you have is a string.

files.  On systems that don't support , passing filehandles raises
an exception.  Filehandles must be passed as globs or glob references to be
recognized; barewords are considered filenames.

module:

0 0 0 0 0

that corresponds to the current value of 0 (also known as
 in the 0 module).  It returns the total
number of characters removed from all its arguments.  It's often used to
remove the newline from the end of an input record when you're worried
that the final record may be missing its newline.  When in paragraph
mode (0), it removes all trailing newlines from the string.
When in slurp mode (0) or fixed-length record mode (0 is
a reference to an integer or the like; see 0)  won't
remove anything.
If VARIABLE is omitted, it chomps 0.  Example:

characters removed is returned.

that is not a simple variable.  This is because 0
is interpreted as 0, rather than as
0 which you might expect.  Similarly,
0 is interpreted as 0 rather than
as 0.

0

chopped.  It is much more efficient than 0 because it neither
scans nor copies the string.  If VARIABLE is omitted, chops 0.
If VARIABLE is a hash, it chops the hash's values, but not its keys.

last 0 is returned.

character, use 0.

0 0 0 0

elements of the list must be the 0 uid and gid, in that
order.  A value of -1 in either position is interpreted by most
systems to leave that value unchanged.  Returns the number of files
successfully changed.

files.  On systems that don't support , passing filehandles raises
an exception.  Filehandles must be passed as globs or glob references to be
recognized; barewords are considered filenames.

file unless you're the superuser, although you should be able to change
the group to any of your secondary groups.  On insecure systems, these
restrictions may be relaxed, but this is not a portable assumption.
On POSIX systems, you can detect this condition this way:

0 0 0 0

For example, 0 is 0 in either ASCII or Unicode, and
chr(0x263a) is a Unicode smiley face.

except under the 0 pragma, where the low eight bits of the value
(truncated to an integer) are used.

internally not encoded as UTF-8 for backward compatibility reasons.

0 0

named directory the new root directory for all further pathnames that
begin with a 0 by your process and all its children.  (It doesn't
change your current working directory, which is unaffected.)  For security
reasons, this call is restricted to the superuser.  If FILENAME is
omitted, does a 0 to 0.

0

buffers, and closes the system file descriptor.  Returns true if those
operations have succeeded and if no error was reported by any PerlIO
layer.  Closes the currently selected filehandle if the argument is
omitted.

another 0 on it, because 0 closes it for you.  (See
0.)  However, an explicit 0 on an input file resets the line
counter (0), while the implicit close done by 0 does not.

the other syscalls involved fails or if its program exits with non-zero
status.  If the only problem was that the program exited non-zero, 0
will be set to 0.  Closing a pipe also waits for the process executing
on the pipe to exit--in case you wish to look at the output of the pipe
afterwards--and implicitly puts the exit status value of that command into
0 and 0.

piped open returns true without waiting for the child process to terminate,
if the filehandle is still open in another thread.

other end is done writing results in the writer receiving a SIGPIPE.  If
the other end can't handle that, be sure to read all the data before
closing the pipe.

filehandle, usually the real filehandle name.

0

system call.

0

Returns true if it succeeded, false otherwise.  NAME should be a
packed address of the appropriate type for the socket.  See the examples in
0.

0

there is a 0 BLOCK attached to a BLOCK (typically in a 0 or
0), it is always executed just before the conditional is about to
be evaluated again, just like the third part of a 0 loop in C.  Thus
it can be used to increment a loop variable, even when the loop has been
continued via the 0 statement (which is similar to the C 0
statement).

block; 0 and 0 behave as if they had been executed within
the main block.  So will 0, but since it will execute a 0
block, it may be more entertaining.

empty one, logically enough, so 0 goes directly back
to check the condition at the top of the loop.

function that exits the current 0 (or 0) block and
falls through to the next one.  See 0 and
0 for more information.

0 0 0 0

takes the cosine of 0.

function, or use this relation:

0 0 0 0 0 0
0 0 0 0

library (assuming that you actually have a version there that has not
been extirpated as a potential munition).

into a short string, called a digest, which is returned.  The same
PLAINTEXT and SALT will always return the same string, but there is no
(known) way to get the original PLAINTEXT from the hash.  Small
changes in the PLAINTEXT or SALT will result in large changes in the
digest.

cryptography (for that, look for 0 modules on your nearby CPAN
mirror) and the name "crypt" is a bit of a misnomer.  Instead it is
primarily used to check if two pieces of text are the same without
having to transmit or store the text itself.  An example is checking
if a correct password is given.  The digest of the password is stored,
not the password itself.  The user types in a password that is
'd with the same salt as the stored digest.  If the two digests
match, the password is correct.

the salt (like 0).  The SALT used
to create the digest is visible as part of the digest.  This ensures
 will hash the new string with the same salt as the digest.
This allows your code to work with the standard 0 and
with more exotic implementations.  In other words, do not assume
anything about the returned string itself, or how many bytes in the
digest matter.

the salt, followed by 11 bytes from the set 0, and only
the first eight bytes of PLAINTEXT mattered. But alternative
hashing schemes (like MD5), higher level security schemes (like C2),
and implementations on non-Unix platforms may produce different
strings.

characters come from the set 0 (like 0).  This set of
characters is just a recommendation; the characters allowed in
the salt depend solely on your system's crypt library, and Perl can't
restrict what salts 0 accepts.

their password:

for it is unwise.

of data, not least of all because you can't get the information
back.  Look at the 0 module for more robust algorithms.

characters with codepoints above 255), Perl tries to make sense
of the situation by trying to downgrade (a copy of)
the string back to an eight-bit byte string before calling 
(on that copy).  If that works, good.  If not,  dies with
0.

0

0 0 0 0 0

hash.  HASH is the name of the hash.  (Unlike normal 0, the first
argument is 0 a filehandle, even though it looks like one).  DBNAME
is the name of the database (without the 0 or 0 extension if
any).  If the database does not exist, it is created with protection
specified by MASK (as modified by the 0).  If your system supports
only the older DBM functions, you may make only one 0 call in your
program.  In older versions of Perl, if your system had neither DBM nor
ndbm, calling 0 produced a fatal error; it now falls back to
.

variables, not set them.  If you want to test whether you can write,
either use file tests or try setting a dummy hash entry inside an 0
to trap the error.

when used on large DBM files.  You may prefer to use the 0
function to iterate over large DBM files.  Example:

cons of the various dbm approaches, as well as 0 for a particularly
rich implementation.

before you call :

0 0 0

the undefined value 0.  If EXPR is not present, 0 is
checked.

system error, uninitialized variable, and other exceptional
conditions.  This function allows you to distinguish 0 from
other values.  (A simple Boolean test will not distinguish among
0, zero, the empty string, and 0, which are all equally
false.)  Note that since 0 is a valid scalar, its presence
doesn't 0 indicate an exceptional condition: 0
returns 0 when its argument is an empty array, 0 when the
element to return happens to be 0.

has ever been defined.  The return value is unaffected by any forward
declarations of 0.  A subroutine that is not defined
may still be callable: its package may have an 0 method that
makes it spring into existence the first time that it is called; see
0.

used to report whether memory for that aggregate had ever been
allocated.  This behavior may disappear in future versions of Perl.
You should instead use a simple test for size:

not whether the key exists in the hash.  Use 0 for the latter
purpose.

discover that the number 0 and 0 (the zero-length string) are, in fact,
defined values.  For example, if you say

matched "nothing".  It didn't really fail to match anything.  Rather, it
matched something that happened to be zero characters long.  This is all
very above-board and honest.  When a function returns an undefined value,
it's an admission that it couldn't give you an honest answer.  So you
should use 0 only when questioning the integrity of what
you're trying to do.  At other times, a simple comparison to 0 or 0 is
what you want.

0

deletes the specified elements from that hash so that  on that element
no longer returns true.  Setting a hash element to the undefined value does
not remove its key, but deleting it does; see 0.

element in scalar context.  The return list's length always matches that of
the argument list: deleting non-existent elements returns the undefined value
in their corresponding positions.

straightforward.  Although  will return false for deleted entries,
deleting array elements never changes indices of existing values; use 
or  for that.  However, if all deleted elements fall at the end of an
array, the array's size shrinks to the position of the highest element that
still tests true for , or to 0 if none do.

be removed in a future version of Perl.

a DBM file deletes the entry from the DBM file.  Deleting from a 0 hash
or array may not necessarily return anything; it depends on the implementation
of the 0 package's DELETE method, which may do whatever it pleases.

block at run time.  Until the block exits, elements locally deleted
temporarily no longer exist.  See 0.

or undefining %HASH or @ARRAY, which is the customary
way to empty out an aggregate:

final operation is an element or slice of an aggregate:

0 0 0 0 0 0

into 0 and the 0 is terminated with the undefined value.
If the exception is outside of all enclosing 0s, then the uncaught
exception prints LIST to 0 and exits with a non-zero value. If you
need to exit the process with a specific exit code, see 0.

script line number and input line number (if any) are also printed,
and a newline is supplied.  Note that the "input line number" (also
known as "chunk") is subject to whatever notion of "line" happens to
be currently in effect, and is also available as the special variable
0.  See 0 and 0.

to make better sense when the string 0 is appended.
Suppose you are running script "canasta".

previous eval) that value is reused after appending 0.
This is useful for propagating exceptions:

0 method, that method will be called with additional file
and line number parameters.  The return value replaces the value in
0;  i.e., as if 
were called.

determined from the values of 0 and 0 with this pseudocode:

into the limited space of the system exit code. However, as 0 is the value
of C's 0, which can be set by any system call, this means that the value
of the exit code used by 0 can be non-predictable, so should not be relied
upon, other than to be non-zero.

within an 0, 0 contains that reference.  This permits more
elaborate exception handling using objects that maintain arbitrary state
about the exception.  Such a scheme is sometimes preferable to matching
particular string values of 0 with regular expressions.  Because 0
is a global variable and 0 may be used within object implementations,
be careful that analyzing the error object doesn't replace the reference in
the global variable.  It's easiest to make a local copy of the reference
before any manipulations.  Here's an example:

you'll probably want to overload stringification operations on
exception objects.  See 0 for details about that.

does its deed, by setting the 0 hook.  The associated
handler is called with the error text and can change the error
message, if it sees fit, by calling 0 again.  See
0 for details on setting 0 entries, and
0 for some examples.  Although this feature was
to be run only right before your program was to exit, this is not
currently so: the 0 hook is currently called
even inside ed blocks/strings!  If one wants the hook to do
nothing in such situations, put

this promotes strange action at a distance, this counterintuitive
behavior may be fixed in a future release.

0 0

sequence of commands indicated by BLOCK.  When modified by the 0 or
0 loop modifier, executes the BLOCK once before testing the loop
condition. (On other statements the loop modifiers test the conditional
first.)

0, 0, or 0 cannot be used to leave or restart the block.
See 0 for alternative strategies.

0

a scalar variable or a subroutine beginning with 0.

0

file as a Perl script.

filename for error messages, searches the 0 directories, and updates
0 if the file is found.  See 0 and 0 for
these variables.  It also differs in that code evaluated with 0
cannot see lexicals in the enclosing scope; 0 does.  It's the
same, however, in that it does reparse the file every time you call it,
so you probably don't want to do this inside a loop.

an error message in 0.  If 0 cannot read the file, it returns undef
and sets 0 to the error.  Always check 0 first, as compilation
could fail in a way that also sets 0.  If the file is successfully
compiled, 0 returns the value of the last expression evaluated.

0 and 0 operators, which also do automatic error checking
and raise an exception if there's a problem.

file.  Manual error checking can be done this way:

0 0 0

command-line switch in 0, which does the same thing.
Primarily this is so that you can use the 0 program (not
supplied) to turn your core dump into an executable binary after
having initialized all your variables at the beginning of the
program.  When the new binary is executed it will begin by executing
a 0 (with all the restrictions that 0 suffers).
Think of it as a goto with an intervening core dump and reincarnation.
If 0 is omitted, restarts the program from the top.

be open any more when the program is reincarnated, with possible
resulting confusion by Perl.

convert a core file into an executable. That's why you should now invoke
it as 0, if you don't want to be warned against a possible
typo.

0 0

0

and value for the next element of a hash, or the index and value for the
next element of an array, so that you can iterate over it.  When called in
scalar context, returns only the key (not the value) in a hash, or the index
in an array.

order is subject to change in future versions of Perl, but it is
guaranteed to be in the same order as either the 0 or 0
function would produce on the same (unmodified) hash.  Since Perl
5.8.2 the ordering can be different even between different runs of Perl
for security reasons (see 0).

call to 0 returns the empty list in list context and 0 in
scalar context.  The next call following that one restarts iteration.  Each
hash or array has its own internal iterator, accessed by 0, 0,
and 0.  The iterator is implicitly reset when 0 has reached
the end as just described; it can be explicitly reset by calling 0 or
0 on the hash or array.  If you add or delete a hash's elements
while iterating over it, entries may be skipped or duplicated--so don't do
that.  Exception: It is always safe to delete the item most recently
returned by 0, so the following code works properly:

but in a different order:

reference to an unblessed hash or array.  The argument will be dereferenced
automatically.  This aspect of 0 is considered highly experimental.
The exact behaviour may change in a future version of Perl.

0
0
0

FILEHANDLE is not open.  FILEHANDLE may be an expression whose value
gives the real filehandle.  (Note that this function actually
reads a character and then 0s it, so isn't useful in an
interactive context.)  Do not read from a terminal file (or call
0 on it) after end-of-file is reached.  File types such
as terminals may lose the end-of-file condition if you do.

with empty parentheses is different.  It refers to the pseudo file
formed from the files listed on the command line and accessed via the
 operator.  Since  isn't explicitly opened,
as a normal filehandle is, an 0 before  has been
used will cause 0 to be examined to determine if input is
available.   Similarly, an 0 after  has returned
end-of-file will assume you are processing another 0 list,
and if you haven't set 0, will read input from 0;
see 0.

detect the end of each file, 0 will detect the end of only the
last file.  Examples:

input operators typically return 0 when they run out of data, or if
there was an error.

0 0 0 0 0 0
0 0

were a little Perl program.  The value of the expression (which is itself
determined within scalar context) is first parsed, and if there weren't any
errors, executed in the lexical context of the current Perl program, so
that any variable settings or subroutine and format definitions remain
afterwards.  Note that the value is parsed every time the 0 executes.
If EXPR is omitted, evaluates 0.  This form is typically used to
delay parsing and subsequent execution of the text of EXPR until run time.

same time the code surrounding the 0 itself was parsed--and executed
within the context of the current Perl program.  This form is typically
used to trap exceptions more efficiently than the first (see below), while
also providing the benefit of checking the code within BLOCK at compile
time.

the BLOCK.

evaluated inside the mini-program; a return statement may be also used, just
as with subroutines.  The expression providing the return value is evaluated
in void, scalar, or list context, depending on the context of the 0
itself.  See 0 for more on how the evaluation context can be
determined.

executed, 0 returns an undefined value in scalar context
or an empty list--or, for syntax errors, a list containing a single
undefined value--in list context, and 0 is set to the error
message.  The discrepancy in the return values in list context is
considered a bug by some, and will probably be fixed in a future
release.  If there was no error, 0 is guaranteed to be the empty
string.  Beware that using 0 neither silences Perl from printing
warnings to STDERR, nor does it stuff the text of warning messages into 0.
To do either of those, you have to use the 0 facility, or
turn off warnings inside the BLOCK or EXPR using S<0.
See 0, 0, 0 and 0.

determining whether a particular feature (such as 0 or 0)
is implemented.  It is also Perl's exception-trapping mechanism, where
the die operator is used to raise exceptions.

the binary interface (such as Perl version skew) may be fatal even with
0 unless 0 is set. See 0.

form to trap run-time errors without incurring the penalty of
recompiling each time.  The error, if any, is still returned in 0.
Examples:

issues.  Due to the current arguably broken state of 0 hooks, you
may wish not to trigger any 0 hooks that user code may have installed.
You can use the 0 construct for this purpose,
as this example shows:

0 again, which has the effect of changing their error messages:

may be fixed in a future release.

being looked at when:

the variable .  (Although case 2 has misleading double quotes making
the reader wonder what else might be happening (nothing is).)  Cases 3
and 4 likewise behave in the same way: they run the code 0, which
does nothing but return the value of .  (Case 4 is preferred for
purely visual reasons, but it also has the advantage of compiling at
compile-time instead of at run-time.)  Case 5 is a place where
normally you 0 like to use double quotes, except that in this
particular situation, you can just use symbolic references instead, as
in case 6.

of localised variables, which means that for your code to run on older
versions, a temporary is required if you want to mask some but not all
errors:

0, 0, or 0 cannot be used to leave or restart the block.

surrounding lexical scope, but rather the scope of the first non-DB piece
of code that called it. You don't normally need to worry about this unless
you are writing a Perl debugger.

0 0

use 0 instead of 0 if you want it to return.  It fails and
returns false only if the command does not exist 0 it is executed
directly instead of via your system's command shell (see below).

warns you if there is a following statement that isn't 0, 0,
or 0 (if 0 is set--but you always do that, right?).   If you
0 want to follow an 0 with some other statement, you
can use one of these styles to avoid the warning:

with more than one value, calls  with the arguments in LIST.
If there is only one scalar argument or an array with one element in it,
the argument is checked for shell metacharacters, and if there are any,
the entire argument is passed to the system's command shell for parsing
(this is 0 on Unix platforms, but varies on other platforms).
If there are no shell metacharacters in the argument, it is split into
words and passed directly to 0, which is more efficient.
Examples:

to the program you are executing about its own name, you can specify
the program you actually want to run as an "indirect object" (without a
comma) in front of the LIST.  (This always forces interpretation of the
LIST as a multivalued list, even if there is only a single scalar in
the list.)  Example:

subject to its quirks and capabilities.  See 0
for details.

secure.  This usage (which also works fine with ) forces
interpretation of the arguments as a multivalued list, even if the
list had just one argument.  That way you're safe from the shell
expanding wildcards or splitting up words with whitespace in them.

program, passing it 0 an argument.  The second version didn't;
it tried to run a program named 0, didn't find it, and set
0 to a non-zero value indicating failure.

output before the exec, but this may not be supported on some platforms
(see 0).  To be safe, you may need to set 0 (
in English) or call the 0 method of 0 on any
open handles to avoid lost output.

0 methods on your objects.

0 0

specified element in the hash has ever been initialized, even if the
corresponding value is undefined.

obvious, and is strongly tied to the use of 0 on arrays.  0
that calling exists on array values is deprecated and likely to be removed in
a future version of Perl.

it exists, but the reverse doesn't necessarily hold true.

returns true if the specified subroutine has ever been declared, even
if it is undefined.  Mentioning a subroutine name for exists or defined
does not count as declaring it.  Note that a subroutine that does not
exist may still be callable: its package may have an 0
method that makes it spring into existence the first time that it is
called; see 0.

operation is a hash or array key lookup or subroutine name:

existence just because its existence was tested, any intervening ones will.
Thus  and  will spring
into existence due to the existence test for the  element above.
This happens anywhere the arrow operator is used, including even here:

second--glance appear to be an lvalue context may be fixed in a future
release.

to  is an error.

0 0 0

universally recognized values for EXPR are 0 for success and 0
for error; other values are subject to interpretation depending on the
environment in which the Perl program is running.  For example, exiting
69 (EX_UNAVAILABLE) from a 0 incoming-mail filter will cause
the mailer to return the item undelivered, but that's not true everywhere.

someone might want to trap whatever error happened.  Use 0 instead,
which can be trapped by an 0.

defined 0 routines first, but these 0 routines may not
themselves abort the exit.  Likewise any object destructors that need to
be called are called before the real exit.  0 routines and destructors
can change the exit status by modifying 0. If this is a problem, you
can call 0 to avoid END and destructor processing.
See 0 for details.

0 0 0 0 0

If EXPR is omitted, gives 0.

0

value returned work just like 0 below.
For example:

Like 0, it maps a 0 return from the system call into
0 in Perl.  This string is true in boolean context and 0
in numeric context.  It is also exempt from the normal 0 warnings
on improper numeric conversions.

doesn't implement .  See the Fcntl module or your 
manpage to learn what functions are available on your system.

non-blocking at the system level.  You'll have to negotiate 0
on your own, though.

0

filehandle is not open.  If there is no real file descriptor at the OS
level, as can happen with filehandles connected to memory objects via
0 with a reference for the third argument, -1 is returned.

bitmaps for 0 and low-level POSIX tty-handling operations.
If FILEHANDLE is an expression, the value is taken as an indirect
filehandle, generally its name.

same underlying descriptor:

0 0 0

for success, false on failure.  Produces a fatal error if used on a
machine that doesn't implement ,  locking, or .
0 is Perl's portable file-locking interface, although it locks
entire files only, not records.

that it waits indefinitely until the lock is granted, and that its locks
are 0.  Such discretionary locks are more flexible, but
offer fewer guarantees.  This means that programs that do not also use
0 may modify files locked with 0.  See 0,
your port's specific documentation, or your system-specific local manpages
for details.  It's best to assume traditional behavior if you're writing
portable programs.  (But if you're not, you should as always feel perfectly
free to write for your own system's idiosyncrasies (sometimes called
"features").  Slavish adherence to portability concerns shouldn't get
in the way of your getting your job done.)

LOCK_NB.  These constants are traditionally valued 1, 2, 8 and 4, but
you can use the symbolic names if you import them from the Fcntl module,
either individually, or as a group using the ':flock' tag.  LOCK_SH
requests a shared lock, LOCK_EX requests an exclusive lock, and LOCK_UN
releases a previously requested lock.  If LOCK_NB is bitwise-or'ed with
LOCK_SH or LOCK_EX then 0 returns immediately rather than blocking
waiting for the lock; check the return status to see if you got it.

before locking or unlocking it.

locks, and it requires that FILEHANDLE be open with write intent.  These
are the semantics that  implements.  Most if not all systems
implement  in terms of  locking, though, so the
differing semantics shouldn't bite too many people.

be open with read intent to use LOCK_SH and requires that it be open
with write intent to use LOCK_EX.

network; you would need to use the more system-specific 0 for
that.  If you like you can force Perl to ignore your system's 
function, and so provide its own -based emulation, by passing
the switch 0 to the 0 program when you configure
Perl.

calls, whereas those that must resort to the more capricious 
function lose their locks, making it seriously harder to write servers.

0 0 0

same program at the same point.  It returns the child pid to the
parent process, 0 to the child process, or 0 if the fork is
unsuccessful.  File descriptors (and sometimes locks on those descriptors)
are shared, while everything else is copied.  On most systems supporting
, great care has gone into making it extremely efficient (for
example, using copy-on-write technology on data pages), making it the
dominant paradigm for multitasking over the last few decades.

output before forking the child process, but this may not be supported
on some platforms (see 0).  To be safe, you may need to set
0 ( in English) or call the 0 method of
0 on any open handles to avoid duplicate output.

accumulate zombies.  On some systems, you can avoid this by setting
0 to 0.  See also 0 for more examples of
forking and reaping moribund children.

STDIN and STDOUT that are actually connected by a pipe or socket, even
if you exit, then the remote server (such as, say, a CGI script or a
backgrounded job launched from a remote shell) won't think you're done.
You should reopen those to 0 if it's any issue.

0

example:

0

too.  It formats (see 0) a list of values according to the
contents of PICTURE, placing the output into the format output
accumulator, 0 (or 0 in English).
Eventually, when a 0 is done, the contents of
0 are written to some filehandle.  You could also read 0
and then set 0 back to 0.  Note that a format typically
does one 0 per line of form, but the 0 function itself
doesn't care how many newlines are embedded in the PICTURE.  This means
that the 0 and 0 tokens treat the entire PICTURE as a single line.
You may therefore need to use multiple formlines to implement a single
record format, just like the 0 compiler.

character may be taken to mean the beginning of an array name.
0 always returns true.  See 0 for other examples.

you may find it easier to open a filehandle to a scalar
() and write to that instead.

0 0 0 0

or the undefined value at end of file or if there was an error (in
the latter case 0 is set).  If FILEHANDLE is omitted, reads from
STDIN.  This is not particularly efficient.  However, it cannot be
used by itself to fetch single characters without waiting for the user
to hit enter.  For that, try something more like:

is left as an exercise to the reader.

systems purporting POSIX compliance.  See also the 0
module from your nearest CPAN site; details on CPAN can be found under
0.

0 0

systems returns the current login from 0, if any.  If it
returns the empty string, use 0.

secure as 0.

0 0

connection.

0 0

a PID of 0 to get the current process group for the
current process.  Will raise an exception if used on a machine that
doesn't implement .  If PID is omitted, returns the process
group of the current process.  Note that the POSIX version of 0
does not accept a PID argument, so only 0 is truly portable.

0 0 0

0 return different values from different threads. In order to
be portable, this behavior is not reflected by the Perl-level function
0, that returns a consistent value across threads. If you want
to call the underlying 0, you may use the CPAN module
0.

0 0 0

(See 0.)  Will raise a fatal exception if used on a
machine that doesn't implement .

0 0 0 0 0
0 0 0 0 0
0 0 0 0 0
0 0 0 0 0 0
0 0 0 0 0 0
0 0 0

system C library.  In list context, the return values from the
various get routines are as follows:

the real name of the user (as opposed to the login name) and other
information pertaining to the user.  Beware, however, that in many
system users are able to change this information and therefore it
cannot be trusted and therefore the  is tainted (see
0).  The  and , user's encrypted password and
login shell, are also tainted, for the same reason.

lookup by name, in which case you get the other thing, whatever it is.
(If the entry doesn't exist you get the undefined value.)  For example:

in that they are unsupported on many systems.  If the
 is unsupported, it is an empty scalar.  If it is supported, it
usually encodes the disk quota.  If the  field is unsupported,
it is an empty scalar.  If it is supported it usually encodes some
administrative comment about the user.  In some systems the 
field may be  or , fields that have to do with password
aging.  In some systems the  field may be .  The 
field, if present, encodes the expiration period of the account or the
password.  For the availability and the exact meaning of these fields
in your system, please consult your  documentation and your
0 file.  You can also find out from within Perl what your
 and  fields mean and whether you have the  field
by using the 0 module and the values 0, 0,
0, 0, and 0.  Shadow password
files are supported only if your vendor has implemented them in the
intuitive fashion that calling the regular C library routines gets the
shadow versions if you're running under privilege or if there exists
the  functions as found in System V (this includes Solaris
and Linux).  Those systems that implement a proprietary shadow password
facility are unlikely to be supported.

the login names of the members of the group.

C, it will be returned to you via 0 if the function call fails.  The
0 value returned by a successful call is a list of raw
addresses returned by the corresponding library call.  In the
Internet domain, each address is four bytes long; you can unpack it
by saying something like:

you can write this:

its return value is checked for definedness.

contains which return value, by-name interfaces are provided
in standard modules: 0, 0, 0,
0, 0, 0, 0,
and 0.  These override the normal built-ins, supplying
versions that return objects with the appropriate names
for each field.  For example:

they aren't, because a 0 object is different from
a 0 object.

0

in case you don't know the address because you have several different
IPs that the connection might have come in on.

0

Options may exist at multiple protocol levels depending on the socket
type, but at least the uppermost socket level SOL_SOCKET (defined in the
0 module) will exist. To query options at another level the
protocol number of the appropriate protocol controlling the option
should be supplied. For example, to indicate that an option is to be
interpreted by the TCP protocol, LEVEL should be set to the protocol
number of TCP, which you can get using 0.

option, or 0 on error, with the reason for the error placed in
0. Just what is in the packed string depends on LEVEL and OPTNAME;
consult  for details.  A common case is that the option is an
integer, in which case the result is a packed integer, which you can decode
using 0 with the 0 (or 0) format.

0 0 0 0

the value of EXPR such as the standard Unix shell 0 would do. In
scalar context, glob iterates through such filename expansions, returning
undef when the list is exhausted. This is the internal function
implementing the  operator, but you can use it directly. If
EXPR is omitted, 0 is used.  The  operator is discussed in
more detail in 0.

each segment as separate pattern.  As such, 0
matches all files with a 0 or 0 extension.  The expression
0 matches all files in the current working directory.

0, no filenames are matched, but potentially many strings
are returned.  For example, this produces nine strings, one for
each pairing of fruits and colors:

0 extension.  See 0 for details, including
0 which does not treat whitespace as a pattern separator.

0 0 0

localized for the standard Greenwich time zone.

returned by gmtime, is always 0.  There is no
Daylight Saving Time in GMT.

0 0 0

resumes execution there. It can't be used to get out of a block or
subroutine given to 0.  It can be used to go almost anywhere
else within the dynamic scope, including out of subroutines, but it's
usually better to use some other construct such as 0 or 0.
The author of Perl has never felt the need to use this form of 0
(in Perl, that is; C is another matter).  (The difference is that C
does not offer named loops combined with loop control.  Perl does, and
this replaces most structured uses of 0 in other languages.)

dynamically.  This allows for computed 0s per FORTRAN, but isn't
necessarily recommended if you're optimizing for maintainability:

function" rule. A pair of parentheses following it does not (necessarily)
delimit its argument. 0 is equivalent to 0.

deprecated and will issue a warning.  Even then, it may not be used to
go into any construct that requires initialization, such as a
subroutine or a 0 loop.  It also can't be used to go into a
construct that is optimized away.

0.  In fact, it isn't a goto in the normal sense at all, and
doesn't have the stigma associated with other gotos.  Instead, it
exits the current subroutine (losing any changes set by ) and
immediately calls in its place the named subroutine using the current
value of @_.  This is used by 0 subroutines that wish to
load another subroutine and then pretend that the other subroutine had
been called in the first place (except that any modifications to 0
in the current subroutine are propagated to the other subroutine.)
After the 0, not even 0 will be able to tell that this
routine was called first.

containing a code reference, or a block that evaluates to a code
reference.

0

relatives.  In particular, it is not limited to using regular expressions.

0 to each element) and returns the list value consisting of those
elements for which the expression evaluated to true.  In scalar
context, returns the number of times the expression was true.

modify the elements of the LIST.  While this is useful and supported,
it can cause bizarre results if the elements of LIST are not variables.
Similarly, grep returns aliases into the original list, much as a for
loop's index variable aliases the list elements.  That is, modifying an
element of a list returned by grep (for example, in a 0, 0
or another 0) actually modifies the element in the original list.
This is usually something to be avoided when writing clear code.

been declared with 0) then, in addition to being locally aliased to
the list elements, 0 keeps being lexical inside the block; i.e., it
can't be seen from the outside, avoiding any potential side-effects.

0 0

(To convert strings that might start with either 0, 0, or 0, see
0.)  If EXPR is omitted, uses 0.

integer overflow trigger a warning.  Leading whitespace is not stripped,
unlike . To present something as hex, look into 0,
0, or 0.

0

method (subroutine) defined (or inherited) by modules that wish to export
names to another module.  The 0 function calls the 0 method
for the package used.  See also 0, 0, and 0.

0 0 0

the wildcard-like behavior of a full regular-expression pattern match.
It returns the position of the first occurrence of SUBSTR in STR at
or after POSITION.  If POSITION is omitted, starts searching from the
beginning of the string.  POSITION before the beginning of the string
or after its end is treated as if it were the beginning or the end,
respectively.  POSITION and the return value are based at 0 (or whatever
you've set the 0 variable to--but don't do that).  If the substring
is not found, 0 returns one less than the base, ordinarily 0.

0 0 0 0 0

You should not use this function for rounding: one because it truncates
towards 0, and two because machine representations of floating-point
numbers can sometimes produce counterintuitive results.  For example,
0 produces -268 rather than the correct -269; that's
because it's really more like -268.99999999999994315658 instead.  Usually,
the 0, 0, or the 0 and 0
functions will serve you better than will .

0

exist or doesn't have the correct definitions you'll have to roll your
own, based on your C header files such as .
(There is a Perl script called 0 that comes with the Perl kit that
may help you in this, but it's nontrivial.)  SCALAR will be read and/or
written depending on the FUNCTION; a C pointer to the string value of SCALAR
will be passed as the third argument of the actual 0 call.  (If SCALAR
has no string value but does have a numeric value, that value will be
passed rather than a pointer to the string value.  To guarantee this to be
true, add a 0 to the scalar before using it.)  The 0 and 0
functions may be needed to manipulate the values of structures used by
0.

still easily determine the actual value returned by the operating
system:

about improper numeric conversions.

0

separated by the value of EXPR, and returns that new string.  Example:

first argument.  Compare 0.

0 0

of an array. (In scalar context, returns the number of keys or indices.)

random order is subject to change in future versions of Perl, but it
is guaranteed to be the same order as either the 0 or 0
function produces (given that the hash has not been modified).  Since
Perl 5.8.1 the ordering can be different even between different runs of
Perl for security reasons (see 0).

(see 0).  In particular, calling  in void context resets
the iterator with no other overhead.

modifying them will not affect the original hash.  Compare 0.

Here's a descending numeric sort of a hash by its values:

allocated for the given hash.  This can gain you a measure of efficiency if
you know the hash is going to get big.  (This is similar to pre-extending
an array by assigning a larger number to $#array.)  If you say

in fact, since it rounds up to the next power of two.  These
buckets will be retained even if you do 0, use 0 if you want to free the storage while 0 is still in scope.
You can't shrink the number of buckets allocated for the hash using
0 in this way (but you needn't worry about doing this by accident,
as trying has no effect). 0 in an lvalue context is a syntax
error.

a reference to an unblessed hash or array.  The argument will be
dereferenced automatically.  This aspect of 0 is considered highly
experimental.  The exact behaviour may change in a future version of Perl.

0 0

processes successfully signaled (which is not necessarily the
same as the number actually killed).

checks whether it's 0 to send a signal to it (that
means, to be brief, that the process is owned by the same user, or we are
the super-user).  This is useful to check that a child process is still
alive (even if only as a zombie) and hasn't changed its UID.  See
0 for notes on the portability of this construct.

of processes. That means you usually want to use positive not negative signals.
You may also use a signal name in quotes.

the operating system.  For example, on POSIX-conforming systems, zero will
signal the current process group and -1 will signal all processes.

0 0

loops); it immediately exits the loop in question.  If the LABEL is
omitted, the command refers to the innermost enclosing loop.  The
0 block, if any, is not executed:

0, 0 or 0, and should not be used to exit
a  or  operation.

that executes once.  Thus 0 can be used to effect an early
exit out of such a block.

0 work.

0 0

implementing the 0 escape in double-quoted strings.

respectively.

change the case
(See 0.)
Otherwise Unicode semantics are used for the case change.

0 will be ignored.

outside the ASCII range is the character itself.

0 0

is the internal function implementing the 0 escape in
double-quoted strings.

as 0 does.

0 0

omitted, returns the length of 0.  If EXPR is undefined, returns
0.

many elements these have.  For that, use 0 and 0, respectively.

characters, not physical bytes.  For how many bytes a string encoded as
UTF-8 would take up, use 0 (you'll have
to 0 first).  See 0 and 0.

0

success, false otherwise.

0

it succeeded, false otherwise.  See the example in
0.

0

what most people think of as "local".  See
0 for details.

block, file, or eval.  If more than one value is listed, the list must
be placed in parentheses.  See 0
for details, including issues with tied arrays and hashes.

of array/hash elements to the current block.
See 0.

0 0

with the time analyzed for the local time zone.  Typically used as
follows:

tm'.  0, 0, and 0 are the seconds, minutes, and hours
of the specified time.

the range 0 with 0 indicating January and 11 indicating December.
This makes it easy to get a month name from a list:

of the year.  That is, 0 is 0 in year 2023.  The proper way
to get a 4-digit year is simply:

to do that, would you?

Wednesday.  0 is the day of the year, in the range 0
(or 0 in leap years.)

Time, false otherwise.

by ).

instead of local time use the 0 builtin. See also the
0 module (to convert the seconds, minutes, hours, ... back to
the integer value returned by ), and the 0 module's 
and  functions.

locale environment variables appropriately (please see 0) and
try for example:

and the month of the year, may not necessarily be three characters wide.

by-name access mechanism to the  and  functions,
respectively.

0 module on CPAN.

0

object contained in 0 until the lock goes out of scope.

by this name (before any calls to it), that function will be called
instead.  If you are not under 0 this does nothing.
See 0.

0 0 0 0 0

returns the log of 0.  To get the
log of another base, use basic algebra:
The base-N log of a number is equal to the natural log of that number
divided by the natural log of N.  For example:

0

special 0 filehandle) but stats a symbolic link instead of the file
the symbolic link points to.  If symbolic links are unimplemented on
your system, a normal 0 is done.  For much more detailed
information, please see the documentation for 0.

0

0 to each element) and returns the list value composed of the
results of each such evaluation.  In scalar context, returns the
total number of elements so generated.  Evaluates BLOCK or EXPR in
list context, so each element of LIST may produce zero, one, or
more elements in the returned value.

input elements. To omit an element, return an empty list ().
This could also be achieved by writing

assigned to a hash such that the elements
become key/value pairs. See 0 for more details.

modify the elements of the LIST.  While this is useful and supported,
it can cause bizarre results if the elements of LIST are not variables.
Using a regular 0 loop for this purpose would be clearer in
most cases.  See also 0 for an array composed of those items of
the original list for which the BLOCK or EXPR evaluates to true.

been declared with 0), then, in addition to being locally aliased to
the list elements, 0 keeps being lexical inside the block; that is, it
can't be seen from the outside, avoiding any potential side-effects.

the start of map BLOCK LIST or map EXPR, LIST. Because Perl doesn't look
ahead for the closing 0 it has to take a guess at which it's dealing with
based on what it finds just after the 0. Usually it gets it right, but if it
doesn't it won't realize something is wrong until it gets to the 0 and
encounters the missing (or unexpected) comma. The syntax error will be
reported close to the 0, but you'll need to change something near the 0
such as using a unary 0 to give Perl some help:

0 0 0

specified by MASK (as modified by 0).  If it succeeds it
returns true, otherwise it returns false and sets 0 (errno).
If omitted, MASK defaults to 0777. If omitted, FILENAME defaults
to 0.

and let the user modify that with their 0, than it is to supply
a restrictive MASK and give the user no way to be more permissive.
The exceptions to this rule are when the file or directory should be
kept private (mail files, for instance).  The  entry on
0 discusses the choice of MASK in more detail.

number of trailing slashes.  Some operating and filesystems do not get
this right, so Perl automatically removes all trailing slashes to keep
everyone happy.

the 0 function of the 0 module.

0

then ARG must be a variable that will hold the returned 0
structure.  Returns like 0: the undefined value for error,
0 for zero, or the actual return value otherwise.  See also
0 and the documentation for 0 and
0.

0

id, or the undefined value if there is an error.  See also
0 and the documentation for 0 and
0.

0

message queue ID into variable VAR with a maximum message size of
SIZE.  Note that when a message is received, the message type as a
native long integer will be the first thing in VAR, followed by the
actual message.  This packing may be opened with 0.
Taints the variable.  Returns true if successful, or false if there is
an error.  See also 0 and the documentation for
0 and 0.

0

message queue ID.  MSG must begin with the native long integer message
type, and be followed by the length of the actual message, and finally
the message itself.  This kind of packing can be achieved with
0.  Returns true if successful,
or false if there is an error.  See also the 0
and 0 documentation.

0

enclosing block, file, or 0.  If more than one value is listed,
the list must be placed in parentheses.

evolving.  TYPE is currently bound to the use of the 0 pragma,
and attributes are handled using the 0 pragma, or starting
from Perl 5.8.0 also via the 0 module.  See
0 for details, and 0,
0, and 0.

0 0

the next iteration of the loop:

executed even on discarded lines.  If LABEL is omitted, the command
refers to the innermost enclosing loop.

0, 0 or 0, and should not be used to exit
a  or  operation.

that executes once.  Thus 0 will exit such a block early.

0 work.

0
0

0 0 0 0 0 0

value.  (If EXPR happens to start off with 0, interprets it as a
hex string.  If EXPR starts off with 0, it is interpreted as a
binary string.  Leading whitespace is ignored in all three cases.)
The following will handle decimal, binary, octal, and hex in standard
Perl notation:

in octal), use  or :

to be converted into a file mode, for example.  Although Perl
automatically converts strings into numbers as needed, this automatic
conversion assumes base 10.

non-digits, such as a decimal point (0 only handles non-negative
integers, not negative integers or floating point).

0 0 0 0

FILEHANDLE.

introduction you may consider 0.)

the variable is assigned a reference to a new anonymous filehandle,
otherwise if FILEHANDLE is an expression, its value is used as the name of
the real filehandle wanted.  (This is considered a symbolic reference, so
0 should 0 be in effect.)

FILEHANDLE contains the filename.  (Note that lexical variables--those
declared with 0--will not work for this purpose; so if you're
using 0, specify EXPR in your call to open.)

the filename are separate. If MODE is  or nothing, the file
is opened for input.  If MODE is , the file is truncated and
opened for output, being created if necessary.  If MODE is C<<< '>>' >>>,
the file is opened for appending, again being created if necessary.

indicate that you want both read and write access to the file; thus
 is almost always preferred for read/write updates--the
 mode would clobber the file first.  You can't usually use
either read-write mode for updating textfiles, since they have
variable-length records.  See the 0 switch in 0 for a
better approach.  The file is created with permissions of 0
modified by the process's 0 value.

0, 0, 0, 0, and 0.

filename should be concatenated (in that order), possibly separated by
spaces.  You may omit the mode in these forms when that mode is
.

interpreted as a command to which output is to be piped, and if MODE
is 0, the filename is interpreted as a command that pipes
output to us.  In the two-argument (and one-argument) form, one should
replace dash (0) with the command.
See 0 for more examples of this.
(You are not allowed to 0 to a command that pipes both in 0
out, but see 0, 0, and
0 for
alternatives.)

(extra arguments after the command name) then LIST becomes arguments
to the command invoked if the platform supports it.  The meaning of
0 with more than three arguments for non-pipe modes is not yet
defined, but experimental "layers" may give extra LIST arguments
meaning.

or 0 opens STDIN and opening  opens STDOUT.

(sometimes referred to as "disciplines") to apply to the handle
that affect how the input and output are processed (see 0 and
0 for more details). For example:

see 0. Note that if layers are specified in the
three-argument form, then default layers stored in ${^OPEN} (see 0;
usually set by the 0 pragma or the switch 0) are ignored.

the 0 involved a pipe, the return value happens to be the pid of
the subprocess.

files and binary files, then you should check out 0 for tips
for dealing with this.  The key distinction between systems that need
0 and those that don't is their text file formats.  Systems
like Unix, Mac OS, and Plan 9, that end lines with a single
character and encode that character in C as 0 do not
need 0.  The rest need it.

if the request failed, so 0 is frequently used with
0.  Even if 0 won't do what you want (say, in a CGI script,
where you want to format a suitable error message (but there are
modules that can help with that problem)) always check
the return value from opening a file.

argument being 0:

works for symmetry, but you really should consider writing something
to the temporary file first.  You will need to  to do the
reading.

changed this (i.e., Configure -Uuseperlio), you can open filehandles
directly to Perl scalars via:

with , in which case the rest of the string is interpreted
as the name of a filehandle (or file descriptor, if numeric) to be
duped (as 0) and opened.  You may use 0 after ,
C<<< >> >>>, , , C<<< +>> >>>, and .
The mode you specify should match the mode of the original filehandle.
(Duping a filehandle does not take into account any existing contents
of IO buffers.) If you use the 3-arg form then you can pass either a
number, the name of a filehandle or the normal "reference to a glob".

0 using various methods:

or a filehandle, then Perl will do an equivalent of C's 0 of
that file descriptor (and not call 0); this is more
parsimonious of file descriptors.  For example:

parsimonious) for example when something is dependent on file
descriptors, like for example locking using .  If you do just
, the filehandle A will not have the same file
descriptor as B, and therefore flock(A) will not flock(B), and vice
versa.  But with  the filehandles will share
the same file descriptor.

the standard C libraries'  to implement the "=" functionality.
On many Unix systems  fails when file descriptors exceed a
certain value, typically 255.  For Perls 5.8.0 and later, PerlIO is
most often the default.

running 0 and looking for the 0 line.  If 0
is 0, you have PerlIO; otherwise you don't.

with the 2-argument (or 1-argument) form of , then
there is an implicit fork done, and the return value of open is the pid
of the child within the parent process, and 0 within the child
process.  (Use 0 to determine whether the open was successful.)
The filehandle behaves normally for the parent, but I/O to that
filehandle is piped from/to the STDOUT/STDIN of the child process.
In the child process, the filehandle isn't opened--I/O happens from/to
the new STDOUT/STDIN.  Typically this is used like the normal
piped open when you want to exercise more control over just how the
pipe command gets executed, such as when running setuid and
you don't want to have to scan shell commands for metacharacters.

not yet supported on all platforms.  A good rule of thumb is that if
your platform has true 0 (in other words, if your platform is
Unix) you can use the list form.

output before any operation that may do a fork, but this may not be
supported on some platforms (see 0).  To be safe, you may need
to set 0 ( in English) or call the 0 method
of 0 on any open handles.

be set for the newly opened file descriptor as determined by the value
of $^F.  See 0.

child to finish, and returns the status value in 0 and
0.

have leading and trailing whitespace deleted, and the normal
redirection characters honored.  This property, known as "magic open",
can often be used to good effect.  A user could specify a filename of
0, or you could change certain filenames as needed:

conscientiously choose between the 0 and 3-arguments form
of :

but will not work on a filename that happens to have a trailing space, while

should use the 0 function, which involves no such magic (but
may use subtly different filemodes than Perl , which is mapped
to C ).  This is
another way to protect your filenames from interpretation.  For example:

subclasses, such as 0 or 0), you can generate anonymous
filehandles that have the scope of whatever variables hold references to
them, and automatically close whenever and however you leave that scope:

0

0, 0, and 0.  Returns true if successful.
DIRHANDLE may be an expression whose value can be used as an indirect
dirhandle, usually the real dirhandle name.  If DIRHANDLE is an undefined
scalar variable (or array or hash element), the variable is assigned a
reference to a new anonymous dirhandle.
DIRHANDLEs have their own namespace separate from FILEHANDLEs.

0 0

or Unicode) value of the first character of EXPR.  If EXPR is an empty
string, returns 0.  If EXPR is omitted, uses 0.

See 0 for more about Unicode.

0 0

package for use within the current scope.  When 0 is in
effect, 0 lets you use declared global variables without qualifying
them with package names, within the lexical scope of the 0 declaration.
In this way 0 differs from 0, which is package-scoped.

a simple name with that storage for use within the current scope, 0
associates a simple name with a package variable in the current package,
for use within the current scope.  In other words, 0 has the same
scoping rules as 0, but does not necessarily create a
variable.

in parentheses.

across its entire lexical scope, even across package boundaries.  The
package in which the variable is entered is determined at the point
of the declaration, not at the point of use.  This means the following
behavior holds:

scope are allowed if they are in different packages.  If they happen
to be in the same package, Perl will emit warnings if you have asked
for them, just like multiple 0 declarations.  Unlike a second
0 declaration, which will bind the name to a fresh variable, a
second 0 declaration in the same package, in the same scope, is
merely redundant.

with it.

evolving.  TYPE is currently bound to the use of 0 pragma,
and attributes are handled using the 0 pragma, or starting
from Perl 5.8.0 also via the 0 module.  See
0 for details, and 0,
0, and 0.

0

given by the TEMPLATE.  The resulting string is the concatenation of
the converted values.  Typically, each converted value looks
like its machine-level representation.  For example, on 32-bit machines
an integer may be represented by a sequence of 4 bytes, which  will in
Perl be presented as a string that's 4 characters long.

of values, as follows:

TEMPLATE (the second column lists letters for which the modifier is valid):

to force a particular byte-order on all components in that group,
including all its subgroups.

count.  A numeric repeat count may optionally be enclosed in brackets, as
in 0.  The repeat count gobbles that many values from
the LIST when used with all format types other than 0, 0, 0, 0,
0, 0, 0, 0, 0, 0, 0, and 0, where it means
something else, dscribed below.  Supplying a 0 for the repeat count
instead of a number means to use however many items are left, except for:

brackets to use the packed byte length of the bracketed template for the
repeat count.

and the template 0 unpacks twice whatever  (when
variable-expanded) unpacks.  If the template in brackets contains alignment
commands (such as 0), its packed length is calculated as if the
start of the template had the maximal possible alignment.

trailing null byte, so the resulting string is always one byte longer than
the byte length of the item itself.

of the innermost 0 group.

calculate the value offset as follows:

packed string.

0th innermost 0 group, or to the start of the string if 0 is
bigger then the group level.

to encode per line of output, with 0, 1 and 2 replaced by 45. The repeat
count should not be more than 65.

string of length count, padding with nulls or spaces as needed.  When
unpacking, 0 strips trailing whitespace and nulls, 0 strips everything
after the first null, and 0 returns data without any sort of trimming.

long and an explicit count is provided, 0 packs only 0 bytes,
followed by a null byte.  Thus 0 always packs a trailing null, except
for when the count is 0.

Each such format generates 1 bit of the result.

input character, i.e., on 0.  In particular, characters 0
and 0 generate bits 0 and 1, as do characters 0 and 0.

of characters is converted to 1 character of output.  With format 0,
the first character of the 8-tuple determines the least-significant bit of a
character; with format 0, it determines the most-significant bit of
a character.

remainder is packed as if the input string were padded by null characters
at the end.  Similarly during unpacking, "extra" bits are ignored.

On unpacking, bits are converted to a string of 0s and 0s.

representable as hexadecimal digits, 0 0) long.

With non-alphabetical characters, the result is based on the 4 least-significant
bits of the input character, i.e., on 0.  In particular,
characters 0 and 0 generate nybbles 0 and 1, as do bytes
0 and 0.  For characters 0 and 0, the result
is compatible with the usual hexadecimal digits, so that 0 and
0 both generate the nybble 0.  Do not use any characters
but these with this format.

of characters is converted to 1 character of output.  With format 0, the
first character of the pair determines the least-significant nybble of the
output character; with format 0, it determines the most-significant
nybble.

a null character at the end.  Similarly, "extra" nybbles are ignored during
unpacking.

, nybbles are converted to a string of hexadecimal digits.

responsible for ensuring that the string is not a temporary value, as that
could potentially get deallocated before you got around to using the packed
result.  The 0 format packs a pointer to a structure of the size indicated
by the length.  A null pointer is created if the corresponding value for
0 or 0 is 0; similarly with , where a null pointer
unpacks into 0.

big as an int nor as big as a long--it may not be possible to pack or
unpack pointers in big- or little-endian byte order.  Attempting to do
so raises an exception.

items where the packed structure contains a packed item count followed by
the packed items themselves.  This is useful when the structure you're
unpacking has encoded the sizes or repeat counts for some of its fields
within the structure itself as separate fields.

0 describes how the length value is packed. Formats likely
to be of most use are integer-packing ones like 0 for Java strings,
0 for ASN.1 or SNMP, and 0 for Sun XDR.

the minimum of that and the number of available items is used as the argument
for 0. If it has no repeat count or uses a '*', the number
of available items is used.

used. You write 00 and the repeat count is obtained by
popping off the last element from the stack. The 0 must not
have a repeat count.

the 0 is the string length, not the number of strings.  With
an explicit repeat count for pack, the packed string is adjusted to that
length.  For example:

0, 0, or 0.  Packing with a 0 of 0 or 0 may
introduce 0 characters, which Perl does not regard as legal in
numeric strings.

followed by a 0 modifier to specify native shorts or
longs.  As shown in the example above, a bare 0 means
exactly 32 bits, although the native 0 as seen by the local C compiler
may be larger.  This is mainly an issue on 64-bit platforms.  You can
see whether using 0 makes any difference this way:

they are identical to 0 and 0.

longs on the platform where Perl was built are also available from
the command line:

long long support.

inherently non-portable between processors and operating systems because
they obey native byteorder and endianness.  For example, a 4-byte integer
0x12345678 (305419896 decimal) would be ordered natively (arranged in and
handled by the CPU registers) into bytes as

including Motorola m68k/88k, PPC, Sparc, HP PA, Power, and Cray, are
big-endian.  Alpha and MIPS can be either: Digital/Compaq used/uses them in
little-endian mode, but SGI/Cray uses them in big-endian mode.

egg-eating habits of the little-endian Lilliputians and the big-endian
Blefuscudians from the classic Jonathan Swift satire, 0.
This entered computer lingo via the paper "On Holy Wars and a Plea for
Peace" by Danny Cohen, USC/ISI IEN 137, April 1, 1980.

via 0:

and 0 are big-endian.

and 0 or else use the  and  modifiers described
immediately below.  See also 0.

the 0 and 0 formats and 0 groups, may all be followed by the
 or  endianness modifiers to respectively enforce big-
or little-endian byte-order.  These modifiers are especially useful
given how 0, 0, 0 and 0 don't cover signed integers,
64-bit integers, or floating-point values.

when all platforms store them in the same format.  Most platforms store
signed integers in two's-complement notation, so usually this is not an issue.

formats on big- or little-endian machines.  Otherwise, attempting to
use them raises an exception.

data exchange can work only if all platforms use the same
binary representation such as IEEE floating-point.  Even if all
platforms are using IEEE, there may still be subtle differences.  Being able
to use  or  on floating-point values can be useful,
but also dangerous if you don't know exactly what you're doing.
It is not a general way to portably store floating-point values.

all types inside the group that accept byte-order modifiers,
including all subgroups.  It is silently ignored for all other
types.  You are not allowed to override the byte-order within a group
that already has a byte-order modifier suffix.

Due to the multiplicity of floating-point formats and the lack of a
standard "network" representation for them, no facility for interchange has been
made.  This means that packed floating-point data written on one machine
may not be readable on another, even if both use IEEE floating-point
arithmetic (because the endianness of the memory representation is not part
of the IEEE spec).  See also 0.

modifiers to force big- or little-endian byte-order on floating-point values.

all numeric calculation, converting from double into float and thence
to double again loses precision, so 0)
will not in general equal .

the packed string is processed per character, and UTF-8 mode (0 mode)
where the packed string is processed in its UTF-8-encoded Unicode form on
a byte-by-byte basis. Character mode is the default unless the format string
starts with 0. You can always switch mode mid-format with an explicit
0 or 0 in the format.  This mode remains in effect until the next
mode change, or until the end of the 0 group it (directly) applies to.

enough 0es while packing.  There is no way for  and 
to know where characters are going to or coming from, so they
handle their output and input as flat sequences of characters.

take a repeat count either as postfix, or for , also via the 0
template character.  Within each repetition of a group, positioning with
0 starts over at 0. Therefore, the result of

jump forward or back to the closest position aligned at a multiple of 0
characters. For example, to  or  a C structure like

doubles must be aligned to the size of double.

both are no-ops.

represent signed 16-/32-bit integers in big-/little-endian order.
This is portable only when all platforms sharing packed data use the
same binary representation for signed integers; for example, when all
platforms use two's-complement representation.

White space can separate pack codes from each other, but modifiers and
repeat counts must follow immediately.  Breaking complex templates into
individual line-by-line components, suitably annotated, can do as much to
improve legibility and maintainability of pack/unpack formats as 0 can
for complicated pattern matches.

assumes additional 0 arguments.  If TEMPLATE requires fewer arguments
than given, extra arguments are ignored.

0 0 0 0

0 0 0 0

the given namespace.  The scope of the package declaration is either the
supplied code BLOCK or, in the absence of a BLOCK, from the declaration
itself through the end of the enclosing block, file, or eval (the same
as the 0 operator).  All unqualified dynamic identifiers in this
scope will be in the given namespace, except where overridden by another
0 declaration.

you've used 0 on, but 0 lexical variables, which are created
with 0 (or 0 (or 0)).  Typically it would be the first
declaration in a file included by 0 or 0.  You can switch into a
package in more than one place, since this only determines which default
symbol table the compiler uses for the rest of that block.  You can refer to
identifiers in other packages than the current one by prefixing the identifier
with the package name and a double colon, as in 0
or 0.  If package name is omitted, the 0
package as assumed.  That is, 0 is equivalent to
0 (as well as to 0, still seen in ancient
code, mostly from Perl 4).

namespace to a 0 object with the VERSION provided.  VERSION must be a
"strict" style version number as defined by the 0 module: a positive
decimal number (integer or decimal-fraction) without exponentiation or else a
dotted-decimal v-string with a leading 'v' character and at least three
components.  You should set 0 only once per package.

and classes.  See 0 for other scoping issues.

0

Note that if you set up a loop of piped processes, deadlock can occur
unless you are very careful.  In addition, note that Perl's pipes use
IO buffering, so you may need to set 0 to flush your WRITEHANDLE
after each command, depending on the application.

0
for examples of such things.

on all newly opened file descriptors whose 0s are 0 than
the current value of $^F (by default 2 for 0).  See 0.

0 0

one element.

happen at other times.  If ARRAY is omitted, pops the 0 array in the
main program, but the 0 array in subroutines, just like 0.

reference to an unblessed array.  The argument will be dereferenced
automatically.  This aspect of 0 is considered highly experimental.
The exact behaviour may change in a future version of Perl.

0 0

variable in question (0 is used when the variable is not
specified). Note that 0 is a valid match offset. 0 indicates
that the search position is reset (usually due to match failure, but
can also be because no match has yet been run on the scalar).

store the offset, so assigning to 0 will change that offset, and
so will also influence the 0 zero-width assertion in regular
expressions. Both of these effects take place for the next match, so
you can't affect the position with 0 during the current match,
such as in 0 or 0.

under 0.

from 0 won't change either in this case.  See 0 and
0.

0

FILEHANDLE may be a scalar variable containing
the name of or a reference to the filehandle, thus introducing
one level of indirection.  (NOTE: If FILEHANDLE is a variable and
the next token is a term, it may be misinterpreted as an operator
unless you interpose a 0 or put parentheses around the arguments.)
If FILEHANDLE is omitted, prints to standard output by default, or
to the last selected output channel; see 0.  If LIST is
also omitted, prints 0 to the currently selected output handle.
To set the default output handle to something other than STDOUT
use the select operation.  The current value of 0 (if any) is
printed between each LIST item.  The current value of 0 (if
any) is printed after the entire LIST has been printed.  Because
print takes a LIST, anything in the LIST is evaluated in list
context, and any subroutine that you call will have one or more of
its expressions evaluated in list context.  Also be careful not to
follow the print keyword with a left parenthesis unless you want
the corresponding right parenthesis to terminate the arguments to
the print; put parentheses around all the arguments
(or interpose a 0, but that doesn't look as good).

any other expression more complex than a scalar variable to retrieve it,
you will have to use a block returning the filehandle value instead:

0 for more on signal handling.

0

(the output record separator) is not appended.  The first argument
of the list will be interpreted as the 0 format. See 0
for an explanation of the format argument.  If 0 is in effect,
and POSIX:: has been called, the character used for the decimal
separator in formatted floating-point numbers is affected by the LC_NUMERIC
locale.  See 0 and 0.

0 would do.  The 0 is more efficient and less
error prone.

0

function has no prototype).  FUNCTION is a reference to, or the name of,
the function whose prototype you want to retrieve.

name for a Perl builtin.  If the builtin is not 0 (such as
0) or if its arguments cannot be adequately expressed by a prototype
(such as 0),  returns 0, because the builtin
does not really behave like a Perl function.  Otherwise, the string
describing the equivalent prototype is returned.

0 0

onto the end of ARRAY.  The length of ARRAY increases by the length of
LIST.  Has the same effect as

the completed 0.

reference to an unblessed array.  The argument will be dereferenced
automatically.  This aspect of 0 is considered highly experimental.
The exact behaviour may change in a future version of Perl.

0 0

characters backslashed.  (That is, all characters not matching
0 will be preceded by a backslash in the
returned string, regardless of any locale settings.)
This is the internal function implementing
the 0 escape in double-quoted strings.

regular expressions, because by default an interpolated variable will be
considered a mini-regular expression. For example:

the user,  or 0 must be used.

quoted in UTF-8 encoded strings, but all are quoted in UTF-8 strings.
It is planned to change this behavior in 5.16, but the exact rules
haven't been determined yet.

0 0

than the value of EXPR.  (EXPR should be positive.)  If EXPR is
omitted, the value 0 is used.  Currently EXPR with the value 0 is
also special-cased as 0 (this was undocumented before Perl 5.8.0
and is subject to change in future versions of Perl).  Automatically calls
0 unless 0 has already been called.  See also 0  As of this writing, a
number of third-party CPAN modules offer random number generators
intended by their authors to be cryptographically secure,
including: 0, 0, and
0.

0 0

from the specified FILEHANDLE.  Returns the number of characters
actually read, 0 at end of file, or undef if there was an error (in
the latter case 0 is also set).  SCALAR will be grown or shrunk
so that the last character actually read is the last character of the
scalar after the read.

string other than the beginning.  A negative OFFSET specifies
placement at that many characters counting backwards from the end of
the string.  A positive OFFSET greater than the length of SCALAR
results in the string being padded to the required size with 0
bytes before the result of the read is appended.

 library function.  To get a true  system call, see 0.

either (8-bit) bytes or characters are read.  By default all
filehandles operate on bytes, but for example if the filehandle has
been opened with the 0 I/O layer (see 0, and the 0
pragma, 0), the I/O will operate on UTF-8 encoded Unicode
characters, not bytes.  Similarly for the 0 pragma:
in that case pretty much any characters can be read.

0

If used in list context, returns all the rest of the entries in the
directory.  If there are no more entries, returns the undefined value in
scalar context and the empty list in list context.

better prepend the directory in question.  Otherwise, because we didn't
0 there, it would have been testing the wrong file.

which will set 0 on every iteration.

0 0 0

*ARGV if EXPR is not provided).  In scalar context, each call reads and
returns the next line until end-of-file is reached, whereupon the
subsequent call returns 0.  In list context, reads until end-of-file
is reached and returns a list of lines.  Note that the notion of "line"
used here is whatever you may have defined with 0 or
0).  See 0.

context (i.e., file slurp mode), and when an empty file is read, it
returns 0 the first time, followed by 0 subsequently.

operator, but you can use it directly.  The 
operator is discussed in more detail in 0.

with the corresponding error message.  It can be helpful to check
0 when you are reading from filehandles you don't trust, such as a
tty or a socket.  The following example uses the operator form of
0 and dies if the result is not defined.

0 filehandle. In that case, you have to open each element of
0 yourself since 0 handles 0 differently.

0

implemented.  If not, raises an exception.  If there is a system
error, returns the undefined value and sets 0 (errno).  If EXPR is
omitted, uses 0.

0

The collected standard output of the command is returned.
In scalar context, it comes back as a single (potentially
multi-line) string.  In list context, returns a list of lines
(however you've defined lines with 0 or 0).
This is the internal function implementing the 0
operator, but you can use it directly.  The 0
operator is discussed in more detail in 0.
If EXPR is omitted, uses 0.

0

of data into variable SCALAR from the specified SOCKET filehandle.
SCALAR will be grown or shrunk to the length actually read.  Takes the
same flags as the system call of the same name.  Returns the address
of the sender if SOCKET's protocol supports this; returns an empty
string otherwise.  If there's an error, returns the undefined value.
This call is actually implemented in terms of  system call.
See 0 for examples.

(8-bit) bytes or characters are received.  By default all sockets
operate on bytes, but for example if the socket has been changed using
 to operate with the 0 I/O layer (see the
0 pragma, 0), the I/O will operate on UTF-8 encoded Unicode
characters, not bytes.  Similarly for the 0 pragma: in that
case pretty much any characters can be read.

0

conditional again.  The 0 block, if any, is not executed.  If
the LABEL is omitted, the command refers to the innermost enclosing
loop.  Programs that want to lie to themselves about what was just input
normally use this command:

0, 0 or 0, and should not be used to exit
a  or  operation.

that executes once.  Thus 0 inside such a block will effectively
turn it into a looping construct.

0 work.

0 0

string otherwise. If EXPR
is not specified, 0 will be used.  The value returned depends on the
type of thing the reference is a reference to.
Builtin types include:

name is returned instead.  You can think of 0 as a 0 operator.

a variable. You get this from taking the reference of function calls like
0 or 0. 0 is returned if the reference points
to a 0.

resulting from 0.

0 0 0 0

clobbered.  Returns true for success, false otherwise.

implementation.  For example, it will usually not work across file system
boundaries, even though the system 0 command sometimes compensates
for this.  Other restrictions include whether it works on directories,
open files, or pre-existing files.  Check 0 and either the
 manpage or equivalent system documentation for details.

module.

0

specified by EXPR or by 0 if EXPR is not supplied.

compared to 0, or a literal of the form v5.6.1, which will be compared
to 0 (aka ).  An exception is raised if
VERSION is greater than the version of the current Perl interpreter.
Compare with 0, which can do a similar check at compile time.

avoided, because it leads to misleading error messages under earlier
versions of Perl that do not support this syntax.  The equivalent numeric
version should be used instead.

hasn't already been included.  The file is included via the do-FILE
mechanism, which is essentially just a variety of 0 with the
caveat that lexical variables in the invoking script will be invisible
to the included code.  Has semantics similar to the following subroutine:

name.

successful execution of any initialization code, so it's customary to
end such a file with 0 unless you're sure it'll return true
otherwise.  But it's better just to put the 0, in case you add more
statements.

replaces "0" with "0" in the filename for you,
to make it easy to load standard modules.  This form of loading of
modules does not risk altering your namespace.

directories specified in the 0 array.

will complain about not finding "0" there.  In this case you can do:

bareword argument, there is a little extra functionality going on behind
the scenes.  Before 0 looks for a "0" extension, it will
first look for a similar filename with a "0" extension. If this file
is found, it will be loaded in place of any file ending in a "0"
extension.

directly into the @INC array.  There are three forms of hooks: subroutine
references, array references and blessed objects.

walks through @INC and encounters a subroutine, this subroutine gets
called with two parameters, the first a reference to itself, and the
second the name of the file to be included (e.g., "0").  The
subroutine should return either nothing or else a list of up to three
values in the following order:

then this subroutine is expected to generate one line of source code per
call, writing the line into 0 and returning 1, then returning 0 at
end of file.  If there is a filehandle, then the subroutine will be
called to act as a simple source filter, with the line as read in 0.
Again, return 1 for each valid line, and 0 after all lines have been
returned.

reference to the subroutine itself is passed in as 0.

is returned, then 0 looks at the remaining elements of @INC.
Note that this filehandle must be a real filehandle (strictly a typeglob
or reference to a typeglob, blessed or unblessed); tied filehandles will be
ignored and return value processing will stop there.

reference.  This subroutine is called as above, but the first parameter is
the array reference.  This lets you indirectly pass arguments to
the subroutine.

called as above, the first parameter being the object itself.  (Note that
you must fully qualify the sub's name, as unqualified 0 is always forced
into package 0.)  Here is a typical code layout:

corresponding to the files they have loaded. See 0.

0

variables and reset 0 searches so that they work again.  The
expression is interpreted as a list of single characters (hyphens
allowed for ranges).  All variables and arrays beginning with one of
those letters are reset to their pristine state.  If the expression is
omitted, one-match searches (0) are reset to match again.
Only resets variables or searches in the current package.  Always returns
1.  Examples:

0 and 0 arrays and your 0 hash.  Resets only package
variables; lexical variables are unaffected, but they clean themselves
up on scope exit anyway, so you'll probably want to use them instead.
See 0.

0

given in EXPR.  Evaluation of EXPR may be in list, scalar, or void
context, depending on how the return value will be used, and the context
may vary from one execution to the next (see 0).  If no EXPR
is given, returns an empty list in list context, the undefined value in
scalar context, and (of course) nothing at all in void context.

or do FILE automatically returns the value of the last expression
evaluated.)

0 0 0

of LIST in the opposite order.  In scalar context, concatenates the
elements of LIST and returns a string value with all characters
in the opposite order.

preserve non-existent elements whenever possible, i.e., for non magical
arrays or tied arrays with 0 and 0 methods.

caveats.  If a value is duplicated in the original hash, only one of those
can be represented as a key in the inverted hash.  Also, this has to
unwind one hash and build a whole new one, which may take some time
on a large hash, such as from a DBM file.

0

0 routine on DIRHANDLE.

0

occurrence of SUBSTR in STR.  If POSITION is specified, returns the
last occurrence beginning at or before that position.

0 0 0

empty.  If it succeeds it returns true, otherwise it returns false and
sets 0 (errno).  If FILENAME is omitted, uses 0.

the 0 function of the 0 module.

0

0 is simply an abbreviation for 0.

enabled: see 0.

0 0

of EXPR.

be interpolated in list context because in practice, this is never
needed.  If you really wanted to do so, however, you could use
the construction 0, but usually a simple
0 suffices.

parenthesized list, this behaves as a scalar comma expression, evaluating
all but the last element in void context and returning the final element
evaluated in scalar context.  This is seldom what you want.

0 0 0

FILEHANDLE may be an expression whose value gives the name of the
filehandle.  The values for WHENCE are 0 to set the new position
0 to POSITION, 0 to set it to the current position plus
POSITION, and 0 to set it to EOF plus POSITION (typically
negative).  For WHENCE you may use the constants 0,
0, and 0 (start of the file, current position, end
of the file) from the Fcntl module.  Returns 0 on success, 0
otherwise.

operate on characters (for example by using the 0 open
layer),  will return byte offsets, not character offsets
(because implementing that would render  and  rather slow).

0, because buffering makes its effect on the file's read-write position
unpredictable and non-portable.  Use 0 instead.

seek whenever you switch between reading and writing.  Amongst other
things, this may have the effect of calling stdio's .
A WHENCE of 0 (0) is useful for not moving the file position:

EOF on your read and then sleep for a while, you (probably) have to stick in a
dummy  to reset things.  The 0 doesn't change the position,
but it 0 clear the end-of-file condition on the handle, so that the
next  makes Perl try again to read something.  (We hope.)

cantankerous), you might need something like this:

0

must be a value returned by 0.  0 also has the same caveats
about possible directory compaction as the corresponding system library
routine.

0 0

sets the new current default filehandle for output.  This has two
effects: first, a 0 or a 0 without a filehandle will
default to this FILEHANDLE.  Second, references to variables related to
output will refer to this output channel.  For example, if you have to
set the top of form format for more than one output channel, you might
do the following:

actual filehandle.  Thus:

methods, preferring to write the last example as:

0

can be constructed using 0 and 0, along these lines:

subroutine like this:

calling  in scalar context just returns .

in seconds, which may be fractional.  Note: not all implementations are
capable of returning the .  If not, they always return
 equal to the supplied .

is implementation-dependent.  See also 0 for notes on the
portability of 0.

-1 and sets 0.

descriptor as "ready for reading" when no data is available, and
thus a subsequent read blocks. This can be avoided if you always use
O_NONBLOCK on the socket. See  and  for further
details.

or <FH>) with 0, except as permitted by POSIX, and even
then only on POSIX systems.  You have to use 0 instead.

0

GETALL, then ARG must be a variable that will hold the returned
semid_ds structure or semaphore value array.  Returns like 0:
the undefined value for error, "0" for zero, or the actual
return value otherwise.  The ARG must consist of a vector of native
short integers, which may be created with 0.
See also 0, 0, 0
documentation.

0

the undefined value if there is an error.  See also
0, 0, 0
documentation.

0

such as signalling and waiting.  OPSTRING must be a packed array of
semop structures.  Each semop structure can be generated with
0.  The length of OPSTRING
implies the number of semaphore operations.  Returns true if
successful, or false if there is an error.  As an example, the
following code waits on semaphore  of semaphore id :

0, 0, and 0
documentation.

0

filehandle.  Takes the same flags as the system call of the same name.  On
unconnected sockets, you must specify a destination to 0, in which
case it does a  syscall.  Returns the number of characters sent,
or the undefined value on error.  The  syscall is currently
unimplemented.  See 0 for examples.

(8-bit) bytes or characters are sent.  By default all sockets operate
on bytes, but for example if the socket has been changed using
 to operate with the 0 I/O layer (see
0, or the 0 pragma, 0), the I/O will operate on UTF-8
encoded Unicode characters, not bytes.  Similarly for the 0
pragma: in that case pretty much any characters can be sent.

0 0

process.  Raises an exception when used on a machine that doesn't
implement POSIX  or BSD .  If the arguments are omitted,
it defaults to 0.  Note that the BSD 4.2 version of 0 does not
accept any arguments, so only 0 is portable.  See also
0.

0 0 0 0

(See .)  Raises an exception when used on a machine
that doesn't implement .

0

error.  Use integer constants provided by the 0 module for
LEVEL and OPNAME.  Values for LEVEL can also be obtained from
getprotobyname.  OPTVAL might either be a packed string or an integer.
An integer OPTVAL is shorthand for pack("i", OPTVAL).

0

array by 1 and moving everything down.  If there are no elements in the
array, returns the undefined value.  If ARRAY is omitted, shifts the
0 array within the lexical scope of subroutines and formats, and the
0 array outside a subroutine and also within the lexical scopes
established by the 0, 0, 0, 0,
0 and 0 constructs.

reference to an unblessed array.  The argument will be dereferenced
automatically.  This aspect of 0 is considered highly experimental.
The exact behaviour may change in a future version of Perl.

same thing to the left end of an array that 0 and 0 do to the
right end.

0

then ARG must be a variable that will hold the returned 0
structure.  Returns like ioctl: the undefined value for error, "0 but
true" for zero, or the actual return value otherwise.
See also 0 and 0 documentation.

0

segment id, or the undefined value if there is an error.
See also 0 and 0 documentation.

0
0

position POS for size SIZE by attaching to it, copying in/out, and
detaching from it.  When reading, VAR must be a variable that will
hold the data read.  When writing, if STRING is too long, only SIZE
bytes are used; if STRING is too short, nulls are written to fill out
SIZE bytes.  Return true if successful, or false if there is an error.
 taints the variable. See also 0,
0 documentation, and the 0 module from CPAN.

0

has the same interpretation as in the syscall of the same name.

side you're done writing but not done reading, or vice versa.
It's also a more insistent form of close because it also
disables the file descriptor in any forked copies in other
processes.

the first argument is not a valid filehandle, or returns 0 and sets
0 for any other failure.

0 0 0 0

returns sine of 0.

function, or use this relation:

0 0

argument is given.  Returns the integer number of seconds actually slept.

is often implemented using 0.

you requested, depending on how it counts seconds.  Most modern systems
always sleep the full amount.  They may appear to sleep longer than that,
however, because your process might not be scheduled right away in a
busy multitasking system.

(from CPAN, and starting from Perl 5.8 part of the standard
distribution) provides .  You may also use Perl's four-argument
version of  leaving the first three arguments undefined, or you
might be able to use the 0 interface to access  if
your system supports it. See 0 for details.

0

SOCKET.  DOMAIN, TYPE, and PROTOCOL are specified the same as for
the syscall of the same name.  You should 0 first
to get the proper definitions imported.  See the examples in
0.

be set for the newly opened file descriptor, as determined by the
value of $^F.  See 0.

0

specified type.  DOMAIN, TYPE, and PROTOCOL are specified the same as
for the syscall of the same name.  If unimplemented, raises an exception.
Returns true if successful.

be set for the newly opened file descriptors, as determined by the value
of $^F.  See 0.

to 0 is essentially:

emulate socketpair using IP sockets to localhost if your system implements
sockets but not socketpair.

0 0 0 0

In scalar context, the behaviour of 0 is undefined.

order.  If SUBNAME is specified, it gives the name of a subroutine
that returns an integer less than, equal to, or greater than 0,
depending on how the elements of the list are to be ordered.  (The
 and 0 operators are extremely useful in such routines.)
SUBNAME may be a scalar variable name (unsubscripted), in which case
the value provides the name of (or a reference to) the actual
subroutine to use.  In place of a SUBNAME, you can provide a BLOCK as
an anonymous, in-line sort subroutine.

are passed by reference in 0, as for a normal subroutine.  This is
slower than unprototyped subroutines, where the elements to be
compared are passed into the subroutine
as the package global variables  and  (see example below).  Note that
in the latter case, it is usually counter-productive to declare  and
 as lexicals.

be modified.

loop control operators described in 0 or with 0.

current collation locale.  See 0.

variable aliases the list elements.  That is, modifying an element of a
list returned by  (for example, in a 0, 0 or 0)
actually modifies the element in the original list.  This is usually
something to be avoided when writing clear code.

That algorithm was not stable, and 0 go quadratic.  (A 0 sort
preserves the input order of elements that compare equal.  Although
quicksort's run time is O(NlogN) when averaged over all arrays of
length N, the time can be O(N**2), 0 behavior, for some
inputs.)  In 5.7, the quicksort implementation was replaced with
a stable mergesort algorithm whose worst-case behavior is O(NlogN).
But benchmarks indicated that for some inputs, on some platforms,
the original quicksort was faster.  5.8 has a sort pragma for
limited control of the sort.  Its rather blunt control of the
underlying algorithm may not persist into future Perls, but the
ability to characterize the input or output in implementation
independent ways quite probably will.  See 0.

a function. If you want to sort the list returned by the function call
0, you can use:

0 then you can use:

and  as lexicals.  They are package globals.  That means
that if you're in the 0 package and type

but if you're in the 0 package, it's the same as typing

inconsistent results (sometimes saying 0 is less than 0 and
sometimes saying the opposite, for example) the results are not
well-defined.

(not-a-number), and because 0 raises an exception unless the
result of a comparison is defined, when sorting with a comparison function
like , be careful about lists that might contain a 0.
The following example takes advantage that 0 to
eliminate any 0s from the input list.

0

replaces them with the elements of LIST, if any.  In list context,
returns the elements removed from the array.  In scalar context,
returns the last element removed, or 0 if no elements are
removed.  The array grows or shrinks as necessary.
If OFFSET is negative then it starts that far from the end of the array.
If LENGTH is omitted, removes everything from OFFSET onward.
If LENGTH is negative, removes the elements from OFFSET onward
except for -LENGTH elements at the end of the array.
If both OFFSET and LENGTH are omitted, removes everything. If OFFSET is
past the end of the array, Perl issues a warning, and splices at the
end of the array.

reference to an unblessed array.  The argument will be dereferenced
automatically.  This aspect of 0 is considered highly experimental.
The exact behaviour may change in a future version of Perl.

0

default, empty leading fields are preserved, and empty trailing ones are
deleted.  (If all fields are empty, they are considered to be trailing.)

splits on whitespace (after skipping any leading whitespace).  Anything
matching PATTERN is taken to be a delimiter separating the fields.  (Note
that the delimiter may be longer than one character.)

of fields the EXPR will be split into, though the actual number of
fields returned depends on the number of times PATTERN matches within
EXPR.  If LIMIT is unspecified or zero, trailing null fields are
stripped (which potential users of 0 would do well to remember).
If LIMIT is negative, it is treated as if an arbitrarily large LIMIT
had been specified.  Note that splitting an EXPR that evaluates to the
empty string always returns the empty list, regardless of the LIMIT
specified.

an empty pattern 0, which is just one member of the set of patterns
matching the epmty string), splits EXPR into individual
characters.  For example:

matches the empty string; this is not be confused with the normal use
of an empty pattern to mean the last successful match.  So to split
a string into individual characters, the following:

the beginning of the string; a zero-width match at the beginning of
the string does not produce an empty field. For example:

hand, are produced when there is a match at the end of the string (and
when LIMIT is given and is not 0), regardless of the length of the match.
For example:

both with an empty trailing field.

a LIMIT one larger than the number of variables in the list, to avoid
unnecessary work.  For the list above LIMIT would have been 4 by
default.  In time critical applications it behooves you not to split
into more fields than you really need.

created from each matching substring in the delimiter.

you could split it up into fields and their values this way:

patterns that vary at runtime.  (To do runtime compilation only once,
use 0.)

white space just as 0 with no arguments does.  Thus, S<0 can
be used to emulate 0's default behavior, whereas S<0
will give you as many initial null fields (empty string) as there are leading spaces.
A 0 on 0 is like a S<0 except that any leading
whitespace produces a null first field.  A 0 with no arguments
really does a S<0 internally.

much use otherwise.

matched in a 0 will be set to 0 when returned:

0

library function 0.  See below for more details
and see 0 or 0 on your system for an explanation of
the general principles.

function , but doesn't use it except for floating-point
numbers, and even then only standard modifiers are allowed.
Non-standard extensions in your local  are
therefore unavailable from Perl.

pass it an array as your first argument. The array is given scalar context,
and instead of using the 0th element of the array as the format, Perl will
use the count of elements in the array as the format, which is almost never
useful.

permits these unnecessary but widely-supported conversions:

by 0, 0, 0 and 0 for numbers with the modulus of the
exponent less than 100 is system-dependent: it may be three or less
(zero-padded as necessary).  In other words, 1.23 times ten to the
99th may be either "1.23e99" or "1.23e099".

additional attributes controlling the interpretation of the format.
In order, these are:

will format the next unused argument in the list, but this allows you
to take the arguments out of order:

a plus sign is used to prefix a positive number.

the precision is incremented if it's necessary for the leading "0".

integers, one for each character in the string. Perl applies the format to
each integer in turn, then joins the resulting strings with a separator (a
dot 0 by default). This can be useful for displaying ordinal values of
characters in arbitrary strings:

use to separate the numbers:

the join string using something like 0; for example:

display the given value. You can override the width by putting
a number here, or get the width from the next argument (with 0)
or from a specified argument (e.g., with 0):

effect as the 0 flag: left-justification.

0

width (for string conversions) by specifying a 0 followed by a number.
For floating-point formats except 'g' and 'G', this specifies
how many places right of the decimal point to show (the default being 6).
For example:

including thoe prior to the decimal point and those after it; for
example:

output of the number itself should be zero-padded to this width,
where the 0 flag is ignored:

to fit the specified width:

as having no precision at all.

but it is intended that this will be possible in the future, for
example using 0:

number as using 0, 0, 0, 0, 0, or 0. For integer
conversions (0), numbers are usually assumed to be
whatever the default integer size is on your platform (usually 32 or 64
bits), but you can override this to use instead one of the standard C types,
as supported by the compiler used to build Perl:

your platform.  However, if warnings are enabled, a warning of the
0 warning class is issued on an unsupported conversion flag.
Should you instead prefer an exception, do this:

start running the program, put something like this at its top:

to be the default floating-point size on your platform (double or long double),
but you can force "long double" with 0, 0, or 0 if your
platform supports them. You can find out whether your Perl supports long
doubles via 0:

floating-point size to use on your platform via 0:

compatibility with XS code.  It means "use the standard size for a Perl
integer or floating-point number", which is the default.

format for each format specification. If the format specification
uses 0 to require additional arguments, these are consumed from
the argument list in the order they appear in the format
specification 0 the value to format.  Where an argument is
specified by an explicit index, this does not affect the normal
order for the arguments, even when the explicitly specified index
would have been the next argument.

as the value to format; while:

value to format.

index, the 0 may need escaping:

the character used for the decimal separator in formatted floating-point
numbers is affected by the LC_NUMERIC locale.  See 0
and 0.

0 0 0

0.  Works only for non-negative operands unless you've
loaded the 0 module.

0 0 0

0 can produce a different sequence each time you run your
program.  When called with a parameter, 0 uses that for the seed;
otherwise it (semi-)randomly chooses a seed.  In either case, starting with
Perl 5.14, it returns the seed.

parameter at the first use of the 0 operator.  However, this was not true
of versions of Perl before 5.004, so if your script will run under older
Perl versions, it should call 0; otherwise most programs won't call
0 at all.

want to call 0.  One is for generating predictable results generally for
testing or debugging.  There, you use 0, with the same 0
each time.  Another other case is where you need a cryptographically-strong
starting point rather than the generally acceptable default, which is based on
time of day, process ID, and memory allocation, or the 0 device
if available.  And still another case is that you may want to call 0
after a 0 to avoid child processes sharing the same seed value as the
parent (and consequently each other).

process.  The internal state of the random number generator should
contain more entropy than can be provided by any seed, so calling
0 again actually 0 randomness.

truncate decimal numbers.  This means 0 will usually
produce the same results as 0.  To be safe, always pass
0 an integer.

current 0.  This isn't a particularly good seed, so many old
programs supply their own seed value (often 0 or C<time ^
($$ + ($$ << 15))>), but that isn't necessary any more.

than the default seed.  Checksumming the compressed output of one or more
rapidly changing operating system status programs is the usual method.  For
example:

random number generator modules instead of rolling out your own.

combinations to test comprehensively in the time available to it each run.  It
can test a random subset each time, and should there be a failure, log the seed
used for that run so that it can later be used to reproduce the exact results.

0 0 0

the file opened via FILEHANDLE or DIRHANDLE, or named by EXPR.  If EXPR is
omitted, it stats 0.  Returns the empty list if 0 fails.  Typically
used as follows:

meanings of the fields:

ctime field is non-portable.  In particular, you cannot expect it to be a
"creation time", see 0 for details.

stat is done, but the current contents of the stat structure from the
last 0, 0, or filetest are returned.  Example:

under NFS.)

should mask off the file type portion and (s)printf using a 0
if you want to see the real permissions.

or failure, and, if successful, sets the information associated with
the special filehandle 0.

(0) from the Fcntl module:

Commonly available 0 constants are:

about the 0 constants.  To get status info for a symbolic link
instead of the target file behind the link, use the 0 function.

0

However, those variables will never be reinitialized, contrary to
lexical variables that are reinitialized each time their enclosing block
is entered.

is in effect.  See 0.

0

doing many pattern matches on the string before it is next modified.
This may or may not save time, depending on the nature and number of
patterns you are searching on, and on the distribution of character
frequencies in the string to be searched; you probably want to compare
run times with and without it to see which runs faster.  Those loops
that scan for many short constant strings (including the constant
parts of more complex patterns) will benefit most.  You may have only
one 0 active at a time: if you study a different scalar the first
is "unstudied".  (The way 0 works is this: a linked list of every
character in the string to be searched is made, so we know, for
example, where all the 0 characters are.  From each search string,
the rarest character is selected, based on some static frequency tables
constructed from some C programs and English text.  Only those places
that contain this "rarest" character are examined.)

before any line containing a certain pattern:

will be looked at, because 0 is rarer than 0.  In general, this is
a big win except in pathological cases.  The only question is whether
it saves you more time than it took to build the linked list in the
first place.

runtime, you can build an entire loop as a string and 0 that to
avoid recompiling all your patterns all the time.  Together with
undefining 0 to input entire files as one record, this can be quite
fast, often faster than specialized programs like .  The following
scans a list of files (0) for a list of words (0), and prints
out the names of those files that contain a match:

0

Without a BLOCK it's just a forward declaration.  Without a NAME,
it's an anonymous function declaration, and does actually return
a value: the CODE ref of the closure you just created.

references, and 0 and 0 for more
information about attributes.

0 0 0 0 0

offset 0, or whatever you've set 0 to (but don't do that).
If OFFSET is negative (or more precisely, less than 0), starts
that far from the end of the string.  If LENGTH is omitted, returns
everything to the end of the string.  If LENGTH is negative, leaves that
many characters off the end of the string.

must itself be an lvalue.  If you assign something shorter than LENGTH,
the string will shrink, and if you assign something longer than LENGTH,
the string will grow to accommodate it.  To keep the string the same
length, you may need to pad or chop your value using 0.

string, only the part within the string is returned.  If the substring
is beyond either end of the string,  returns the undefined
value and produces a warning.  When used as an lvalue, specifying a
substring that is entirely outside the string raises an exception.
Here's an example showing the behavior for boundary cases:

replacement string as the 4th argument.  This allows you to replace
parts of the EXPR and return what was there before in one operation,
just as you can with .

a 'magic bullet'; each time it is assigned to, it remembers which part
of the original string is being modified; for example:

unspecified.

0 0 0 0

Returns 0 for success, 0 otherwise.  On systems that don't support
symbolic links, raises an exception.  To check for that,
use eval:

0 0

passing the remaining elements as arguments to the system call.  If
unimplemented, raises an exception.  The arguments are interpreted
as follows: if a given argument is numeric, the argument is passed as
an int.  If not, the pointer to the string value is passed.  You are
responsible to make sure a string is pre-extended long enough to
receive any result that might be written into a string.  You can't use a
string literal (or other read-only string) as an argument to 0
because Perl has to assume that any string pointer might be written
through.  If your
integer arguments are not literals and have never been interpreted in a
numeric context, you may need to add 0 to them to force them to look
like numbers.  This emulates the 0 function (or vice versa):

which in practice should (usually) suffice.

If the system call fails, 0 returns 0 and sets 0 (errno).
Note that some system calls can legitimately return 0.  The proper
way to handle such calls is to assign 0 before the call and
check the value of 0 if syscall returns 0.

number of the read end of the pipe it creates.  There is no way
to retrieve the file number of the other end.  You can avoid this
problem by using 0 instead.

0

with FILEHANDLE.  If FILEHANDLE is an expression, its value is used as
the name of the real filehandle wanted.  This function calls the
underlying operating system's 0 function with the parameters
FILENAME, MODE, PERMS.

system-dependent; they are available via the standard module 0.
See the documentation of your operating system's 0 to see which
values and flag bits are available.  You may combine several flags
using the 0-operator.

read-only mode, 0 for opening the file in write-only mode,
and 0 for opening the file in read-write mode.
0 0 0

supported by Perl: 0 means read-only, 1 means write-only, and 2
means read/write.  We know that these values do 0 work under
OS/390 & VM/ESA Unix and on the Macintosh; you probably don't want to
use them in new code.

it (typically because MODE includes the 0 flag), then the value of
PERMS specifies the permissions of the newly created file.  If you omit
the PERMS argument to 0, Perl uses the octal value 0.
These permission values need to be in octal, and are modified by your
process's current 0.
0

exclusive mode.  This is 0 locking: exclusiveness means here that
if the file already exists,  fails.  0 may not work
on network filesystems, and has no effect unless the 0 flag
is set as well.  Setting 0 prevents the file from
being opened if it is a symbolic link.  It does not protect against
symbolic links in the file's path.
0

can be done using the 0 flag.  The behavior of
0 with 0 is undefined.
0

that takes away the user's option to have a more permissive umask.
Better to omit it.  See the  entry on 0 for more
on this.

On many Unix systems,  is known to fail when file descriptors
exceed a certain value, typically 255. If you need more file
descriptors than that, consider rebuilding Perl to use the 0
library, or perhaps using the POSIX:: function.

0

specified FILEHANDLE, using the .  It bypasses
buffered IO, so mixing this with other kinds of reads, 0,
0, 0, 0, or 0 can cause confusion because the
perlio or stdio layers usually buffers data.  Returns the number of
bytes actually read, 0 at end of file, or undef if there was an
error (in the latter case 0 is also set).  SCALAR will be grown or
shrunk so that the last byte actually read is the last byte of the
scalar after the read.

string other than the beginning.  A negative OFFSET specifies
placement at that many characters counting backwards from the end of
the string.  A positive OFFSET greater than the length of SCALAR
results in the string being padded to the required size with 0
bytes before the result of the read is appended.

well on device files (like ttys) anyway.  Use  and check
for a return value for 0 to decide whether you're done.

characters are read instead of bytes (the LENGTH, OFFSET, and the
return value of  are in Unicode characters).
The 0 layer implicitly introduces the 0 layer.
See 0, 0, and the 0 pragma, 0.

0 0

.  FILEHANDLE may be an expression whose value gives the name
of the filehandle.  The values for WHENCE are 0 to set the new
position to POSITION, 0 to set the it to the current position plus
POSITION, and 0 to set it to EOF plus POSITION (typically
negative).

on characters (for example by using the 0 I/O layer),
 will return byte offsets, not character offsets (because
implementing that would render  unacceptably slow).

than 0, for example  or ) 0, 0,
0, 0, or 0 may cause confusion.

and 0 (start of the file, current position, end of the file)
from the Fcntl module.  Use of the constants is also more portable
than relying on 0, 1, and 2.  For example to define a "systell" function:

of zero is returned as the string 0; thus 0 returns
true on success and false on failure, yet you can still easily determine
the new position.

0 0

done first, and the parent process waits for the child process to
exit.  Note that argument processing varies depending on the
number of arguments.  If there is more than one argument in LIST,
or if LIST is an array with more than one value, starts the program
given by the first element of the list with arguments given by the
rest of the list.  If there is only one scalar argument, the argument
is checked for shell metacharacters, and if there are any, the
entire argument is passed to the system's command shell for parsing
(this is 0 on Unix platforms, but varies on other
platforms).  If there are no shell metacharacters in the argument,
it is split into words and passed directly to 0, which is
more efficient.

output before any operation that may do a fork, but this may not be
supported on some platforms (see 0).  To be safe, you may need
to set 0 ( in English) or call the 0 method
of 0 on any open handles.

0 call.  To get the actual exit value, shift right by eight (see
below). See also 0.  This is 0 what you want to use to capture
the output from a command, for that you should use merely backticks or
0, as described in 0.  Return value of -1
indicates a failure to start the program or an error of the  system
call (inspect $! for the reason).

have a look at the 0 pragma.

you use the 0 syntax.  Again, see 0.

0, if you expect your program to terminate on receipt of these
signals you will need to arrange to do so yourself based on the return
value.

possible failure modes by inspecting 0 like this:

with the 0 calls from the POSIX module.

results and return codes are subject to its quirks.
See 0 and 0 for details.

handler. See 0 for details.

0

specified FILEHANDLE, using .  If LENGTH is
not specified, writes whole SCALAR.  It bypasses buffered IO, so
mixing this with reads (other than 0, 0, 0,
0, 0, or 0 may cause confusion because the perlio and
stdio layers usually buffers data.  Returns the number of bytes
actually written, or 0 if there was an error (in this case the
errno variable 0 is also set).  If the LENGTH is greater than the
data available in the SCALAR after the OFFSET, only as much data as is
available will be written.

string other than the beginning.  A negative OFFSET specifies writing
that many characters counting backwards from the end of the string.
If SCALAR is of length zero, you can only use an OFFSET of 0.

encoded in UTF-8 are written instead of bytes, and the LENGTH, OFFSET, and
return value of  are in (UTF-8 encoded Unicode) characters.
The 0 layer implicitly introduces the 0 layer.
See 0, 0, and the 0 pragma, 0.

0

error.  FILEHANDLE may be an expression whose value gives the name of
the actual filehandle.  If FILEHANDLE is omitted, assumes the file
last read.

operate on characters (for example by using the 0 open
layer),  will return byte offsets, not character offsets (because
that would render  and  rather slow).

depends on the operating system: it may return -1 or something else.
 on pipes, fifos, and sockets usually returns -1.

that has been manipulated by ,  or .
Those functions ignore the buffering, while  does not.

0

Value may be given to 0 to access a particular location in a
directory.  0 has the same caveats about possible directory
compaction as the corresponding system library routine.

0

implementation for the variable.  VARIABLE is the name of the variable
to be enchanted.  CLASSNAME is the name of a class implementing objects
of correct type.  Any additional arguments are passed to the 0
method of the class (meaning 0, 0, 0,
or 0).  Typically these are arguments such as might be passed
to the 0 function of C.  The object returned by the 0
method is also returned by the 0 function, which would be useful
if you want to access other methods in CLASSNAME.

when used on large objects, like DBM files.  You may prefer to use the
0 function to iterate over such.  Example:

0, 0, 0, and 0.

for you; you need to do that explicitly yourself.  See 0
or the 0 module for interesting 0 implementations.

0

that was originally returned by the 0 call that bound the variable
to a package.)  Returns the undefined value if VARIABLE isn't tied to a
package.

0 0

considers to be the epoch, suitable for feeding to 0 and
0. On most systems the epoch is 00:00:00 UTC, January 1, 1970;
a prominent exception being Mac OS Classic which uses 00:00:00, January 1,
1904 in the current local time zone for its epoch.

you may use either the 0 module (from CPAN, and starting from
Perl 5.8 part of the standard distribution), or if you have
, you may be able to use the 0 interface of Perl.
See 0 for details.

For a comprehensive date and time representation look at the
0 module.

0

seconds, for this process and the children of this process.

0.

0

specified length.  Raises an exception if truncate isn't implemented
on your system.  Returns true if successful, the undefined value
otherwise.

file.

call 0 before writing to the file.

0 0 0

implementing the 0 escape in double-quoted strings.
It does not attempt to do titlecase mapping on initial letters.  See
0 for that.

as 0 does.

0 0

(titlecase in Unicode).  This is the internal function implementing
the 0 escape in double-quoted strings.

as 0 does.

0

If EXPR is omitted, merely returns the current umask.

bits, or three octal digits: 0 (the leading 0 indicates octal
and isn't one of the digits).  The 0 value is such a number
representing disabled permissions bits.  The permission (or "mode")
values you pass 0 or 0 are modified by your umask, so
even if you tell 0 to create a file with permissions 0,
if your umask is 0 then the file will actually be created with
permissions 0.  If your 0 were 0 (group can't
write; others can't read, write, or execute), then passing
0 0 would create a file with mode 0 (0 is 0).

files (in 0) and one of 0 for directories (in
0) and executable files.  This gives users the freedom of
choice: if they want protected files, they might choose process umasks
of 0, 0, or even the particularly antisocial mask of 0.
Programs should rarely if ever make policy decisions better left to
the user.  The exception to this is when writing files that should be
kept private: mail files, web browser cookies, 0 files, and
so on.

restrict access for 0 (i.e., ),
raises an exception.  If  is not implemented and you are
not trying to restrict access for yourself, returns 0.

string of octal digits.  See also 0, if all you have is a string.

0 0

scalar value, an array (using 0), a hash (using 0), a subroutine
(using 0), or a typeglob (using 0).  Saying 0
will probably not do what you expect on most predefined variables or
DBM list values, so don't do that; see 0.  Always returns the
undefined value.  You can omit the EXPR, in which case nothing is
undefined, but you still get an undefined value that you could, for
instance, return from a subroutine, assign to a variable, or pass as a
parameter.  Examples:

0 0 0 0 0

it successfully deleted. On failure, it returns false and sets 0
(errno):

If you want to know which files you could not remove, try them one
at a time:

superuser and the 0 flag is supplied to Perl. Even if these
conditions are met, be warned that unlinking a directory can inflict
damage on your filesystem.  Finally, using 0 on directories is
not supported on many operating systems.  Use 0 instead.

0

and expands it out into a list of values.
(In scalar context, it returns merely the first value produced.)

See 0 for an introduction to this function.

is converted separately to a value.  Typically, either the string is a result
of 0, or the characters of the string represent a C structure of some
kind.

Here's a subroutine that does substring:

a %<number> to indicate that
you want a <number>-bit checksum of the items instead of the items
themselves.  Default is a 16-bit checksum.  Checksum is calculated by
summing numeric values of expanded values (for string fields the sum of
0 is taken, for bit fields the sum of zeroes and ones).

computes the same number as the System V sum program:

has no way of checking whether the value passed to 0
corresponds to a valid memory location, passing a pointer value that's
not known to be valid is likely to have disastrous consequences.

is larger than what the remainder of the input string allows, the result
is not well defined: the repeat count may be decreased, or
0 may produce empty strings or zeros, or it may raise an exception.
If the input string is longer than one described by the TEMPLATE,
the remainder of that input string is ignored.

0

Has no effect if the variable is not tied.

0

depending on how you look at it.  Prepends list to the front of the
array, and returns the new number of elements in the array.

prepended elements stay in the same order.  Use 0 to do the
reverse.

a reference to an unblessed array.  The argument will be dereferenced
automatically.  This aspect of 0 is considered highly
experimental.  The exact behaviour may change in a future version of Perl.

0 0 0

generally by aliasing certain subroutine or variable names into your
package.  It is exactly equivalent to

decimal fraction such as 5.006, which will be compared to 0, or a v-string
of the form v5.6.1, which will be compared to 0 (aka ).  An
exception is raised if VERSION is greater than the version of the
current Perl interpreter; Perl will not attempt to parse the rest of the
file.  Compare with 0, which can do a similar check at run time.
Symmetrically, 0 allows you to specify that you want a version
of Perl older than the specified one.

avoided, because it leads to misleading error messages under earlier
versions of Perl (that is, prior to 5.6.0) that do not support this
syntax.  The equivalent numeric version should be used instead.

0ing library modules that won't work with older versions of Perl.
(We try not to do this more than we have to.)

0 will also load the 0 pragma and enable all
features available in the requested version.  See 0.
Similarly, if the specified Perl version is greater than or equal to
5.11.0, strictures are enabled lexically as with 0 (except
that the 0 file is not actually loaded).

0 makes sure the module is loaded into memory if it hasn't been
yet.  The 0 is not a builtin; it's just an ordinary static method
call into the 0 package to tell the module to import the list of
features back into the current package.  The module can implement its
0 method any way it likes, though most modules just choose to
derive their 0 method via inheritance from the 0 class that
is defined in the 0 module.  See 0.  If no 0
method can be found then the call is skipped, even if there is an AUTOLOAD
method.

to stop your namespace from being altered), explicitly supply the empty list:

0 will call the VERSION method in class Module with the given
version as an argument.  The default VERSION method, inherited from
the UNIVERSAL class, croaks if the given version is larger than the
value of the variable 0.

with no arguments) and an explicit empty LIST 0 (0 not
called).  Note that there is no comma after VERSION!

are also implemented this way.  Currently implemented pragmas are:

block scope (like 0 or 0, unlike ordinary modules,
which import symbols into the current package (which are effective
through the end of the file).

ordinary flow control of the code being compiled.  In particular, putting
a 0 inside the false branch of a conditional doesn't prevent it
from being processed.  If a module or pragma only needs to be loaded
conditionally, this can be done using the 0 pragma:

by 0, i.e., it calls 0 instead of 0.
It behaves just as 0 does with VERSION, an omitted or empty LIST,
or no unimport method being found.

0 meant to be used to assert that the running perl is of a earlier
version than its argument and 0 to undo the feature-enabling side effects
of 0.

for the 0 and 0 command-line options to Perl that give 0
functionality from the command-line.

0

files.  The first two elements of the list must be the NUMERICAL access
and modification times, in that order.  Returns the number of files
successfully changed.  The inode change time of each file is set
to the current time.  For example, this code has the same effect as the
Unix  command when the files 0 and belong to
the user running the program:

the  syscall from your C library is called with a null second
argument. On most systems, this will set the file's access and
modification times to the current time (i.e., equivalent to the example
above) and will work even on files you don't own provided you have write
permission:

the local machine.  If there is a time synchronization problem, the
NFS server and local machine will have different times.  The Unix
 command will in fact normally use this form instead of the
one shown in the first example.

equivalent to passing a 0 and will not have the effect
described when both are 0.  This also triggers an
uninitialized warning.

files.  On systems that don't support , passing filehandles raises
an exception.  Filehandles must be passed as globs or glob references to be
recognized; barewords are considered filenames.

0

of an array. (In a scalar context, returns the number of values.)

random order is subject to change in future versions of Perl, but it
is guaranteed to be the same order as either the 0 or 0
function would produce on the same (unmodified) hash.  Since Perl
5.8.1 the ordering is different even between different runs of Perl
for security reasons (see 0).

iterator,
see 0. (In particular, calling  in void context resets
the iterator with no other overhead. Apart from resetting the iterator,
0 in list context is the same as plain 0.
We recommend that you use void context 0 for this, but reasoned
that it taking 0 out would require more documentation than
leaving it in.)

modify the contents of the hash:

a reference to an unblessed hash or array.  The argument will be
dereferenced automatically.  This aspect of 0 is considered highly
experimental.  The exact behaviour may change in a future version of Perl.

0 0 0

width BITS, and returns the value of the element specified by OFFSET
as an unsigned integer.  BITS therefore specifies the number of bits
that are reserved for each element in the bit vector.  This must
be a power of two from 1 to 32 (or 64, if your platform supports
that).

of size BITS/8, and each group is converted to a number as with
/ with big-endian formats 0/0 (and analogously
for BITS==64).  See 0 for details.

of each byte are broken into 8/BITS groups.  Bits of a byte are
numbered in a little-endian-ish way, as in 0, 0,
0, 0, 0, 0, 0, 0.  For example,
breaking the single input byte 0 into two groups gives a list
0; breaking it into 4 groups gives 0.

to give the expression the correct precedence as in

If an element off the end of the string is written to, Perl will first
extend the string with sufficiently many zero bytes.   It is an error
to try to write off the beginning of the string (i.e., negative OFFSET).

the UTF8 flag set), this is ignored by 0, and it operates on the
internal byte string, not the conceptual character string, even if you
only have characters with values less than 256.

operators 0, 0, 0, and 0.  These operators will assume a bit
vector operation is desired when both operands are strings.
See 0.

The comments show the string after each step.  Note that this code works
in the same way on big-endian or little-endian machines.

example above should print the following table:

0

process to terminate and returns the pid of the deceased process, or
0 if there are no child processes.  The status is returned in 0
and 0.
Note that a return value of 0 could mean that child processes are
being automatically reaped, as described in 0.

child created by  or . See 0 for details.

0

the deceased process, or 0 if there is no such child process.  On some
systems, a value of 0 indicates that there are processes still running.
The status is returned in 0 and 0.  If you say

Non-blocking wait is available on machines supporting either the
 or  syscalls.  However, waiting for a particular
pid with FLAGS of 0 is implemented everywhere.  (Perl emulates the
system call by remembering the status values of processes that have
exited but have not been harvested by the Perl script yet.)

processes are being automatically reaped.  See 0 for details,
and for other examples.

0 0

0 is looking for a list value.  Returns false if the context is
looking for a scalar.  Returns the undefined value if the context is
looking for no value (void context).

in a 0, 0, 0, 0 or 0 block, or
in a 0 method.

0 0 0

not end in a newline, it appends the same file/line number text as 0
does.

previous eval) that value is used after appending 0
to 0.  This is useful for staying almost, but not entirely similar to
0.

installed.  It is the handler's responsibility to deal with the message
as it sees fit (like, for instance, converting it into a 0).  Most
handlers must therefore arrange to actually display the
warnings that they are not prepared to deal with, by calling 0
again in the handler.  Note that this is quite safe and will not
produce an endless loop, since 0 hooks are not called from
inside one.

0 handlers (which don't suppress the error text, but can
instead call 0 again to change it).

warnings (even the so-called mandatory ones).  An example:

examples.  See the Carp module for other kinds of warnings using its
 and  functions.

0

using the format associated with that file.  By default the format for
a file is the one having the same name as the filehandle, but the
format for the current output channel (see the 0 function) may be set
explicitly by assigning the name of the format to the 0 variable.

insufficient room on the current page for the formatted record, the
page is advanced by writing a form feed, a special top-of-page format
is used to format the new page header, and then the record is written.
By default the top-of-page format is the name of the filehandle with
"_TOP" appended, but it may be dynamically set to the format of your
choice by assigning the name to the 0 variable while the filehandle is
selected.  The number of lines remaining on the current page is in
variable 0, which can be set to 0 to force a new page.

channel, which starts out as STDOUT but may be changed by the
0 operator.  If the FILEHANDLE is an EXPR, then the expression
is evaluated and the resulting string is used to look up the name of
the FILEHANDLE at run time.  For more on formats, see 0.

0.

=encoding utf8

Consistent formatting of this file is achieved with:

just interested in working on a quick patch, see 0 first.
This document is intended for people who are regular contributors to
Perl, including those with write access to the git repository.

0.

clone via http, though this is much slower:

it. After a clone the repository will contain a single local branch,
which will be the current branch as well, as indicated by the asterisk.

branches in the repository:

that you cloned from (which is named "origin"). Each branch on the
remote will be exactly tracked by theses branches. You should NEVER do
work on these remote tracking branches. You only ever do work in a
local branch. Local branches can be configured to automerge (on pull)
from a designated remote tracking branch. This is the case with the
default branch 0 which will be configured to merge from the
remote tracking branch 0.

repository (must be clean first)

command would be more or less equivalent to:

your working directory you do:

remotes simultaneously you can do

however both will update the remote-tracking branches in your
repository.

of the repository, including modified files and unignored untracked
files, and in addition it will show things like what files have been
staged for the next commit, and usually some useful information about
how to change things. For instance the following:

and that there were further changes in the working directory not yet
staged. It also shows that there was an untracked file in the working
directory, and as you can see shows how to change all of this. It also
shows that there is one commit on the working branch 0 which has
not been pushed to the 0 remote yet. 0: that this output
is also what you see as a template if you do not provide a message to
0.

That document covers many details on how to create a good patch.

the 0 branch, and your repository is up to date:

is where new development occurs for all changes other than critical bug
fixes. Critical bug fix patches should be made against the relevant
maint branches, or should be submitted with a note indicating all the
branches where the fix should be applied.

new branch for these changes and switch into it:

or merge back into the master blead for a more linear history. If you
don't work on a topic branch the maintainer has to manually cherry pick
your changes onto blead before they can be applied.

to Orange Brocard, we should change his name in the AUTHORS file:

have changed. If at this time, you only want to commit some of the
files you have worked on, you can omit the 0 and use the command
C<S<git add 0 before doing the commit. C<0 allows you to even just commit portions of files
instead of all the changes in them.

git will open a text editor for you to compose the message
interactively. This is useful when the changes are more complex than
the sample given here, and, depending on the editor, to know that the
first line of the commit message doesn't exceed the 50 character legal
maximum.

editor, git will write your change to disk and tell you something like
this:

it carefully, many questions are answered directly by the git status
output.

itself you can fix it up by editing the files once more and then issue:

0 with a description of your
changes, and include this patch file as an attachment. In addition to
being tracked by RT, mail to perlbug will automatically be forwarded to
perl5-porters (with manual moderation, so please be patient). You
should only send patches to
0 directly if the
patch is not ready to be applied, but intended for discussion.

emails for you.

single atomic unit, run this command:

New files aren't automatically added to your commit when you use
0 If you want to add files or to commit some, but not all of
your changes, have a look at the documentation for 0.)

commit message for your change. See 0 for more
information about what makes a good commit message.

editor, git will write your change to disk and tell you something like
this:

it carefully, many questions are answered directly by the git status
output.

should be sent.

tracker:

email service provider. For example, to set your global git config to
send email via a gmail account:

when you run 'git send-email'. You can also configure
0 with your password if you don't care about having
your password in the .gitconfig file.

patching them, because git won't see the changes to them, and the build
process will overwrite them. Patch the originals instead. Most
utilities (like perldoc) are in this category, i.e. patch
0 rather than 0. Similarly, don't
create patches for files under /ext from their copies found in
/lib. If you are unsure about the proper location of a
file that may have gotten copied while building the source
distribution, consult the 0.

replacement for 0 and give it a list of files to be reverted, or 0 to revert them all.

the history, which commit should be blamed for introducing a given bug.

when some behaviour is correct, and with 0 when it's faulty. You
need an helper script that automates building 0 and running the
testcase:

should be skipped. Otherwise, it returns the status of
0.

0 will learn about this when you enter:

0. You can then run the bisecting process with:

0. 0 will get you out of bisect
mode.

first 0 state. If you want to search for the commit that 0
some bug, you have to negate your test case (i.e. exit with 0 if OK
and 0 if not) and still mark the lower bound as 0 and the
upper as 0. The "first bad commit" has then to be understood as
the "first commit where the bug is solved".

binary searches.
=head1 Topic branches and rewriting history

0/0. Other committers should check
with a topic branch's creator before making any change to it.

versions of git is to push the current head as a new branch on the
remote, then check it out locally:

might sometimes find that the original author has edited the branch's
history. There are lots of good reasons for this. Sometimes, an author
might simply be rebasing the branch onto a newer source point.
Sometimes, an author might have found an error in an early commit which
they wanted to fix before merging the branch to blead.

non-fast-forward merges. This means that the branches within can not be
rebased and pushed as a single step.

of a pushed branch is to delete it and push it as a new branch under
the same name. Please think carefully about doing this. It may be
better to sequentially rename your branches so that it is easier for
others working with you to cherry-pick their local changes onto the new
version. (XXX: needs explanation).

your existing topic branch and push as a new version of it. You can do
this via the following formula (see the explanation about 0's
in the git push documentation for details) after you have rebased your
branch:

"primary" branches. That is any branch matching
0. Any attempt to do so will result in git
producing an error like this:

maint-* branches. If a typo (or worse) sneaks into a commit to blead or
maint-*, we'll fix it in another commit. The only types of updates
allowed on these branches are "fast-forward's", where all history is
preserved.

deleted or modified. Think long and hard about whether you want to push
a local tag to perl.git before doing so. (Pushing unannotated tags is
not allowed.)

conversion: a merge was recorded in the history between blead and
maint-5.10 where no merge actually occurred. Due to the nature of git,
this is now impossible to fix in the public repository. You can remove
this mis-merge locally by adding the following line to your
0 file:

is done in the area of the "merge" in question.

0/0. Other committers should check
with a topic branch's creator before making any change to it.

versions of git is to push the current head as a new branch on the
remote, then check it out locally:

might sometimes find that the original author has edited the branch's
history. There are lots of good reasons for this. Sometimes, an author
might simply be rebasing the branch onto a newer source point.
Sometimes, an author might have found an error in an early commit which
they wanted to fix before merging the branch to blead.

non-fast-forward merges. This means that the branches within can not be
rebased and pushed as a single step.

of a pushed branch is to delete it and push it as a new branch under
the same name. Please think carefully about doing this. It may be
better to sequentially rename your branches so that it is easier for
others working with you to cherry-pick their local changes onto the new
version. (XXX: needs explanation).

your existing topic branch and push as a new version of it. You can do
this via the following formula (see the explanation about 0's
in the git push documentation for details) after you have rebased your
branch:

"primary" branches. That is any branch matching
0. Any attempt to do so will result in git
producing an error like this:

maint-* branches. If a typo (or worse) sneaks into a commit to blead or
maint-*, we'll fix it in another commit. The only types of updates
allowed on these branches are "fast-forward's", where all history is
preserved.

deleted or modified. Think long and hard about whether you want to push
a local tag to perl.git before doing so. (Pushing unannotated tags is
not allowed.)

origin remote to enable pushing. Edit 0 with the
git- command:

this once globally in their 0 by doing something like:

execute something like the following in 0:

remote for ssh access:

0, which is faster and doesn't require you to authenticate, and
to push your changes back with the 0 remote:

themselves should have been fetched when pulling from 0.
=head1 Accepting a patch

you should try out the patch.

switch into it:

0 for details.

test file. You'd be wrong. Here's an example of where not running the
suite caused problems. A patch was submitted that added a couple of
tests to an existing .t. It couldn't possibly affect anything else, so
no need to test beyond the single affected .t, right?  But, the
submitter's email address had changed since the last of their
submissions, and this caused other tests to fail. Running the test
target given in the next item would have caught this problem.

This will run basic sanity checks. To see which sanity checks, have a
look in 0.

different code paths for miniperl, be sure to run 0.
This will catch problems that even the full test suite will not catch
because it runs a subset of tests under miniperl rather than perl.

see 0.

tracking branch:

remote branch 0. Then you can pull, commit, merge
and push as before.

using the 0 command. It is recommended to use the
0 option to 0 in order to record the SHA1 of the
original commit in the new commit message.

satisfied the steps in 0 above.

conversion: a merge was recorded in the history between blead and
maint-5.10 where no merge actually occurred. Due to the nature of git,
this is now impossible to fix in the public repository. You can remove
this mis-merge locally by adding the following line to your
0 file:

is done in the area of the "merge" in question.

will still happen. Here is a guide to merging patches from a GitHub
repository.

0. One is 0 itself (0),
which is the 'master' repository. The second one is
0 (0), which can be used for
general testing and development. Dromedary syncs the git tree from
camel every few minutes, you should not push there. Both machines also
have a full CPAN mirror in /srv/CPAN, please use this. To share files
with the general public, dromedary serves your ~/public_html/ as
0

rsync, ssh and git are allowed. For http and ftp, you can use
http://webproxy:3128 as proxy. Incoming, the firewall tries to detect
attacks and blocks IP addresses with suspicious activity. This
sometimes (but very rarely) has false positives and you might get
blocked. The quickest way to get unblocked is to notify the admins.

reach the sysadmins in #p5p on irc.perl.org or via mail to
0. 

=encoding utf8

Other useful sources include the Free On-Line Dictionary of Computing
0, the Jargon File
0, and Wikipedia 0.

state (its 0).

or 0 when you call it.  For instance, when you call
0, the string 0 is the actual argument.  See
also 0 and 0.

this can be like playing with fire.  Perl provides a set of asbestos
gloves for handling all memory management.  The closest to an address
operator in Perl is the backslash operator, but it gives you a 0, which is much safer than a memory address.

computer could do them.

used the original name instead of the nickname.  Temporary aliases are
implicitly created in the loop variable for 0 loops, in the
0 variable for 0 or 0
operators, in 0 and 0 during 0's
comparison function, and in each element of 0 for the 0 of a subroutine call.  Permanent aliases are explicitly
created in 0 by 0 symbols or by
assignment to 0.  Lexically scoped aliases for
package variables are explicitly created by the 0
declaration.

"Would you like door A, B, or C?"  Alternatives in regular expressions
are separated with a single vertical bar: 0.  Alternatives in
normal Perl expressions are separated with a double vertical bar:
0.  Logical alternatives in 0 expressions are separated
with either 0 or 0.

through a named 0.  Such a referent must be indirectly
accessible through at least one 0.  When the last
hard reference goes away, the anonymous referent is destroyed without
pity.

means all those computers sharing a compatible machine language.
Since Perl programs are (typically) simple text files, not executable
images, a Perl program is much less sensitive to the architecture it's
running on than programs in other languages, such as C, that are
compiled into machine code.  See also 0 and 0.

0, 0, or 0 to tell it what it's
supposed to do.  Also called a "parameter".

command line.  If you use the empty  operator, 0 is
the name of both the 0 used to traverse the arguments and
the 0 containing the name of the current input file.

you were supposed to learn in grade school.

easily access any of the values using an integer 0
that specifies the value's 0 in the sequence.

0.

character set adequate only for poorly representing English text).
Often used loosely to describe the lowest 128 values of the various
ISO-8859-X character sets, a bunch of mutually incompatible 8-bit
codes sometimes described as half ASCII.  See also 0.

pattern to match but does not necessarily match any characters itself.
Often used specifically to mean a 0 assertion.

of a 0.

of an ordinary assignment and some other operator, that changes the
value of a variable in place, that is, relative to its old value.  For
example, 0 adds 0 to 0.

0 first when you have "A 0 B 0 C" and
the two operators are of the same precedence.  Operators like 0 are
left associative, while operators like 0 are right associative.
See 0 for a list of operators and their associativity.

indeterminate because too many things are going on at once.  Hence, an
asynchronous event is one you didn't know when to expect.

0 containing one or more characters and treated as an
indivisible syntactic unit by any following 0.  (Contrast
with an 0 that matches something of 0 and may
not be quantified.)

matter, he meant literally something that could not be cut: 0
(not) + 0 (cuttable).  An atomic operation is an action that
can't be interrupted, not one forbidden in a nuclear-free zone.

and 0 with modifiers as in 0.  Also, another name for an 0 of an
0.

the behavior of certain 0 can be reasonably
deduced using more fundamental operators.  This assumes that the
overloaded operators will often have the same relationships as the
regular operators.  See 0.

operator.  To instead subtract one from something automatically is
known as an "autodecrement".

call an 0 subroutine on behalf of an
undefined subroutine.

running under 0 or 0 in order to emulate 0.  (See also
the 0 module, which has nothing to do with the 0
switch, but a lot to do with autoloading.)

storage locations (0) spontaneously generate
themselves as needed, including the creation of any 0
values to point to the next level of storage.  The assignment
0 potentially creates five scalar
storage locations, plus four references (in the first four scalar
locations) pointing to four new anonymous arrays (to hold the last
four scalar locations).  But the point of autovivification is that you
don't have to worry about it.

types that holds an 0.  The 0 type is a subclass of
0.

refers to a venerable text-processing language from which Perl derived
some of its high-level ideas.

unadorned parentheses in a 0, also referred to as a capture group.  The
sequences (0, 0, etc.)  later in the same pattern refer back to
the corresponding subpattern in the current match.  Outside the pattern,
the numbered variables (0, 0, etc.) continue to refer to these
same values, as long as the pattern was the last successful match of
the current dynamic scope.  0 can be used to refer to a group by
relative rather than absolute position; and groups can be also be named, and
referred to later by name rather than number.  See 0.

differently," and then actually going back and doing it all over
differently.  Mathematically speaking, it's returning from an
unsuccessful recursion on a tree of possibilities.  Perl backtracks
when it attempts to match patterns with a 0, and
its earlier attempts don't pan out.  See 0.  In the absence of that stricture, a
bareword is treated as if quotes were around it.

specific classes are derived genetically by 0.  Also
called a "superclass" by people who respect their ancestors.

computers that store the most significant 0 of a word at a
lower byte address than the least significant byte.  Often considered
superior to little-endian machines.  See also 0.

basically two numbers, 0 and 1.  Also used to describe a "non-text
file", presumably because such a file makes full use of all the binary
bits in its bytes.  With the advent of 0, this distinction,
already suspect, loses even more of its meaning.

unit of information storage.  An eighth of a 0 or of a dollar.
(The term "Pieces of Eight" comes from being able to split the old
Spanish dollar into 8 bits, each of which still counted for money.
That's why a 25-cent piece today is still "two bits".)

effect of multiplying or dividing by a power of 2.

sequence of bits, for once.

VP of Engineering has blessed our WebCruncher project." Similarly in
Perl, to grant official approval to a 0 so that it can
function as an 0, such as a WebCruncher object.  See
0.

blocked waiting for the disk."  As an unrelated noun, it refers to a
large chunk of data, of a size that the 0 likes to
deal with (normally a power of two such as 512 or 8192).  Typically
refers to a chunk of data that's coming from or going to a disk file.

0 that is delimited by braces.  The 0 and
0 statements are defined in terms of 0, for instance.
Sometimes we also say "block" to mean a lexical scope; that is, a
sequence of statements that act like a 0, such as within an
0 or a file, even though the statements aren't
delimited by braces.

at a time.  By default, Perl does block buffering to disk files.  See
0 and 0.

whether the 0 returned by an expression is 0 or
0.  Does not evaluate as either a string or a number.  See
0.

0 means that the data is passed on to its destination
whenever the buffer is full.  0 means
that it's passed on whenever a complete line is received.  0 means that it's passed every time you do
a 0 command (or equivalent).  If your output is
unbuffered, the system processes it one byte at a time without the use
of a holding area.  This can be rather inefficient.

by 0, you can always get at a built-in function by
0 its name with the 0 pseudo-package.

group of command-line switches grouped into one 0.)

reveal their orientation (see 0).  Named after some similar
languages spoken (for similar reasons) between compilers and
interpreters in the late 20th century.  These languages are
characterized by representing everything as a
non-architecture-dependent sequence of bytes.

inscrutable 0 rules, and heavy 0 of the
function-call mechanism.  (Well, actually, people first switched to C
because they found lowercase identifiers easier to read than upper.)
Perl is written in C, so it's not surprising that Perl borrowed a few
ideas from it.

with 0 for conditional compilation and macro definition and does
various manipulations of the program text based on the current
definitions.  Also known as .

refer directly to the 0, and the 0 can
change the actual arguments by changing the formal arguments.  That
is, the formal argument is an 0 for the actual argument.  See
also 0.

refer to a copy of the 0, and the 0
cannot change the actual arguments by changing the formal arguments.
See also 0.

in the hope that the other part of your program will 0 your
handler when some event of interest transpires.

a 0 to store the matched 0 as a 0
or 0.
(Captured strings are also returned as a list in 0.)

Historically, characters were usually stored as fixed-width integers
(typically in a byte, or maybe two, depending on the character set),
but with the advent of UTF-8, characters are often stored in a
variable number of bytes depending on the size of the integer that
represents the character.  Perl manages this transparently for you,
for the most part.

to indicate that any character of the set may occur at a given point.
Loosely, any predefined set of characters so used.

0.  Many standard properties are defined for 0.

operator, or parentheses, or a hug.

provides (either directly or by inheritance) 0 (that
is, 0) to handle 0 of
the class (its 0).  See also 0.

0.

at run time, keeps track of the identities of externally visible
0 even after those lexical
variables have supposedly gone out of 0 into a single 0.

it to a reference to a subroutine.  See also 0.

code to implement the backend of a compiler.  See 0.

0 is almost certainly at the zeroth position in all character
sets, so its code point is 0.  The code point for the 0
character in the ASCII character set is 0x20, or 32 decimal; in EBCDIC
it is 0x40, or 64 decimal.  The 0 function returns
the code point of a character.

some Perl code, for example, the 0 and 0
subpatterns.

0 comparison routines to decide, for example, where in this
glossary to put "collating sequence".

and its arguments.  More loosely, anything you type to a shell (a
command interpreter) that starts it doing something.  Even more
loosely, a Perl 0, which might start with a 0 and
typically ends with a semicolon.

0 and then flush it out as a single request to the
0.  It's enabled by setting the 0
(0) variable to a true value.  It's used when you don't
want data sitting around not going where it's supposed to, which may
happen because the default on a 0 or 0 is to use
0.

line.  In C, the 0 name is passed to the program as the
first command-line argument.  In Perl, it comes in separately as
0.

tell a 0 to execute a 0.  These values are passed to
a Perl program through 0.

comment is introduced by a 0 character and continues to the end of
the line.

that is currently being compiled.

0.  Compile phase is mostly spent in 0, but
may also be spent in 0 when 0 blocks,
0 declarations, or constant subexpressions are being
evaluated.  The startup and import code of any 0
declaration is also run during compile phase.

when it thinks it knows what your code means and is merely trying to
do what it thinks your code says to do, which is 0.

out yet another file containing the program in a "more executable"
form, typically containing native machine instructions.  The 0
program is not a compiler by this definition, but it does contain a
kind of compiler that takes a program and turns it into a more
executable form (0) within the 0
process itself, which the 0 then interprets.  There are,
however, extension 0 to get Perl to act more like a
"real" compiler.  See 0.

like an anonymous array or a hash (or a sonata, for that matter).  For
example, a pair of braces acts as a composer for a hash, and a pair of
brackets acts as a composer for an array.  See 0.

similar operation on two 0.

and the callee's phone.  In networking, the same kind of temporary
circuit between a 0 and a 0.

transitive verb, to create an 0 using a 0.

that composes, initializes, blesses, and returns an 0.
Sometimes we use the term loosely to mean a 0.

surrounding code determines what kind of data a particular
0 is expected to return.  The three primary contexts are
0, 0, and 0.  Scalar
context is sometimes subdivided into 0, 0, 0, and 0.  There's also a
"don't care" scalar context (which is dealt with in Programming Perl,
Third Edition, Chapter 2, "Bits and Pieces" if you care).

line.  0 lines are continued by putting a backslash before
the 0.  Mail headers as defined by RFC 822 are continued by
putting a space or tab 0 the newline.  In general, lines in
Perl do not need any form of continuation mark, because 0
(including newlines) is gleefully ignored.  Usually.

0 of the process, usually as a result of certain
kinds of fatal error.

true 0 or only a 0.

backwards in the text of your program through the current 0 or any enclosing lexical scopes till you find
a package declaration.  That's your current package name.

; 0, if no filehandle
has been selected.

type is a subclass of 0.

or 0 conditional.  C allows them.  Perl doesn't.

they make when you put them all together, as in a rectangular table or
a triangular-shaped tree.

how to deal with those values.  For example, a numeric data type has a
certain set of numbers that you can work with and various mathematical
operations that you can do on the numbers but would make little sense
on, say, a string such as 0.  Strings have their own
operations, such as 0.  Compound types made of a
number of smaller pieces generally have operations to compose and
decompose them, and perhaps to rearrange them.  0
that model things in the real world often have operations that
correspond to real activities.  For instance, if you model an
elevator, your elevator object might have an 0
0.

of the programs involved) can be sent independently over the network.
(In fact, all packets are sent independently at the 0 level, but
0 protocols such as 0 hide this from your program.)

emulate an 0 using disk files.  The routines use a
dynamic hashing scheme to locate any entry with only two disk
accesses.  DBM files allow a Perl program to keep a persistent
0 across multiple invocations.  You can 0
your hash variables to various DBM implementations--see 0
and 0.

what it's like, without giving any commitment as to how or where
you'll use it.  A declaration is like the part of your recipe that
says, "two cups flour, one large egg, four or five tadpoles..."  See
0 for its opposite.  Note that some declarations also
function as statements.  Subroutine declarations also act as
definitions if a body is supplied.

to remove 1 from its value) or "decrement 0 by 3".

do are devoid of meaning, in particular, making use of variables that
have never been given a 0 and performing certain operations on
data that isn't there.  For example, if you try to read data past the
end of a file, Perl will hand you back an undefined value.  See also
0 and 0.

textual object, not to be confused with a 0 or
0.  "To delimit" really just means "to surround" or "to
enclose" (like these parentheses are doing).

release, but later found to be subtly flawed, and which should be avoided.
They are subject to removal and/or bug-incompatible reimplementation in
the next major release (but they will be preserved through maintenance
releases).  Deprecation warnings are issued under 0 or 0, and notices are found in 0s, as well as various
other PODs. Coding practices that misuse features, such as 0, can also be deprecated.

what it points to".  The "de" part of it refers to the fact that
you're taking away one level of 0.

more generic class, called a 0.  Note that classes aren't
classified exclusively into base classes or derived classes: a class
can function as both a derived class and a base class simultaneously,
which is kind of classy.

0 method, if it has one).

about 0 itself.  A Perl program's 0
method doesn't do the actual destruction; Perl just
0 the method in case the 0 wants to do any
associated cleanup.

joystick or a mouse) attached to your computer, that the 0 tries to make look like a 0 (or a bunch of files).
Under Unix, these fake files tend to live in the 0 call these "folders", "drawers", or
"catalogs".

read it, until you close it.  See the 0
function.

metaphorically to indicate a transfer of programmatic control to a
destination selected algorithmically, often by lookup in a table of
function 0 or, in the case of object
0, by traversing the inheritance tree looking for the
most specific definition for the method.

usage implies source code is included.  If that is not the case, it
will be called a "binary-only" distribution.

included, which have now fallen out of common use.  It has been suggested
that these modules should be removed, since the distribution became rather
large, and the common criterion for new module additions is now limited to
modules that help to build, test, and extend perl itself.  Furthermore,
the CPAN (which didn't exist at the time of Perl 5.0) can become the new
home of dropped modules. Dropping modules is currently not an option, but
further developments may clear the last barriers.

magical 0 effects don't do what you expect, but rather seem
to be the product of arcane dweomercraft, sorcery, or wonder working.
[From Old English]

should just do what you want it to do without an undue amount of fuss.
A bit of code that does "dwimming" is a "dwimmer".  Dwimming can
require a great deal of behind-the-scenes magic, which (if it doesn't
stay properly behind the scenes) is called a 0 instead.

throughout the rest of the 0 in which they are first used and
in any 0 that are called by the rest of the
block.  Dynamically scoped variables can have their values temporarily
changed (and implicitly restored later) by a 0
operator.  (Compare 0.)  Used more loosely to mean
how a subroutine that is in the middle of calling another subroutine
"contains" that subroutine at 0.

one of the items that make up the array.

might be considered surprising: "I've embedded a complete Perl
interpreter in my editor!"

its 0.

passing", as in the exotic pawn-capturing maneuver in chess.]

0 (whether enforced or not), which mandates that all
access to an 0's state be through 0 alone.

your 0 inherits from its parent.  Accessed via 0.

preferences down to its future offspring (child 0,
grandchild processes, great-grandchild processes, and so on).  Each
environment variable is a 0/0 pair, like one entry in a
0.

of a 0.

to the error by the name 0 (or 0 if you use the English
module).

mechanism in Perl is the 0 operator.

another without exiting the process or relinquishing any resources
held (apart from the old memory image).

that it's okay to run this file as a program.  Usually shortened to
"executable".

to do with the 0 built-in, unless you're trying to
run a 0.)

program.  There are actually three execute bits under Unix, and which
bit gets used depends on whether you own the file singularly,
collectively, or not at all.

Typically composed of 0, 0,
0, 0, and 0
calls, not necessarily in that order.

generally, any experimental option that can be compiled into Perl,
such as multithreading.

in a string context.  Since undefined values evaluate to 0, all
undefined values are false, but not all false values are undefined.

answered, especially if the answer appears in the Perl FAQ shipped
standard with Perl).

after printing a message on your 0 stream.  Errors
that happen inside an 0 are not fatal.  Instead,
the 0 terminates after placing the exception
message in the 0 (0) variable.  You can try to
provoke a fatal error with the 0 operator (known as
throwing or raising an exception), but this may be caught by a
dynamically enclosing 0.  If not caught, the
0 becomes a fatal error.

0, 0, or 0.  Variable-width fields are usually
split up by 0 (so use 0 to
extract the fields), while fixed-width fields are usually at fixed
positions (so use 0).  0 are also known as fields.

0.

in a 0.  Roughly like a document, if you're into office
metaphors.  In modern filesystems, you can actually give a file more
than one name.  Some files have special properties, like directories
and devices.

opened 0 you're talking about.  Perl hides the file descriptor
inside a L</standard I0 stream and then attaches the stream to
a 0.

is 0 about a file, such as 0 to test whether
you're the owner of the file.

0 function.

that represents a particular instance of opening a file until you
close it.  If you're going to open and close several different files
in succession, it's fine to open each of them with the same
filehandle, so you don't have to write out separate code to process
each file.

can use it in an 0 to tell the 0 exactly which file you want to open, and associate the file
with a 0 which will carry the subsequent identity of that
file in your program, until you close it.

partition of the disk.  Sometimes known as a "partition".  You can
change the file's name or even move a file around from directory to
directory within a filesystem without actually moving the file itself,
at least under Unix.

a stream of output.

mean a command-line 0 that takes no argument
itself (such as Perl's 0 and 0
flags) or, less frequently, a single-bit indicator (such as the
0 and 0 flags used in
0).

precision of the number is independent of its magnitude (the decimal
point "floats").  Perl does its numeric work with floating-point
numbers (sometimes called "floats"), when it can't get away with
using 0.  Floating-point numbers are mere
approximations of real numbers.

treatise on one narrow topic, something of a super-0.  See Tom
for far more.

moment of conception, at least until it gets ideas of its own.  A
thread with protected memory.

0.  In many languages, formal arguments are
always given individual names, but in Perl, the formal arguments are
just the elements of an array.  The formal arguments to a Perl program
are 0, 0, and so on.  Similarly, the formal
arguments to a Perl subroutine are 0, 0, and so on.  You
may give the arguments individual names by assigning the values to a
0 list.  See also 0.

somewhere so that whatever you're printing comes out nice and pretty.

may still belong to someone else (like Larry).

your friends and we find out about it.  In fact, we'd rather you gave
a copy to all your friends.

make the source code available as well.  Now often called 0.  Recently there has been a trend to use the term in
contradistinction to 0, to refer only to free
software released under the Free Software Foundation's GPL (General
Public License), but this is difficult to justify etymologically.

particular output value.  In computers, refers to a 0 or
0 that returns a 0.  It may or may not have input
values (called 0).

the strange prefixes that Perl requires as noun markers on its
variables.

pick up after you".  Strictly speaking, Perl doesn't do this, but it
relies on a reference-counting mechanism to keep things tidy.
However, we rarely speak strictly and will often refer to the
reference-counting scheme as a form of garbage collection.  (If it's
any comfort, when your interpreter exits, a "real" garbage collector
runs to make sure everything is cleaned up if you've been messy with
circular references and such.)

uses to identify you and members of your 0.

characters when you're trying to generate a list of filenames.
Loosely, the act of using globs and similar symbols to do pattern
matching.  See also 0 and 0.

0 and 0 that are visible
everywhere in your program.  In Perl, only certain special variables
are truly global--most variables (and all subroutines) exist only in
the current 0.  Global variables can be declared with
0.  See 0.

associated object destructors) that takes place when a Perl
0 is being shut down.  Global destruction should not be
confused with the Apocalypse, except perhaps when it should.

weren't intended to be hooked together.

possible.

Regular Expression and Print it", now used in the general sense of any
kind of search, especially text searches.  Perl has a built-in
0 function that searches a list for elements
matching any given criterion, whereas the  program searches
for lines matching a 0 in one or more files.

(like Unix), you can give certain file access permissions to other
members of your group.

type is a subclass of 0.

whether these involve golfing, fighting orcs, or programming.  Hacker
is a neutral term, morally speaking.  Good hackers are not to be
confused with evil 0 or clueless 0.  If you confuse them, we will presume that
you are either evil or clueless.

program needs to respond to some internal event, such as a 0,
or an encounter with an operator subject to 0.
See also 0.

0, such that the referent's 0 count accounts
for it.  (Some hard references are held internally, such as the
implicit reference from one of a 0's variable slots to its
corresponding referent.)  A hard reference is different from a
0.

you can easily use a string 0 to look up its associated data
0.  This glossary is like a hash, where the word to be defined
is the key, and the definition is the value.  A hash is also sometimes
septisyllabically called an "associative array", which is a pretty
good reason for simply calling it a "hash" instead.

arrays (hashes) efficiently.  See also 0.

"ahead" of the rest of your program to do certain obscure operations.
A C header file has a 0 extension.  Perl doesn't really have
header files, though historically Perl has sometimes used translated
0 files with a 0 extension.  See 0.
(Header files have been superseded by the 0 mechanism.)

pretends that the 0 following the 0 are a
separate 0 to be fed to the command, up to some terminating
string.  In Perl, however, it's just a fancy form of quoting.

are customarily represented by the letters 0 through 0.
Hexadecimal constants in Perl start with 0.  See also
0.

name is often placed into 0 or 0 by
0, but you can also find it with C<(getpwuid(.
(Some platforms do not have a concept of a home directory.)

quality that makes you write (and maintain) programs that other people
won't want to say bad things about.  Hence, the third great virtue of
a programmer.  See also 0 and 0.

representation of a hash.  The 0 type is a subclass of 0.

might be interested.  Many languages (including Perl) allow
identifiers that start with a letter and contain letters and digits.
Perl also counts the underscore character as a valid letter.  (Perl
also has more complicated names, such as 0 names.)

write programs that don't just react to your needs, but actually
anticipate them.  Or at least that pretend to.  Hence, the second
great virtue of a programmer.  See also 0 and 0.

code should not count on implementation details staying the same
unless they are part of the published 0.

0.

so specified).

(such as a phone book), but now merely the act of using any kind of
key or position to find the corresponding 0, even if no index
is involved.  Things have degenerated to the point that Perl's
0 function merely locates the position (index)
of one string in another.

0: a 0 (filehandle name), a 0, a
typeglob 0, or a low-level 0 object.

object indicating the beneficiary or recipient of the action.  In
Perl, 0 can be understood as "verb
indirect-object object" where 0 is the recipient of the
0 action, and 0 is the object being
printed.  Similarly, when invoking a 0, you might place the
invocand between the method and its arguments:

to be avoided.

when using the indirect object invocation syntax.  (The slot is
distinguished by the absence of a comma between it and the next
argument.) 0 is in the indirect object slot here:

indicates where the value is, that's indirection.  This can be done
with either 0 or 0.

as multiplication in 0.

happen to be a 0, your ancestors are called 0 and your descendants are called 0.  See 0 and 0.

object rather than with the class as a whole.

1, 2, 3, and so on, but including 0 and the negatives.

its 0, which it should feel free to change whenever it
likes.

another value, such that it appears to have been there all along.  In
Perl, variable interpolation happens in double-quoted strings and
patterns, and list interpolation occurs when constructing the list of
values to pass to a list operator or other such construct that takes a
0.

the second program says directly without turning the program into a
different form first, which is what 0 do.  Perl
is not an interpreter by this definition, because it contains a kind
of compiler that takes a program and turns it into a more executable
form (0) within the 0 process itself,
which the Perl 0 system then interprets.

method, the invocand is a package name.  In an 0 method,
the invocand is an object reference.

function to get it do what you think it's supposed to do.  We usually
"call" subroutines but "invoke" methods, since it sounds cooler.

considered to be a more specific version of the other, generic object:
"A camel is a mammal."  Since the generic object really only exists in
a Platonic sense, we usually add a little abstraction to the notion of
objects and think of the relationship as being between a generic
0 and a specific 0.  Oddly enough,
Platonic classes don't always have Platonic relationships--see
0.

something that you're trying to iterate over.  The 0 loop in
Perl contains an iterator; so does a hash, allowing you to
0 through it.

IV also means an internal Integer Value of the type a 0 can
hold, not to be confused with an 0.

when executed, evaluates to that string.  Often used to illustrate a
particular Perl feature, and something of an ongoing Obfuscated Perl
Contest seen in Usenix signatures.

associated with that key.

statement elsewhere in the program.

expenditure.  It makes you write labor-saving programs that other
people will find useful, and document what you wrote so you don't have
to answer so many questions about it.  Hence, the first great virtue
of a programmer.  Also hence, this book.  See also 0 and
0.

leftmost occurrence of a 0, then given a position at which a
match will occur, the preference for the longest match (presuming the
use of a 0 quantifier).  See 0 for 0 more on
this subject.

(Also known as 0, because dictionaries don't change
very fast.)  Similarly, looking at variables stored in a private
dictionary (namespace) for each scope, which are visible only from
their point of declaration down to the end of the lexical scope in
which they are declared.  --Syn. 0.
--Ant. 0.

0.  Often just called a "lexical".  (The
0 declaration declares a lexically scoped name for a
global variable, which is not itself a lexical variable.)

collection of subroutines in a 0 file.  In modern times, refers
more often to the entire collection of Perl 0 on your
system.

0.

with a 0 character.  On non-Unix machines, this is emulated
by the C library even if the underlying 0 has
different ideas.

0 after every 0.  Many standard I/O libraries
automatically set up line buffering on output that is going to the
terminal.

separate line number for each source or input file it opens.  The
current source file's line number is represented by 0.  The
current input line number (for the file that was most recently read
via ) is represented by the 0
(0) variable.  Many error messages report both
values, if available.

given file can have multiple links to it.  It's like having the same
phone number listed in the phone directory under different names.  As
a verb, to resolve a partially compiled file's unresolved symbols into
a (nearly) executable image.  Linking can generally be static or
dynamic, which has nothing to do with static or dynamic scoping.

expressions, evaluated to produce a 0.  Each
0 in a 0 is evaluated in 0 and
interpolated into the list value.

surroundings (the code calling it) to return a list of values rather
than a single value.  Functions that want a 0 of arguments tell
those arguments that they should produce a list value.  See also
0.

0 or 0.  Usually used for
named built-in operators (such as 0,
0, and 0) that do not
require parentheses around their 0 list.

within a program from any list-generating function to any function or
construct that provides a 0.

gives you an actual 0 instead of merely representing possible
values as a 0 does.

computers that store the least significant 0 of a word at a
lower byte address than the most significant byte.  Often considered
superior to big-endian machines.  See also 0.

be localized inside a 0 via the
0 operator.

match location.

match location.

prematurely stop looping or skip an 0.  Generally you
shouldn't try this on roller coasters.

loop control statements can talk about which loop they want to
control.

new 0 to, such as a 0 or an element of an
0.  The "l" is short for "left", as in the left side of an
assignment, a typical place for lvalues.  An 0 function or
expression is one to which a value may be assigned, as in 0.

in some declarative fashion.  Currently there are three lvalue
modifiers: 0, 0, and
0.

as 0, 0, 0, or 0, or to any tied variable.
Magical things happen when you diddle those variables.

well as numbers.

assign to them.  For example, in Perl, changing elements of the
0 array also changes the corresponding environment variables
that subprocesses will use.  Reading the 0 variable gives you the
current system error number or message.

don't usually need a 0 because the Perl compiler has plenty
of self-control.

you.

command.  A manpage contains a SYNOPSIS, a DESCRIPTION, a list of
BUGS, and so on, and is typically longer than a page.  There are
manpages documenting 0, 0,
0 0, 0,
0, 0, and such.  In this book, we
call any piece of standard Perl documentation (like 0 or
0) a manpage, no matter what format it's installed in on
your system.

is the fact that your machine may implement 0 memory; that
is, it will pretend that it has more memory than it really does, and
it'll use disk space to hold inactive bits.  This can make it seem
like you have a little more memory than you really do, but it's not a
substitute for real memory.  The best thing that can be said about
virtual memory is that it lets your performance degrade gradually
rather than suddenly when you run out of real memory.  But your
program can die when you run out of virtual memory too, if you haven't
thrashed your disk to death first.

characters are to be treated specially as metacharacters varies
greatly from context to context.  Your 0 will have certain
metacharacters, double-quoted Perl 0 have other
metacharacters, and 0 patterns have all the
double-quote metacharacters plus some extra ones of their own.

more than one character.  Generally, the first character in the
sequence must be a true metacharacter to get the other characters in
the metasymbol to misbehave along with it.

0.

something in a small language, it turns out big, and if you say it in
a big language, it turns out small.  Go figure.

the 0 and the type of the 0.

0, not necessarily in that order.

can either 0 symbols or function as an 0 class.  (A
module's main 0 file may also load in other files in support of
the module.)  See the 0 built-in.

the quotient.

finishes.

implements these using 0--see 0 and
0.

unpredictably.  (See also 0, and 0.)  In computer languages (including Perl), the notion
that a given class may have multiple direct ancestors or 0.

be accessed by two unrelated 0.

such domain have been used in another.  See 0.

telephone number.  Typically an IP address.  See also 0.

value of 012 octal under Unix (but 015 on a Mac), and represented by
0 in Perl strings.  For Windows machines writing text files, and
for certain physical devices like terminals, the single newline gets
automatically translated by your C library into a line feed and a
carriage return, but normally, no translation is done.

if it were local.

strings, but Perl allows strings to contain a null.

string containing a 0, which has a positive length
and is 0.

(the code calling it) to return a number.  See also 0 and
0.

civilization.  NV also means an internal floating-point Numeric Value
of the type a 0 can hold, not to be confused with an 0.

four 0.

user-defined type (class) it is, and what it can do because of what
class it is.  Your program can request an object to do things, but the
object gets to decide whether it wants to do them or not.  Some
objects are more accommodating than others.

constants in Perl start with 0, as in 013.  See also the
0 function.

of a string or array to a specific position within it.  Thus, the
minimum offset is zero, not one, because you don't skip anything to
get to the first item.

redistributable, with no commercial strings attached.  For a more
detailed definition, see 0.

operates on.  See also 0.

details of managing 0 and 0.
Usually used in a looser sense to indicate a particular culture of
programming.  The loose sense can be used at varying levels of
specificity.  At one extreme, you might say that all versions of Unix
and Unix-lookalikes are the same operating system (upsetting many
people, especially lawyers and other advocates).  At the other
extreme, you could say this particular version of this particular
vendor's operating system is different from any other version of this
or any other vendor's operating system.  Perl is much more portable
across operating systems than many other languages.  See also
0 and 0.

output values, often built into a language with a special syntax or
symbol.  A given operator may have specific expectations about what
0 of data you give as its arguments
(0) and what type of data you want back from it.

0 to make them work on 0 as if
the objects were ordinary scalar values, but with the actual semantics
supplied by the object class.  This is set up with the 0
0.

languages do overloading to one extent or another, since people are
good at figuring out things from 0.

to be confused with 0, which adds definitions that must
be disambiguated some other way.) To confuse the issue further, we use
the word with two overloaded definitions: to describe how you can
define your own 0 to hide a built-in 0 of the
same name (see 0) and to
describe how you can define a replacement 0 in a 0 to hide a 0's method of the same name (see
0).

a 0.  A file may also have a 0 of users who may
exercise joint ownership if the real owner permits it.  See
0.

0, and the like, such that they can be kept
separate from like-named 0 in other namespaces.  In a
sense, only the package is global, since the symbols in the package's
symbol table are only accessible from code compiled outside the
package by naming the package.  But in another sense, all package
symbols are also globals--they're just well-organized globals.

possibly malformed program into a valid 0.

listing of the differences between two versions of a program as might
be applied by the  program when you want to fix a bug or
upgrade your old version.

program you want to 0.  The list is stored as one of your
0, accessible in Perl as
0.

confused with 0.

pattern various ways on a string to see whether there's any way to
make it fit.  Often used to pick interesting tidbits out of a file.

access to other people.  These flag bits are part of the 0 word
returned by the 0 built-in when you ask about a
file.  On Unix systems, you can check the  manpage for more
information.

curl your hair.  You have to increment it eight times to shampoo your
hair.  Lather, rinse, iterate.

the input of another without an intermediate temporary file.  Once the
pipe is set up, the two processes in question can read and write as if
they were talking to a normal file, with some caveats.

0, where each passes its output stream to the next.

change any of: machine, operating system, libraries, compiler, or
system configuration.  The 0 interpreter has to be compiled
differently for each platform because it is implemented in C, but
programs written in the Perl language are largely
platform-independent.

0.

location of some other item.  Perl handles pointers internally so you
don't have to worry about them.  Instead, you just use symbolic
pointers in the form of 0 and 0 names, or 0, which aren't pointers (but act like
pointers and do in fact contain pointers).

and the object will interpret the command in different ways depending
on its type.  [0Gk many shapes]

the correct process after finding the right machine, something like
the phone extension you give when you reach the company operator.
Also, the result of converting code to run on a different platform
than originally intended, or the verb denoting this conversion.

general, code that can be easily converted to run on another
0, where "easily" can be defined however you like, and
usually is.  Anything may be considered portable if you try hard
enough.  See 0 or 0.

Porting programs written in platform-dependent languages such as C can
be difficult work, but porting programs like Perl is very much worth
the agony.

implementing Perl's stack machine.

(and possibly ignored) at compile time.  Pragmas are named in all
lowercase.

what should happen first.  For example, in the absence of parentheses,
you always do multiplication before addition.

form more suitable for the current process.  Often done with an
incoming 0.  See also 0.

Unix, two or more separate processes could be running the same program
independently at the same time--in fact, the 0
function is designed to bring about this happy state of affairs.
Under other operating systems, processes are sometimes called
"threads", "tasks", or "jobs", often with slight nuances in meaning.

language.  See also 0.

so that neither correspondent will get too confused.

compiler how many and what flavor of arguments may be passed as
0, so that you can write subroutine calls that
parse much like built-in functions.  (Or don't parse, as the case may
be.)

Usually reserved for 0 modifiers like 0, for
0 modifiers like 0, and for the
pick-your-own-quotes constructs, 0, 0, 0, 0,
0, 0, 0, 0, and 0.

reference to a hash.  You can treat a pseudohash reference as either
an array reference or a hash reference.

output-grabbing operator, 0I<00.

0 in the public domain--it's just 0 and
0.

the lead integrator in some arena of development.

least priming it.  Must be willing to play the part of the Great
Pumpkin now and then.

0 is unqualified.  A fully qualified filename is specified from
the top-level directory.

foregoing 0 may occur.

let you access the file.  With respect to computer programs, one
that's written well enough that someone has a chance of figuring out
what it's trying to do.

deceased child process so that it doesn't remain a 0.  See
the 0 and 0 function
calls.

associated with a unique 0 field.  In Unix, often commensurate
with a 0, or a blank-line-terminated set of lines (a
"paragraph").  Each line of the 0 file is a record, keyed
on login name, containing information about that user.

which is a naughty no-no in dictionaries but often works out okay in
computer programs if you're careful not to recurse forever, which is
like an infinite loop with more spectacular failure modes.

0.)  References come in two flavors, 0 and 0.

Common types of referents include scalars, arrays, hashes, and
subroutines.

computer scientist, it's a grammar for a little language in which some
strings are legal and others aren't.  To normal people, it's a pattern
you can use to find what you're looking for when it varies from case
to case.  Perl's regular expressions are far from regular in the
theoretical sense, but in regular use they work quite well.  Here's a
regular expression: 0.  This will match strings like "0" and "0".  See
0.

pattern case insensitive.  See also 0.

or 0, or a 0.  Perl uses the 0 file test
operator to identify regular files.  Sometimes called a "plain" file.

is 0 about a pair of 0.  Perl has both
numeric and string relational operators.  See 0.

0 or 0.  In many languages (not Perl),
it's illegal to use reserved words to name anything else.  (Which is
why they're reserved, after all.)  In Perl, you just can't use them to
name 0 or 0.  Also called
"keywords".

evaluated.  In Perl, a return value may be either a 0 or a
0.

of a series of important standards documents.

filesystem.

0.  Run phase is mostly spent in 0 but may
also be spent in 0 when 0,
0 0, or 0 0
operators are executed or when a substitution uses the 0
modifier.

opposed to the earlier period of time when it was trying to figure out
whether what you said made any sense whatsoever, which is 0.

before parsing the pattern as a 0, and that
therefore cannot be analyzed at compile time, but must be re-analyzed
each time the pattern match operator is evaluated.  Run-time patterns
are useful but expensive.

RV also means an internal Reference Value of the type a 0 can
hold.  See also 0 and 0 if you're not confused yet.

0.  See also 0.

surroundings (the code calling it) to return a single 0 rather
than a 0 of values.  See also 0 and 0.
A scalar context sometimes imposes additional constraints on the
return value--see 0 and 0.
Sometimes we talk about a 0 inside conditionals, but
this imposes no additional constraints, since any scalar value,
whether numeric or 0, is already true or false.

program, as opposed to a 0.

has two visibility mechanisms: it does 0 of
0 0, meaning that the rest
of the 0, and any 0 that are called
by the rest of the block, can see the variables that are local to the
block.  Perl does 0 of 0 variables,
meaning that the rest of the block can see the variable, but other
subroutines called by the block 0 see the variable.

subroutine keeps some of its temporary values, including any lexically
scoped variables.

directly rather than 0 to another form of file
before execution.  Also, in the context of 0, a writing
system for a particular language or group of languages, such as Greek,
Bengali, or Klingon.

canned scripts.  A cargo-cult programmer.

0 from using up the same resources simultaneously.

being confused with each other.  The 0 function
works on separators.  Not to be confused with 0
or 0.  The "or" in the previous sentence
separated the two alternatives.

stored as a 0 in a disk file or database or sent through a
0.  Also called marshalling.

just hangs around at a known location and waits for 0
who need service to get in touch with it.

the time of day (or of their life).  On some machines, well-known
services are listed by the 0 function.

privileges.

rather than (as is usually the case) the privileges of whoever is
running it.  Also describes the bit in the mode word (0) that controls the feature.  This bit must be explicitly set by
the owner to enable this feature, and the program must be carefully
written not to give away more privileges than it ought to.

0 who otherwise would not see each other's memory.

"sharp" and "bang", meaning the 0 sequence that tells the system
where to find the interpreter.

gives you a prompt, accepts one or more 0 of input, and
executes the programs you mentioned, feeding each of them their proper
0 and input data.  Shells can also execute
scripts containing such commands.  Under Unix, typical shells include
the Bourne shell (0), the C shell (0), and the Korn
shell (0).  Perl is not strictly a shell because it's not
interactive (although Perl programs can be interactive).

Nowadays it can refer to almost anything.  For example, evaluating a
simple assignment statement typically has the "side effect" of
assigning a value to a variable.  (And you thought assigning the value
was your primary intent in the first place!)  Likewise, assigning a
value to the special variable 0 (0) has the side
effect of forcing a flush after every 0 or
0 on the currently selected filehandle.

0, probably when you're least expecting it.

normal fashion, sits around waiting for a bolt out of the blue before
it will deign to 0.  Under Perl, bolts out of the blue are
called signals, and you send them with the 0
built-in.  See 0 and 0.

have a father.  (See also 0 and 0.)  In computer languages, the notion that
0 reproduce asexually so that a given class can only
have one direct ancestor or 0.  Perl supplies no such
restriction, though you may certainly program Perl that way if you
like.

0, or 0.

0 that works much like a telephone or a post
office box.  The most important thing about a socket is its 0 (like a phone number).  Different kinds of sockets have
different kinds of addresses--some look like filenames, and some
don't.

script just before it gets to the 0.

off in the opposite order in which you put them on.  See 0.

standard tool, or a standard Perl 0.

0.  Represented within a Perl program by the
0 0.  You can use this stream explicitly, but the
0 and 0 built-ins write to your
standard error stream automatically.

the 0.  (The "standard" of standard I/O is only
marginally related to the "standard" of standard input and output.)
In general, Perl relies on whatever implementation of standard I/O a
given operating system supplies, so the buffering characteristics of a
Perl program on one machine may not exactly match those on another
machine.  Normally this only influences efficiency, not semantics.  If
your standard I/O package is doing block buffering and you want it to
0 the buffer more often, just set the 0 variable to a true
value.

shouldn't care where its data is coming from.  Represented within a
Perl program by the 0 0.

shouldn't care where its data is going.  Represented within a Perl
program by the 0 0.

last 0 on which you requested information.

recipe: "Add marmalade to batter and mix until mixed."  A statement is
distinguished from a 0, which doesn't tell the computer
to do anything, but just to learn something.

instead of before, if you know what we mean.

is relatively stable compared to something else, except for certain
elementary particles, and we're not so sure about them.)  In
computers, where things are supposed to vary rapidly, "static" has a
derogatory connotation, indicating a slightly dysfunctional
0, 0, or 0.  In Perl culture, the
word is politely avoided.

your 0.

processes dies.  This value is placed in the special variable 0.
Its upper eight 0 are the exit status of the defunct
process, and its lower eight bits identify the signal (if any) that
the process died from.  On Unix systems, this status value is the same
as the status word returned by .  See 0.

or characters, without the appearance of being broken up into packets.
This is a kind of 0--the underlying 0 may
well break your data up into separate packets for delivery, but this
is hidden from you.

not have to be entirely printable.

(the code calling it) to return a 0.  See also 0
and 0.

object.

from elsewhere in the program in order to accomplish some sub-goal of
the program.  A subroutine is often parameterized to accomplish
different but related things depending on its input
0.  If the subroutine returns a meaningful
0, it is also called a 0.

0 in an array.

this term to mean 0.)

position (0) and proceeding for a certain number of
characters.

Typically your system administrator or someone pretending to be your
system administrator.  On Unix systems, the 0 user.  On Windows
systems, usually the Administrator user.

0 is treated as a member of a class derived from SV, in an
object-oriented sort of way.  Every 0 inside Perl is passed
around as a C language 0 pointer.  The SV 0 knows its
own "referent type", and the code is smart enough (we hope) not to try
to call a 0 function on a 0.

works, usually introduced with a minus sign.  The word is also used as
a nickname for a 0.

into one switch (e.g., 0).  Any switch with an additional
0 must be the last switch in a cluster.

based on the value of the expression, do a multiway branch to the
appropriate piece of code for that value.  Also called a "case
structure", named after the similar Pascal construct.  See
0.

specifically to mean the sort of name you might find in a 0.

somehow remember all the names of all the 0,
0, and 0 you've
used.  It does this by placing the names in a symbol table, which is
implemented in Perl using a 0.  There is a separate
symbol table for each 0 to give each package its own
0.

program, stopping or printing things out here and there to see whether
anything has gone wrong, and if so, what.  The "symbolic" part just
means that you can talk to the debugger using the same symbols with
which your program is written.

turn points to the real 0.  Whenever the 0
is trying to parse a 0 containing a symbolic link, it
merely substitutes the new name and continues parsing.

By 0 the first variable, you can get at
the second one.  Symbolic references are illegal under 0.

that is, when things happen one after the other, not at the same time.

put together with each other.

0 dangle off the higher-level constructs
enclosing them.

important subroutines and functions you use aren't direct system
calls, but are built up in one or more layers above the system call
level.  In general, Perl programmers don't need to worry about the
distinction.  However, if you do happen to know which Perl functions
are really syscalls, you can predict which of these will set the 0
(0) variable on failure.  Unfortunately, beginning programmers
often confusingly employ the term "system call" to mean what happens
when you call the Perl 0 function, which
actually involves many syscalls.  To avoid any confusion, we nearly
always use say "syscall" for something you could call indirectly via
Perl's 0 function, and never for something
you would call with Perl's 0 function.

for a secure program to rely on.  Perl does taint checks if you run a
0 (or 0) program, or if you use the 0 switch.

the Internet Protocol to make an unreliable packet transmission
mechanism appear to the application program to be a reliable
0 of bytes.  (Usually.)

thing that functions grammatically as an 0 for the operators
in an expression.

The 0 variable contains the string that terminates a
0 operation, which 0
deletes from the end.  Not to be confused with
0 or 0.  The period at
the end of this sentence is a terminator.

pronounced 0.

protection.  A thread is lighter weight than a full process, in that a
process could have multiple threads running around in it, all fighting
over the same process's memory space unless steps are taken to protect
threads from each other.  See 0.

0 and 0.

there can be more than one valid path to solving a programming problem
in context.  (This doesn't mean that more ways are always better or
that all possible paths are equally desirable--just that there need
not be One True Way.)  Pronounced TimToady.

semantic significance.

0 for later analysis by a parser.

"lexing", in which case you get "lexemes" instead of tokens.

together, you can build almost anything you want.  Which is fine if
you're assembling a tricycle, but if you're building a defranishizing
comboflux regurgalator, you really want your own machine shop in which
to build special tools.  Perl is sort of a machine shop.

character of the source string to its corresponding character in the
result string.  See
L<perlop/tr0SEARCHLIST0REPLACEMENTLIST0.

three 0.  Sometimes pronounced 0.

its 0 variable and which is secretly used in the production of
Camel books.

opening a file for writing or explicitly via the
0.

stands for any or all of 0, 0, 0, 0, or
just 0.  How you use it determines whether it is interpreted as
all or only one of them.  See 0.

within an 0 module written in 0.

over the Internet.

ownership.

creating files or directories, in order to establish a policy of whom
you'll ordinarily deny access to.  See the 0
function.

0.  Unary operators are usually prefix
operators; that is, they precede their operand.  The 0 and 0
operators can be either prefix or postfix.  (Their position 0
change their meanings.)

more or less.  See 0 and 0.

and largely incompatible syntaxes, in which anyone can define anything
any way they choose, and usually do.  Speakers of this language think
it's easy to learn because it's so easily twisted to one's own ends,
but dialectical differences make tribal intercommunication nearly
impossible, and travelers are often reduced to a pidgin-like subset of
the language.  To be universally understood, a Unix shell programmer
must spend years of study in the art.  Many have abandoned this
discipline and now communicate via an Esperanto-like language called
Perl.

couple of people at Bell Labs wrote to make use of a PDP-7 computer
that wasn't doing much of anything else at the time.

keys, indexes, operators, and whatnot that you need to access the
value.

0, as your program sees fit.

of 0.

virtual memory is not real memory.  (See also 0.)  The
opposite of "virtual" is "transparent", which means providing the
reality of something without the appearance, as in: Perl handles the
variable-length UTF-8 character encoding transparently.

expected to return any 0 at all and is evaluated for its
0 alone.

series of decimal integers in dot notation, for instance,
0.  Each number turns into a 0 with the
specified ordinal value.  (The 0 is optional when there are at
least three integers.)

might be wrong but isn't worth blowing up over.  See 0
and the 0 pragma.

the Perl debugger.

anything on your screen.  Typically refers to any of: space, tab, line
feed, carriage return, or form feed.

efficiently handled by your computer, typically 32 bits or so, give or
take a few powers of 2.  In Perl culture, it more often refers to an
alphanumeric 0 (including underscores), or to a string of
nonwhitespace 0 bounded by whitespace or string
boundaries.

interpreted by the 0.  The operating system knows
your current directory because you told it with a
0 or because you started out in the place where
your parent 0 was when you were born.

you, modifying some of its input or output to better suit your
purposes.

appears on the screen matches how it will eventually look, like Perl's
0 declarations.  Also used to mean the
opposite of magic because everything works exactly as it appears, as
in the three-argument form of 0.

eXternal Subroutine, executed in existing C or C++ or in an exciting
new extension language called (exasperatingly) XS.  Examine 0
for the exact explanation or 0 for an exemplary unexacting
one.

probably would not have existed.  See the file 0 in the Perl
source distribution.

0.

proper notification of its demise by virtue of having called
0 or 0.  If you
0, you must clean up after your child processes
when they exit, or else the process table will fill up and your system
administrator will Not Be Happy with you.

by Larry Wall, Tom Christiansen & Jon Orwant.
Copyright (c) 2000, 1996, 1991 O'Reilly Media, Inc.
This document may be distributed under the same terms as Perl itself. 

=encoding utf8

it under the terms of either:

It's here so that modules, programs, etc., that want to declare
this as their distribution license can link to it.

# it, we haven't gone thru and prettied it up with =item's or
# anything.  It's good enough the way it is.

=encoding utf8

to provide some info on the basic workings of the Perl core. It is far
from complete and probably contains many errors. Please refer any
questions or comments to the author below.

guaranteed to be large enough to hold a pointer (as well as an integer).
Additionally, there is the UV, which is simply an unsigned IV.

least 32-bits and 16-bits long, respectively. (Again, there are U32 and U16,
as well.)  They will usually be exactly 32 and 16 bits long, but on Crays
they will both be 64 bits.

values that can be loaded: an integer value (IV), an unsigned integer
value (UV), a double (NV), a string (PV), and another scalar (SV).

0) guaranteed to be large enough to represent the size of
any string that perl can handle.

can create an empty SV with newSV(len).  If 0 is 0 an empty SV of
type NULL is returned, else an SV of type PV is returned with len + 1 (for
the NUL) bytes of storage allocated, accessible via SvPVX.  In both cases
the SV has value undef.

assigned by using 0, 0, or 0, or you may
allow Perl to calculate the length by using 0 or by specifying
0 as the second argument to 0.  Be warned, though, that Perl will
determine the string's length by using 0, which depends on the
string terminating with a NUL character.

formatted output becomes the value.

either a pointer to a variable argument list or the address and length of
an array of SVs.  The last argument points to a boolean; on return, if that
boolean is true, then locale-specific information has been used to format
the string, and the string's contents are therefore untrustworthy (see
0).  This pointer may be NULL if that information is not
important.  Note that this function requires you to specify the length of
the format.

that have "magic".  See 0 later in this document.

If it is not NUL-terminated there is a risk of
core dumps and corruptions from code which passes the string to C
functions or system calls which expect a NUL-terminated string.
Perl's own functions typically add a trailing NUL for this reason.
Nevertheless, you should be very careful when you pass a string stored
in an SV to a C function or system call.

or string.

variable 0 (this is a macro, so you do 0 use 0).  If you do
not care what the length of the data is, use the 0 macro.
Historically the 0 macro with the global variable 0 has been
used in this case.  But that can be quite inefficient because 0. It might work with your compiler, but it won't work for everyone.
Break this sort of statement up into separate assignments:

Perl to allocate more memory for your SV, you can use the macro

call the function 0.  Note that 0 can only increase, not
decrease, the allocated memory of an SV and that it does not automatically
add a byte for the a trailing NUL (perl's own string functions typically do
0).

in it, you can use the following macros to check the type of SV you have.

the following macros:

with the macro:

you can use the following functions:

using 0.  In the second, you specify the length of the string
yourself.  The third function processes its arguments like 0 and
appends the formatted output.  The fourth function works like 0.
You can specify the address and length of an array of SVs instead of the
va_list argument. The fifth function extends the string stored in the first
SV with the string stored in the second SV.  It also forces the second SV
to be interpreted as a string.

have "magic".  See 0 later in this document.

by using the following:

you can call:

you don't try to compare a random sv with 0. For example
when interfacing Perl code, it'll work correctly for:

AVs or HVs (see 0).

boolean TRUE and FALSE values, respectively.  Like 0, their
addresses can be used whenever an 0 is needed.

Take this code:

return a real value, or undef otherwise.  Instead it has returned a NULL
pointer which, somewhere down the line, will cause a segmentation violation,
bus error, or just weird results.  Change the zero to 0 in the
first line and all will be well.

call is not necessary (see 0).

from the beginning of a string; you give it an SV and a pointer to
somewhere inside the PV, and it discards everything before the
pointer. The efficiency comes by means of a little hack: instead of
actually removing the characters, 0 sets the flag 0
(offset OK) to signal to other functions that the offset hack is in
effect, and it puts the number of bytes chopped off into the IV field
of the SV. It then moves the PV pointer (called 0) forward that
many bytes, and adjusts 0 and 0.

at 0 in memory and the PV pointer is pointing
into the middle of this allocated storage.

0 helpfully reminds us that this is an offset. The
portion of the string between the "real" and the "fake" beginnings is
shown in parentheses, and the values of 0 and 0 reflect
the fake beginning, not the real one.

efficient shifting and splicing off the beginning of the array; while
0 points to the first element in the array that is visible from
Perl, 0 points to the real start of the C array. These are
usually the same, but a 0 operation can be carried out by
increasing 0 by one and decreasing 0 and 0.
Again, the location of the real start of the C array only comes into
play when freeing the array. See 0 in 0.

to use 0 macros.  Because a scalar can be both a number and a string,
usually these macros will always return TRUE and calling the 0
macros will do the appropriate conversion of string to integer/double or
integer/double to string.

pointer in an SV, you can use the following three macros instead:

stored in your SV.  The "p" stands for private.

For example, a tied SV may have a valid underlying value in the IV slot
(so SvIOKp is true), but the data should be accessed via the FETCH
routine rather than directly, so SvIOK is false. Another is when
numeric conversion has occurred and precision has been lost: only the
private flag is set on 'lossy' values. So when an NV is converted to an
IV with loss, SvIOKp, SvNOKp and SvNOK will be set, while SvIOK wont be.

empty AV:

AV has been created, the SVs can be destroyed, if so desired.

This routine adds 0 elements at the front of the array with the 0
value.  You must then use 0 (described below) to assign values
to these new elements.

like $#array in Perl).  If the array is empty, -1 is returned.  The
0 function returns the value at index 0, but if 0
is non-zero, then 0 will store an undef value at that index.
The 0 function stores the value 0 at index 0, and does
not increment the reference count of 0.  Thus the caller is responsible
for taking care of that, and if 0 returns NULL, the caller will
have to decrement the reference count to avoid a memory leak.  Note that
0 and 0 both return 0's, not 0's as their
return value.

does not actually delete the array itself.  The 0 function will
delete all the elements in the array plus the array itself.  The
0 function extends the array so that it contains at least 0
elements.  If 0 is less than the currently allocated length of the array,
then nothing is done.

by using the following:

information on how to use the array access functions on tied arrays.

you cannot pass 0 in as a value of 0 to tell Perl to measure the
length of the key).  The 0 argument contains the SV pointer to the
scalar being stored, and 0 is the precomputed hash value (zero if
you want 0 to calculate it for you).  The 0 parameter
indicates whether this fetch is actually a part of a store operation, in
which case a new undefined value will be added to the HV with the supplied
key and 0 will return as if the value had already existed.

0.  To access the scalar value, you must first dereference the return
value.  However, you should check to make sure that the return value is
not NULL before dereferencing it.

create and return a mortal copy of the deleted value.

table but does not actually delete the hash table.  The 0 deletes
both the entries and the hash table itself.

These contain the actual key and value pointers (plus extra administrative
overhead).  The key is a string pointer; the value is an 0.  However,
once you have an 0, to get the actual key and value, use the routines
specified below.

by using the following:

lower bits in the resulting hash value.

information on how to use the hash access functions on tied hashes.

of extension code that deals with hash structures.  These functions
also allow passing of 0 keys to 0 functions without forcing
you to stringify the keys (unlike the previous set of functions).

use more efficient (since the hash number for a particular string
doesn't have to be recomputed every time).  See 0 for detailed
descriptions.

entries.  Note that the arguments to these macros must be simple
variables, since they may get evaluated more than once.  See
0 for detailed descriptions of these macros.

dealing with keys that are not 0s:

reference count of the stored 0, which is the caller's responsibility.
If these functions return a NULL value, the caller will usually have to
decrement the reference count of 0 to avoid a memory leak.

this may be a rare case, it can be tricky. That's because you're
used to using 0 if you need an undefined SV.

for indicating that an array element has not yet been initialized.
Thus, 0 would be true for the above Perl code, but
false for the array generated by the XS code.

the value of 0, you'll get the following error:

in restricted hashes. This caused such hash entries not to appear
when iterating over the hash or when checking for the keys
with the 0 function.

0 into AVs or HVs. Trying to modify such elements
will give you the following error:

0, 0 and 0 with AVs and
HVs, but you have to make sure you know what you're doing.

or HV, you should not use 0, but rather create a
new undefined value using the 0 function, for example:

(including references).

functions are identical except that 0 increments the reference
count of the 0, while 0 does not.  For historical
reasons, 0 is a synonym for 0.

the reference:

0 or 0, if required.

macro and then check the return value.

OO lexicon, an object is simply a reference that has been blessed into a
package (or class).  Once blessed, the programmer may now use the reference
to access the various methods in the class.

specifies which class the reference will belong to.  See
0 for information on converting class names into stashes.

point to.  If 0 is non-null, the SV is blessed into the specified
class.  SV is returned.

if 0 is non-null.

reference is rv.  SV is blessed if 0 is non-null.

Perl calculate the string length.  SV is blessed if 0 is non-null.

check inheritance relationships.

a reference to a blessed object or a string containing a class name. This
is the function implementing the 0 functionality.

to write:

your Perl script, use the following routines, depending on the variable type.

be set, using the routines appropriate to the data type.

0 argument to enable certain extra features.  Those bits are:

package.

AVs, or HVs (xV for short in the following) start their life with a
reference count of 1.  If the reference count of an xV ever drops to 0,
then it will be destroyed and its memory made available for reuse.

undef'ed or the last variable holding a reference to it is changed or
overwritten.  At the internal level, however, reference counts can be
manipulated with the following macros:

count of its argument.  The 0 function, you will recall,
creates a reference to the specified argument.  As a side effect,
it increments the argument's reference count.  If this is not what
you want, use 0 instead.

Inside the XSUB routine, you create an SV which initially has a reference
count of one.  Then you call 0, passing it the just-created SV.
This returns the reference as a new SV, but the reference count of the
SV you passed to 0 has been incremented to two.  Now you
return the reference from the XSUB routine and forget about the SV.
But Perl hasn't!  Whenever the returned reference is destroyed, the
reference count of the original SV is decreased to one and nothing happens.
The SV will hang around without any way to access it until Perl itself
terminates.  This is a memory leak.

0.  Then, if and when the last reference is destroyed,
the reference count of the SV will go to zero and it will be destroyed,
stopping any memory leak.

destruction of xVs.  These functions introduce the concept of "mortality".
An xV that is mortal has had its reference count marked to be decremented,
but not actually decremented, until "a short time later".  Generally the
term "short time later" means a single Perl statement, such as a call to
an XSUB function.  The actual determinant for when mortal xVs have their
reference count decremented depends on two macros, SAVETMPS and FREETMPS.
See 0 and 0 for more details on these macros.

However, if you mortalize a variable twice, the reference count will
later be decremented twice.

For example an SV which is created just to pass a number to a called sub
is made mortal to have it cleaned up automatically when it's popped off
the stack. Similarly, results returned by XSUBs (which are pushed on the
stack) are often made mortal.

SV to a mortal SV (and thus defers a call to 0), and the
third creates a mortal copy of an existing SV.
Because 0 gives the new SV no value,it must normally be given one
via 0, 0, etc. :

can happen if you make the same value mortal within multiple contexts,
or if you make a variable mortal multiple times. Thinking of "Mortalization"
as deferred 0 should help to minimize such problems.
For example if you are passing an SV which you 0 has high enough REFCNT
to survive its use on the stack you need not do any mortalization.
If you are not sure then doing an 0 and 0, or
making a 0 is safer.

made mortal by passing their address (type-casted to 0) to the
0 or 0 routines.

within a package.  Each key of the stash is a symbol
name (shared by all the different types of objects that have the same
name), and each value in the hash table is a GV (Glob Value).  This GV
in turn contains references to the various objects of that name,
including (but not limited to) the following:

in the 0 package.  To get at the items in other packages, append the
string "::" to the package name.  The items in the 0 package are in
the stash 0 in PL_defstash.  The items in the 0 package are
in the stash 0 in 0's stash.

in the SV.  Remember that a stash is just a hash table, so you get back an
0.  The 0 flag will create a new package if it is set to GV_ADD.

you want.  The default package is called 0.  If you have multiply nested
packages, pass their names to 0, separated by 0 as in the Perl
language itself.

out the stash pointer by using:

function:

argument is a stash.  The returned 0 can now be used in the same way
as any other SV.

double, pointer, or reference.  Perl will automatically convert the
actual scalar data from the stored type into the requested type.

example, the variable 0 contains either the numeric value of 0
or its string equivalent from either 0 or 0.

0 routines to add the additional scalar type, then set a flag
so that Perl will believe it contains more than one type of data.  The
four macros to set the flags are:

you called first.  This is because every 0 routine turns on
only the bit for the particular type of data being set, and turns off
all the rest.

both the numeric and descriptive string error values, you could use the
following code:

macro 0 would need to be called instead of 0.

bills.  Everything not permitted is forbidden.]

SV does not have.  These features are stored in the SV structure in a
linked list of 0's, typedef'ed to 0.

feature.

convert 0 to type 0. Perl then continues by adding new magic
to the beginning of the linked list of magical features.  Any prior entry
of the same type of magic is deleted.  Note that this can be overridden,
and multiple instances of the same type of magic can be associated with an
SV.

the magic, typically the name of a variable. 0 is stored in the
0 field and if 0 is non-null then either a 0 copy of
0 or 0 itself is stored in the 0 field, depending on
whether 0 is greater than zero or equal to zero respectively.  As a
special case, if 0 then 0 is assumed
to contain an 0 and is stored as-is with its REFCNT incremented.

"Magic Virtual Table" should be assigned to the 0 field.
See the 0 section below.  The 0 argument is also
stored in the 0 field. The value of 0 should be chosen
from the set of macros 0 found in 0. Note that before
these macros were added, Perl internals used to directly use character
literals, so you may occasionally come across old code or documentation
referring to 'U' magic rather than 0 for example.

structure.  If it is not the same as the 0 argument, the reference
count of the 0 object is incremented.  If it is the same, or if
the 0 argument is 0, or if it is a NULL pointer,
then 0 is merely stored, without the reference count being incremented.

to an SV.

was initially made magical.

0. If you want to remove only certain magic of a 0 based on the magic
virtual table, use 0 instead:

0, which is a structure of function pointers and stands for
"Magic Virtual Table" to handle the various operations that might be
applied to that variable.

routine types:

currently 32 types.  These different structures contain pointers to various
routines that perform additional actions depending on which function is
being called.

to an 0 of 0) contains:

if a get operation is being performed, the routine 0 is
called.  All the various routines for the various magical types begin
with 0.  NOTE: the magic routines are not considered part of
the Perl API, and may not be exported by the Perl library.

compatibility they are only checked for if one of the three flags
MGf_COPY, MGf_DUP or MGf_LOCAL is set in mg_flags. This means that most
code can continue declaring a vtable as a 5-element value. These three are
currently used exclusively by the threading code, and are highly subject
to change.

uppercase letter is typically used to represent some kind of composite type
(a list or a hash), and the lowercase letter is used to represent an element
of that composite type. Some internals code makes use of this case
relationship.  However, 'v' and 'V' (vec and v-string) are in no way related.

specifically for use by extensions and will not be used by perl itself.
Extensions can use 0 magic to 'attach' private information
to variables (typically objects).  This is especially useful because
there is no way for normal perl code to corrupt this private information
(unlike using extra elements of a hash object).

C function any time a scalar's value is used or changed.  The 0's
0 field points to a 0 structure:

function will be called with 0 as the first arg and a pointer to
the SV as the second.  A simple example of how to add 0
magic is shown below.  Note that the ufuncs structure is copied by
sv_magic, so you can safely allocate it on the stack.

keys (but not values).  This hook calls 0 'get' magic
if the "set" function in the 0 structure is NULL.  The hook
is activated whenever the hash is accessed with a key specified as
an 0 through the functions 0, 0,
0, and 0.  Accessing the key as a string
through the functions without the 0 suffix circumvents the
hook.  See 0 for a detailed description.

or 0 magic, it is important for extensions to take
extra care to avoid conflict.  Typically only using the magic on
objects blessed into the same class as the extension is sufficient.
For 0 magic, it is usually a good idea to define an
0, even if all its fields will be 0, so that individual
0 pointers can be identified as a particular kind of magic
using their magic virtual table. 0 provides an easy way
to do that:

earlier do 0 invoke 'set' magic on their targets.  This must
be done by the user either by calling the 0 macro after
calling these functions, or by using one of the 0 or
0 functions.  Similarly, generic C code must call the
0 macro to invoke any 'get' magic if they use an SV
obtained from external sources in functions that don't handle magic.
See 0 for a description of these functions.
For example, calls to the 0 functions typically need to be
followed by 0, but they don't need a prior 0
since their implementation handles 'get' magic.

If the SV does not have that magical feature, 0 is returned. If the
SV has multiple instances of that magical feature, the first one will be
returned. 0 can be used to find a 0 structure of an SV
based on both it's magic type and it's magic virtual table:

SVt_PVMG, Perl may core dump.

field is an uppercase letter, then the mg_obj is copied to 0, but
the mg_type field is changed to be the lowercase letter.

magic type.

access functions requires understanding a few caveats.  Some
of these caveats are actually considered bugs in the API, to be fixed
in later releases, and are bracketed with [MAYCHANGE] below. If
you find yourself actually applying such information in this section, be
aware that the behavior may change in the future, umm, without warning.

the various GET, SET, etc methods.  To perform the equivalent of the perl
tie function from an XSUB, you must mimic this behaviour.  The code below
carries out the necessary steps - firstly it creates a new hash, and then
creates a second hash which it blesses into the class which will implement
the tie methods. Lastly it ties the two hashes together, and returns a
reference to the new tied hash.  Note that the code below does NOT call the
TIEHASH method in the MyTie class -
see 0 for details on how
to do this.

copies the magic of the array onto the value to be "stored", using
0.  It may also return NULL, indicating that the value did not
actually need to be stored in the array.  [MAYCHANGE] After a call to
0 on a tied array, the caller will usually need to call
0 to actually invoke the perl level "STORE" method on the
TIEARRAY object.  If 0 did return NULL, a call to
0 will also be usually necessary to avoid a memory
leak. [/MAYCHANGE]

0 and 0 functions as well.

0 actually return an undefined mortal value whose magic
has been initialized using 0.  Note the value so returned does not
need to be deallocated, as it is already mortal.  [MAYCHANGE] But you will
need to call 0 on the returned value in order to actually invoke
the perl level "FETCH" method on the underlying TIE object.  Similarly,
you may also call 0 on the return value after possibly assigning
a suitable value to it using 0,  which will invoke the "STORE"
method on the TIE object. [/MAYCHANGE]

In other words, the array or hash fetch/store functions don't really
fetch and store actual values in the case of tied arrays and hashes.  They
merely call 0 to attach magic to the values that were meant to be
"stored" or "fetched".  Later calls to 0 and 0 actually
do the job of invoking the TIE methods on the underlying objects.  Thus
the magic mechanism currently implements a kind of lazy access to arrays
and hashes.

functions requires the user to be aware of whether they are operating on
"normal" hashes and arrays, or on their tied variants.  The API may be
changed to provide more transparent access to both tied and normal data
types in future versions.
[/MAYCHANGE]

are mere sugar to invoke some perl method calls while using the uniform hash
and array syntax.  The use of this sugar imposes some overhead (typically
about two to four extra opcodes per FETCH/STORE operation, in addition to
the creation of all the mortal variables required to invoke the methods).
This overhead will be comparatively small if the TIE methods are themselves
substantial, but if they are only a few statements long, the overhead
will not be insignificant.

reinstate the initial value of , irrespective of how control exits
the block: 0, 0, 0/0, etc. It is a little bit
more efficient as well.

0, and arrange for some changes to be automatically
undone at the end of it, either explicit, or via a non-local exit (via
). A 0-like construct is created by a pair of
0/0 macros (see 0).
Such a construct may be created specially for some important localized
task, or an existing one (like boundaries of enclosing Perl
subroutine/block, or an existing pair for freeing TMPs) may be
used. (In the second case the overhead of additional localization must
be almost negligible.) Note that any XSUB is automatically enclosed in
an 0/0 pair.

0 at the end of enclosing 0.

0. 0 must be a pointer of a type which survives conversion to
0 and back, 0 should be able to survive conversion to 0
and back.

0.  This is similar to 0 in that it is also a
mechanism for doing a delayed 0.  However, while 0
extends the lifetime of 0 until the beginning of the next statement,
0 extends it until the end of the enclosing scope.  These
lifetimes can be wildly different.

scope instead of decrementing its reference count.  This usually has the
effect of keeping 0 alive until the statement that called the currently
live scope has finished executing.

end of 0.

the end of 0.

string pointed to by 0 is ed.  If one has a 0 in
short-lived storage, the corresponding string may be reallocated like
this:

only argument 0.

implicit context argument (if any), and 0.

at the end of 0.

provide pointers to the modifiable data explicitly (either C pointers,
or Perlish 0s).  Where the above macros take 0, a similar
function takes 0.

0/0 0 will restore the value of 0
using the stored value. It doesn't handle magic. Use 0 if
magic is affected.

0 of 0 of length 0.

0.  People who are interested in how to localize things in
the containing scope should take a look there too.

An XSUB routine will have a stack that contains the arguments from the Perl
program, and a way to map from the Perl data structures to a C equivalent.

the 0'th stack argument.  Argument 0 is the first argument passed in the
Perl subroutine call.  These arguments are 0, and can be used anywhere
an 0 is used.

the RETVAL and OUTPUT directives.  However, there are some cases where the
argument stack is not already long enough to handle all the return values.
An example is the POSIX  call, which takes no arguments, but returns
two, the local time zone's standard and summer time abbreviations.

extended using the macro:

and 0 is the number of elements the stack should be extended by.

macro. The pushed values will often need to be "mortal" (See
0):

as in:

to use the macro:

do not need to call 0 to extend the stack.

0 are 0 suited to XSUBs which return multiple results.
For that, either stick to the 0 macros shown above, or use the new
0 macros instead; see 0.

within a C program.  These four are:

contains either the name of the Perl subroutine to be called, or a
reference to the subroutine.  The second argument consists of flags
that control the context in which the subroutine is called, whether
or not the subroutine is being passed arguments, how errors should be
trapped, and how to treat return values.

on the Perl stack.

but those names are now deprecated; macros of the same name are provided for
compatibility.

must manipulate the Perl stack.  These include the following macros and
functions:

consult 0.

using the macros described in this section.  The macros provide the necessary
transparency between differences in the actual malloc implementation that is
used within perl.

with Perl.  It keeps pools of various sizes of unallocated memory in
order to satisfy allocation requests more quickly.  However, on some
platforms, it may cause spurious malloc or free errors.

point to the newly allocated memory.

the specified type of data structure should be allocated.  The argument
0 is passed to 0.  The final argument to 0, 0,
should be used if the 0 argument is different from the 0
argument.

to zero out all the newly allocated memory.

piece of memory no longer needed.  The arguments to 0 and 0
match those of 0 and 0 with the exception of not needing the
"magic cookie" argument.

memory.  The 0 and 0 arguments point to the source and
destination starting points.  Perl will move, copy, or zero out 0
instances of the size of the 0 data structure (using the 0
function).

removing Perl's dependency on the "normal" standard I/O suite and allowing
other stdio implementations to be used.  This involves creating a new
abstraction layer that then calls whichever implementation of stdio Perl
was compiled with.  All XSUBs should now use the functions in the PerlIO
abstraction layer and not make any assumptions about what kind of stdio
is being used.

stack machine) put an SV* on the stack. However, as an optimization
the corresponding SV is (usually) not recreated each time. The opcodes
reuse specially assigned SVs (0s) which are (as a corollary)
not constantly freed/created.

0 below), and when an opcode needs to put
an integer, a double, or a string on stack, it just sets the
corresponding parts of its 0 and puts the 0 on stack.

directly used in some opcodes, as well as indirectly in zillions of
others, which use it via 0.

values on the stack. The following code will not do what you think:

the stack; set 0 to 20, push a pointer to 0 onto the stack".
At the end of the operation, the stack does not contain the values 10
and 20, but actually contains two pointers to 0, which we have set
to 20.

the 0 macros, or else use the new 0 macros,
none of which make use of 0.  The 0 macros simply push an
SV* on the stack, which, as noted under 0,
will often need to be "mortal".  The new 0 macros make
this a little easier to achieve by creating a new mortal for you (via
0), pushing that onto the stack (extending it if necessary
in the case of the 0 macros), and then setting its value.
Thus, instead of writing this to "fix" the example above:

need a 0 in your variable declarations so that the 0
macros can make use of the local variable 0.  See also 0
and 0.

are created. The answer is that they are created when the current
unit--a subroutine or a file (for opcodes for statements outside of
subroutines)--is compiled. During this time a special anonymous Perl
array is created, which is called a scratchpad for the current unit.

targets for opcodes. One can deduce that an SV lives on a scratchpad
by looking on its flags: lexicals have 0 set, and
0s have 0 set.

OPs in the compile tree of the unit can use the same target, if this
would not conflict with the expected life of the temporary.

the scratchpad AV. In fact it contains a pointer to an AV of
(initially) one element, and this element is the scratchpad AV. Why do
we need an extra level of indirection?

these can create several execution pointers going into the same
subroutine. For the subroutine-child not write over the temporaries
for the subroutine-parent (lifespan of which covers the call to the
child), the parent and the child should have different
scratchpads. (0 the lexicals should be separate anyway!)

On each entry to the subroutine it is checked that the current
depth of the recursion is not more than the length of this array, and
if it is, new scratchpad is created and pushed into the array.

marked with correct flags.

Perl. Start with a simple example:

parsed your code, but has nothing to do with the execution order.
There is an additional "thread" going through the nodes of the tree
which shows the order of execution of the nodes.  In our simplified
example above it looks like:

some nodes 0.  As a corollary, though the actual tree
contains more nodes than our simplified example, the execution order
is the same as in our example.

0 on the 0 command line), you may examine the
compiled tree by specifying 0 on the Perl command line.  The
output takes several lines per node, and for 0 it looks like
this:

not optimized away (one per number in the left column).  The immediate
children of the given node correspond to 0 (node 0 is not included into above listing), i.e.,
0.

Perl core. The code which implements each operation can be found in the
0 files; the function which implements the op with type 0
is 0, and so on. As the tree above shows, different ops have
different numbers of children: 0 is a binary operator, as one would
expect, and so has two children. To accommodate the various different
numbers of children, there are various types of op data structure, and
they link together in different ways.

operators, 0s, have one child, and this is pointed to by the
0 field. Binary operators (0s) have not only an
0 field but also an 0 field. The most complex type of
op is a 0, which has any number of children. In this case, the
first child is pointed to by 0 and the last child by
0. The children in between can be found by iteratively
following the 0 pointer from the first child to the last.

and has no children, and a 0 may or may not have children. If the
0 field is non-zero, it behaves like a 0. To
complicate matters, if a 0 is actually a 0 op after
optimization (see 0) it will still
have children in accordance with its former type.

as 0.

the constructions it recognizes. Since 0 works bottom-up, so does
the first pass of perl compilation.

optimization may be performed on this pass.  This is optimization by
so-called "check routines".  The correspondence between node names
and corresponding check routines is described in 0 (do not
forget to run 0 if you modify this file).

for the execution-order thread.  Since at this time there are no
back-links to the currently constructed node, one can do most any
operation to the top-level node, including freeing it and/or creating
new nodes above/below it.

tree (if the top-level node was not modified, check routine returns
its argument).

called from 0 subroutines (or 0) (which in turn are
called from 0).

checked for being compile-time executable.  If it is (the value is
judged to be constant) it is immediately executed, and a 0
node with the "return value" of the corresponding subtree is
substituted instead.  The subtree is deleted.

created.

down through the tree.  At this time the context can have 5 values
(instead of 2 for runtime context): void, boolean, scalar, list, and
lvalue.  In contrast with the pass 1 this pass is processed from top
to bottom: a node's context determines the context for its children.

Since at this moment the compile tree contains back-references (via
"thread" pointers), nodes cannot be d now.  To allow
optimized-away nodes at this stage, such nodes are ified instead
of ing (i.e. their type is changed to OP_NULL).

is created, an additional pass over the code is performed. This pass
is neither top-down or bottom-up, but in the execution order (with
additional complications for conditionals).  Optimizations performed
at this stage are subject to the same restrictions as in the pass 2.

by the global variable 0.  By default, 0 just
calls the function pointed to by the global variable 0.
By default, that performs some basic op fixups and optimisations along
the execution-order op chain, and recursively calls 0 for
each side chain of ops (resulting from conditionals).  Extensions may
provide additional optimisations or fixups, hooking into either the
per-subroutine or recursive stage, like this:

functions, in 0 and in 0.  0 is used
with DEBUGGING and 0 is used otherwise.  For fine
control over the execution of the compile tree it is possible to provide
your own runops function.

change it to suit your needs.  Then, in the BOOT section of your XS
file, add the line:

running as fast as possible.

scope mechanism using 0. This is used like
this:

compiling every lexical scope. The available hooks are:

code like

the second starts at the 0 and has 0. Both end at the
0, so calls to 0 and 0 will match. Anything
pushed onto the save stack by this hook will be popped just before the
scope ends (between the 0 and 0 hooks, in fact).

stack. 0 is the root of the optree representing the scope; it is a
double pointer so you can replace the OP if you need to.

stack. 0 is as above. Note that it is possible for calls to 0
and 0, 0 or 0, after the eval has been set up. 0 is the
OP that requested the eval, and will normally be an 0,
0 or 0.

them in. It's best to allocate it statically, since there is no way to
free it once it's registered. The function pointers should be inserted
into this structure using the 0 macro, which will also set
flags indicating which entries are valid. If you do need to allocate
your 0 dynamically for some reason, be sure to zero it before you
start.

that is necessary you will need to do this yourself. An entry in 0
is probably the best way, so the effect is lexically scoped; however it
is also possible to use the 0 and 0 macros to
temporarily switch entries on and off. You should also be aware that
generally speaking at least one scope will have opened before your
extension is loaded, so you will see some 0 pairs that
didn't have a matching 0.

functions which produce formatted output of internal data structures.

for dumping SVs, AVs, HVs, and CVs. The 0 module calls
0 to produce debugging output from Perl-space, so users of that
module should already be familiar with its format.

derivatives, and produces output similar to 0; in fact,
0 will dump the main root of the code being evaluated,
exactly like 0.

op tree, 0 which calls 0 on all the
subroutines in a package like so: (Thankfully, these are all xsubs, so
there is no op tree)

the op tree of the main root.

for feeding it code or otherwise making it do things, but it also has
functions for its own use.  This smells a lot like an object, and
there are ways for you to build Perl so that you can have multiple
interpreters, with one interpreter represented either as a C structure,
or inside a thread-specific structure.  These structures contain all
the context, the state of that interpreter.

MULTIPLICITY build has a C structure that packages all the interpreter
state. With multiplicity-enabled perls, PERL_IMPLICIT_CONTEXT is also
normally defined, and enables the support for passing in a "hidden" first
argument that represents all three data structures. MULTIPLICITY makes
multi-threaded perls possible (with the ithreads threading model, related
to the macro USE_ITHREADS.)

PERL_GLOBAL_STRUCT_PRIVATE (the latter turns on the former, and the
former turns on MULTIPLICITY.)  The PERL_GLOBAL_STRUCT causes all the
internal variables of Perl to be wrapped inside a single global struct,
struct perl_vars, accessible as (globals) &PL_Vars or PL_VarsPtr or
the function  .  The PERL_GLOBAL_STRUCT_PRIVATE goes
one step further, there is still a single struct (allocated in 
either from heap or from stack) but there are no global data symbols
pointing to it.  In either case the global struct should be initialised
as the very first thing in  using  and
correspondingly tear it down after  using ,
please see 0 for usage details.  You may also need
to use 0 in your coding to "declare the global variables"
when you are using them.  dTHX does this for you automatically.

doesn't actually hide all symbols inside a big global struct: some
PerlIO_xxx vtables are left visible.  The PERL_GLOBAL_STRUCT_PRIVATE
then hides everything (see how the PERLIO_FUNCS_DECL is used).

either subroutines taking some kind of structure as the first
argument, or subroutines taking nothing as the first argument.  To
enable these two very different ways of building the interpreter,
the Perl source (as it does in so many other situations) makes heavy
use of macros and subroutine naming conventions.

which will be private.  All functions whose names begin 0 are private
(think "S" for "secret" or "static").  All other functions begin with
"Perl_", but just because a function begins with "Perl_" does not mean it is
part of the API. (See 0.) The easiest way to be 0 a
function is part of the API is to find its entry in 0.
If it exists in 0, it's part of the API.  If it doesn't, and you
think it should be (i.e., you need it for your extension), send mail via
0 explaining why you think it should be.

declarations and calls can pass a structure as their first argument,
or pass nothing.  To solve this, the subroutines are named and
declared in a particular way.  Here's a typical start of a static
function used within the Perl guts:

configurations in future.

sanctioned for use in extensions) begins like this:

details of the interpreter's context.  THX stands for "thread", "this",
or "thingy", as the case may be.  (And no, George Lucas is not involved. :-)
The first character could be 'p' for a 0rototype, 'a' for 0rgument,
or 'd' for 0eclaration, so we have 0, 0 and 0, and
their variants.

first argument containing the interpreter's context.  The trailing underscore
in the pTHX_ macro indicates that the macro expansion needs a comma
after the context argument because other arguments follow it.  If
PERL_IMPLICIT_CONTEXT is not defined, pTHX_ will be ignored, and the
subroutine is not prototyped to take the extra argument.  The form of the
macro without the trailing underscore is used when there are no additional
explicit arguments.

is normally hidden via macros.  Consider 0.  It expands into
something like this:

compiled with.

imply that the number of arguments is known in advance.  Instead we
either need to spell them out fully, passing 0 as the first
argument (the Perl core tends to do this with functions like
Perl_warner), or use a context-free version.

Perl_warner_nocontext, and does not take the extra argument.  Instead
it does dTHX; to get the context from thread-local storage.  We
0 so that extensions get source
compatibility at the expense of performance.  (Passing an arg is
cheaper than grabbing it from thread-local storage.)

Those are strictly for use within the core.  Extensions and embedders
need only be aware of [pad]THX.

The older thread model now uses the 0 mechanism to pass context
pointers around, so 0 is not useful any more.  Perl 5.6.0 and
later still have it for backward source compatibility, but it is defined
to be a no-op.

any functions in the Perl API will need to pass the initial context
argument somehow.  The kicker is that you will need to write it in
such a way that the extension still compiles when Perl hasn't been
built with PERL_IMPLICIT_CONTEXT enabled.

which is also the default, in order to maintain source compatibility
with extensions: whenever 0 is #included, it redefines the aTHX
and aTHX_ macros to call a function that will return the context.
Thus, something like:

in effect:

the Perl library provides , it will all just
work.

your Foo.xs:

extension is the addition of a 0 before
including the Perl headers, followed by a 0 declaration at
the start of every function that will call the Perl API.  (You'll
know which functions need this, because the C compiler will complain
that there's an undeclared identifier in those functions.)  No changes
are needed for the XSUBs themselves, because the  macro is
correctly defined to pass in the implicit context if needed.

the Perl guts:

call, since it is always passed as an extra argument.  Depending on
your needs for simplicity or efficiency, you may mix the previous
two approaches freely.

macro with the underscore for functions that take explicit arguments,
or the form without the argument for functions with no explicit arguments.

definition is needed if the Perl global variables (see 0
or 0) are accessed in the function and 0 is not
used (the 0 includes the 0 if necessary).  One notices
the need for 0 only with the said compile-time define, because
otherwise the Perl global variables are visible as-is.

another, you need to make sure perl's own Thread Local Storage (TLS) slot is
initialized correctly in each of those threads.

the TLS slot to the interpreter they created, so that there is no need to do
anything special if the interpreter is always accessed in the same thread that
created it, and that thread did not create or call any other interpreters
afterwards.  If that is not the case, you have to set the TLS slot of the
thread before calling any functions in the Perl API on that particular
interpreter.  This is done by calling the 0 macro in that
thread as the first thing you do:

that the interpreter knows about itself and pass it around, so too are
there plans to allow the interpreter to bundle up everything it knows
about the environment it's running on.  This is enabled with the
PERL_IMPLICIT_SYS macro.  Currently it only works with USE_ITHREADS on
Windows.

environment) for all the system calls.  This makes it possible for
all the system stuff to maintain their own state, broken down into
seven C structures.  These are thin wrappers around the usual system
calls (see 0) for the default perl executable, but for a
more ambitious host (like the one that would do  emulation) all
the extra work needed to pretend that different interpreters are
actually different "processes", would be done here.

There could be one or more interpreters in a process, and one or
more "hosts", with free association between them.

world are prefixed by 0 so that they will not conflict with XS
functions or functions used in a program in which Perl is embedded.
Similarly, all global variables begin with 0. (By convention,
static functions start with 0.)

either with or without the 0 prefix, thanks to a bunch of defines
that live in 0. Note that extension code should 0 set
0; this exposes the full perl internals, and is likely to cause
breakage of the XS in each new perl release.

0 and 0. 0 also creates the prototyping
header files for the internal functions, generates the documentation
and a lot of other bits and pieces. It's important that when you add
a new function to the core or change an existing one, you change the
data in the table in 0 as well. Here's a sample entry from
that table:

after that are the arguments. The first column is a set of flags:

have 'd', very few do not.

0.

look at in a second.  Some functions have 'd' but not 'A'; docs are good.

usually called within the sources as 0.

0, and it follows that callers don't use 0.  (See
0.)

The argument list should end with 0, like this:

or disappear without notice.

0 to 0. It must be called as 0.

a 0 implementation (which is exported).

0 to force a rebuild of 0 and other
auto-generated files.

formatting codes like 0, 0, 0, you should use the
following macros for portability

For example:

with , do not use %lx or %p.

use the follow macros to do it right.

modules. You have to define 0 before including 0 to
be able to use these macros:

to do some cleanup before giving control back to Perl. For example:

caught. Using these macros, it is not possible to just catch the
exception and ignore it. If you have to ignore the exception, you
have to use the 0 function.

to setup an extra function for 0, and that using these
macros is faster than using 0.

automatically produce reference manuals from them - 0 is one
such manual which details all the functions which are available to XS
writers. 0 is the autogenerated manual for the functions
which are not part of the API and are supposedly for internal use only.

source, like this:

Perl core.

of existing functions are changed. The 0 module tries to
provide compatibility code for some of these changes, so XS writers don't
have to code it themselves when supporting multiple versions of Perl.

be run as a Perl script. To generate 0, run:

compatibility information for various API calls using the 0
command line switch. For example:

writers to understand this support and make sure that the code they
write does not corrupt Unicode data.

us did, anyway. The big problem with ASCII is that it's American. Well,
no, that's not actually the problem; the problem is that it's not
particularly useful for people who don't use the Roman alphabet. What
used to happen was that particular languages would stick their own
alphabet in the upper range of the sequence, between 128 and 255. Of
course, we then ended up with plenty of variants that weren't quite
ASCII, and the whole point of it being a standard was lost.

Japanese that has hundreds or thousands of characters, then you really
can't fit them into a mere 256, so they had to forget about ASCII
altogether, and build their own systems using pairs of numbers to refer
to one character.

produced a new character set containing all the characters you can
possibly think of and more. There are several ways of representing these
characters, and the one Perl uses is called UTF-8. UTF-8 uses
a variable number of bytes to represent a character. You can learn more
about Unicode and Perl's Unicode model in 0.

non-UTF-8 data. The Unicode character 200, (0 for you hex types)
capital E with a grave accent, is represented by the two bytes
0. Unfortunately, the non-Unicode string 0
has that byte sequence as well. So you can't tell just by looking - this
is what makes Unicode input an interesting problem.

have to guess.  The API function 0 can help; it'll tell
you if a string contains only valid UTF-8 characters. However, it can't
do the work for you. On a character-by-character basis, 0
will tell you whether the current character in a string is valid UTF-8.

character. Characters with values 0...127 are stored in one byte, just
like good ol' ASCII. Character 128 is stored as 0; this
continues up to character 191, which is 0. Now we've run out of
bits (191 is binary 0) so we move on; 192 is 0. And
so it goes on, moving to three bytes at character 2048.

how long the first character in it is with the 0 macro:

0, which takes a string and a number of characters to skip
over. You're on your own about bounds checking, though, so don't use it
lightly.

so you can test if you need to do something special with this
character like this (the  is a macro that tests
whether the byte can be encoded as a single byte even in UTF-8):

value of the character; the inverse function 0 is available
for putting a UV into UTF-8:

you're ever in a situation where you have to match UTF-8 and non-UTF-8
characters. You may not skip over UTF-8 characters in this case. If you
do this, you'll lose the ability to match hi-bit non-UTF-8 characters;
for instance, if your UTF-8 string contains 0, and you skip
that character, you can never match a 0 in a non-UTF-8 string.
So don't do that!

slightly differently. A flag in the SV, 0, indicates that the
string is internally encoded as UTF-8. Without it, the byte value is the
codepoint number and vice versa (in other words, the string is encoded
as iso-8859-1, but 0 is needed to get iso-8859-1
semantics). You can check and manipulate this flag with the
following macros:

Unicode data is not properly distinguished, regular expressions,
0, 0 and other string handling operations will have
undesirable results.

flagged as UTF-8, and contains a byte sequence that could be UTF-8 -
especially when combining non-UTF-8 and UTF-8 strings.

need be sure you don't accidentally knock it off while you're
manipulating SVs. More specifically, you cannot expect to do this:

copy or reconstruct an SV just by copying the string value. Check if the
old SV has the UTF8 flag set, and act accordingly:

not it's dealing with UTF-8 data, so that it can handle the string
appropriately.

the SV is not enough to copy the UTF8 flags, even less right is just
passing a 0 to an XS function.

one of the strings to UTF-8. If you've got an SV, the easiest way to do
this is:

strings that came into the operator, and, while it shouldn't be noticeable
by the end user, it can cause problems in deficient code.

string argument. This is useful for having the data available for
comparisons and so on, without harming the original SV. There's also
0 to go the other way, but naturally, this will fail if
the string contains any characters above 255 that can't be represented
in a single byte.

is UTF-8 by looking at is 0 flag. Don't forget to set the flag if
something should be UTF-8. Treat the flag as part of the PV, even though
it's not - if you pass on the PV to somewhere, pass on the flag too.

unless 0 in which case you can use 0.

0, unless 0 in which case
you can use 0.

a new string which is UTF-8 encoded, and then combine them.

define your own ops. This is primarily to allow the building of
interpreters for other languages in the Perl core, but it also allows
optimizations through the creation of "macro-ops" (ops which perform the
functions of multiple ops which are usually executed together, such as
0.)

core does not "know" anything special about this op type, and so it will
not be involved in any optimizations. This also means that you can
define your custom ops to be any op structure - unary, binary, list and
so on - you like.

won't let you add new syntax to Perl, directly. They won't even let you
add new keywords, directly. In fact, they won't change the way Perl
compiles a program at all. You have to do those changes yourself, after
Perl has compiled the program. You do this either by manipulating the op
tree using a 0 block and the 0 module, or by adding
a custom peephole optimizer with the 0 module.

creating ops with the type 0 and the 0 of your own
PP function. This should be defined in XS code, and should look like
the PP ops in 0. You are responsible for ensuring that your op
takes the appropriate number of values from the stack, and you are
responsible for adding stack marks if necessary.

can produce sensible error and warning messages. Since it is possible to
have multiple custom ops within the one "logical" op type 0,
Perl uses the value of  to determine which custom op
it is dealing with. You should create an 0 structure for each
ppaddr you use, set the properties of the custom op with
0, and register the structure against the ppaddr using
0. A trivial example might look like:

and will also be returned as  by the 0 module, so
it will appear in the output of module like 0.

the 0 constants from 0, namely

the only core 0, 0, can sometimes be a 0. If it is set, this function
will be called from 0 when ops of this type are encountered
by the peephole optimizer. 0 is the OP that needs optimizing;
0 is the previous OP optimized, whose 0 points to 0.

0okamoto@corp.hp.com0.  It is now maintained as part of Perl
itself by the Perl 5 Porters 0perl5-porters@perl.org0.

Andreas Koenig, Paul Hudson, Ilya Zakharevich, Paul Marquess, Neil
Bowers, Matthew Green, Tim Bunce, Spider Boardman, Ulrich Pfeifer,
Stephen McCamant, and Gurusamy Sarathy.

=encoding utf8

Consistent formatting of this file is achieved with:

about the Perl 5 Porters email list, the Perl repository, the Perlbug
bug tracker, patch guidelines, and commentary on Perl development
philosophy.

for a bug, comment fixes, etc., it's easy! Here's how:

with the following command:

sentence. For example, "Fixed spelling errors in perlhack.pod".

via email.

perlbug with this command line:

address and the patch you're submitting. Once you've answered them you
can submit your patch.

Thank you!

line tool. This tool will ensure that your bug report includes all the
relevant system and configuration information.

at 0.

the bug tracking system before submitting a bug report. Often, you'll
find that the bug has been reported already.

reports. If you have additional information regarding an existing bug,
please add it. This will help the porters fix the bug.

distribution is maintained and developed. The people who maintain Perl
are also referred to as the "Perl 5 Porters", or just the "porters".

0. There is
also another archive at
0.

submitted to the maintenance and development branches of the perl
repository. See 0 for
subscription and archive information.

0. The repository contains many Perl revisions from
Perl 1 onwards and all the revisions from Perforce, the previous
version control system.

0.

the repository using the git protocol:

directory.

clone via http, though this is much slower:

the tree, see recent commits, subscribe to RSS feeds for the changes,
search for particular commits and more. You may access it at
0. A mirror of the repository is
found at 0 will produce a patch in a style suitable for Perl. The
0 command produces one patch file for each commit you
made. If you prefer to send a single patch for all commits, you can use
0.

current branch. It's important to make sure that blead is up to date
before producing the diff, that's why we call 0 first.

life easier, and ours as well.

patch. You'll need a pristine copy of the Perl source to diff against.
The porters prefer unified diffs. Using GNU 0.

patching.

sources:

should be at end-of-line otherwise

previous line)

between function name and following paren

extra paren, e.g. "if (a && (b = c)) ..."

you should also include one or more test cases which illustrate the bug
you're fixing or validate the new functionality you're adding. In
general, you should update an existing test file rather than create a
new one.

(courtesy of Gurusamy Sarathy <gsar@activestate.com>):

found in t/op/tie.t is much more maintainable, and gives better failure
reports).

do use them, make sure that you cover _all_ perl platforms.

tested, not those that were already installed.

update it.

consideration.

Perl core. When the author updates the module, the updates are simply
copied into the core.

outside of the Perl core. See that module's listing on documentation or
its listing on 0 for more information on
reporting bugs and submitting patches.

core.

the porters will greatly appreciate it if you submit a delta entry
along with your actual change. Significant changes include, but are not
limited to:

0 directory

within 0. More information on how to write good
perldelta entries is available in the 0 section of
0.

is no specific set of criteria which determine what features get added,
but here are some questions to consider when developing a patch:

almost every case, the person or people who argue for a new feature
will be expected to be the ones who implement it. Porters capable of
coding new features have their own agendas, and are not available to
implement your (possibly good) idea.

be contentious--some say that a program that emits warnings is not
broken, while others say it is. Adding keywords has the potential to
break programs, changing the meaning of existing token sequences or
functions might break programs.

incompatible changes more compatible such as the 0 and
0, I hesitate to make 10 ways to do something". This is a tricky
heuristic to navigate, though--one man's essential addition is another
man's pointless cruft.

authors, ... Perl is supposed to be easy.

add a feature stands a much higher chance of making it to the language
than does a random feature request, no matter how fervently argued the
request might be. This ties into "Will it be useful?", as the fact that
someone took the time to make the patch demonstrates a strong desire
for the feature.

"ok/not ok" run through Test::Harness, but there are a few special
considerations.

0 and ad hoc 0. The
decision of which to use depends on what part of the test suite you're
working on. This is a measure to prevent a high-level failure (such as
Config.pm breaking) from causing basic functionality tests to fail.

0, but avoids loading most modules and uses as few core
features as possible.

tests for these two. Step carefully to avoid using the feature being
tested.

0 library.

sure to skip the test gracefully if it's not there.

used. You can also use the full suite of core modules in the tests.

test suite (except under Win32 where it uses 0 instead). All
tests are run from the 0 directory, 0 the directory which
contains the test. This causes some problems with the tests in 0,
so here's some opportunity for some patching.

boils down to using 0 and avoiding things like 0
and 0 unless absolutely necessary.

slightly differently than the standard "test" target. Not all them are
expected to give a 100% success rate. Many of them have several
aliases, and many of them are not available on certain operating
systems.

basic errors before you submit a patch.

expected to succeed (until they're specifically fixed, of course).

0, 0 and 0 tests.

memory access tool "valgrind". The log files will be named
0.

extra tests are Abigail's JAPHs, 0.

0 argument to 0.

versions of this encoding.

and 0 arguments to 0.

of 0. 0 is more sophisticated, and uses the
0 module, thus using this test target supposes that perl
mostly works. The main advantage for our purposes is that it prints a
detailed summary of failed tests at the end. Also, unlike 0, it
doesn't redirect stderr to stdout.

so there is no special "test_harness" target.

TEST_FILES environment variables to control the behaviour of
0. This means you can say

Unix-like platforms. Instead of running 0, set 0
in your environment to the number of tests to run in parallel, and run
0. On a Bourne-like shell, this can be done as

because 0 needs to be able to schedule individual
non-conflicting test scripts itself, and there is no standard interface
to 0 utilities to interact with their job schedulers.

notably 0). If necessary, run just the failing scripts
again sequentially and see if the failures go away.

commands from the 0 directory:

available to you. The arguments are as follows, and are in the order
that they must appear if used together.

the manifest. The file list may include shell wildcards which will be
expanded out.

and debug output.

that this form is distinct from the 0 form below
in that it allows the file list to be provided as well.

/(LIST|OF|PATTERNS)/. Note that with this form the patterns are joined
by '|' and you cannot supply a list of files, instead the test files
are obtained from the MANIFEST.

affect the execution of the test:

suite. This is useful for modules that have a dual life on CPAN.

0).

executable that should be used to run the tests (the default being
0).

automatically by the Makefile, but can also be forced artificially by
running 'make test_notty'.

some tests that interact with the outside world are skipped. See
0.

more environment variables that affect testing.

you're looking for.

Perl does what it does.

code. If you're just getting started with Perl core hacking, this will
help you understand how it works.

level details such as how to write tests, compilation issues,
portability, debugging, etc.

goes where in the Perl source. Read it over a couple of times and it
might start to make sense - don't worry if it doesn't yet, because the
best way to study it is to read it in conjunction with poking at Perl
source, and we'll do that later on.

helpful pictures:

hacking; XSUBs use techniques drawn from the PP code, the portion of
the guts that actually executes a Perl program. It's a lot gentler to
learn those techniques from simple examples and explanation than from
the core itself.

functions do, as well as the many macros used in the source.

is only useful to the pumpkin holder, but most of it applies to anyone
wanting to go about Perl development.

http://dev.perl.org/perl5/docs/p5p-faq.html . It contains hints on
reading perl5-porters, information on how perl5-porters works and how
Perl development in general works.

who test CPAN modules on a variety of platforms.

http://www.nntp.perl.org/group/perl.daily-build.reports/ )
automatically test Perl source releases on platforms with various
configurations.

testing of the perl itself visit
0. In order to start smoke
testing CPAN modules visit
0 or
0 or
0.

listed above, you're more than ready to hack on Perl.

them; don't be afraid to ask if there's a portion you're not clear on -
who knows, you may unearth a bug in the patch...

README.aix on the IBM AIX OS. Don't hesitate to supply patches to that
README if you find anything missing or changed over a new OS release.

work out how it works. Scan through the source, and step over it in the
debugger. Play, poke, investigate, fiddle! You'll probably get to
understand not just your chosen area but a much wider range of
0's activity as well, and probably sooner than you'd think.

porting. Thanks for wanting to help make Perl better - and happy
hacking!

each file's purpose. Perl instead begins each with a literary allusion
to that file's purpose.

with a few others here and there) begin with an epigramic inscription
that alludes, indirectly and metaphorically, to the material you're
about to read.

Legendarium, almost always from 0. Chapters and
page numbers are given using the following editions:

edition of 2007 was used, published in the UK by Harper Collins
Publishers and in the US by the Houghton Mifflin Company.

50th-anniversary edition of 2004 was used, published in the UK by
Harper Collins Publishers and in the US by the Houghton Mifflin
Company.

by his son and literary executor, C.J.R. Tolkien, being the 3rd of the
12 volumes in Christopher's mammoth 0, 0, 0,
and 0, all but the first
posthumously assembled by CJRT. But 0 itself is
perfectly fine and probably best to quote from, provided you can find a
suitable quote there.

to Perl, you should conform to this peculiar practice by yourself
selecting an appropriate quotation from Tolkien, retaining the original
spelling and punctuation and using the same format the rest of the
quotes are in. Indirect and oblique is just fine; remember, it's a
metaphor, so being meta is, after all, what it's for.

maintained by the perl5-porters mailing list. 

=encoding utf8

Consistent formatting of this file is achieved with:

the Perl core C code. It covers common problems, debugging, profiling,
and more.

to do that first.

some cases we have to take pre-ANSI requirements into consideration.
You don't care about some particular platform having broken Perl? I
hear there is still a strong demand for J2EE programmers.

function prototypes of Perl. You better try your changes with that.
Related to this is the difference between "Perl_-less" and "Perl_-ly"
APIs, for example:

e.g. threaded builds. The second one does that implicitly; do not get
them mixed. If you are not passing in a aTHX_, you will need to do a
dTHX (or a dVAR) as the first thing in the function.

supported"> for further discussion about context.

ways for things to go wrong. You should try it.

They are bad form and complicate multithreading and other forms of
concurrency. The right way is to introduce them as new interpreter
variables, see 0 (at the very end for binary
compatibility).

with e.g. 0 (if your 0 has
BSD-style output) that the data you added really is read-only. (If it
is, it shouldn't show up in the output of that command.)

right combination of 0s:

moved to heap), the compilation setting
0. It is not normally used, but can be
used for testing, read more about it in 0.

function that is part of the public API (the shared Perl library) to be
explicitly marked as exported. See the discussion about 0 in
0.

arduous refactoring is now ready and correctly exported. So what could
possibly go wrong?

first place. Perl has a long and not so glorious history of exporting
functions that it should not have.

static. See the discussion about 0 in 0.

Perl's internal use (and this should be the common case), do not export
it to the public API. See the discussion about 0 in
0 flags which enforce stricter ANSI rules.

0) are given unless you also compile with 0.

code files (the ones at the top level of the source code distribution,
but not e.g. the extensions under ext/) are automatically compiled with
as many as possible of the 0, 0, 0, and a
selection of 0 flags (see cflags.SH).

operating system, filesystems, and so forth.

still compile Perl with just the bare minimum of interfaces. (See
README.micro.)

does it right. (Likewise, there are , , , and
.)

pointers is unportable and undefined, but practically speaking it seems
to work, but you should use the  and  macros.
Sometimes you can also play games with unions.

are 64 bits, and while we are out to shock you, even platforms where
shorts are 64 bits. This is all legal according to the C standard. (In
other words, "long long" is not a portable way to specify 64 bits, and
"long long" is not even guaranteed to be any wider than "long".)

Avoid things like I32 because they are 0 guaranteed to be
0 32 bits, they are 0 32 bits, nor are they
guaranteed to be 0 or 0. If you really explicitly need
64-bit variables, use I64 and U64, but only if guarded by HAS_QUAD.

a pony if the p happens not be correctly aligned.

use temporary variables, or dirty tricks with unions.

control, like the ones coming from the system headers)

between different platforms the definitions might differ

the bytes can be anything

the fields - which for native types is for usually equivalent to
 of the field

This is transparent for the most part, but because the character sets
differ, you shouldn't use numeric (decimal, octal, nor hex) constants
to refer to characters. You can safely say 'A', but not 0x41. You can
safely say '\n', but not \012. If a character doesn't have a trivial
input form, you can create a #define for it in both 0 and
0, so that it resolves to different values depending on the
character set being used. (There are three different EBCDIC character
sets defined in 0, so it might be best to insert the
#define three times in that file.)

case alphabetic characters. That is not true in EBCDIC. Nor for 'a' to
'z'. But '0' - '9' is an unbroken range in both systems. Don't assume
anything about other ranges.

EBCDIC, and may be wrong therefore, even if the code works. This is
actually a tribute to the successful transparent insertion of being
able to handle EBCDIC without having to change pre-existing code.

Unicode code points as sequences of bytes. Macros  with the same names
(but different definitions) in 0 and 0 are used to
allow the calling code to think that there is only one such encoding.
This is almost always referred to as 0, but it means the EBCDIC
version as well. Again, comments in the code may well be wrong even if
the code itself is right. For example, the concept of 0 differs between ASCII and EBCDIC. On ASCII platforms, only
characters that do not have the high-order bit set (i.e. whose ordinals
are strict ASCII, 0 - 127) are invariant, and the documentation and
comments in the code may assume that, often referring to something
like, say, 0. The situation differs and is not so simple on
EBCDIC machines, but as long as the code itself uses the
0 macro appropriately, it works, even if the
comments are wrong.

characters have different meanings depending on the locale.  Absent a
locale, currently these extra characters are generally considered to be
unassigned, and this has presented some problems. This is being changed
starting in 5.12 so that these characters will be considered to be
Latin-1 (ISO-8859-1).

you need two separate  #defines, one for each #ifdef branch.

them. If you want to document what is going (which is a good idea
especially if the branches are long), use (C) comments:

default on starting from Perl 5.9.4).

between compilers, you might need to (int).

allowed by many C compilers but cranking up the ANSI C89 strictness
(which we like to do) causes the compilation to fail.

problems (by default on starting from Perl 5.9.4).

also in C89, to limit the scope of the loop variable, alas, we cannot.

fatal in at least one platform: for example VMS cc considers this a
fatal error. One cause for people often making this mistake is that a
"naked char" and therefore dereferencing a "naked char pointer" have an
undefined signedness: it depends on the compiler and the flags of the
compiler and the underlying platform whether the result is signed or
unsigned. For this very same reason using a 'char' as an array index is
bad.

the string constants

one reasonably common and modern C compiler does "real backward
compatibility" here, in AIX that is what still happens even though the
rest of the AIX compiler is very happily C89.

be an 0), in general it cannot. IV might be something larger. Even
worse the situation is with more specific types (defined by Perl's
configuration step in 0):

might also be unsigned, in which case large uids would be printed as
negative values.

intelligence, but for many types the right format is available as with
either 'f' or '_f' suffix, for example:

with a standardized syntax. Don't use the former, and use the latter
only if the HAS_C99_VARIADIC_MACROS is defined.

functions. The right thing to do is to copy the va_list using the
 if the NEED_VA_COPY is defined.

admittedly use them if available to gain some extra speed (essentially
as a funky form of inlining), but you shouldn't.

features

for the "Foonix" operating system 0 that is available 0
correctly working for 0 past, present, 0 future versions of
"Foonix", the above is very wrong. This is more correct (though still
not perfect, because the below is a compile-time check):

Foonix happens to be Unixy enough to be able to run the Configure
script, and Configure has been taught about detecting and testing
, the HAS_QUUX will be correctly defined. In other platforms, the
corresponding configuration step will hopefully do the same.

have a good hunch of where  might be available, you can
temporarily try the following:

separate.

allocate at least one byte. (In general you should rarely need to work
at this low level, but instead use the various malloc wrappers.)

implementation, or Perl's own implementation (borrowed from the public
domain implementation of INN).

 instead, which will try to use  and
 if those safer APIs are available. If you want something
fancier than a plain byte string, use SVs and .

to use the 0 option of Perl to tell more about what Perl is doing.
But sometimes there is no alternative than to dive in with a debugger,
either to see the stack trace of a core dump (very useful in a bug
report), or trying to figure out what went wrong before the core dump
happened, or how did we end up having wrong or unexpected results.

debugging, like this:

information which will allow us to step through a running program, and
to see in which C function we are at (without the debugging information
we might see only the numerical addresses of the functions, which is
not very helpful).

which enables all the internal debugging code in Perl. There are a
whole bunch of things you can debug with this: 0 lists them
all, and the best way to find out about them is to play about with
them. The most useful options are probably

XS modules.

through perl's execution with a source-level debugger.

any debugger (many vendors call their debugger 0), but check the
manual of the one you're using.

read the source code. You should see the copyright message, followed by
the prompt.

useful commands:

either the named function (but see 0!) or
the given line in the named source file.

functions.

blessing when stepping through miles of source code.

heavy use of macros, and 0 does not necessarily support macros
(see later 0). You'll have to substitute them
yourself, or to invoke cpp on the source code files (see 0) So, for instance, you can't say

produce by saying 0. Even then, 0 won't
recursively apply those macros for you.

to use it you'll need to compile perl with macro definitions included
in the debugging information. Using 0 version 3.1, this means
configuring with 0. Other compilers might use a
different switch (if they support debugging macros at all).

in 0; these work a little like an internal
0, but they also cover OPs and other
structures that you can't get at from Perl. Let's take an example.
We'll use the 0 we used before, but give it a bit of
context: 0. Where's a good place to stop and
poke around?

0 operator:

0. With the breakpoint in place, we can
run our program:

libraries, and then:

0 arranges for two 0s to be placed into 0 and
0 - let's slightly expand it:

either directly (if 0 is set) or by calling the 0
function. 0 takes the next SV from the top of the stack - yes,
0 uses 0 - but doesn't remove it. We then use 0 to
get the NV from 0 in the same way as before - yes, 0 uses
0.

convert it. If we step again, we'll find ourselves there:

subroutine:

0, and we can dump it with 0. This'll give us
similar output to 0.

opposed to 0, that is, without executing the code. It is
possible to detect resource leaks, undefined behaviour, type
mismatches, portability problems, code paths that would cause illegal
memory accesses, and other similar problems by just parsing the C code
and looking at the resulting graph, what does it tell about the
execution and data flows. As a matter of fact, this is exactly how C
compilers know to give warnings about dubious code.

platforms, but please be aware that there are several different
implementations of it by different vendors, which means that the flags
are not identical across different platforms.

available from http://www.splint.org/ that should compile on any
Unix-like platform.

diddle with the flags (see above).

a testbed for their product they periodically check several open source
projects, and they give out accounts to open source developers to the
defect databases.

cut-and-pasted code changes, all the other spots should probably be
changed, too. Therefore such code should probably be turned into a
subroutine or a macro.

(http://pmd.sourceforge.net/). pmd was originally written for static
analysis of Java code, but later the cpd part of it was extended to
parse also C and C++.

pmd-X.Y.jar from it, and then run that on source code thusly:

option:

problems of gcc warnings (like 0 not meaning "all the warnings",
or some common portability problems not being covered by 0, or
0 and 0 both being a poorly defined collection of
warnings, and so forth), gcc is still a useful tool in keeping our
coding nose clean.

always, but unfortunately they are not safe on all platforms, they can
for example cause fatal conflicts with the system headers (Solaris
being a prime example). If Configure 0 is used, the
0 frontend selects 0 for the platforms where
they are known to be safe.

their own Augean stablemaster:

to bundle a lot of warnings under one switch (it would be impossible to
deploy in practice because it would complain a lot) but it does contain
some warnings that would be beneficial to have available on their own,
such as the warning about string constants inside macros containing the
macro arguments: this behaved differently pre-ANSI than it does in
ANSI, and some C compilers are still in transition, AIX being an
example.

have their "strict ANSI" or "strict ANSI with some portability
extensions" modes on, like for example the Sun Workshop has its 0
mode on (though implicitly), or the DEC (these days, HP...) has its
0 mode on.

Third Degree greatly slows down the execution: seconds become minutes,
minutes become hours. For example as of Perl 5.8.1, the
ext/Encode/t/Unicode.t takes extraordinarily long to complete under
e.g. Purify, Third Degree, and valgrind. Under valgrind it takes more
than six hours, even on a snappy computer. The said test must be doing
something that is quite unfriendly for memory debuggers. If you don't
feel like waiting, that you can simply kill away the perl process.

0 for more information), you have to set the
environment variable PERL_DESTRUCT_LEVEL to 2.

errors within eval or require, seeing 0 in the call stack is
a good sign of these. Fixing these leaks is non-trivial, unfortunately,
but they must be fixed eventually.

unless Perl is built with the Configure option
0.

overruns, wild pointers, memory leaks and other such badness. Perl must
be compiled in a specific way for optimal testing with Purify.  Purify
is available under Windows NT, Solaris, HP-UX, SGI, and Siemens Unix.

of Purify, you should create the perl to Purify using:

use of memory allocation functions derived from the system malloc.

where the problem occurs. Without this flag, all you will see is the
source filename of where the error occurred.

allocations and leaks. Using Perl's malloc will make Purify report most
leaks in the "potential" leaks category.

when the interpreter shuts down, which reduces the number of bogus leak
reports from Purify.

binary is used in place of the standard 'perl' binary when you want to
debug Perl memory problems.

Perl testset you would create and run the Purify'ed perl as:

have a windowing environment or if you simply want the Purify output to
unobtrusively go to a log file instead of to the interactive window,
use these following options to output to the log file "perl.log":

option:

most use out of Purify:

something like:

force use of memory allocation functions derived from the system
malloc.

when the interpreter shuts down, which reduces the number of bogus leak
reports from Purify.

allocations and leaks. Using Perl's malloc will make Purify report most
leaks in the "potential" leaks category.

where the problem occurs. Without this flag, all you will see is the
source filename of where the error occurred.

Perl testset you would create and run Purify as:

finally report any memory problems.

and illegal memory accesses. As of version 3.3.0, Valgrind only
supports Linux on x86, x86-64 and PowerPC. The special "test.valgrind"
target can be used to run the tests under valgrind. Found errors  and
memory leaks are logged in files named 0.

valgrind allows to suppress such errors using suppression files. The
default suppression file that comes with valgrind already catches a lot
of them. Some additional suppressions are defined in 0.

0 and 0.

and since the program counter can be correlated with the code generated
for functions, we get a statistical view of in which functions the
program is spending its time. The caveats are that very small/fast
functions have lower probability of showing up in the profile, and that
periodically interrupting the program (this is usually done rather
frequently, in the scale of milliseconds) imposes an additional
overhead that may skew the results. The first problem can be alleviated
by running the code for longer (in general this is a good idea for
profiling), the second problem is usually kept in guard by the
profiling tools themselves.

Basic blocks are sections of code that are entered only in the
beginning and exited only at the end. For example, a conditional jump
starts a basic block. Basic block profiling usually works by
0 the code by adding 0
book-keeping code to the generated code. During the execution of the
code the basic block counters are then updated appropriately. The
caveat is that the added extra code can skew the results: again, the
profiling tools usually try to factor their own effects out of the
results.

0.

invoking the make target "perl.gprof"  (What is required is that Perl
must be compiled using the 0 flag, you may need to re-Configure).
Running the profiled version of Perl will create an output file called
0 is created which contains the profiling data collected
during the execution.

Usually gprof understands the following options:

subsequent gprof runs to accumulate data over several runs.

formats, see your own local documentation of gprof.

for the GNU CC.

invoking the make target "perl.gcov" (what is required that Perl must
be compiled using gcc with the flags 0,
you may need to re-Configure).

generated. For each source file an accompanying ".da" file will be
created.

installed if you have gcc 3.0 or newer installed). 0 is run on
source code files, like this

the source code annotated with relative frequencies of execution
indicated by "#" markers.

block, branch, and function call coverage, and 0 which instead of
relative frequencies will use the actual counts. For more information
on the use of 0 and basic block profiling with gcc, see the
latest GNU CC manual, as of GCC 3.0 see

valgrind, or the pureperl or perl.third executables, please note that
by default perl 0 explicitly cleanup all the memory it has
allocated (such as global memory arenas) but instead lets the  of
the whole program "take care" of such allocations, also known as
"global destruction of objects".

variable PERL_DESTRUCT_LEVEL to a non-zero value. The t/TEST wrapper
does set this to 2, and this is what you need to do too, if you don't
want to see the "global leaks": For example, for "third-degreed" Perl:

for its own purposes and extended its semantics. Refer to the mod_perl
documentation for more information. Also, spawned threads do the
equivalent of setting this variable to the value 1.)

can recompile with 0, which will cause the
addresses of all those leaked SVs to be dumped along with details as to
where each SV was originally allocated. This information is also
displayed by Devel::Peek. Note that the extra details recorded with
each SV increases memory usage, so it shouldn't be used in production
environments. It also converts 0 from a macro into a real
function, so you can use your favourite debugger to discover where
those pesky SVs were allocated.

nor 0 will find anything, you're probably
leaking SVs that are still reachable and will be properly cleaned up
during destruction of the interpreter. In such cases, using the 0
switch can point you to the source of the leak. If the executable was
built with 0, 0 will output SV
allocations in addition to memory allocations. Each SV allocation has a
distinct serial number that will be written on creation and destruction
of the SV. So if you're executing the leaking code in a loop, you need
to look for SVs that are created, but never destroyed between each
cycle. If such an SV is found, set a conditional breakpoint within
0 and make it break only when 0 is equal to the
serial number of the leaking SV. Then you will catch the interpreter in
exactly the state where the leaking SV is allocated, which is
sufficient in many cases to find the source of the leak.

allocate quite a bunch of SVs, which are hidden to avoid recursion. You
can bypass the PerlIO layer if you use the SV logging provided by
0 instead.

through logging functions, which is handy for breakpoint setting.

read {PERL_MEM_LOG} to determine whether to log the event, and if
so how:

0, and at a higher level; all uses of , , and
 are logged with the caller's source code file and line
number (and C function name, if supported by the C compiler). In
contrast, 0 is directly at the point of 0. SV logging is
similar.

no extra SV allocations are introduced by enabling the logging. If
compiled with 0 Edit Menu

or 0xEFEFEFEF, you may be seeing the effect of the  macros, see
0.

check for write accesses from buggy code, compile with
0 to enable the OP slab allocator and
0 to enable code that allocates op memory
via 0, and sets it read-only at run time. Any write access to an
op results in a 0 and abort.

even to all Unix variants. Also, it is an 80% solution, in that it
isn't able to make all ops read only. Specifically it

allocated later via 0 or 0 will be re-write

slab needs to be decreased.

freed.

requiring read-write access, as either can happen during op tree
building time, so there may still be legitimate write access.

catches a write access during the generation of 0, which
means that we can't yet build 0 with this enabled.

maintained by the perl5-porters mailing list. 

=encoding utf8

Consistent formatting of this file is achieved with:

want to read through 0 too.

during a 0, (for example, 0) then the
resulting string should be treated as UTF-8 encoded.

want to create a branch for your changes. This will make creating a
proper patch much simpler. See the 0 for details on how to do
this.

- the 0 happens at runtime, so it's going to be in one of the
0 files. Sure enough, 0 is in 0. Since we're going
to be altering this file, let's copy it to 0.

been split off with 0 to its own file, 0]

loop over the pattern, taking each format character in turn into
0. Then for each possible format character, we swallow up
the other arguments in the pattern (a field width, an asterisk, and so
on) and convert the next chunk input into the specified format, adding
it onto the output SV 0.

we have a pointer to the start of 0 then, if we see a 0 we can
test whether we're still at the start of the string. So, here's where
0 is set up:

of 0:

the 0 flag for the output SV, 0:

the string is the 0 which has been swallowed into 0

pattern? 0 will have 0 as the first active
character, even though it's not the first thing in the pattern. In this
case, we have to advance 0 along with 0 when we see
spaces:

this patch is ready to go: we've changed the behaviour of Perl, and so
we must document that change. We must also provide some more regression
tests to make sure our patch works and doesn't create a bug somewhere
else along the line.

a copy of 0 to 0. Now we can add our tests
to the end. First, we'll test that the 0 does indeed create Unicode
strings.

the one from t/test.pl.

explanation of  and other testing functions).

0 the first active format:

or else the automated tester will get confused. This will either look
like this:

tests pass, hooray!

is over, so let's describe the change we've just made. The relevant
place is 0; again, we make a copy, and then we'll
insert this text in the description of 0:

maintained by the perl5-porters mailing list. 

=encoding utf8

Ing-Simmons, Chip Salzenberg, Tim Bunce, Malcolm Beattie, Gurusamy
Sarathy, Graham Barr, Jarkko Hietaniemi, Hugo van der Sanden,
Michael Schwern, Rafael Garcia-Suarez, Nicholas Clark, Richard Clamp,
Leon Brocard, Dave Mitchell, Jesse Vincent, Ricardo Signes, Steve Hay,
Matt S Trout, David Golden, Florian Ragwitz, Tatsuhiko Miyagawa,
Chris 0 Williams, Zefram and Ævar Arnfjörð Bjarmason.

David Croy.  We had passed around various names (baton, token, hot
potato) but none caught on.  Then, Chip asked:

there was one tape drive and multiple systems that used it for backups.
But instead of some high-tech exclusion software, they used a low-tech
method to prevent multiple simultaneous backups: a stuffed pumpkin.
No one was allowed to make backups unless they had the "backup pumpkin".

the pumpking (keeping the source afloat?) or the pumpkineer (pulling
the strings?).

it had in the core 212 kilobytes, in 29 files.  The "core".."doc" are
explained below.

distribution.  The glob notation ** means recursively, (.) means
regular files.

the Perl source distribution for somewhat more selected releases.

applied on top of the 5.003_07 (or whatever was before the 5.003_08)
added lines for 110 kilobytes, it removed lines for 19 kilobytes, and
changed lines for 424 kilobytes.  Just the lines themselves are
counted, not their context.  The "+ - !" become from the 
context diff output format.

can be followed (nearly) instantly (with rsync, and since late 2008, git)
patches between versions are no longer provided. However, that doesn't
keep us from calculating how large a patch could have been. Which is
shown in the table below. Unless noted otherwise, the size mentioned is
the patch to bring version x.y.z to x.y.z+1.

Keepers of the Pumpkin also Alan Champion, Mark Dominus,
Andreas K0nig, John Macdonald, Matthias Neeracher, Jeff Okamoto,
Michael Peppler, Randal Schwartz, and Paul D. Smith sent corrections
and additions. Abigail added file and patch size data for the 5.6.0 - 5.10
era.

=encoding utf8

Consistent formatting of this file is achieved with:

the level of C code, along with pointers to the relevant C source code
files.

into the internal representation, or bytecode, and then executing it.
0 explains exactly how the compilation stage
happens.

This is very high-level code, enough to fit on a single screen, and it
resembles the code found in 0; most of the real action takes
place in 0

0 at make time, so you should make perl to follow this
along.

interpreter, along these lines:

system. Line 3 references 0, a global variable - all
global variables in Perl start with 0. This tells you whether the
current running program was created with the 0 flag to perl and
then 0, which means it's going to be false in any sane context.

interpreter. It's quite a simple function, and the guts of it looks
like this:

later: 0 is either your system's 0, or Perl's
own 0 as defined in 0 if you selected that option at
configure time.

also in 0; this sets up all the special variables that Perl
needs, the stacks, and so on.

in 0, which processes the command line options, sets up any
statically linked XS modules, opens the program and calls 0 to
parse it.

op tree. We'll see what one of those looks like later. Strictly
speaking, there's three things going on here.

reading the original YACC input in 0. (Yes, Virginia, there
0 a YACC grammar for Perl!) The job of the parser is to take your
code and "understand" it, splitting it into sentences, deciding which
operands go with which operators and so on.

into tokens, and decides what type of thing each token is: a variable
name, an operator, a bareword, a subroutine, a core function, and so
on. The main point of entry to the lexer is 0, and that and its
associated routines can be found in 0. Perl isn't much like
other computer languages; it's highly context sensitive at times, it
can be tricky to work out what sort of token something is, or where a
token ends. As such, there's a lot of interplay between the tokeniser
and the parser, which can get pretty frightening if you're not used to
it.

operations for the interpreter to perform during execution. The
routines which construct and link together the various operations are
to be found in 0, and will be examined later.

operations that the Perl interpreter needs to perform to execute our
program. Next, Perl does a dry run over the tree looking for
optimisations: constant expressions such as 0 will be computed
now, and the optimizer will also see if any multiple operations can be
replaced with a single one. For instance, to fetch the variable
0, instead of grabbing the glob 0 and looking at the scalar
component, the optimizer fiddles the op tree to use a function which
directly looks up the scalar in question. The main optimizer is 0
in 0, and many ops have their own optimizing functions.

that's left to do is run it. The actual execution is done by the
0 function in 0; more specifically, it's done
by these three innocent looking lines:

stipulates the function which will actually carry out the operation.
This function will return the next op in the sequence - this allows for
things like 0 which choose the next op dynamically at run time. The
0 makes sure that things like signals interrupt
execution if required.

between four files: 0 contains the "hot" code, which is most
often used and highly optimized, 0 contains all the
system-specific functions, 0 contains the functions which
implement control structures (0, 0 and the like) and 0
contains everything else. These are, if you like, the C code for Perl's
built-in functions and operators.

next op. Calls to perl subs (and eval blocks) are handled within the
same runops loop, and do not consume extra space on the C stack. For
example, 0 and 0 just push a 0 or
0 block struct onto the context stack which contain the address
of the op following the sub call or eval. They then return the first op
of that sub or eval block, and so execution continues of that sub or
block. Later, a 0 or 0 op pops the 0
or 0, retrieves the return op from it, and returns it.

low-level 0/0 C-library functions. These basically
provide a way to capture the current PC and SP registers and later
restore them; i.e. a 0 continues at the point in code where
a previous 0 was done, with anything further up on the C
stack being lost. This is why code should always save values using
0 rather than in auto variables.

0. The basic rule of perl exceptions is that 0, and
0 (in the absence of 0) perform a 0, while
0 within 0 does a 0.

0 each does a 0, then enter a runops
loop or whatever, and handle possible exception returns. For a 2
return, final cleanup is performed, such as popping stacks and calling
0 or 0 blocks. Amongst other things, this is how scope
cleanup still occurs during an 0.

stack is popped to that level and the return op in that block is
assigned to 0; then a 0 is performed.
This normally passes control back to the guard. In the case of
0 and 0, a non-null 0 triggers
re-entry to the runops loop. The is the normal way that 0 or
0 is handled within an 0.

sort or overload code. In this case, something like

both runops loops, which is clearly incorrect. One way to avoid this is
for the tie code to do a 0 before executing 0 in
the inner runops loop, but for efficiency reasons, perl in fact just
sets a flag, using 0. The 0,
0 and 0 ops check this flag, and if true,
they call 0, which does a 0 and starts a new
runops level to execute the code, rather than doing it on the current
loop.

execution of the code following the block is still carried on in the
inner loop. When an exception is raised, 0 compares the
0 level of the 0 with 0 and if they differ,
just re-throws the exception. In this way any inner loops get popped.

then enters a runops loop. This loop executes the eval and tie ops on
line 1, with the eval pushing a 0 onto the context stack.

loop to execute the body of 0. When it executes the entertry
op on line 3, 0 is true, so 0 calls 0
which does a 0 and starts a third runops loop, which then
executes the die op. At this point the C call stack looks like this:

0 from it, does a 0, and control returns
to the top 0. This then starts another third-level runops
level, which executes the nextstate, pushmark and die ops on line 4. At
the point that the second 0 is called, the C call stack looks
exactly like that above, even though we are no longer within an inner
eval; this is because of the optimization mentioned earlier. However,
the context stack now looks like this, ie with the top CxEVAL popped:

leaving it as:

0 done, which pops the C stack back to the docatch:

differs from the current one, 0 just does a 0
and the C stack unwinds to:

loop and execution continues.

Perl's internal variable types: SVs, HVs, AVs and the rest. If not, do
that now.

but also any constants in the code, as well as some structures
completely internal to Perl. The symbol table, for instance, is an
ordinary Perl hash. Your code is represented by an SV as it's read into
the parser; any program files you call are opened via ordinary Perl
filehandles, and so on.

Perl program. Let's see, for instance, how Perl treats the constant
0.

through it line by line.

memory. SVs themselves are very simple structures, but they contain a
pointer to a more complex structure. In this case, it's a PV, a
structure which holds a string value, at location 0. Line 2
is the reference count; there are no other references to this data, so
it's 1.

read-only SV (because it's a constant) and the data is a PV internally.
Next we've got the contents of the string, starting at location
0.

0 include the null terminator. Line 6 is not the length of the
string, but the length of the currently allocated buffer; as the string
grows, Perl automatically extends the available storage via a routine
called 0.

0 to the name of the field shown in the snippet, and you've got a
macro which will return the value: 0 returns the current
length of the string, 0 returns the reference count,
0 returns the string itself with its length, and so on.
More macros to manipulate these properties can be found in 0.

0

the end of the PV stored in 0. The first thing we do in line 6 is
make sure that the SV 0 a valid PV, by calling the 0
macro to force a PV. As a side effect, 0 gets set to the current
value of the PV, and the PV itself is returned to 0.

accommodate the old string, the new string and the null terminator. If
0 isn't big enough, 0 will reallocate space for us.

grab the string directly from the SV; 0 is the address of the PV
in the SV.

memory around: we move the string 0 to the end of the PV - that's
the start of the PV plus its current length. We're moving 0 bytes
of type 0. After doing so, we need to tell Perl we've extended
the string, by altering 0 to reflect the new length. 0 is a
macro which gives us the end of the string, so that needs to be a
0.

values will no longer be valid: if we have 0 we don't
want to use the old IV of 10. 0 is a special
UTF-8-aware version of 0, a macro which turns off the IOK
and NOK flags and turns on POK. The final 0 is a macro which
launders tainted data if taint mode is turned on.

variable type being thrown around. Having seen something of how we
manipulate these, let's go on and look at how the op tree is
constructed.

representation of your program, as we saw in our section on parsing,
and it's the sequence of operations that Perl goes through to execute
your program, as we saw in 0.

built-in functions and operators are ops, and there are a series of ops
which deal with concepts the interpreter needs internally - entering
and leaving a block, ending a statement, fetching a variable, and so
on.

two "routes" through it, two orders in which you can traverse the tree.
First, parse order reflects how the parser understood the code, and
secondly, execution order tells perl what order to perform the
operations in.

finished parsing, and get it to dump out the tree. This is exactly what
the compiler backends 0, 0
and 0 do.

operator, which is at location 0. The specific operator in
question is 0 - scalar assignment - and you can find the code
which implements it in the function 0 in 0. As a
binary operator, it has two children: the add operator, providing the
result of 0, is uppermost on line 5, and the left hand side is
on line 10.

there? If you see the null op, it's a sign that something has been
optimized away after parsing. As we mentioned in 0, the
optimization stage sometimes converts two operations into one, for
example when fetching a scalar variable. When this happens, instead of
rewriting the op tree and cleaning up the dangling pointers, it's
easier just to replace the redundant operation with the null op.
Originally, the tree would have looked like this:

at the scalar component of it: 0 (0 into 0)
happens to do both these things.

seen: we have the 0 op (0 also in 0) add
together two 0s.

housekeeping every time you enter and leave a block: lexical variables
are tidied up, unreferenced variables are destroyed, and so on. Every
program will have those first three lines: 0 is a list, and its
children are all the statements in the block. Statements are delimited
by 0, so a block is a collection of 0 ops, with
the ops to be performed for each statement being the children of
0. 0 is a single op which functions as a marker.

you have to find the values of 0 and 0 before you add them
together, for instance. So, the other thread that runs through the op
tree is the execution order: each op has a field 0 which
points to the next op to be run, so following these pointers tells us
how perl executes the code. We can traverse the tree in this order
using the 0 option to 0:

statement. Get the values of 0 and 0, and add them together.
Find 0, and assign one to the other. Then leave.

unravelled by examining 0, the YACC grammar. Let's take the
piece we need to construct the tree for 0

You're fed certain things by the tokeniser, which generally end up in
upper case. Here, 0, is provided when the tokeniser sees 0 in
your code. 0 is provided when 0 is used for assigning.
These are "terminal symbols", because you can't get any simpler than
them.

build up more complex forms. These complex forms, "non-terminal
symbols" are generally placed in lower case. 0 here is a
non-terminal symbol, representing a single expression.

left of the colon if you see all the things on the right in sequence.
This is called a "reduction", and the aim of parsing is to completely
reduce the input. There are several different ways you can perform a
reduction, separated by vertical bars: so, 0 followed by 0
followed by 0 makes a 0, and 0 followed by 0
followed by 0 can also make a 0.

turn them into a single expression. When you do this, you execute the
code in the block on the next line: if you see 0, you'll do the code
in line 2. If you see 0, you'll do the code in line 4. It's this
code which contributes to the op tree.

variables. The variables refer to the tokens: 0 is the first token
in the input, 0 the second, and so on - think regular expression
backreferences. 0 is the op returned from this reduction. So, we
call 0 to create a new binary operator. The first parameter
to 0, a function in 0, is the op type. It's an addition
operator, so we want the type to be 0. We could specify this
directly, but it's right there as the second token in the input, so we
use 0. The second parameter is the op's flags: 0 means "nothing
special". Then the things to add: the left and right hand side of our
expression, in scalar context.

results to the next op? The answer is, through the use of stacks. Perl
has a number of stacks to store things it's currently working on, and
we'll look at the three most important ones here.

argument stack, 0. The typical way to handle arguments is to pop
them off the stack, deal with them how you wish, and then push the
result back onto the stack. This is how, for instance, the cosine
operator works:

below. 0 gives you the NV (floating point value) of the top SV on
the stack: the 0 in 0. Then we compute the cosine, and
push the result back as an NV. The 0 in 0 means that the
stack should be extended if necessary - it can't be necessary here,
because we know there's room for one more item on the stack, since
we've just removed one! The 0 macros at least guarantee safety.

the first element in your portion of the stack, and 0 gives you
the top SV/IV/NV/etc. on the stack. So, for instance, to do unary
negation of an integer:

XSUBs - see 0, 0 and 0 for a longer
description of the macros used in stack manipulation.

necessarily get the whole stack to itself: if your function calls
another function, you'll only want to expose the arguments aimed for
the called function, and not (necessarily) let it get at your own data.
The way we do this is to have a "virtual" bottom-of-stack, exposed to
each function. The mark stack keeps bookmarks to locations in the
argument stack usable by each function. For instance, when dealing with
a tied variable, (internally, something with "P" magic) Perl has to
call methods for accesses to the tied variables. However, we need to
separate the arguments exposed to the method to the argument exposed to
the original function - the store or fetch or whatever it may be.
Here's roughly how the tied 0 is implemented; see 0 in
0:

is so that when we've finished adding items to the argument stack, Perl
knows how many things we've added recently.

have a tied array, the 0 subroutine receives the object and the
value to be pushed, and that's exactly what we have here - the tied
object, retrieved with 0, and the value, the SV 0.

variable: 0 only gave us a local copy, not a reference to the
global.

all variables are tidied up, everything that has been localised gets
its previous value returned, and so on. Think of them as the 0 and
0 of a Perl block.

Perl space: 0 takes care of that, and it's described in
0. We call the 0 method in scalar context, and we're
going to discard its return value. The  function removes
the top element of the mark stack, so there is nothing for the caller
to clean up.

seen that 0 and 0 are used as scoping braces; the save
stack implements the C equivalent of, for example:

macros. Some have called the pervasive use of macros the hardest thing
to understand, others find it adds to clarity. Let's take an example,
the code which implements the addition operator:

The first line sets up the function declaration as Perl expects for PP
code; line 3 sets up variable declarations for the argument stack and
the target, the return value of the operation. Finally, it tries to see
if the addition operation is overloaded; if so, the appropriate
subroutine is called.

start with 0 - which pops from the top of the argument stack two NVs
(hence 0) and puts them into the variables 0 and 0,
hence the 0. These are the two operands to the addition operator.
Next, we call 0 to set the NV of the return value to the result
of adding the two values. This done, we return - the 0 macro
makes sure that our return value is properly handled, and we pass the
next operator to run back to the main run loop.

important ones are explained in 0 as well. Pay special
attention to 0 for
information on the 0 macros.

listed at 0. 

=encoding utf8

programming language, along with pointers to further documentation.  It
is intended as a "bootstrap" guide for those who are new to the
language, and provides just enough information for you to be able to
read other peoples' Perl and understand roughly what it's doing, or
write your own simple scripts.

even aim to be entirely accurate.  In some cases perfection has been
sacrificed in the goal of getting the general idea across.  You are
0 advised to follow this introduction with more information
from the full Perl manual, the table of contents to which can be found
in 0.

Perl documentation.  You can read that documentation using the 0
command or whatever method you're using to read this document.

to help explain the discussed features.  Please keep in mind that many
of them are code fragments rather than complete programs.

that piece of the documentation, and may be briefer than a corresponding
line of code in a real program.  Except where otherwise noted, you
should assume that 0 and 0 statements
appear earlier in the "program", and that any variables used have
already been declared, even if those declarations have been omitted
to make the example easier to read.

a period of several decades. Styles and techniques will therefore differ,
although some effort has been made to not vary styles too widely in the
same sections. Do not consider one style to be better than others - "There
Is More Than One Way Of Doing It" is one Perl's mottos. After all, in your
journey as a programmer, you are likely to encounter different styles.

text manipulation and now used for a wide range of tasks including
system administration, web development, network programming, GUI
development, and more.

complete) rather than beautiful (tiny, elegant, minimal).  Its major
features are that it's easy to use, supports both procedural and
object-oriented (OO) programming, has powerful built-in support for text
processing, and has one of the world's most impressive collections of
third-party modules.

no doubt other places.  From this we can determine that Perl is different
things to different people, but that lots of people think it's at least
worth writing about.

to be executable first, so 0 (under Unix).

directly the path to your perl executable, like in 0).

Windows and Mac OS, read 0.

it is recommended to start every program with the following lines:

problems in your code. They check different things so you need both. A
potential problem caught by 0 will cause your code to stop
immediately when it is encountered, while 0 will merely
give a warning (like the command-line switch 0) and let your code run.
To read more about them check their respective manual pages at 0
and 0.

statements are simply written in the script in a straightforward
fashion.  There is no need to have a 0 function or anything of
that kind.

characters such as newlines (0):

according to your personal taste.  They are only required
occasionally to clarify issues of precedence.

will automatically convert between them as required.  There is no need
to pre-declare your variable types, but you have to declare them using
the 0 keyword the first time you use them. (This is one of the
requirements of 0.)

punctuation or line noise.  These special variables are used for all
kinds of purposes, and are documented in 0.  The only one you
need to know about for now is 0 which is the "default variable".
It's used as the default argument to a number of functions in Perl, and
it's set implicitly by certain looping constructs.

of an array:

are in an array.  Don't bother.  As it happens, using 0 where Perl
expects to find a scalar value ("in scalar context") will give you the number
of elements in the array:

we're getting just a single value out of the array; you ask for a scalar,
you get a scalar.

line arguments to your script) and 0 (the arguments passed to a
subroutine).  These are documented in 0.

nicely:

0.

and loop through them.

The most well known of these is 0 which contains environment
variables.  Read all about it (and other special variables) in
0.

you to build lists and hashes within lists and hashes.

type. So by storing a reference as the value of an array or hash
element, you can easily create lists and hashes within lists and
hashes. The following example shows a 2 level hash of hash
structure using anonymous hash references.

0, 0, 0 and 0.

program, which is bad programming practice.  0 creates lexically
scoped variables instead.  The variables are scoped to the block
(i.e. a bunch of statements surrounded by curly-braces) in which they
are defined.

your Perl scripts means that the interpreter will pick up certain common
programming errors.  For instance, in the example above, the final
0 would cause a compile-time error and prevent you from
running the program.  Using 0 is highly recommended.

5.10, it even has a case/switch statement (spelled 0/0).  See
0 for more details.

the next section for information on comparison and boolean logic operators,
which are commonly used in conditional statements.

line in the block.  However, there is a clever way of making your one-line
conditional blocks more English like:

the more friendly list scanning 0 loop.

this overview) see 0.

we've already seen include 0, 0 and 0.  A list of
them is given at the start of 0 and you can easily read
about any given function by using C<perldoc -f 0.

of the most common ones:

have special variable types, and Perl needs to know whether to sort
numerically (where 99 is less than 100) or alphabetically (where 100 comes
before 99).

of the operators. They're also supported as operators in their own
right.  They're more readable than the C-style operators, but have
different precedence to 0 and friends.  Check 0 for more
detail.)

It's documented in extravagant detail in 0 and 0,
but in short:

scalar context it reads a single line from the filehandle, and in list
context it reads the whole file in, assigning each line to an element of
the list:

be useful but it may be a memory hog. Most text file processing
can be done a line at a time with Perl's looping constructs.

However, 0 can also take an optional first argument specifying
which filehandle to print to:

(though to be honest, Perl will clean up after you if you forget):

subject of lengthy documentation in 0, 0, and
elsewhere.  However, in short:

0 by default, or can be bound to another variable using the 0
binding operator (also documented in 0).

on just about anything you could dream of by using more complex regular
expressions.  These are documented at great length in 0, but for
the meantime, here's a quick cheat sheet:

want to match on, where "thing" means either a literal character, one
of the metacharacters listed above, or a group of characters or
metacharacters in parentheses.

used to capture the results of parts of the regexp match for later use.
The results end up in 0, 0 and so on.

other complex details.  Read all about them in 0,
0, and 0.

to us as a special array called 0 (see 0 for more on that).
The default argument to the 0 function just happens to be 0.
So 0 shifts the first item off the list of
arguments and assigns it to 0.

know what sort of object they are based on Perl's concept of packages.
However, OO Perl is largely beyond the scope of this document.
Read 0, 0, 0 and 0.

in using third-party modules, which are documented below.

the wheel, and can be downloaded from CPAN ( http://www.cpan.org/ ).  A
number of popular modules are included with the Perl distribution
itself.

to database integration to graphics.  A categorized list of modules is
also available from CPAN.

0.

Typically you will want to C<use 0, which will then give
you access to exported functions or an OO interface to the module.

tasks, and often provides suggestions for good CPAN modules to use.

modules which came with your Perl installation.

good advice.

=encoding utf8

abstraction described in 0 when 0 is defined (and
0 is not).

just an abstraction until perl5.7.0. However during that time a number
of perl extensions switched to using it, so the API is mostly fixed to
maintain (source) compatibility.

and platform neutral manner. It is also a trial of an "Object Oriented
C, with vtables" approach which may be applied to Perl 6.

calls (file descriptors in C) getting bytes in and out, the higher
layers of the stack buffer, filter, and otherwise manipulate the I/O,
and return characters (or bytes) to Perl.  Terms 0 and 0
are used to refer to the relative positioning of the stack layers.

a table of function pointers), and status flags.  The functions in the
vtable implement operations like "open", "read", and "write".

first down the stack using "read" functions of each layer, then at the
bottom the input is requested from the operating system services, then
the result is returned up the stack, finally being interpreted as Perl
data.

operating system: that's where PerlIO buffering comes into play.

the layers you specify are "pushed" on top of the already existing
default stack.  One way to see it is that "operating system is
on the left" and "Perl is on the right".

things: your operating system, Perl version, Perl compile time
configuration, and Perl runtime configuration.  See 0,
0, and 0 for more information.

layers are pushed on top of the existing stack.

for  and , this doesn't mean that the effects are
limited to the "top": PerlIO layers can be very 'active' and inspect
and affect layers also deeper in the stack.  As an example there
is a layer called "raw" which repeatedly "pops" layers until
it reaches the first layer that has declared itself capable of
handling binary data.  The "pushed" layers are processed in left-to-right
order.

.  For example in Unix or Unix-like systems  operates
directly at the level of file descriptors: in the terms of PerlIO
layers, it uses only the "unix" layer, which is a rather thin wrapper
on top of the Unix file descriptors.

the term "discipline" for the entities which were added. This came (I
believe) from the use of the term in "sfio", which in turn borrowed it
from "line disciplines" on Unix terminals. However, this document (and
the C code) uses the term "layer".

avoid connotations that are inherent in earlier uses of "discipline"
for things which are rather different.

level 0 is a pointer to a 0 - i.e. a pointer
to a pointer to the struct. This allows the application level 0
to remain constant while the actual 0 underneath
changes. (Compare perl's 0 which remains constant while its
0 field changes as the scalar's type changes.) An IO stream is
then in general represented as a pointer to this linked-list of
"layers".

a  "is" a 0, and so to some degree
at least one layer can use the "standard" API on the next layer down.

member of 0. The functions (methods of the layer "class") are
fixed, and are defined by the 0 type. They are broadly the
same as the public 0 functions:

compatibility check "name" for the layer, the  size to 0 for the per-instance data,
and some flags which are attributes of the class as whole (such as whether it is a buffering
layer), then follow the functions which fall into four basic groups:

table has to be present. Unimplemented slots can be NULL (which will
result in an error when called) or can be filled in with stubs to
"inherit" behaviour from a "base class". This "inheritance" is fixed
for all instances of the layer, but as the layer chooses which stubs
to populate the table, limited "multiple inheritance" is possible.

struct, by making a PerlIOl the first member of the layer's struct
thus:

treated as a pointer to a PerlIOl.

The application's 0 points to an entry in the table(s)
representing open (allocated) handles. For example the first three slots
in the table correspond to 0,0 and 0. The table
in turn points to the current "top" layer for the handle - in this case
an instance of the generic buffering layer "perlio". That layer in turn
points to the next layer down - in this case the low-level "unix" layer.

much more flexibility:

sockets then the "unix" layer can be replaced (at open time or even
dynamically) with a "socket" layer.

layer could be the "mmap" layer if reading disk files was quicker
using 0 than 0. An "unbuffered" stream can be implemented
simply by not having a buffer layer.

This was the driving need for including the scheme in perl 5.7.0+ - we
needed a mechanism to allow data to be translated between perl's
internal encoding (conceptually at least Unicode as UTF-8), and the
"native" format used by the system. This is provided by the
":encoding(xxxx)" layer which typically sits above the buffering layer.

can be used on any platform, not just those that normally do such
things.

from the mode string passed to 0, and state bits for
typical buffer layers.

mapped to "\n" for input. Normally the provided "crlf" layer is the only
layer that need bother about this. 0 will mess with this
flag rather than add/remove layers if the 0 bit is set
for the layers class.

by this layer should be considered UTF-8 encoded. Can be set on any layer
by ":utf8" dummy layer. Also set on ":encoding" layer.

each write to this layer.

to next layer.

layer below.

whenever a "\n" is seen. Any data beyond the "\n" should then be
processed.

Normally set based on 0 for the class and by the
existence of the function(s) in the table. However a class that
normally provides that interface may need to avoid it on a
particular instance. The "pending" layer needs to do this when
it is pushed above a layer which does not support the interface.
(Perl's 0 does not expect the streams fast 0 behaviour
to change during one "get".)

code "knows" as a compatibility check. Future versions 0 be able
to tolerate layers compiled against an old version of the headers.

.  For example if the layer is called APR, you will call:

implemented by the APR layer.

and assumes layer's Pushed function will do any required layer stack
manipulation - used to avoid malloc/free overhead for dummy layers.
If the field is non-zero it must be at least the size of 0,
0 will allocate memory for the layer's data structures
and link new layer onto the stream's stack. (If the layer's Pushed
method returns an error indication the layer is popped again.)

(or will configure itself not to) transform bytes passing through it.

extra arguments should come not before the 0 argument. When this
flag is used it's up to the layer to validate the args.

onto the stack.  The 0 argument may be NULL if this occurs
post-open. The 0 will be non-0 if an argument string was
passed. In most cases this should call 0 to
convert 0 into the appropriate 0 flags in
addition to any actions the layer itself takes.  If a layer is not
expecting an argument it need neither save the one passed to it, nor
provide 0 (it could perhaps 0 that the argument
was un-expected).

be popped after 0 is called. But a layer can be popped
without being closed if the program is dynamically managing layers on
the stream. In such cases 0 should free any resources
(buffers, translation tables, ...) not held directly in the layer's
struct.  It should also 0 any unconsumed data that has been
read and buffered from the layer below back to that layer, so that it
can be re-provided to what ever is now above.

0 assumes that either the layer has popped itself, or the
layer is super special and needs to be retained for other reasons.
In most cases it should return 0.

functions of perl's 0, 0, perl's 0,
0 and 0.  The full prototype is as
follows:

a slot in the table and associate it with the layers information for
the opened file, by calling 0.  The 0 is an
array of all the layers destined for the 0, and any
arguments passed to them, 0 is the index into that array of the
layer being called. The macro 0 will return a (possibly
0) SV * for the argument passed to the layer.

the regular expression 0.

special 0 calls; the 0 prefix means that this is
0 and that 0 and 0 should be passed to
0; 0 means 0ead, 0 means 0rite and
0 means 0ppend. The 0 suffix means that both reading and
writing/appending are permitted.  The 0 suffix means file should
be binary, and 0 means it is text. (Almost all layers should do
the IO in binary mode, and ignore the b/t bits. The 0 layer
should be pushed to handle the distinction.)

does not use this (yet?) and semantics are a little vague.

which will be open in a manner compatible with the supplied mode
string, the call is thus equivalent to 0. In this case
0 will be zero.

passed to 0, otherwise it will be 1 if for example
0 was called.  In simple cases SvPV_nolen(*args) is the
pathname to open.

method of next layer down (if any) and then push itself on top if that
succeeds.  0 is provided to do exactly that, so in
most cases you don't have to write your own 0 method.  If this
method is not defined, other layers may have difficulty pushing
themselves on top of it during open.

0 itself, since if it's not, the layer won't be removed
and may cause bad problems.

of binmode(FH)). If not present layer will be popped. If present
should configure layer as binary (or pop itself) and return 0.
If it returns -1 for error 0 will fail with layer
still on the stack.

argument passed to the layer when it was
pushed. e.g. ":encoding(ascii)" would return an SvPV with value
"ascii". (0 and 0 arguments can be ignored in most
cases)

0, so you must implement this function if your layer has an
extra argument to 0 and will ever be 0ed.

0 (which just asks next layer down) will suffice
for this.

layer cannot provide such a file descriptor.

case param will be non-NULL) and when a stream is being duplicated via
'&' in the 0.

API).  0 may be suitable for derived classes which
provide "fast gets" methods.

see the bytes in 0. If there is no obviously better implementation
then 0 provides the function by pushing a "fake"
"pending" layer above the calling layer.

method and then the 0 method of next layer down.

position to avoid overhead.

itself and close layers below, and then deallocate any data structures
(buffers, translation tables, ...) not  held directly in the data
structure.

buffered write data should be written, and file position of lower layers
adjusted for data read from below but not actually consumed.
(Should perhaps 0 such data to the lower layer.)

below.  When you "subclass" PerlIOBuf layer, you want to use its
0 method and to supply your own fill method, which fills the
PerlIOBuf's buffer.

0 otherwise.

to set the 0 flags, which may suffice.

PERLIO_F_LINEBUF flag and is normally sufficient.

return pointer to it. Return NULL on failure.

The application (or layer above) must ensure they are consistent.
(Checking is allowed by the paranoid.)

this does is really just to check that the pointer is non-NULL and
that the pointer behind that is non-NULL.)

the 0 pointer.

calls the 0 from the functions of the layer 0 (just by
the name of the IO function, like "Read") with the 0, or if
there is no such callback, calls the 0 version of the callback
with the same args, or if the f is invalid, set errno to EBADF and
return 0.

the 0 of the functions of the layer 0 with the 0,
or if there is no such callback, set errno to EINVAL.  Or if the f is
invalid, set errno to EBADF and return 0.

the 0 of the functions of the layer 0 with the 0,
or if there is no such callback, calls the 0 version of the
callback with the same args, or if the f is invalid, set errno to
EBADF.

0 of the functions of the layer 0 with the 0, or if
there is no such callback, set errno to EINVAL.  Or if the f is
invalid, set errno to EBADF.

look at the existing PerlIO layer implementations, which include:

"unix", "perlio", "stdio", "crlf", "utf8", "byte", "raw", "pending"
layers, and also the "mmap" and "win32" layers if applicable.
(The "win32" is currently unfinished and unused, to see what is used
instead in Win32, see 0 .)

words, implement only the methods that interest you.  The other methods
you can either replace with the "blank" methods

certain methods you may assume a default behaviour by using a NULL
method.  The Open method looks for help in the 'parent' layer.
The following table summarizes the behaviour:

0, 0. No buffering. Even on platforms that distinguish
between O_TEXT and O_BINARY this layer is always O_BINARY.

PerlIO API. It is also intended to be used as a "base class" for other
layers. (For example its 0 method is implemented in terms of
the 0/0/0 methods).

via PerlIO API. This is the default for USE_PERLIO when system's stdio
does not permit perl's "fast gets" access, and which do not
distinguish between 0 and 0.

implements it by calling system's stdio. This is (currently) the default
if system's stdio provides sufficient access to allow perl's "fast gets"
access and which do not distinguish between 0 and 0.

"\n" to CR,LF translation. Can either be applied above "perlio" or serve
as the buffer layer itself. "crlf" over "unix" is the default if system
distinguishes between 0 and 0 opens. (At some point
"unix" will be replaced by a "native" Win32 IO layer on that platform,
as Win32's read/write layer has various drawbacks.) The "crlf" layer is
a reasonable model for a layer which transforms data in some way.

"perlio" as a "base") which does "read" operations by ing the
file. Performance improvement is marginal on modern systems, so it is
mainly there as a proof of concept. It is likely to be unbundled from
the core at some point. The "mmap" layer is a reasonable model for a
minimalist "derived" layer.

 function for layers which have no buffer or cannot be
bothered.  (Basically this layer's 0 pops itself off the stack
and so resumes reading from layer below.)

"pushed" it actually pops the stack removing itself, it then calls
Binmode function table entry on all the layers in the stack - normally
this (via PerlIOBase_binmode) removes any layers which do not have
0 bit set. Layers can modify that behaviour by defining
their own Binmode entry.

0 flag on the layer which was (and now is once more)
the top of the stack.

functions which are intended to be used in the table slots of classes
which do not need to do anything special for a particular method.

is encountered the PerlIO code will perform the equivalent of :

will fail.

find it.  It is an example of a layer which takes an argument as it is
called thus:

of 0, and writes change the value. In both cases the position
in 0 starts as zero but can be altered via 0, and
determined via 0.

a layer). For example if the file is not opened through perl, but we
want to get back a fh, like it was opened by Perl.

should be set explicitly, when the error handling should be just
delegated to the top layer.

can be found.

to understand the API. Of course I agree that the API has to be
concise, but since there is no second document that is more of a
guide, I think that it'd make it easier to start with the doc which is
an API, but has examples in it in places where things are unclear, to
a person who is not a PerlIO guru (yet).

=encoding utf8

signals, named pipes, pipe opens, the Berkeley socket routines, and SysV
IPC calls.  Each is used in slightly different situations.

or references of user-installed signal handlers.  These handlers will
be called with an argument which is the name of the signal that
triggered it.  A signal may be generated intentionally from a
particular keyboard sequence like control-C or control-Z, sent to you
from another process, or triggered automatically by the kernel when
special events transpire, like a child process exiting, your own process
running out of stack space, or hitting a process file-size limit.

could in your handler; notice how all we do is set a global variable
and then raise an exception.  That's because on most systems,
libraries are not re-entrant; particularly, memory allocation and I/O
routines are not.  That meant that doing nearly 0 in your
handler could in theory trigger a memory fault and subsequent core
dump - see 0 below.

system, or you can retrieve them from the Config module.  Set up an
@signame list indexed by number to get the name and a %signo hash table
indexed by name to get the number:

the handler, in which case Perl will try to discard the signal or do the
default thing.

has special behavior with respect to a value of 0.
Setting 0 to 0 on such a platform has the effect of
not creating zombie processes when the parent process fails to 0
on its child processes (i.e., child processes are automatically reaped).
Calling 0 with 0 set to 0 usually returns
0 on such platforms.

(but not the TSTP) signals.  One strategy for temporarily ignoring signals
is to use a  on that hash element, automatically restoring a
previous value once your block is exited.  Remember that values created by
the dynamically-scoped  are "inherited" by functions called from
within their caller's scope.

to the entire Unix process group.  This code sends a hang-up signal to all
processes in the current process group, and also sets {HUP} to 0
so it doesn't kill itself:

actually affect a child process, but instead checks whether it's alive
or has changed its UID.

of the sending process, signal number zero may fail because
you lack permission to send the signal, even though the process is alive.
You may be able to determine the cause of failure using 0.

handlers:

to reinstall themselves.  Because Perl's signal mechanism is currently
based on the  function from the C library, you may sometimes be so
unfortunate as to run on systems where that function is "broken"; that
is, it behaves in the old unreliable SysV way rather than the newer, more
reasonable BSD and POSIX fashion.  So you'll see defensive people writing
signal handlers like this:

do a , then  for the result. Thus, your signal handler
(0 in the example) will be called. Because  was already
called by  or , the  in the signal handler will see no
more zombies and will therefore block.

example:

protected within an 0 block, you set a signal handler to trap
alarm signals and then schedule to have one delivered to you in some
number of seconds.  Then try your blocking operation, clearing the alarm
when it's done but not before you've exited your 0 block.  If it
goes off, you'll use  to jump out of the block, much as you might
using  or  in other languages.

is liable to generate zombies.    If this matters to you, you'll
need to do your own  and , and kill the errant child process.

module.  Lamentably, this is almost entirely undocumented, but
the 0 file from the Perl source distribution has some
examples in it.

when the system is shut down is called a daemon (Disk And Execution
MONitor). If a daemon process has a configuration file which is
modified after the process has been started, there should be a way to
tell that process to reread its configuration file without stopping
the process. Many daemons provide this mechanism using a 0
signal handler. When you want to tell the daemon to reread the file,
simply send it the 0 signal.

handlers after a signal delivery.  This means that the handler works
the first time the signal is sent, only. The solution to this problem
is to use 0 signal handlers if available; their behavior
is well-defined.

itself every time the 0 signal is received. The actual code is
located in the subroutine 0, which just prints some debugging
info to show that it works; it should be replaced with the real code.

danger from two things.  First, few system library functions are
re-entrant.  If the signal interrupts while Perl is executing one function
(like  or ), and your signal handler then calls the same
function again, you could get unpredictable behavior--often, a core dump.
Second, Perl isn't itself re-entrant at the lowest levels.  If the signal
interrupts Perl while Perl is changing its own internal data structures,
similarly unpredictable behavior may result.

pragmatic.  The paranoid approach was to do as little as possible in your
signal handler.  Set an existing integer variable that already has a
value, and return.  This doesn't help you if you're in a slow system call,
which will just restart.  That means you have to 0 to  out
of the handler.  Even this is a little cavalier for the true paranoiac,
who avoids 0 in a handler because the system 0 out to get you.
The pragmatic approach was to say "I know the risks, but prefer the
convenience", and to do anything you wanted in your signal handler,
and be prepared to clean up core dumps now and again.

when the signal is delivered to the process by the system (to the C code
that implements Perl) a flag is set, and the handler returns immediately.
Then at strategic "safe" points in the Perl interpreter (e.g. when it is
about to execute a new opcode) the flags are checked and the Perl level
handler from %SIG is executed. The "deferred" scheme allows much more
flexibility in the coding of signal handlers as we know the Perl
interpreter is in a safe state, and that we are not in a system library function when the handler is called.  However the implementation does
differ from previous Perls in the following ways:

to execute a new opcode, a signal that arrives during a long-running
opcode (e.g. a regular expression operation on a very large string) will
not be seen until the current opcode completes.

(such as from a fine-grained timer), the handler for that signal will
be called only once, after the opcode completes; all other
instances will be discarded.  Furthermore, if your system's signal queue
gets flooded to the point that there are signals that have been raised
but not yet caught (and thus not deferred) at the time an opcode
completes, those signals may well be caught and deferred during
subsequent opcodes, with sometimes surprising results.  For example, you
may see alarms delivered even after calling 0 as the latter
stops the raising of alarms but does not cancel the delivery of alarms
raised but not yet caught.  Do not depend on the behaviors described in
this paragraph as they are side effects of the current implementation and
may change in future versions of Perl.

system breaks into IO operations like , which is used to
implement Perl's  function, the  operator. On older
Perls the handler was called immediately (and as 0 is not "unsafe",
this worked well). With the "deferred" scheme the handler is 0 called
immediately, and if Perl is using the system's 0 library that
library may restart the 0 without returning to Perl to give it a
chance to call the %SIG handler. If this happens on your system the
solution is to use the 0 layer to do IO--at least on those handles
that you want to be able to break into with signals. (The 0 layer
checks the signal flags and calls %SIG handlers before resuming IO
operation.)

the 0 layer.

handler where that signal has interrupted an I/O operation on that same
handle. While perl will at least try hard not to crash, there are no
guarantees of data integrity; for example, some data might get dropped or
written twice.

their own implementations of timeouts which may conflict with your
timeouts.  If you have problems with such functions, try using the POSIX
 function, which bypasses Perl safe signals.  Be warned that
this does subject you to possible memory corruption, as described above.

the 0 module from CPAN, which affects
all signals.

SA_RESTART flag when installing %SIG handlers.  This meant that
restartable system calls would continue rather than returning when
a signal arrived.  In order to deliver deferred signals promptly,
Perl 5.7.3 and later do 0 use SA_RESTART.  Consequently,
restartable system calls can fail (with $! set to 0) in places
where they previously would have succeeded.

and 0 as described above; interrupted 0 and
0 calls will always be retried.

addressing errors and similar "faults". These are normally fatal: there is
little a Perl-level handler can do with them.  So Perl now delivers them
immediately rather than attempting to defer them.

something" before returning. One example can be CHLD or CLD, which
indicates a child process has completed. On some operating systems the
signal handler is expected to 0 for the completed child
process. On such systems the deferred signal scheme will not work for
those signals: it does not do the 0. Again the failure will
look like a loop as the operating system will reissue the signal because
there are completed child processes that have not yet been 0ed for.

memory corruption, set the environment variable 0 to
0.  This feature first appeared in Perl 5.8.1.

mechanism for processes communicating on the same machine.  It works
just like regular anonymous pipes, except that the
processes rendezvous using a filename and need not be related.

systems, .  These may not be in your normal path, though.

one.  When you open a fifo, the program will block until there's something
on the other end.

named pipe that has a Perl program on the other end.  Now every time any
program (like a mailer, news reader, finger program, etc.) tries to read
from that file, the reading program will read the new signature from your
program.  We'll use the pipe-checking file-test operator, 0, to find
out whether anyone (or anything) has accidentally removed our fifo.

interprocess communication by either appending or prepending a pipe
symbol to the second argument to .  Here's how to start
something up in a child process you intend to write to:

filenames in @ARGV, the clever programmer can write something like this:

read from the file 0, the process 0, standard input (0
in this case), the 0 file, the 0 command, and finally the 0
file.  Pretty nifty, eh?

same effect as opening a pipe for reading:

file one line or record at a time because then you don't have to read the
whole thing into memory at once.  It also gives you finer control of the
whole process, letting you kill off the child process early if you'd like.

you're 0 to a pipe, you should also trap SIGPIPE.  Otherwise,
think of what happens when you start up a pipe to a command that doesn't
exist: the  will in all likelihood succeed (it only reflects the
's success), but then your output will fail--spectacularly.  Perl
can't know whether the command worked, because your command is actually
running in a separate process whose  might have failed.  Therefore,
while readers of bogus commands return just a quick EOF, writers
to bogus commands will get hit with a signal, which they'd best be prepared
to handle.  Consider:

pipe buffering; physical writes are delayed.  That won't blow up until the
close, and it will blow up with a SIGPIPE.  To catch it, you could use
this:

STDIN, STDOUT, and STDERR filehandles.  If both processes try to access
them at once, strange things can happen.  You may also want to close
or reopen the filehandles for the child.  You can get around this by
opening your pipe with , but on some systems this means that the
child process cannot outlive the parent.

shell) will be the same as the parent's.  You won't need to catch
SIGCHLD because of the double-fork taking place; see below for details.

completely dissociate the child process from the parent.  This is
often called daemonization.  A well-behaved daemon will also 
to the root directory so it doesn't prevent unmounting the filesystem
containing the directory from which it was launched, and redirect its
standard file descriptors from and to 0 so that random
output doesn't wind up on the user's terminal.

process group leader; the  will fail if you are.  If your
system doesn't have the  function, open 0 and use the
0  on it instead.  See  for details.

other possible solutions.

multiprocess and communicate between--or even amongst--yourselves.  The
 function will accept a file argument of either 0 or 0
to do a very interesting thing: it forks a child connected to the
filehandle you've opened.  The child is running the same program as the
parent.  This is useful for safely opening a file when running under an
assumed UID or GID, for example.  If you open a pipe 0 minus, you can
write to the filehandle you opened and your kid will find it in 0
STDIN.  If you open a pipe 0 minus, you can read from the filehandle
you opened whatever your kid writes to 0 STDOUT.

something without the shell's interference.  With , it's
straightforward, but you can't use a pipe open or backticks safely.
That's because there's no way to stop the shell from getting its hands on
your arguments.   Instead, use lower-level control to call  directly.

indeed with any use of  with multiple subprocesses.  The
example above is "safe" because it is simple and calls .  See
0 for general safety principles, but there
are extra gotchas with Safe Pipe Opens.

cannot simply use  in the parent process to close an unwanted
writer.  Consider this code:

filehandle, so it closes it.  However, because WRITER was opened using
0, it has a special behavior: closing it calls
 (see 0), which waits for the subprocess
to exit.  If the child process ends up waiting for something happening
in the section marked "do something else", you have deadlock.

complicated code, which will call  on all open filehandles
during global destruction--in no predictable order.

 which sets one file descriptor to another, as shown below:

This is preferred when you wish to avoid having the shell interpret
metacharacters that may be in your command string.

command 0 spawning a shell, and reads its standard output via the
0 filehandle.  The corresponding syntax to 0 to command
pipes is to use 0 in place of 0.

literals whose content is perfectly safe.  There is therefore no cause to
resort to the harder-to-read, multi-argument form of pipe .  However,
whenever you cannot be assured that the program arguments are free of shell
metacharacters, the fancier form of  should be used.  For example:

pattern and indeed even the filenames themselves might hold metacharacters.

not be correctly implemented on all alien systems.  Additionally, these are
not true multithreading.  To learn more about threading, see the 0
file mentioned below in the SEE ALSO section.

closes whichever half of any pipes created for interprocess communication
it is not using.  This is because any child process reading from the pipe
and expecting an EOF will never receive it, and therefore never exit. A
single process closing a pipe is not enough to close it; the last process
with the pipe open must close it for it to read EOF.

instance, filehandles have a "close on exec" flag, which is set 0
under control of the 0 variable.  This is so any filehandles you
didn't explicitly route to the STDIN, STDOUT or STDERR of a child
0 will be automatically closed.

pipe, unless that process is actually writing to it.  Even if you don't
explicitly call , Perl will still  all filehandles during
global destruction.  As previously discussed, if those filehandles have
been opened with Safe Pipe Open, this will result in calling ,
which may again deadlock.

about bidirectional communication?  The most obvious approach doesn't work:

helpful diagnostic message:

0 module to catch both ends.  There's also an  in
0 for tridirectional I/O so you can also catch your child's
STDERR, but doing so would then require an awkward  loop and
wouldn't allow you to use normal Perl input operations.

primitives like the  and  syscalls to create all the
connections.  Although it might have been more efficient by using
, this would have been even less portable than it already
is. The  and  functions are unlikely to work anywhere
except on a Unix system, or at least one purporting POSIX compliance.

Hold on, is this even true?  First it says that  is avoided
for portability, but then it says it probably won't work except on
Unixy systems anyway.  Which one of those is true?

day.  Even though your 0 filehandle is auto-flushed so the process
on the other end gets your data in a timely manner, you can't usually do
anything to force that process to give its data to you in a similarly quick
fashion.  In this special case, we could actually so, because we gave
0 a 0 flag to make it unbuffered.  But very few commands are
designed to operate over pipes, so this seldom works unless you yourself
wrote the program on the other end of the double-ended pipe.

program behave more reasonably.  This way you don't have to have control
over the source code of the program you're using.  The 0 module
from CPAN also addresses this kind of thing.  This module requires two
other modules from CPAN, 0 and 0.  It sets up a pseudo
terminal to interact with programs that insist on talking to the terminal
device driver.  If your system is supported, this may be your best bet.

this together by hand.  This example only talks to itself, but you could
reopen the appropriate handles to STDIN and STDOUT and call other processes.
(The following example lacks proper error checking.)

have the  system call, it will do this all for you.

on PCs provides socket support, as do some VMS libraries), you might not have
sockets on your system, in which case this section probably isn't going to
do you much good.  With sockets, you can do both virtual circuits like TCP
streams and datagrams like UDP packets.  You may be able to do even more
depending on your system.

the corresponding system calls in C, but their arguments tend to differ
for two reasons.  First, Perl filehandles work differently than C file
descriptors.  Second, Perl already knows the length of its strings, so you
don't need to pass that information.

was that it used hard-coded values for some of the constants, which
severely hurt portability.  If you ever see code that does anything like
explicitly setting 0, you know you're in for big trouble.
An immeasurably superior approach is to use the 0 module, which more
reliably grants access to the various constants and functions you'll need.

NNTP or SMTP, you should give some thought to how your server will
know when the client has finished talking, and vice-versa.  Most
protocols are based on one-line messages and responses (so one party
knows the other has finished when a "\n" is received) or multi-line
messages and responses that end with a period on an empty line
("\n.\n" terminates a message/response).

Unix, that could usually be written as "\r\n", but under other systems,
"\r\n" might at times be "\015\015\012", "\012\012\015", or something
completely different.  The standards specify writing "\015\012" to be
conformant (be strict in what you provide), but they also recommend
accepting a lone "\012" on input (be lenient in what you require).
We haven't always been very good about that in the code in this manpage,
but unless you're on a Mac from way back in its pre-Unix dark ages, you'll
probably be ok.

communication that might extend to machines outside of your own system.

leave the address as 0 so that the kernel can choose
the appropriate interface on multihomed hosts.  If you want sit
on a particular interface (like the external side of a gateway
or firewall machine), fill this in with your real address instead.

like most typical servers, it spawns (s) a slave server to
handle the client request so that the master server can quickly
go back to service a new client.

for each incoming request.  That way it can handle many requests at
once, which you might not always want.  Even if you don't , the
 will allow that many pending connections.  Forking servers
have to be particularly careful about cleaning up their dead children
(called "zombies" in Unix parlance), because otherwise you'll quickly
fill up your process table.  The REAPER subroutine is used here to
call  for any child processes that have finished, thereby
ensuring that they terminate cleanly and don't join the ranks of the
living dead.

a false value.  This would normally indicate a system error needs
to be reported.  However, the introduction of safe signals (see
0 above) in Perl 5.7.3 means that
 might also be interrupted when the process receives a signal.
This typically happens when one of the forked subprocesses exits and
notifies the parent process with a CHLD signal.

If this happens, we can safely continue to the next iteration of
the loop and another call to .  It is important that your
signal handling code not modify the value of $!, or else this test
will likely fail.  In the REAPER subroutine we create a local version
of $! before calling .  When  sets $! to ECHILD as
it inevitably does when it has no more children waiting, it
updates the local copy and leaves the original unchanged.

even if we aren't running setuid or setgid.  This is always a good idea
for servers or any program run on behalf of someone else (like CGI
scripts), because it lessens the chances that people from the outside will
be able to compromise your system.

service on a number of different machines and shows how far their clocks
differ from the system on which it's being run:

communications?  While you can use the same setup, sometimes you don't
want to.  Unix-domain sockets are local to the current host, and are often
used internally to implement pipes.  Unlike Internet domain sockets, Unix
domain sockets can show up in the file system with an  listing.

network terminators here because Unix domain sockets are guaranteed
to be on the localhost, and thus everything works right.

much so, in fact, that we've omitted several duplicate functions--,
, , and --which are the same as in the other server.

simpler named pipe?  Because a named pipe doesn't give you sessions.  You
can't tell one process's data from another's.  With socket programming,
you get a separate session for each client; that's why  takes two
arguments.

that you want folks to be able to access from the Web, but only
if they go through a CGI interface.  You'd have a small, simple CGI
program that does whatever checks and logging you feel like, and then acts
as a Unix-domain client and connects to your private server.

IO::Socket module provides an object-oriented approach.  IO::Socket has
been included in the standard Perl distribution ever since Perl 5.004.  If
you're running an earlier version of Perl (in which case, how are you
reading this manpage?), just fetch IO::Socket from CPAN, where you'll also
find modules providing easy interfaces to the following systems: DNS, FTP,
Ident (RFC 931), NIS and NISPlus, NNTP, Ping, POP3, SMTP, SNMP, SSLeay,
Telnet, and Time--to name just a few.

service at port 13 of the host name "localhost" and prints out everything
that the server there cares to provide.

looks like this:

will be connected to a TCP socket, because we want a stream-oriented
connection, that is, one that acts pretty much like a plain old file.
Not all sockets are this of this type.  For example, the UDP protocol
can be used to make a datagram socket, used for message-passing.

running on.  We could have specified a longer name like 0,
or an address like 0.  For demonstration purposes, we've
used the special hostname 0, which should always mean the
current machine you're running on.  The corresponding Internet address
for localhost is 0, if you'd rather use that.

We could have gotten away with using just 0 on systems with a
well-configured system services file,[FOOTNOTE: The system services file
is found in 0 under Unixy systems.] but here we've specified the
port number (13) in parentheses.  Using just the number would have also
worked, but numeric literals make careful programmers nervous.

a filehandle in the 0 loop?  That's what's called an 0, a scalar variable containing a filehandle.  You can use
it the same way you would a normal filehandle.  For example, you
can read one line from it this way:

from, and then a list of files to get from that host.  This is a
more interesting client than the previous one because it first sends
something to the server before fetching the server's response.

its standard port, number 80.  If the server you're trying to
connect to is at a different port, like 1080 or 8080, you should specify it
as the named-parameter pair, .  The 0
method is used on the socket because otherwise the system would buffer
up the output we sent it.  (If you're on a prehistoric Mac, you'll also
need to change every 0 in your code that sends data over the network
to be a 0 instead.)

have the connection, you have to use the server's language.  Each server
on the network has its own little command language that it expects as
input.  The string that we send to the server starting with "GET" is in
HTTP syntax.  In this case, we simply request each specified document.
Yes, we really are making a new connection for each document, even though
it's the same host.  That's the way you always used to have to speak HTTP.
Recent versions of web browsers may request that the remote server leave
the connection open a little while, but the server doesn't have to honor
such a request.

particular document.  But a long response wouldn't have fit on this page.

the 0 program included with the LWP modules from CPAN.

but what about setting up something fully interactive, somewhat like
the way 0 works?  That way you can type a line, get the answer,
type a line, get the answer, etc.

you're on a system that supports the powerful 0 call, the solution
isn't that rough.  Once you've made the connection to whatever service
you'd like to chat with, call 0 to clone your process.  Each of
these two identical process has a very simple job to do: the parent
copies everything from the socket to standard output, while the child
simultaneously copies everything from standard input to the socket.
To accomplish the same thing using just one process would be 0
harder, because it's easier to code two processes to do one thing than it
is to code one process to do two things.  (This keep-it-simple principle
a cornerstones of the Unix philosophy, and good software engineering as
well, which is probably why it's spread to other systems.)

signal to our child process, currently running in the 0 block,
as soon as the remote server has closed its end of the connection.

data immediately without waiting for a newline (which might not happen),
you may wish to replace the 0 loop in the parent with the
following:

(to put it mildly) but is the simplest to explain and works reasonably
well.

The model is that the server creates a special kind of socket that
does nothing but listen on a particular port for incoming connections.
It does this by calling the  method with
slightly different arguments than the client did.

still specify 0 here.

port in the 0 argument, which we didn't do for the client.
This is service name or port number for which you want to be the
server. (Under Unix, ports under 1024 are restricted to the
superuser.)  In our sample, we'll use port 9000, but you can use
any port that's not currently in use on your system.  If you try
to use one already in used, you'll get an "Address already in use"
message.  Under Unix, the 0 command will show
which services current have servers.

pending connections we can accept until we turn away incoming clients.
Think of it as a call-waiting queue for your telephone.
The low-level Socket module has a special symbol for the system maximum, which
is SOMAXCONN.

manually without waiting a few minutes to allow system buffers to
clear out.

listed above, the server then waits for a new client to connect
to it.  The server blocks in the 0 method, which eventually accepts a
bidirectional connection from the remote client.  (Make sure to autoflush
this handle to circumvent buffering.)

Most servers don't do this.  Because of the prompt without a newline,
you'll have to use the 0 variant of the interactive client above.

the client.  Unlike most network servers, this one handles only one
incoming client at a time.  Multithreaded servers are covered in
Chapter 16 of the Camel.

messages.  UDP communications involve much lower overhead but also provide
less reliability, as there are no promises that messages will arrive at
all, let alone in order and unmangled.  Still, UDP offers some advantages
over TCP, including being able to "broadcast" or "multicast" to a whole
bunch of destination hosts at once (usually on your local subnet).  If you
find yourself overly concerned about reliability and start building checks
into your message system, then you probably should use just TCP to start
with.

This makes using I/O mechanisms with internal buffering like stdio (i.e.
 and friends) especially cumbersome. Use , or better
, like in the example below.

earlier.  However, instead of checking one host at a time, the UDP version
will check many of them asynchronously by simulating a multicast and then
using  to do a timed-out wait for I/O.  To do something similar
with TCP, you'd have to use a different socket handle for each host.

contact a reachable host. The most prominent reason for this is congestion
of the queues on the sending host if the number of hosts to contact is
sufficiently large.

interesting uses.  However, you cannot use SysV IPC or Berkeley  to
have a variable shared amongst several processes.  That's because Perl
would reallocate your string when you weren't wanting it to.  You might
look into the 0 or 0 modules for that.

Call the file 0:

Call this file 0:

clunky looking.  For a more modern look, see the IPC::SysV module
which is included with Perl starting from Perl 5.005.

fail instead of causing your program to die right then and there due to
an uncaught exception.  (Actually, some of the new 0 conversion
functions do  on bad arguments.)  It is therefore essential to
check return values from these functions.  Always begin your socket
programs this way for optimal success, and don't forget to add the 0
taint-checking flag to the 0 by W. Richard Stevens (published by
Prentice-Hall).  Most books on networking address the subject from the
perspective of a C programmer; translation to Perl is left as an exercise
for the reader.

manpage describes the low-level interface to sockets.  Besides the obvious
functions in 0, you should also check out the 0 file at
your nearest CPAN site, especially
0.
See 0 or best yet, the 0 for a description
of what CPAN is and where to get it if the previous link doesn't work
for you.

Control (modems), and Interprocess Communication", and contains numerous
unbundled modules numerous networking modules, Chat and Expect operations,
CGI programming, DCE, FTP, IPC, NNTP, Proxy, Ptty, RPC, SNMP, SMTP, Telnet,
Threads, and ToolTalk--to name just a few. 

=encoding utf8

0 0 0

to be enabled in which parts of a Perl program. It's a more flexible
alternative for both the command line flag 0 and the equivalent Perl
variable, 0.

This means that the scope of the warning pragma is limited to the
enclosing block. It also means that the pragma setting will not
leak across files (via 0, 0 or 0). This allows
authors to independently define the degree of warning checks that will
be applied to their module.

doesn't attempt to control the warnings will work unchanged.

block has them disabled. In this case that means the assignment to the
scalar 0 will trip the 0
warning, but the assignment to the scalar 0 will not.

warnings: mandatory and optional.

would get a warning whether you wanted it or not.
For example, the code below would always produce an 0
warning about the "2:".

0 warnings. The difference is that although the previously
mandatory warnings are still enabled by default, they can then be
subsequently enabled or disabled with the lexical warning pragma. For
example, in the code below, an 0 warning will only
be reported for the 0 variable.

disable/enable default warnings. They are still mandatory in this case.

line to enable warnings is that it is all or nothing. Take the typical
scenario when you are writing a Perl program. Parts of the code you
will write yourself, but it's very likely that you will make use of
pre-written Perl modules. If you use the 0 flag in this case, you
end up enabling warnings in pieces of code that you haven't written.

fundamentally flawed. For a start, say you want to disable warnings in
a block of code. You might expect this to be enough to do the trick:

for the 0 line:  0.

disable compile-time warnings you need to rewrite the code like this:

change the warning setting in unexpected places in your code. For example,
when the code below is run (without the 0 flag), the second call
to 0 will trip a 0 warning, whereas
the first will not.

over where warnings can or can't be tripped.

warnings are (or aren't) produced:

0

used in any of you code, or any of the modules that you use, this flag
will enable warnings everywhere. See 0 for
details of how this flag interacts with lexical warnings.

0

throughout the program regardless of whether warnings were disabled
locally using 0 or 0. This includes all files that get
included via 0, 0 or 0.
Think of it as the Perl equivalent of the "lint" command.

0

introduction of lexically scoped warnings, or have code that uses both
lexical warnings and 0, this section will describe how they interact.

control warnings is used and neither 0 or the 0 pragma
are used, then default warnings will be enabled and optional warnings
disabled.
This means that legacy code that doesn't attempt to control the warnings
will work unchanged.

means that any legacy code that currently relies on manipulating 0
to control warning behavior will still work as is.

the same horrible uncontrolled global way, except that it cannot
disable/enable default warnings.

both the 0 variable and the 0 flag will be ignored for the
scope of the lexical warning.

or 0 command line flags.

the 0 pragma to control the warning behavior of $^W-type
code (using a 0) if it really wants to, but not vice-versa.

0

to be enabled/disabled in isolation.

0 pragma in a given scope the cumulative effect is additive.

0.

sub-category of the "syntax" category. It is now a top-level category
in its own right.

0

warnings detected from the categories specified in the lexical scope
into fatal errors. In the code below, the use of 0, 0
and 0 can all produce a 0
warning.

category into a fatal error, so the program terminates immediately it
encounters the warning.

it is associated with.  So, for example, to disable the "void" warning
in the example above, either of these will do the trick:

error back to a normal warning, you can use the "NONFATAL" keyword. For
example, the code below will promote all warnings into fatal errors,
except for those in the "syntax" category.

0 0

module authors. These are used when you want to report a module-specific
warning to a calling module has enabled warnings via the 0
pragma.

called "MyMod::Abc", i.e. the new category name matches the current
package name. The 0 function in the module will display a warning
message if it gets given a relative path as a parameter. This warnings
will only be displayed if the code that uses 0 has actually
enabled them with the 0 pragma like below.

set in the calling module with the 0 function. Consider
this snippet of code:

display a warning message whenever the calling module has (at least) the
"deprecated" warnings category enabled. Something like this, say.

used to actually display the warnings message. This is because they can
make use of the feature that allows warnings to be escalated into fatal
errors. So in this case

displaying the warning message.

and 0 can optionally take an object reference in place
of a category name. In this case the functions will use the class name
of the object as the warnings category.

0.

a warning.

used.

warnings::register like this:

=encoding utf8

continues to support them.  See 0 below.

a letter", "what is the uppercase equivalent of this letter", and
"which of these letters comes first".  These are important issues,
especially for languages other than English--but also for English: it
would be na0ve to imagine that 0 defines all the "letters"
needed to write correct English. Perl is also aware that some character other
than "." may be preferred as a decimal point, and that output date
representations may be language-specific.  The process of making an
application take account of its users' preferences in such matters is
called 0 (often abbreviated as 0); telling
such an application about a particular set of preferences is known as
0 (0).

XPG4, POSIX 1.c) method called "the locale system". The locale system is
controlled per application using one pragma, one function call, and
several environment variables.

application specifically requests it--see 0.
The one exception is that  now 0 uses the current locale
- see 0.

correctly according a locale of your choice, 0 of the following
must be true:

you should find that the  function is a documented part of
its C library.

your system administrator, must make sure that this is the case. The
available locales, the location in which they are kept, and the manner
in which they are installed all vary from system to system.  Some systems
provide only a few, hard-wired locales and do not allow more to be
added.  Others allow you to add "canned" locales provided by the system
supplier.  Still others allow you or the system administrator to define
and add arbitrary locales.  (You may have to ask your supplier to
provide canned locales that are not delivered with your operating
system.)  Read your system documentation for further illumination.

0 will say that the value for 0 is
0.

according to a particular locale, the application code should include
the S<0 pragma (see 0) where
appropriate, and 0 at the time the application is started, either
by yourself or by whoever set up your system account; or

0.

pragma and the 0 regular expression modifier tell Perl to use the
current locale for some operations (0 for just pattern matching).

0 described below.  If that function
hasn't yet been called in the course of the program's execution, the
current locale is that which was determined by the 0 in
effect at the start of the program, except that
C<0 is always
initialized to the C locale (mentioned under 0).
If there is no valid environment, the current locale is undefined.  It
is likely, but not necessarily, the "C" locale.

the POSIX string collation functions  and  use
0.   is also affected if used without an
explicit comparison function, because it uses 0 by default.

perform a char-by-char comparison of their scalar operands.  What's
more, if 0 finds that its operands are equal according to the
collation sequence specified by the current locale, it goes on to
perform a char-by-char comparison, and only returns 0 (equal) if the
operands are char-for-char identical.  If you really want to know whether
two strings--which 0 and 0 may consider different--are equal
as far as collation in the locale is concerned, see the discussion in
0.

, and ) use 0

0.

upon reaching the end of block enclosing 0.

information is tainted, as it is possible for a locale to be
untrustworthy.  See 0.

POSIX:: function:

0.  The category tells in what aspect of data processing you
want to apply locale-specific rules.  Category names are discussed in
0 and 0.  The locale is the name of a
collection of customization information corresponding to a particular
combination of language, country or territory, and codeset.  Read on for
hints on the naming of locales: not all systems name locales as in the
example.

than LC_ALL, the function returns a string naming the current locale
for the category.  You can use this value as the second argument in a
subsequent call to .

result is implementation-dependent.  It may be a string of
concatenated locale names (separator also implementation-dependent)
or a single locale name.  Please consult your  man page for
details.

the locale for the category is set to that value, and the function
returns the now-current locale value.  You can then use this in yet
another call to .  (In some implementations, the return
value may sometimes differ from the value you gave as the second
argument--think of it as an alias for the value you gave.)

category's locale is returned to the default specified by the
corresponding environment variables.  Generally, this results in a
return to the default that was in force when Perl started up: changes
to the environment made by the application after startup may or may not
be noticed, depending on your system's C library.

for the category is not changed, and the function returns 0.

see whether it leads to the list of available locales (search for the
0 section).  If that fails, try the following command lines:

standardized, names of locales and the directories where the
configuration resides have not been.  The basic form of the name is
000, but the latter parts after
0 are not always present.  The 0 and 0
are usually from the standards 0 and 0, the
two-letter abbreviations for the countries and the languages of the
world, respectively.  The 0 part often mentions some 0 character set, the Latin codesets.  For example, 0
is the so-called "Western European codeset" that can be used to encode
most Western European languages adequately.  Again, there are several
ways to write even the name of that one standard.  Lamentably.

Currently these are effectively the same locale: the difference is
mainly that the first one is defined by the C standard, the second by
the POSIX standard.  They define the 0 in which
every program starts in the absence of locale information in its
environment.  (The 0 default locale, if you will.)  Its language
is (American) English and its character codeset ASCII.
0. The C locale delivered by some vendors may not
actually exactly match what the C standard calls for.  So beware.

POSIX-conformant), so use "C" when you need explicitly to specify this
default locale.

LANG exists but has no value.  Perl tried to believe you but could not.
Instead, Perl gave up and fell back to the "C" locale, the default locale
that is supposed to work no matter what.  This usually means your locale
settings were wrong, they mention locales your system has never heard
of, or the locale installation in your system has problems (for example,
some system files are broken or missing).  There are quick and temporary
fixes to these problems, as well as more thorough and lasting fixes.

locale inconsistencies or to run Perl under the default locale "C".

environment variable PERL_BADLANG to a zero value, for example "0".
This method really just sweeps the problem under the carpet: you tell
Perl to shut up even when Perl sees that something is wrong.  Do not
be surprised if later something locale-dependent misbehaves.

variable LC_ALL to "C".  This method is perhaps a bit more civilized
than the PERL_BADLANG approach, but setting LC_ALL (or
other locale variables) may affect other programs as well, not just
Perl.  In particular, external programs run from within Perl will see
these changes.  If you make the new settings permanent (read on), all
programs you run see the changes.  See 0 for
the full list of relevant environment variables and 0
for their effects in Perl.  Effects in other programs are
easily deducible.  For example, the variable LC_COLLATE may well affect
your 0 program (or whatever the program that arranges "records"
alphabetically in your system is called).

new settings seem to help, put those settings into your shell startup
files.  Consult your local documentation for the exact details.  For in
Bourne-like shells (0, 0, 0, 0):

discussed above.  We decided to try that instead of the above faulty
locale "En_US"--and in Cshish shells (0, 0)

helpdesk or the equivalent.

fix the misconfiguration of your own environment variables.  The
mis(sing)configuration of the whole system's locales usually requires
the help of your friendly system administrator.

how to find which locales are really supported--and more importantly,
installed--on your system.  In our example error message, environment
variables affecting the locale are listed in the order of decreasing
importance (and unset variables do not matter).  Therefore, having
LC_ALL set to "En_US" must have been the bad choice, as shown by the
error message.  First try fixing locale settings listed first.

(prefix matches do not count and case usually counts) like "En_US"
without the quotes, then you should be okay because you are using a
locale name that should be installed and available in your system.
In this case, see 0.

commands.  You may see things like "en_US.ISO8859-1", but that isn't
the same.  In this case, try running under a locale
that you can list and which somehow matches what you tried.  The
rules for matching locale names are a bit vague because
standardization is weak in this area.  See again the
0 about general rules.

error message you get, and ask them to read this same documentation you
are now reading.  They should be able to check whether there is something
wrong with the locale configuration of the system.  The 0
section is unfortunately a bit vague about the exact commands and places
because these things are not that standardized.

locale-dependent numeric formatting information specified by the current
0 and 0 locales.  (If you just want the name of
the current locale for a particular category, use POSIX::
with a single parameter--see 0.)

The keys of this hash are variable names for formatting, such as
0 and 0.  The values are the
corresponding, er, values.  See 0 for a longer
example listing the categories an implementation might be expected to
provide; some provide more and others fewer.  You don't need an
explicit 0, because  always observes the
current locale.

parameters as integers correctly formatted in the current locale:

I18N::Langinfo:: function, available at least in Unix-like
systems and VMS.

three constants to be used as arguments to : a constant for
the abbreviated first day of the week (the numbering starts from
Sunday = 1) and two more constants for the affirmative and negative
answers for a yes/no question in the current locale.

print something like:

some combination categories allow manipulation of more than one
basic category at a time.  See 0 for a discussion of these.

environment variable to determine the application's notions on collation
(ordering) of characters.  For example, "b" follows "a" in Latin
alphabets, but where do "0" and "0 has appeared earlier in the same block) must be used for
sorting raw binary data, whereas the locale-dependent collation of the
first example is useful for natural text.

collation locale when 0 is in effect, but falls back to a
char-by-char comparison for strings that the locale says are equal. You
can use POSIX:: if you don't want this fall-back:

dictionary-like ordering that ignores space characters completely and
which folds case.

locale" against several others, you might think you could gain a little
efficiency by using POSIX:: in conjunction with 0:

in char-by-char comparisons against other transformed strings during
collation.  "Under the hood", locale-affected Perl comparison operators
call  for both operands, then do a char-by-char
comparison of the transformed strings.  By calling  explicitly
and using a non locale-affected comparison, the example attempts to save
a couple of transformations.  But in fact, it doesn't save anything: Perl
magic (see 0) creates the transformed version of a
string the first time it's needed in a comparison, then keeps this version around
in case it's needed again.  An example rewritten the easy way with
0 runs just about as fast.  It also copes with null characters
embedded in strings; if you call  directly, it treats the first
null it finds as a terminator.  don't expect the transformed strings
it produces to be portable across systems--or even from one revision
of your operating system to the next.  In short, don't call 
directly: let Perl do it for you.

needed:  and  exist only to generate locale-dependent
results, and so always obey the current 0 locale.

setting.  This controls the application's notion of which characters are
alphabetic.  This affects Perl's 0 regular expression metanotation,
which stands for alphanumeric characters--that is, alphabetic,
numeric, and including other special characters such as the underscore or
hyphen.  (Consult 0 for more information about
regular expressions.)  Thanks to 0, depending on your locale
setting, characters like "0", "0", "0", and
"0" may be understood as 0 characters.

characters between lower and uppercase.  This affects the case-mapping
functions--, lcfirst, , and ; case-mapping
interpolation with 0, 0, 0, or 0 in double-quoted strings
and 0 substitutions; and case-independent regular expression
pattern matching using the 0 modifier.

functions--, , and so on.  For example, if you move
from the "C" locale to a 7-bit Scandinavian one, you may find--possibly
to your surprise--that "|" moves from the  class to .

in clearly ineligible characters being considered to be alphanumeric by
your application.  For strict matching of (mundane) ASCII letters and
digits--for example, in command strings--locale-aware applications
should use 0 with the 0 regular expression modifier.  See 0.

locale information, which controls an application's idea of how numbers
should be formatted for human readability by the , , and
 functions. String-to-numeric conversion by the POSIX::
function is also affected.  In most implementations the only effect is to
change the character used for the decimal point--perhaps from "."  to ",".
These functions aren't aware of such niceties as thousands separation and
so on. (See 0 if you care about these things.)

corresponds to what you'd get from  in the "C" locale.  The
same is true for Perl's internal conversions between numeric and
string formats:

that is affected by its contents.  (Those with experience of standards
committees will recognize that the working group decided to punt on the
issue.)  Consequently, Perl takes no notice of it.  If you really want
to use 0, you can query its contents--see
0--and use the information that it returns in your
application's own formatting of currency amounts.  However, you may well
find that the information, voluminous and complex though it may be, still
does not quite meet your requirements: currency formatting is a hard nut
to crack.

human-readable date/time string, is affected by the current 0
locale.  Thus, in a French locale, the output produced by the 0
format element (full month name) for the first month of the year would
be "janvier".  Here's how to get a list of long month names in the
current locale:

exists only to generate locale-dependent results,  always
obeys the current 0 locale.

0..0, and 0..0.

by others in particular implementations) is not currently used by
Perl--except possibly to affect the behavior of library functions
called by extensions outside the standard Perl distribution and by the
operating system and its utilities.  Note especially that the string
value of 0 and the error messages given by external utilities may
be changed by 0.  If you want to have portable error
codes, use 0.  See 0.

0, a discussion of Perl's locale handling would be incomplete
if it did not draw your attention to locale-dependent security issues.
Locales--particularly on systems that allow unprivileged users to
build their own locales--are untrustworthy.  A malicious (or just plain
broken) locale can make a locale-aware application give unexpected
results.  Here are a few possibilities:

0 may be spoofed by an 0 locale that claims that
characters such as "0, may produce dangerous results if a bogus LC_CTYPE
case-mapping table is in effect.

"D" grades appearing ahead of those with "A"s.

0 may format debits as if they were credits and vice versa
if that locale has been subverted.  Or it might make payments in US
dollars instead of Hong Kong dollars.

manipulated to advantage by a malicious user able to subvert the
0 locale.  ("Look--it says I wasn't in the building on
Sunday.")

application's environment which may be modified maliciously presents
similar challenges.  Similarly, they are not specific to Perl: any
programming language that allows you to write programs that take
account of their environment exposes you to these issues.

examples--there is no substitute for your own vigilance--but, when
0 is in effect, Perl uses the tainting mechanism (see
0) to mark string results that become locale-dependent, and
which may be untrustworthy in consequence.  Here is a summary of the
tainting behavior of operators and functions that may be affected by
the locale:

0 is in effect.

are tainted if 0 is in effect, and the subpattern regular
expression contains 0 (to match an alphanumeric character), 0
(non-alphanumeric character), 0 (whitespace character), or 0
(non whitespace character).  The matched-pattern variable, $&, $`
(pre-match), $' (post-match), and $+ (last match) are also tainted if
0 is in effect and the regular expression contains 0,
0, 0, or 0.

operand of 0 becomes tainted when 0 in effect
if modified as a result of a substitution based on a regular
expression match involving 0, 0, 0, or 0; or of
case-mapping with 0, 0,0 or 0.

for example 0, should be tainted if 0 is in
effect.

, ):

, , , , , ,
):

The first program, which ignores its locale, won't run: a value taken
directly from the command line may not be used to name an output file
when taint checks are enabled.

a regular expression: the second example--which still ignores locale
information--runs, creating the file named on its command line
if it can.

of a match involving 0 while 0 is in effect.

at startup.  Failure can occur if the locale support in the operating
system is lacking (broken) in some way--or if you mistyped the name of
a locale when you set up your environment.  If this environment
variable is absent, or has a value that does not evaluate to integer
zero--that is, "0" or ""-- Perl will complain about locale setting
failures.

The message tells about some problem in your system's locale support,
and you should investigate what the problem is.

part of the standardized (ISO C, XPG4, POSIX 1.c)  method
for controlling an application's opinion on data.

set, it overrides all the rest of the locale environment variables.

are using the GNU libc.  This is the case if you are using e.g. Linux.
If you are using "commercial" Unixes you are most probably 0
using GNU libc and you can ignore 0.

language of informational, warning, and error messages output by
commands (in other words, it's like 0) but it has higher
priority than 0.  Moreover, it's not a single value but
instead a "path" (":"-separated list) of 0 (not locales).
See the GNU 0 library documentation for more information.

locale.  In the absence of both 0 and 0, 0
chooses the character type locale.

(sorting) locale.  In the absence of both 0 and 0,
0 chooses the collation locale.

formatting locale.  In the absence of both 0 and 0,
0 chooses the monetary formatting locale.

locale.  In the absence of both 0 and 0, 0
chooses the numeric format.

formatting locale.  In the absence of both 0 and 0,
0 chooses the date and time formatting locale.

is used as the last resort after the overall 0 and the
category-specific 0.

generally behaving as if something similar to the 0 locale were
always in force, even if the program environment suggested otherwise
(see 0).  By default, Perl still behaves this
way for backward compatibility.  If you want a Perl application to pay
attention to locale information, you 0 use the S<0
pragma (see 0) or for just pattern matching, the
0 regular expression modifier (see 0) to instruct it to do so.

information if available; that is, 0 did understand what
were the letters according to the locale environment variables.
The problem was that the user had no control over the feature:
if the C library supported locales, Perl used them.

using the 0 library module.  This module is now mildly
obsolete and should be avoided in new applications.  The 0
functionality is now integrated into the Perl core language: One can
use locale-specific scalar data completely normally with 0,
so there is no longer any need to juggle with the scalar references of
0 is in effect when the format is declared, the locale is used
to specify the decimal point character in formatted output.  Formatted
output cannot be controlled by 0 at the time when 
is called.

unsupported, and is not claimed to be fit for any purpose.  If your
system allows installation of arbitrary locales, you may find the
definitions useful as they are, or as a basis for the development of
your own locales.

and last letters are separated by eighteen others.  (You may guess why
the internalin ... internaliti ... i18n tends to get abbreviated.)  In
the same way, "localization" is often abbreviated to 0.

criticized as incomplete, ungainly, and having too large a granularity.
(Locales apply to a whole process, when it would arguably be more useful
to have them apply to a single thread, window group, or whatever.)  They
also have a tendency, like standards groups, to divide the world into
nations, when we all know that the world can equally well be divided
into bankers, bikers, gamers, and so on.

implemented in version 5.8 and later.  See 0.  Perl tries to
work with both Unicode and locales--but of course, there are problems.

Asian languages, such as Big5 or Shift JIS.  However, the increasingly common
multi-byte UTF-8 locales, if properly implemented, tend to work
reasonably well in Perl, simply because both they and Perl store
characters that take up multiple bytes the same way.

in a single byte, and Unicode rules for those that can't (though this wasn't
uniformly applied prior to Perl 5.14).  This prevents many problems in locales
that aren't UTF-8.  Suppose the locale is ISO8859-7, Greek.  The character at
0xD7 there is a capital Chi. But in the ISO8859-1 locale, Latin1, it is a
multiplication sign.  The POSIX regular expression character class
0 will magically match 0xD7 in the Greek locale but not in the
Latin one, even if the string is encoded in UTF-8, which would normally imply
Unicode semantics.  (The "U" in UTF-8 stands for Unicode.)

for Unicode only, such as 0.  They assume that 0xD7 always has its
Unicode meaning (or the equivalent on EBCDIC platforms).  Since Latin1 is a
subset of Unicode and 0xD7 is the multiplication sign in both Latin1 and
Unicode, 0 will never match it, regardless of locale.  A similar
issue occurs with 0.  It is therefore a bad idea to use 0 or
0 under 0--0 you can guarantee that the locale will
be a ISO8859-1 or UTF-8 one.  Use POSIX character classes instead.

standard file handles, default 0 layer, and 0 on non-ISO8859-1,
non-UTF-8 locales (by using either the 0 command line switch or the
0 environment variable; see 0).
Things are read in as UTF-8, which would normally imply a Unicode
interpretation, but the presence of a locale causes them to be interpreted
in that locale instead.  For example, a 0xD7 code point in the Unicode
input, which should mean the multiplication sign, won't be interpreted by
Perl that way under the Greek locale.  Again, this is not a problem
0 you make certain that all locales will always and only be either
an ISO8859-1 or a UTF-8 locale.

its locale-handling code because this interacts with code that Perl has no
control over; therefore the locale-handling code in Perl may be buggy as
well.  But if you 0 have locales that work, using them may be
worthwhile for certain specific purposes, as long as you keep in mind the
gotchas already mentioned.  For example, collation runs faster under
locales than under 0 (albeit with less flexibility), and
you gain access to such things as the local currency symbol and the names
of the months and days of the week.

is broken and cannot be fixed or used by Perl.  Such deficiencies can
and will result in mysterious hangs and/or Perl core dumps when
0 is in effect.  When confronted with such a system,
please report in excruciating detail to <0, and
also contact your vendor: bug fixes may exist for these problems
in your operating system.  Sometimes such bug fixes are called an
operating system upgrade.

0, 0,
0, 0, 0,
0, 0, 0,
0, 0, 0,
0, 0, 0,
0, 0.

Dunlop, assisted by the perl5-porters.  Prose worked over a bit by
Tom Christiansen, and updated by Perl 5 porters. 

=encoding utf8

called a list of lists).  It's reasonably easy to understand, and
almost everything that applies here will also be applicable later
on with the fancier data structures.

get at with two subscripts, like 0.  Here's a declaration
of the array:

is a round one, that is, a parenthesis.  That's because you're assigning to
an @array, so you need parentheses.  If you wanted there 0 to be an @AoA,
but rather just a reference to it, you could do something more like this:

has also changed.  That's because unlike C, in perl you can't freely
interchange arrays and references thereto.   is a reference to an
array, whereas @AoA is an array proper.  Likewise, 0 is not an
array, but an array ref.  So how come you can write these:

square or curly), you are free to omit the pointer dereferencing arrow.
But you cannot do so for the very first one if it's a scalar containing
a reference, which means that  always needs it.

but what if you wanted to add new elements on the fly, or build
it up entirely from scratch?

adding a row at a time.  We'll assume that there's a flat file in which
each line is a row and each word an element.  If you're trying to develop an
@AoA array containing all these, here's the right way to do that:

array in it.

constructor.  That's because this will be very wrong:

number of elements in @tmp, which probably isn't what you want.

declarations to make it happy:

if you knew where you wanted to put it:

potentially return lists in scalar context without explicitly stating
such.  This would be clearer to the casual reader:

you'd have to do something like this:

dealing with just matrices, it's often easiest to use simple assignment:

there or not: it'll gladly create them for you, setting
intervening elements to 0 as need be.

to do something a bit funnier looking:

to  must be a real array, not just a reference to such.

are you going to do that?  Well, if you want only one
of the elements, it's trivial:

say

automatically dereference things for you.  Instead, you have to
roll yourself a loop or two.  This prints the whole structure,
using the shell-style  construct to loop across the outer
set of subscripts.

sometimes is easier to take a temporary on your way through:

array, you're going to have to do some fancy subscripting.  That's
because while we have a nice synonym for single elements via the
pointer arrow for dereferencing, no such convenience exists for slices.
(Remember, of course, that you can always write a loop to do a slice
operation.)

variable as before.

 run from 4..8 and  run from 7 to 12?  Hmm... here's the simple way:

have selected map for that

insecurity) through inscrutable code, it would be hard to argue. :-)
If I were you, I'd put that in a function:

=encoding utf8

0 0 0 0 0

packages from stomping on each other's variables.  In fact, there's
really no such thing as a global variable in Perl.  The package
statement declares the compilation unit as being in the given
namespace.  The scope of the package declaration is from the
declaration itself through the end of the enclosing block, 0,
or file, whichever comes first (the same scope as the  and
 operators).  Unqualified dynamic identifiers will be in
this namespace, except for those few identifiers that if unqualified,
default to the main package instead of the current one as described
below.  A package statement affects only dynamic variables--including
those you've used  on--but 0 lexical variables created
with .  Typically it would be the first declaration in a file
included by the 0, 0, or 0 operators.  You can
switch into a package in more than one place; it merely influences
which symbol table is used by the compiler for the rest of that
block.  You can refer to variables and filehandles in other packages
by prefixing the identifier with the package name and a double
colon: 0.  If the package name is null, the
0 package is assumed.  That is, 0 is equivalent to
0.

preferred delimiter, in part because it's more readable to humans, and
in part because it's more readable to 0 macros.  It also makes C++
programmers feel like they know what's going on--as opposed to using the
single quote as separator, which was there to make Ada programmers feel
like they knew what was going on.  Because the old-fashioned syntax is still
supported for backwards compatibility, if you try to use a string like
0, you'll be accessing 0; that is,
the  variable in package 0, which is probably not what you meant.
Use braces to disambiguate, as in 0.
0 0

0.  This implies nothing about the order of
name lookups, however.  There are no relative packages: all symbols
are either local to the current package, or must be fully qualified
from the outer package name down.  For instance, there is nowhere
within package 0 that 0 refers to
0.  0 refers to a totally
separate global package.

in a package's symbol table.  All other symbols are kept in package
0, including all punctuation variables, like .  In addition,
when unqualified, the identifiers STDIN, STDOUT, STDERR, ARGV,
ARGVOUT, ENV, INC, and SIG are forced to be in package 0,
even when used for other purposes than their built-in ones.  If you
have a package called 0, 0, or 0, then you can't use the
qualified form of an identifier because it would be instead interpreted
as a pattern match, a substitution, or a transliteration.
0

main, but we decided it was more useful for package writers to be able
to use leading underscore to indicate private variables and method names.
However, variables and functions named with a single 0, such as
 and 0, are still forced into the package 0.  See also
0.

compiled.  (Assignments to 0, however, assume the signal
handler specified is in the 0 package.  Qualify the signal handler
name if you wish to have a signal handler in a package.)  For an
example, examine 0 in the Perl library.  It initially switches
to the 0 package so that the debugger doesn't interfere with variables
in the program you are trying to debug.  At various points, however, it
temporarily switches back to the 0 package to evaluate various
expressions in the context of the 0 package (or wherever you came
from).  See 0.

(easily) be used to construct variable names.

and 0 regarding closures.

0 0 0 0 0 0 0

name with two colons appended.  The main symbol table's name is thus
0, or 0 for short.  Likewise the symbol table for the nested
package mentioned earlier is named 0.

use the 0 typeglob notation.

instance.  The standard but antiquated 0 library and
the CPAN module Devel::Symdump make use of this.

accessible via the identifier 0 also to be accessible via the
identifier 0.  If you want to alias only a particular variable or
subroutine, assign a reference instead:

@richard and @dick as separate arrays.  Tricky, eh?

0 makes the SCALAR portions of two distinct typeglobs
refer to the same scalar value. This means that the following code:

0. The one that was stuffed away by 0 and which will be
restored when the block ends. Because variables are accessed through the
typeglob, you can use 0 to create an alias which can be
localized. (But be aware that this means you can't have a separate
0 and 0, etc.)

aliasing as the import/export mechanism. Whether or not you can properly
localize a variable that has been exported from a module depends on how
it was exported:

(0) where you need a local value, or by overriding it
by saying 0 in your script.

into or from subroutines if you don't want to copy the whole
thing.  It only works when assigning to dynamic variables, not
lexicals.

symbol table specified by the *some_hash typeglob.  This
is a somewhat tricky way of passing around references cheaply
when you don't want to have to remember to dereference variables
explicitly.

0 0

This isn't the same as a constant subroutine, which is subject to
optimization at compile-time.  A constant subroutine is one prototyped
to take no arguments and to return a constant expression.  See
0 for details on these.  The 0 pragma is a
convenient shorthand for these.

package the *foo symbol table entry comes from.  This may be useful
in a subroutine that gets passed typeglobs as arguments:

individual elements of *foo.  See 0.

not necessarily be situated in the package whose symbol table they
occupy.  You can define a subroutine outside its package by
explicitly qualifying the name of the subroutine:

lexically in the main package, 0 in Some_package. So
something like this:

(see 0).

0 0 0 0 0

the end of a running Perl program.  These are the 0,
0, 0, 0, and 0 blocks.

subroutine (although this is not considered good style).  One should note
that these code blocks don't really exist as named subroutines (despite
their appearance). The thing that gives this away is the fact that you can
have 0 of these code blocks in a program, and they will get
0 executed at the appropriate moment.  So you can't execute any of
these code blocks by name.

it is completely defined, even before the rest of the containing file (or
string) is parsed.  You may have multiple 0 blocks within a file (or
eval'ed string); they will execute in order of definition.  Because a 0
code block executes immediately, it can pull in definitions of subroutines
and such from other files in time to be visible to the rest of the compile
and run time.  Once a 0 has run, it is immediately undefined and any
code it used is returned to Perl's memory pool.

perl has finished running the program and just before the interpreter
is being exited, even if it is exiting as a result of a  function.
(But not if it's morphing into another program via 0, or
being blown out of the water by a signal--you have to trap that yourself
(if you can).)  You may have multiple 0 blocks within a file--they
will execute in reverse order of definition; that is: last in, first
out (LIFO).  0 blocks are not executed when you run perl with the
0 switch, or if compilation fails.

0: if any 0 code blocks are created in a string 0,
they will be executed just as any other 0 code block of that package
in LIFO order just before the interpreter is being exited.

going to pass to 0.  You can modify 0 to change the exit
value of the program.  Beware of changing 0 by accident (e.g. by
running something via 0).
0

0.

transition between the compilation phase and the execution phase of
the main program.

been compiled.  The main program file and each module it loads are
compilation units, as are string 0s, code compiled using the
0 construct in a regex, calls to 0, 0,
and code after the 0 switch on the command line.

the interpreter.  They can be created and executed during any phase.

and before the run time begins, in LIFO order.  0 code blocks are used
in the Perl compiler suite to save the compiled state of the program.

0.

"first in, first out" (FIFO) order.

or string 0 will not be executed if they occur after the end of the
main compilation phase; that can be a problem in mod_perl and other persistent
environments which use those functions to load code at runtime.

0 work just as they do in 0, as a degenerate case.
Both 0 and 0 blocks are run when you use the 0
switch for a compile-only syntax check, although your main code
is not.

0 0

as a class if it provides subroutines to act as methods.  Such a
package may also derive some of its methods from another class (package)
by listing the other package name(s) in its global @ISA array (which
must be a package global, not a lexical).

0

a Perl package with the same name as the file.  It is specifically
designed to be reusable by other modules or programs.  It may do this
by providing a mechanism for exporting some of its symbols into the
symbol table of any package using it, or it may function as a class
definition and make its semantics available implicitly through
method calls on the class and its objects, without explicitly
exporting anything.  Or it can do a little of both.

create a file called 0 and start with this template:

any qualifications.  See 0 and the 0 for
details on mechanics and style issues in module creation.

assumes this so you don't have to spell out "0" in quotes.
This also helps to differentiate new modules from old 0 and
0 files.  Module names are also capitalized unless they're
functioning as pragmas; pragmas are in effect compiler directives,
and are sometimes called "pragmatic modules" (or even "pragmata"
if you're a classicist).

colons in the module name, such as 0, are translated
into your system's directory separator, usually "/".   The second
case does not, and would have to be specified literally.  The other
difference is that seeing the first 0 clues in the compiler
that uses of indirect object notation involving "SomeModule", as
in 0, are method calls, not function calls.
(Yes, this really can make a difference.)

of semantics happens as soon as the 0 statement is compiled,
before the rest of the file is compiled.  This is how it is able
to function as a pragma mechanism, and also how modules are able to
declare subroutines that are then visible as list or unary operators for
the rest of the current file.  This will not work if you use 0
instead of 0.  With 0 you can get into this problem:

because it determines module availability at compile time, not in the
middle of your program's execution.  An exception would be if two modules
each tried to 0 each other, and each also called a function from
that other module.  In that case, it's easy to use 0 instead.

package names containing 0.  But if we used that package name
directly as a filename it would make for unwieldy or impossible
filenames on some systems.  Therefore, if a module's name is, say,
0, then its definition is actually found in the library
file 0.

dynamically linked executables (often ending in 0) or autoloaded
subroutine definitions (often ending in 0) associated with the
module.  If so, these will be entirely transparent to the user of
the module.  It is the responsibility of the 0 file to load
(or arrange to autoload) any additional functionality.  For example,
although the POSIX module happens to do both dynamic loading and
autoloading, the user can say just 0 to get it all.

0 0
0 0
0 0 0 0 0

interpreter threads (ithreads). These threads can be used explicitly
and implicitly.

between different threads. These threads can be used by using the 0
module or by doing  on win32 (fake  support). When a
thread is cloned all Perl data is cloned, however non-Perl data cannot
be cloned automatically.  Perl after 5.7.2 has support for the 0
special subroutine.  In 0 you can do whatever
you need to do,
like for example handle the cloning of non-Perl data, if necessary.
0 will be called once as a class method for every package that has it
defined (or inherits it).  It will be called in the context of the new thread,
so all modifications are made in the new area.  Currently CLONE is called with
no parameters other than the invocand package name, but code should not assume
that this will remain unchanged, as it is likely that in future extra parameters
will be passed in to give more information about the state of cloning.

package. This is simply done using a hash and Scalar::Util::.

Like 0, 0 is called once per package; however, it is
called just before cloning starts, and in the context of the parent
thread. If it returns a true value, then no objects of that class will
be cloned; or rather, they will be copied as unblessed, undef values.
For example: if in the parent there are two references to a single blessed
hash, then in the child there will be two references to a single undefined
scalar value instead.
This provides a simple mechanism for making a module threadsafe; just add
0 at the top of the class, and 0 will
now only be called once per object. Of course, if the child thread needs
to make use of the objects, then a more sophisticated approach is
needed.

than the invocand package name, although that may change. Similarly, to
allow for future expansion, the return value should be a single 0 or
0 value.

modules and classes, as well as descriptions of the standard library
and CPAN, 0 for how Perl's standard import/export mechanism
works, 0 and 0 for an in-depth tutorial on
creating classes, 0 for a hard-core reference document on
objects, 0 for an explanation of functions and scoping,
and 0 and 0 for more information on writing
extension modules. 

=encoding utf8

code; see 0 for details.  Whenever anyone creates a chunk of
Perl code that they think will be useful to the world, they register
as a Perl developer at http://www.cpan.org/modules/04pause.html
so that they can then upload their code to the CPAN.  The CPAN is the
Comprehensive Perl Archive Network and can be accessed at
http://www.cpan.org/ , and searched at http://search.cpan.org/ .

and install them on their own computer.

0.  (Replace "Foo" with the name of the module; for
instance, 0.

see an error message, it's still possible you have the module, but
that it's not in your path, which you can display with 0.)  For the remainder of this document, we'll assume
that you really honestly truly lack an installed module, but have
found it on the CPAN.

know there's a tasty module inside.  There are four steps you must now
take:

<not> a substitute for reading the README and INSTALL files that
might have come with your module!

module into your system's repository of Perl modules, but you can
install modules into any directory you wish.  For instance, where I
say 0, you can substitute 0 to install the modules into
0.  Then you can use the modules from your Perl
programs with 0 or
sometimes just 0.  If you're on a system
that requires superuser/root access to install modules into the
directories you see when you type 0, you'll
want to install them into a local directory (such as your home
directory) and use this approach.

( http://www.cpan.org/modules/by-module/CPAN )
to automate the following steps, from DECOMPRESS through INSTALL.

put 0 near the top of the program that
is to use this module.

in your Perl 5 library directory.  Often, you'll need to be root.

Most Unix systems have dynamic linking. If yours doesn't, or if for
another reason you have a statically-linked perl, 0 the
module requires compilation, you'll need to build a new Perl binary
that includes the module.  Again, you'll probably need to be root.

repository has your module.  If so, you can install it with 0 and
you won't have to bother with any of the other steps here.  You might
be able to use the CPAN instructions from the "Unix or Linux" section
above as well; give it a try.  Otherwise, you'll have to follow the
steps below.

decompress and unpack modules.

http://download.microsoft.com/download/vc15/Patch/1.52/W95/EN-US/nmake15.exe
or dmake, available on CPAN.
http://search.cpan.org/dist/dmake/

in .xs, .c, .h, .y, .cc, .cxx, or .C)?  If it does, life is now
officially tough for you, because you have to compile the module
yourself (no easy feat on Windows).  You'll need a compiler such as
Visual C++.  Alternatively, you can download a pre-built PPM package
from ActiveState.
http://aspn.activestate.com/ASPN/Downloads/ActivePerl/PPM/

http://www.cpan.org/authors/id/CNANDOR/ ), which has utilities for
doing all of the steps.  Read the cpan-mac directions carefully and
install it.  If you choose not to use cpan-mac for some reason, there
are alternatives listed here.

0 droplet, which will decompress and unpack for you.

( http://my.smithmicro.com/mac/stuffit/ )
or the freeware 0 program (
http://persephone.cps.unizar.es/general/gente/spd/gzip/gzip.html ).

now.  0, you can use the freeware 0 or 0 (
http://hyperarchive.lcs.mit.edu/HyperArchive/Archive/cmp/ ).

Read the module's documentation, looking for
reasons why you might have trouble using it with MacPerl.  Look for
0 and 0 files, which normally denote that the distribution
must be compiled, and you cannot install it "out of the box."
(See 0.)

0 droplet, and use the module.

If they are not then you might have decompressed them incorrectly.  Check
your decompression and unpacking utilities settings to make sure they are
translating text files properly.

may be some additional ones, too; check the module documentation)
to their final destination: This will
most likely be in 0 (i.e.,
0).  You can add new paths to
the default 0 in the Preferences menu item in the
MacPerl application (0 is added
automagically).  Create whatever directory structures are required
(i.e., for 0, create
0 and put
0 in that directory).

will both uncompress and unpack.

in the Perl distribution.

http://hobbes.nmsu.edu ) or Leo ( http://www.leo.org ), and then follow
the instructions for Unix.

extension instead of 0.  All other periods in the
filename should be replaced with underscores.  For example,
0 should be downloaded as
0.

package.  The former is a simple compression tool; the latter permits
creation of multi-file archives.

from MadGoat at http://www.madgoat.com ).  Then type this to create
the DESCRIP.MMS for the module:

ASCII to EBCDIC.

http://www.s390.ibm.com/products/oe/bpxqp1.html

modules generate Makefiles that work better with GNU make, which is
available from http://www.mks.com/s390/gnu/

See 0  (These modules contain
0 or 0 files, usually.)  You might be able to find
existing binaries on the CPAN or elsewhere, or you might
want to try getting compilers and building it yourself, and then
release the binary for other poor souls to use.

(Such as the Win32:: modules.)  If the module is targeted
specifically at a platform other than yours, you're out
of luck, most likely.

but it doesn't behave as you'd expect, or you aren't sure whether or
not a module will work under your platform.  If the module you want
isn't listed there, you can test it yourself and let CPAN Testers know,
you can join CPAN Testers, or you can request it be tested.

don't send me mail asking for help on how to install your modules.
There are too many modules, and too few Orwants, for me to be able to
answer or even acknowledge all your questions.  Contact the module
author instead, or post to comp.lang.perl.modules, or ask someone
familiar with Perl on your operating system.

Allbery, Charles Bailey, Graham Barr, Dominic Dunlop, Jarkko
Hietaniemi, Ben Holzman, Tom Horsley, Nick Ing-Simmons, Tuomas
J. Lukka, Laszlo Molnar, Alan Olsen, Peter Prymmer, Gurusamy Sarathy,
Christoph Spalinger, Dan Sugalski, Larry Virden, and Ilya Zakharevich.

documentation provided the copyright notice and this permission notice are
preserved on all copies.

documentation under the conditions for verbatim copying, provided also
that they are marked clearly as modified versions, that the authors'
names and title are unchanged (though subtitles and additional
authors' names may be added), and that the entire resulting derived
work is distributed under the terms of a permission notice identical
to this one.

documentation into another language, under the above conditions for
modified versions. 

=encoding utf8

for writing Perl modules.  It extends the recommendations found in
0 , which should be considered required reading
before reading this document.

particularly aimed at authors who wish to publish their modules on CPAN.

module, rather than those parts which are only seen by the module's
developers.  However, many of the guidelines presented in this document
can be extrapolated and applied successfully to a module's internals.

rather than a tutorial on creating CPAN modules.  It provides a
checklist against which modules can be compared to determine whether
they conform to best practice, without necessarily describing in detail
how to achieve this.

extensive conversations with experienced CPAN authors and users.  Every
piece of advice given here is the result of previous mistakes.  This
information is here to help you avoid the same mistakes and the extra
work that would inevitably be required to fix them.

subsequent sections provide a more detailed discussion of the items on
the list.  The final section, "Common Pitfalls", describes some of the
most popular mistakes made by CPAN authors.

parameters

some time thinking first.  A little forethought may save you a vast
amount of effort later on.

been done in Perl, and avoid re-inventing the wheel unless you have a
good reason.

http://search.cpan.org/ and asking on modules@perl.org

patch, writing a subclass, or otherwise extending the existing module
rather than rewriting it.

A Perl developer should be able to use modules to put together the
building blocks of their application.  However, it's important that the
blocks are the right shape, and that the developer shouldn't have to use
a big block when all they need is a small one.

a single sentence.  Can your module be broken down into a family of
related modules?

related BAR standard."

implements the related BAR protocol."

they should not be forced to install libraries for FOO as well.

will help people find and remember your module, and make programming
with your module more intuitive.

hierarchy already exists under which you could place your module.

before publishing your module.  You should also try to ask people who
are already familiar with the module's application domain and the CPAN
naming system.  Authors of similar modules, or modules with similar
names, may be a good place to start.

of interfaces available.  There are pros and cons of each technique, which
should be considered when you design your API.

polymorphic invocation of methods feasible)

into the system, and will need to be handled by existing code

overloaded operators

change over time (and hence should be encapsulated)

should be insulated from changes in its implementation)

same set of data

Gratuitous object orientation results in complex APIs which are
difficult for the average module user to understand or use.

The following guidelines may help you judge whether your API is
sufficiently straightforward:

If your routine changes its behaviour significantly based on its
arguments, it's a sign that you should have two (or more) separate
routines.

to choose how to use them.  The most generic form possible is usually a
Perl data structure which can then be used to generate a text report,
HTML, XML, a database query, or whatever else your users require.

files, or records in a database) you may consider providing a callback
so that users can manipulate each element of the list in turn.
File::Find provides an example of this with its
0 syntax.

simple result.  You can always include optional parameters or routines for
more complex or non-standard behaviour.  If most of your users have to
type a few almost identical lines of code when they start using your
module, it's a sign that you should have made that behaviour a default.
Another good indicator that you should use defaults is if most of your
users call your routines with the same arguments.

which is visible to the user (and most things that aren't!)

arguments, any more arguments become hard for the module user to
remember, and hard for the module author to manage.  If you want to add
a new parameter you will have to add it to the end of the list for
backward compatibility, and this will probably make your list order
unintuitive.  Also, if many elements may be undefined you may see the
following unattractive method calls:

your users specify parameters which will almost always be the same.

largely a matter of personal style.

upper case (0) is a relic of older versions of Perl in which
ordinary lower case strings were not handled correctly by the C<=0
operator.  While some modules retain uppercase or hyphenated argument
keys for historical reasons or as a matter of personal style, most new
modules should use simple lower case keys.  Whatever you choose, be
consistent!

run without generating any warnings.  Your module should also handle
taint-checking where appropriate, though this can cause difficulties in
many cases.

without at least a long transition phase and a major change in version
number.

DBI and other popular modules; if you choose something else, be sure to
document it clearly).

do.  (0 is a better version of 0 for use within
modules, which reports its errors from the perspective of the caller.
See 0 for details of 0, 0 and other useful
routines.)

the Error module.

offering a choice of levels for warning and debug messages, an option to
send messages to a separate file, a way to specify an error-handling
routine, or other such features.  Be sure to default all these options
to the commonest use.

You should use Perl's "plain old documentation" (POD) for your general
technical documentation, though you may wish to write additional
documentation (white papers, tutorials, etc) in some other format.
You need to cover the following subjects:

parameters and return values

less detailed to more detailed.  Your SYNOPSIS section should contain a
minimal example of use (perhaps as little as one line of code; skip the
unusual use cases or anything not needed by most users); the
DESCRIPTION should describe your module in broad terms, generally in
just a few paragraphs; more detail of the module's routines or methods,
lengthy code examples, or other in-depth material should be given in
subsequent sections.

to refresh their memory without hitting "page down".  As your reader
continues through the document, they should receive a progressively
greater amount of knowledge.

methods and routines and any other relevant information.

documentation).  Include POD for a given method right above that
method's subroutine.  This makes it easier to keep the documentation up
to date, and avoids having to document each piece of code twice (once in
POD and once in comments).

giving pointers to further information (website, author email).

instructions. When using ExtUtils::MakeMaker this will usually be:

software describing user-visible changes to your module, in terms
relevant to the user.

possibly sub-minor releases.  A major release is one in which most of
the functionality has changed, or in which major new functionality is
added.  A minor release is one in which a small amount of functionality
has been added or changed.  Sub-minor version numbers are usually used
for changes which do not affect functionality, such as documentation
patches.

2 digits after the decimal. You can test whether it conforms to CPAN by
using

don't want CPAN.pm to list it as most recent use an '_' after the
regular version number followed by at least 2 digits, eg. 1.20_01. If
you do this, the following idiom is recommended:

the underscore, while the perl interpreter will evaluate the 
and convert the string into a number. Later operations that treat
 as a number will then be able to do so without provoking a
warning about  not being a number.

incrementing the number.  Even a one-word documentation patch should
result in a change in version at the sub-minor level.

modules, and which modules to rely on.

order of preference:

pre-requisites in your Makefile.PL or Build.PL.

Build.PL and with 0 or similar. See the section on
0 of 0 for details.

and the tests should also be available to people installing the modules
(using "make test").
For Module::Build you would use the 0 equivalent 0.

module. A module which purports to be stable or which hopes to achieve wide
use should adhere to as strict a testing regime as possible.

development process or your time) include Test::Simple, Carp::Assert
and Test::Inline.
For more sophisticated test suites there are Test::More and Test::MockObject.

Currently you have the choice between ExtUtils::MakeMaker and the
more platform independent Module::Build, allowing modules to be installed in a
consistent manner.
When using ExtUtils::MakeMaker, you can use "make dist" to create your
package. Tools exist to help you to build your module in a MakeMaker-friendly
style. These include ExtUtils::ModuleMaker and h2xs.  See also 0.

is included in the distribution (unless it's a common one and the terms
of the license don't require you to include it).

and Artistic licenses (the same as Perl itself) is a good idea.
See 0 and 0.

served by CPAN.  One example is templating systems, another is date and
time modules, and there are many more.  While it is a rite of passage to
write your own version of these things, please consider carefully
whether the Perl world really needs you to publish it.

itself, form the 0 toolkit.  It's tempting to add extra features
until your code is a monolithic system rather than a set of modular
building blocks.

primary audience is a reasonably experienced developer with at least
a moderate understanding of your module's application domain, who's just
downloaded your module and wants to start using it as quickly as possible.

appropriate in a module's main documentation.  If you really want to
write these, include them as sub-documents such as 0 or
0 and provide a link in the SEE ALSO section of the
main documentation.

authors.

=encoding utf8

resolution orders other than the default (linear depth first search).
The C3 method resolution order added in 5.10.0 has been re-implemented as
a plugin, without changing its Perl-space interface.

the following structure

direct as the parameter 0 to 0.

given stash, using this MRO. It is called with a pointer to the stash, and
a 0 of 0. The core always sets 0 to 0 when it calls your
function - the parameter is provided to allow your implementation to track
depth if it needs to recurse.

classes in order. The names of the classes should be the result of calling
0 on the stash. In those cases where 0 returns null,
0 should be used instead.

returned if it wants to keep the structure. Hence, if you have created a
temporary value that you keep no pointer to, 0 to ensure that
it is disposed of correctly. If you have cached your return value, then
return a pointer to it without changing the reference count.

which you can store a single 0, or anything that can be cast to
0, such as 0. To read your private value, use the macro
0, passing it the 0 structure from the
stash, and a pointer to your 0 structure:

much the same way that 0 takes ownership of a reference to the
value that you pass it.

and the 0 section of 0, and 0
in 0

written by Brandon L Black. Nicholas Clark created the pluggable interface,
refactored Brandon's implementation to work with it, and wrote this document.

=encoding utf8

Perl modules, preparing them for distribution, and making them available
via CPAN.

hackers tend to want to share the solutions to problems they've faced,
so you and I don't have to battle with the same problem again.

module. If you don't know what one of these is, the rest of this
document isn't going to be much use to you. You're also missing out on
an awful lot of useful code; consider having a look at 0,
0 and 0 before coming back here.

trying to do, and you've had to write the code yourself, consider
packaging up the solution into a module and uploading it to CPAN so that
others can benefit.

than XS modules. XS modules serve a rather different purpose, and
you should consider different things before distributing them - the
popularity of the library you are gluing, the portability to other
operating systems, and so on. However, the notes on preparing the Perl
side of the module and packaging and distributing it will apply equally
well to an XS module as a pure-Perl one.

useful to others. Anything that's likely to fill a hole in the communal
library and which someone else can slot directly into their program. Any
part of your code which you can isolate and extract and plug into
something else is a likely candidate.

format into a hash-of-hashes in Perl, turning that into a tree, walking
the tree and then piping each node to an Acme Transmogrifier Server.

write something to talk the protocol from scratch - you'd almost
certainly want to make that into a module. The level at which you pitch
it is up to you: you might want protocol-level modules analogous to
0 which then talk to higher level modules analogous
to 0. The choice is yours, but you do want to get
a module out for that server protocol.

can ignore that. But what about the thing in the middle? Building tree
structures from Perl variables and then traversing them is a nice,
general problem, and if nobody's already written a module that does
that, you might want to modularise that code too.

Let's now see how it's done.

want to do in advance.

starting with 0, since it's in the standard
library and is nice and simple, and then looking at something a little
more complex like 0.  For object oriented
code, 0 or the 0 modules provide some good
examples.

written.

similar to what you're planning on contributing. Have a good plough
through the 0 and make sure you're not the one
reinventing the wheel!

might not actually be any real demand for it out there. If you're unsure
about the demand your module will have, consider sending out feelers
on the 0 newsgroup, or as a last resort, ask the
modules list at 0. Remember that this is a closed list
with a very long turn-around time - be prepared to wait a good while for
a response from them.

fit in with. See 0 for more details on how this works, and
browse around CPAN and the modules list to get a feel of it. At the very
least, remember this: modules should be title capitalised, (This::Thing)
fit in with a category, and explain their purpose succinctly.

similar to the one you're about to write.

wanted and not currently available, it's time to start coding.

0 CPAN package.  It creates a directory
with stubs of all the necessary files to start a new module, according
to recent "best practice" for module development, and is invoked from
the command line, thus:

package from CPAN, 0 is an older tool, originally intended for the
development of XS modules, which comes packaged with the Perl
distribution.

0 omits the Exporter code, 0 sets up a
modern testing environment, and 0 specifies the name of the module.

guarantee the conditions that it'll be used under. Besides, you wouldn't
want to distribute code that wasn't warning or strict-clean anyway,
right?

the caller's perspective; this gives you a way to signal a problem with
the caller and not your module. For instance, if you say this:

to put the blame on the user, and say this:

0s. If you need to 0, say 0 instead. However, keep
0 and 0 in place for your sanity checks - where it really is
your module at fault.

subroutines from your module into the caller's namespace. For instance,
saying 0 would import the 0 subroutine.

exported when the caller simply says 0 - you will hardly
ever want to put anything in there. 0, on the other hand,
specifies which symbols you're willing to export. If you do want to
export a bunch of symbols, use the 0 and define a standard
export set - look at 0 for more details.

need to put in some time writing some documentation for your module.
0 or 0 will provide a stub for you to fill in; if
you're not sure about the format, look at 0 for an
introduction. Provide a good synopsis of how your module is used in
code, a description, and then notes on the syntax and function of the
individual subroutines or methods. Use Perl comments for developer notes
and POD for end-user notes.

working as intended on the myriad platforms Perl supports; if you upload
your module to CPAN, a host of testers will build your module and send
you the results of the tests. Again, 0 and 0
provide a test framework which you can extend - you should do something
more than just checking your module will compile.
0 and 0 are good
places to start when writing a test suite.

README file and place that in your CPAN directory. It'll also appear in
the main 0 and 0 directories if you make it onto
the modules list. It's a good idea to put here what the module actually
does in detail, and the user-visible changes since the last release.

0, select "Request PAUSE Account", and wait for
your request to be approved by the PAUSE administrators.

They produce the standard 0 you see when you download and
install modules, and this produces a Makefile with a 0 target.

good thing to make sure - you can 0, and the Makefile will
hopefully produce you a nice tarball of your module, ready for upload.

log in to PAUSE, the Perl Authors Upload SErver. From the menus there,
you can upload your module to CPAN.

it connected to the rest of the CPAN, you'll need to go to "Register
Namespace" on PAUSE.  Once registered, your module will appear in the
by-module and by-category listings on CPAN.

an announcement to the moderated 0 newsgroup.

you're lucky, they'll even send you patches. Welcome to the joys of
maintaining a software project...

0, 0, 0, 0, 0
0, 0, 0
http://www.cpan.org/ , Ken Williams's tutorial on building your own
module at http://mathforum.org/~ken/perl_modules.html 

=encoding utf8

overloading allows user-defined behaviors for numbers, such as operations
over arbitrarily large integers, floating points numbers with arbitrary
precision, operations over "exotic" numbers such as modular arithmetic or
p-adic arithmetic, and so on.  See 0 for details.

integers, as native floating point numbers, and as decimal strings.
Decimal strings may have an exponential notation part, as in 0.
0 here means "a format supported by the C compiler which was used
to build perl".

integers, as it does when native floating point numbers are involved.
The only implication of the term "native" on integers is that the limits for
the maximal and the minimal supported true integral quantities are close to
powers of 2.  However, "native" floats have a most fundamental
restriction: they may represent only those numbers which have a relatively
"short" representation when converted to a binary fraction.  For example,
0.9 cannot be represented by a native float, since the binary fraction
for 0.9 is infinite:

limitation,  the exponent of the binary number is also restricted when it
is represented as a floating point number.  On typical hardware, floating
point values can store numbers with up to 53 binary digits, and with binary
exponents between -1024 and 1024.  In decimal representation this is close
to 16 decimal digits and decimal exponents in the range of -304..304.
The upshot of all this is that Perl cannot store a number like
12345678901234567 as a floating point number on such architectures without
loss of information.

finite decimal expansion.  Being strings, and thus of arbitrary length, there
is no practical limit for the exponent or number of decimal digits for these
numbers.  (But realize that what we are discussing the rules for just the
0 of these numbers.  The fact that you can store such "large" numbers
does not mean that the 0 over these numbers will use all
of the significant digits.
See 0 for details.)

in the signed native form, or in the unsigned native form.  Thus the limits
for Perl numbers stored as native integers would typically be -2**31..2**32-1,
with appropriate modifications in the case of 64-bit integers.  Again, this
does not mean that Perl can do operations only over integers in this range:
it is possible to store many more integers in floating point format.

a finite decimal expansion or a "short" binary expansion.

but most operators typically understand only one of those formats.  When
a numeric value is passed as an argument to such an operator, it will be
converted to the format understood by the operator.

representation is used.

a representation of the closest limit is used.  (0)

a representation of one of these numbers is used.  (0)

of the result is less than or equal to the magnitude of the source.
(0)

without loss of information, the result is compatible with the conversion
sequence .
In particular, rounding is strongly biased to 0, though a number like
0 has a chance of being rounded to 1.

performed by the C compiler.  In particular, bugs/features of the compiler
used may lead to breakage of some of the above rules.

of four different ways: they may force it to one of the integer/floating/
string formats, or they may behave differently depending on the format of
the operand.  Forcing a numeric value to a particular format does not
change the number stored in the value.

argument as in modular arithmetic, e.g., 0 on a 32-bit
architecture.  0 therefore provides the same result as
0.

C<0 C<0 and the unary operators 0 0 and 0 will
attempt to convert arguments to integers.  If both conversions are possible
without loss of precision, and the operation can be performed without
loss of precision then the integer result is used.  Otherwise arguments are
converted to floating point format and the floating point result is used.
The caching of conversions (as described above) means that the integer
conversion does not throw away fractional parts on floating point numbers.

matching the format 0 the string increment described
in 0 is used.

above will force their argument(s) into integer format, and return an integer
result.  The exceptions, 0, 0 and 0, do not change their
behavior with 0

format.

signed integers rather than the default unsigned.

to the third and fourth arguments of 0, for example.

applicable to 0.

stored number, Perl remembers the result of such conversions.  In
particular, though the first such conversion may be time-consuming,
repeated operations will not need to redo the conversion.

=encoding utf8

0 0

See 0 for that.  Second, if you still find the following
reference work too complicated, a tutorial on object-oriented programming
in Perl can be found in 0 and 0.

here are three very simple definitions that you should find reassuring.

belongs to.

with object references.

a package name, for class methods) as the first argument.

0 0 0 0

constructors.  A constructor is merely a subroutine that returns a
reference to something "blessed" into a class, generally the
class that the subroutine is defined in.  Here is a typical
constructor:

a construct this way, too:

be tricked into thinking that 0 works in Perl as it does in C++.
It doesn't.  We recommend that you name your constructors whatever
makes sense in the context of the problem you're solving.  For example,
constructors in the Tk extension to Perl are named after the widgets
they create.

C++ is that in Perl, they have to allocate their own memory.  (The other
things is that they don't automatically call overridden base-class
constructors.)  The 0 allocates an anonymous hash containing no
key/value pairs, and returns it  The  takes that reference and
tells the object it references that it's now a Critter, and returns
the reference.  This is for convenience, because the referenced object
itself knows that it has been blessed, and the reference to it could
have been returned directly, like this:

that wish to call methods in the class as part of the construction:

0),
then you want to use the two-arg form of bless
so that your constructors may be inherited:

, then use something like the following.  (Note that using
this to call  on an instance does not automatically perform any
copying.  If you want a shallow or deep copy of an object, you'll have to
specifically allow for that.)  The  method used will be of
whatever  we blessed the object into:

reference as an ordinary reference.  Outside the class package,
the reference is generally treated as an opaque value that may
be accessed only through the class's methods.

currently belonging to another class, this is almost certainly going
to get you into trouble.  The new class is responsible for all
cleanup later.  The previous blessing is forgotten, as an object
may belong to only one class at a time.  (Although of course it's
free to inherit methods from many classes.)  If you find yourself
having to do this, the parent class is probably misbehaving, though.

know which package they belong to.  References do not.  The 
function uses the reference to find the object.  Consider
the following example:

operated on the object and not on the reference.

0 0 0 0

definitions.  You use a package as a class by putting method
definitions into the class.

where else to look for a method if you can't find it in the current
package.  This is how Perl implements inheritance.  Each element of the
@ISA array is just the name of another package that happens to be a
class package.  The classes are searched for missing methods in
depth-first, left-to-right order by default (see 0 for alternative
search order and other in-depth information).  The classes accessible
through @ISA are known as base classes of the current class.

last base class.  Several commonly used methods are automatically
supplied in the UNIVERSAL class; see 0 or
0 for more details.
0 0 0

in the current class for efficiency.  Changing @ISA or defining new
subroutines invalidates the cache and causes Perl to do the lookup again.

class contains the requested method, these three places are searched
all over again, this time looking for a method named .  If an
AUTOLOAD is found, this method is called on behalf of the missing method,
setting the package global  to be the fully qualified name of
the method that was intended to be called.
0

0

to the class itself.  By and large, this is not a problem in Perl,
because most classes model the attributes of their object using an
anonymous hash, which serves as its own little namespace to be carved up
by the various classes that might want to do something with the object.
The only problem with this is that you can't sure that you aren't using
a piece of the hash that isn't already used.  A reasonable workaround
is to prepend your fieldname in the hash with the package name.
0 0

0

definition.  (It does provide a little syntax for method invocation
though.  More on that later.)  A method expects its first argument
to be the object (reference) or package (string) it is being invoked
on.  There are two ways of calling methods, which we'll call class
methods and instance methods.

provides functionality for the class as a whole, not for any
individual object belonging to the class.  Constructors are often
class methods, but see 0 and 0 for alternatives.
Many class methods simply ignore their first argument, because they
already know what package they're in and don't care what package
they were invoked via.  (These aren't necessarily the same, because
class methods follow the inheritance tree just like ordinary instance
methods.)  Another typical use for class methods is to look up an
object by name:

Typically it shifts the first argument into a "self" or "this" variable,
and then uses that as an ordinary reference.

0 0 0 

ways to write a method call.  The simpler and more common way is to use
the arrow notation:

references.  In fact, since 0 above is a reference to an object,
you could think of the method call as just another form of
dereferencing.

class name, is passed to the method subroutine as its first argument.
So the above code is mostly equivalent to:

the left side of the arrow, which must be either a package name or a
reference to an object, i.e. something that has been blessed to a
package.  Either way, that's the package where Perl starts looking.  If
that package has no subroutine with that name, Perl starts looking for
it in any base classes of that package, and so on.

its own versions of  and .  We haven't specified what
those methods do, but that doesn't matter above since we've forced Perl
to start looking for the subroutines in 0.

tell Perl to start looking for the method in the packages named in the
current class's 0 list.
0

0 and not to the superclass(es) of the object. Also, the
0 pseudo-class can only currently be used as a modifier to a method
name, but not in any of the other ways that class names are normally used,
eg:
0

expression that returns either of those on the left side of the arrow.
So the following statement is valid:

scalar variable containing either the method name or a subroutine
reference can also be used.

to a subroutine, then this is equivalent to calling the referenced
subroutine directly with the class name or object on the left side
of the arrow as its first argument. No lookup is done and there is
no requirement that the subroutine be defined in any package related
to the class name or object on the left side of the arrow.

0 0 0

object" notation.  This syntax was available in Perl 4 long before
objects were introduced, and is still used with filehandles like this:

parameters.  This is how Perl can tell you want an indirect method call
instead of an ordinary subroutine call.

you want.  Even worse, it must make that guess 0.
Usually Perl gets it right, but when it doesn't you get a function
call compiled as a method, or vice versa.  This can introduce subtle bugs
that are hard to detect.

programmers are wont to make) can be miscompiled into a subroutine
call if there's already a 0 function in scope.  You'd end up
calling the current package's 0 as a subroutine, rather than the
desired class's method.  The compiler tries to cheat by remembering
bareword 0s, but the grief when it messes up just isn't worth the
years of debugging it will take you to track down such subtle bugs.

limited to a name, a scalar variable, or a block, because it would have
to do too much lookahead otherwise, just like any other postfix
dereference in the language.  (These are the same quirky rules as are
used for the filehandle slot in functions like 0 and 0.)
This can lead to horribly confusing precedence problems, as in these
next two lines:

to use a block around the indirect object:

be a function named 0 in the current package.  0  However, you may still end up having
to read code using the indirect object notation, so it's important to be
familiar with it.

0

are inherited by all other classes:

0

0

default, this is equivalent to 0.

0

if it does then a reference to the sub is returned, if it does not then
0 is returned.

0

NEED argument is given then it will check that the current version (as
defined by the  variable in the given package) not less than
NEED; it will die if this is not the case.  This method is called automatically
by the 0 form of 0.

0 0

automatically destroyed.  (This may even be after you exit, if you've
stored references in global variables.)  If you want to capture control
just before the object is freed, you may define a DESTROY method in
your class.  It will automatically be called at the appropriate moment,
and you can do any extra cleanup you need to do.  Perl passes a reference
to the object under destruction as the first (and only) argument.  Beware
that the reference is a read-only value, and cannot be modified by
manipulating 0 within the destructor.  The object itself (i.e.
the thingy the reference points to, namely 0, 0,
0 etc.) is not similarly constrained.

important that you localise any global variables that the method may
update.  In particular, localise 0 if you use 0 and
localise 0 if you use 0 or backticks.

perl will again call the DESTROY method for the re-blessed object after
the current one returns.  This can be used for clean delegation of
object destruction, or for ensuring that destructors in the base classes
of your choosing get called.  Explicitly calling DESTROY is also possible,
but is usually never needed.

your class has an AUTOLOAD method, but does not need any DESTROY actions,
you probably want to provide a DESTROY method anyway, to prevent an
expensive call to AUTOLOAD each time an object is freed. As this technique
makes empty DESTROY methods common, the implementation is optimised so that
a DESTROY method that is an empty or constant subroutine, and hence could
have no side effects anyway, is not actually called.
0 0

one are destroyed.  Such objects will be freed and destroyed automatically
when the current object is freed, provided no other references to them exist
elsewhere.

book about object-oriented design methodology, and bang your forehead
with it for the next six months or so.

0 0 0
0 0 0

garbage collection system.  That means there's an extra
dereference going on at some level, so if you haven't built
your Perl executable using your C compiler's 0 flag, performance
will suffer.  If you 0 built Perl with 0, then this
probably won't matter.

reference count will not normally get freed.  Therefore, this is a bad
idea:

structures, you'll have to break the self-reference yourself explicitly
if you don't care to leak.  For example, here's a self-referential
node such as one might use in a sophisticated tree structure:

break their self reference yourself.  (In other words, this is not to be
construed as a feature, and you shouldn't depend on it.)

exits), then a rather costly but complete mark-and-sweep style of garbage
collection is performed, and everything allocated by that thread gets
destroyed.  This is essential to support Perl as an embedded or a
multithreadable language.  For example, this program demonstrates Perl's
two-phased garbage collection:

garbage collector reaching the unreachable.

are destructed in a separate pass before ordinary refs just to
prevent object destructors from using refs that have been themselves
destructed.  Plain refs are only garbage-collected if the destruct level
is greater than 0.  You can test the higher levels of global destruction
by setting the PERL_DESTRUCT_LEVEL environment variable, presuming
0 was enabled during perl build time.
See 0 for more information.

at a future date.

class that holds a pointer to the self-referential data structure.
Define a DESTROY method for the containing object's class that manually
breaks the circularities in the self-referential structure.

be found in 0, 0 and 0.  You should
also check out 0 for other object tricks, traps, and tips, as
well as 0 for some style guides on constructing both
modules and classes. 

=encoding utf8

0

0 0 0

they do in mathematics.

others.  For example, in 0, the multiplication has higher
precedence so 0 is evaluated first yielding 0 and not 0.

same operators is used one after another: whether the evaluator will
evaluate the left operations first or the right.  For example, in 0, subtraction is left associative so Perl evaluates the
expression left to right.  0 is evaluated first making the
expression 0 and not 0.

listed from highest precedence to lowest.  Operators borrowed from
C keep the same precedence relationship with each other, even where
C's precedence is slightly screwy.  (This makes learning Perl easier
for C folks.)  With very few exceptions, these all operate on scalar
values only, not array values.

0 0 0

quote and quote-like operators, any expression in parentheses,
and any function whose arguments are parenthesized.  Actually, there
aren't really functions in this sense, just list operators and unary
operators behaving as functions because you put parentheses around
the arguments.  These are all documented in 0.

is followed by a left parenthesis as the next token, the operator and
arguments within parentheses are taken to be of highest precedence,
just like a normal function call.

0, 0, or 0 is either very high or very low depending on
whether you are looking at the left side or the right side of the operator.
For example, in

but the commas on the left are evaluated after.  In other words,
list operators tend to gobble up all arguments that follow, and
then act like a simple TERM with regard to the preceding expression.
Be careful with parentheses:

enclose the argument list for 0 which is evaluated (printing
the result of 0).  Then one is added to the return value
of 0 (usually 1).  The result is something like this:

well as subroutine and method calls, and the anonymous
constructors 0 and 0.

as well as 0.

0 0 

and C++.  If the right side is either a 0, 0, or a
0 subscript, then the left side must be either a hard or
symbolic reference to an array, a hash, or a subroutine respectively.
(Or technically speaking, a location capable of holding a hard
reference, if it's an array or hash reference being used for
assignment.)  See 0 and 0.

variable containing either the method name or a subroutine reference,
and the left side must be either an object (a blessed reference)
or a class name (that is, a package name).  See 0.

0 0 0 0 0 0

they increment or decrement the variable by one before returning the
value, and if placed after, increment or decrement after returning the
value.

incremented or decremented. You just know it will be done sometime
before or after the value is returned. This also means that modifying
a variable twice in the same statement will lead to undefined behaviour.
Avoid statements like:

you increment a variable that is numeric, or that has ever been used in
a numeric context, you get a normal increment.  If, however, the
variable has been used in only string contexts since it was set, and
has a value that is not the empty string and matches the pattern
0, the increment is done as a string, preserving each
character within its range, with carry:

to 0 before incrementing (so that a post-increment of an undef value
will return 0 rather than 0).

0 0 0

tightly than unary minus, so -2**4 is -(2**4), not (-2)**4. (This is
implemented using C's  function, which actually works on doubles
internally.)

0 0

precedence version of this.
0

including any string that looks like a number.  If the operand is
an identifier, a string consisting of a minus sign concatenated
with the identifier is returned.  Otherwise, if the string starts
with a plus or minus, a string starting with the opposite sign is
returned.  One effect of these rules is that -bareword is equivalent
to the string "-bareword".  If, however, the string begins with a
non-alphabetic character (excluding "+" or "-"), Perl will attempt to convert
the string to a numeric and the arithmetic negation is performed. If the
string cannot be cleanly converted to a numeric, Perl will give the warning
0.
0 0

example, 0 is 0640.  (See also 0 and
0.)  Note that the width of the result is
platform-dependent: ~0 is 32 bits wide on a 32-bit platform, but 64
bits wide on a 64-bit platform, so if you are expecting a certain bit
width, remember to use the & operator to mask off the excess bits.
0 0

syntactically for separating a function name from a parenthesized expression
that would otherwise be interpreted as the complete list of function
arguments.  (See examples above under 0.)
0

and 0.  Do not confuse this behavior with the behavior of
backslash within a string, although both forms do convey the notion
of protecting the next thing from interpolation.
0 0 0

0 0 0 0

search or modify the string  by default.  This operator makes that kind
of operation work on some other string.  The right argument is a search
pattern, substitution, or transliteration.  The left argument is what is
supposed to be searched, substituted, or transliterated instead of the default
.  When used in scalar context, the return value generally indicates the
success of the operation.  The exceptions are substitution (s///)
and transliteration (y///) with the 0 (non-destructive) option,
which cause the 0eturn value to be the result of the substitution.
Behavior in list context depends on the particular operator.
See 0 for details and 0 for
examples using these operators.

substitution, or transliteration, it is interpreted as a search pattern at run
time. Note that this means that its contents will be interpolated twice, so

pattern 0, which it will consider a syntax error.

the logical sense.

(y///r) is a syntax error.

0

0

0 0

remainder of its first argument with respect to its second argument.
Given integer
operands 0 and 0: If 0 is positive, then 0 is
0 minus the largest multiple of 0 less than or equal to
0.  If 0 is negative, then 0 is 0 minus the
smallest multiple of 0 that is not less than 0 (i.e. the
result will be less than or equal to zero).  If the operands
0 and 0 are floating point values and the absolute value of
0 (that is 0) is less than 0, only
the integer portion of 0 and 0 will be used in the operation
(Note: here 0 means the maximum of the unsigned integer type).
If the absolute value of the right operand (0) is greater than
or equal to 0, "%" computes the floating-point remainder
0 in the equation 0 where 0 is a certain
integer that makes 0 have the same sign as the right operand
0 (0 as the left operand 0 like C function 0)
and the absolute value less than that of 0.
Note that when 0 is in scope, "%" gives you direct access
to the modulo operator as implemented by your C compiler.  This
operator is not as well defined for negative operands, but it will
execute faster.
0 0 0 0

operand is not enclosed in parentheses, it returns a string consisting
of the left operand repeated the number of times specified by the right
operand.  In list context, if the left operand is enclosed in
parentheses or is a list formed by 0, it repeats the list.
If the right operand is zero or negative, it returns an empty string
or an empty list, depending on the context.
0

0

0

0

0 0
0 0 0 0

0 0 X<<< << >>>
X<<< >> >>> 0 0 0
0 0 0 0

number of bits specified by the right argument.  Arguments should be
integers.  (See also 0.)

the number of bits specified by the right argument.  Arguments should
be integers.  (See also 0.)

"<<" and ">>" in C.  If 0 (see 0) is
in force then signed C integers are used, else unsigned C integers are
used.  Either way, the implementation isn't going to generate results
larger than the size of the integer type Perl was built with (32 bits
or 64 bits).

because it is undefined also in C.  In other words, using 32-bit
integers,  is undefined.  Shifting by a negative number
of bits is also undefined.

0

argument, with optional parentheses.

is followed by a left parenthesis as the next token, the operator and
arguments within parentheses are taken to be of highest precedence,
just like a normal function call.  For example,
because named unary operators are higher precedence than ||:

treated like named unary operators, but they don't follow this functional
parenthesis rule.  That means, for example, that 0 is
equivalent to 0.
0 0 0

0 0

the right argument.

than the right argument.

or equal to the right argument.

than or equal to the right argument.

the right argument.

than the right argument.

or equal to the right argument.

than or equal to the right argument.

0 0 0 0

the right argument.
0

to the right argument.
0

argument is numerically less than, equal to, or greater than the right
argument.  If your platform supports NaNs (not-a-numbers) as numeric
values, using them with "<=>" returns undef.  NaN is not "<", "==", ">",
"<=" or ">=" anything (even NaN), so those 5 return false. NaN != NaN
returns true, as does NaN != anything else. If your platform doesn't
support NaNs then NaN is just a string with numeric value 0.
 0

the right argument.
0

to the right argument.
0

argument is stringwise less than, equal to, or greater than the right
argument.
0

is described in 0.
0

by the current locale if 0 is in effect.  See 0.

0 0 0

(See also 0 and 0.)

the brackets are essential in a test like

0 0 0 0
0 0

(See also 0 and 0.)

(See also 0 and 0.)

for example the brackets are essential in a test like

0 0 0

if the left operand is false, the right operand is not even evaluated.
Scalar or list context propagates down to the right operand if it
is evaluated.

0 0

if the left operand is true, the right operand is not even evaluated.
Scalar or list context propagates down to the right operand if it
is evaluated.

0 0

to its C-style or.  In fact, it's exactly the same as 0, except that it
tests the left hand side's definedness instead of its truth.  Thus, 0
is similar to 0 (except that it returns the value of 0
rather than the value of 0) and yields the same result as
0 (except that the ternary-operator form can be
used as a lvalue, while 0 cannot).  This is very useful for
providing default values for variables.  If you actually want to test if
at least one of 0 and 0 is defined, use 0.

(unlike C's 0 and 0, which return 0 or 1). Thus, a reasonably
portable way to find out the home directory might be:

for selecting between two aggregates for assignment:

control flow, Perl provides the 0 and 0 operators (see below).
The short-circuit behavior is identical.  The precedence of "and"
and "or" is much lower, however, so that you can safely use them after a
list operator without the need for parentheses:

0 0 0 0

operators depending on the context.  In list context, it returns a
list of values counting (up by ones) from the left value to the right
value.  If the left value is greater than the right value then it
returns the empty list.  The range operator is useful for writing
0 loops and for doing slice operations on arrays. In
the current implementation, no temporary array is created when the
range operator is used as the expression in 0 loops, but older
versions of Perl might burn a lot of memory when you write something
like this:

auto-increment, see below.

bistable, like a flip-flop, and emulates the line-range (comma)
operator of 0, 0, and various editors. Each ".." operator
maintains its own boolean state, even across calls to a subroutine
that contains it. It is false as long as its left operand is false.
Once the left operand is true, the range operator stays true until the
right operand is true, 0 which the range operator becomes false
again.  It doesn't become false till the next time the range operator
is evaluated.  It can test the right operand and become false on the
same evaluation it became true (as in 0), but it still returns
true once. If you don't want it to test the right operand until the
next evaluation, as in 0, just use three dots ("...") instead of
two.  In all other regards, "..." behaves just like ".." does.

"false" state, and the left operand is not evaluated while the
operator is in the "true" state.  The precedence is a little lower
than || and &&.  The value returned is either the empty string for
false, or a sequence number (beginning with 1) for true.  The sequence
number is reset for each range encountered.  The final sequence number
in a range has the string "E0" appended to it, which doesn't affect
its numeric value, but gives you something to search for if you want
to exclude the endpoint.  You can exclude the beginning point by
waiting for the sequence number to be greater than 1.

that operand is considered true if it is equal (0) to the current
input line number (the 0 variable).

but that is only an issue if you use a floating point expression; when
implicitly using 0 as described in the previous paragraph, the
comparison is 0 which is only an issue when 0
is set to a floating point value and you are not reading from a file.
Furthermore, 0 or 0 will not do what
you want in scalar context because each of the operands are evaluated
using their integer representation.

the two range operators:

the range operator is changed to 0, it will also print the
"Baz" line.

auto-increment algorithm if the operands are strings.  You
can say

increment would produce, the sequence goes until the next value would
be longer than the final value specified.

sequence (that is, a non-empty string matching "/^[a-zA-Z]*[0-9]*\z/"),
only the initial value will be returned.  So the following will only
return an alpha:

return two elements in list context.

0 0 0 0

like an if-then-else.  If the argument before the ? is true, the
argument before the : is returned, otherwise the argument after the :
is returned.  For example:

or 3rd argument, whichever is selected.

legal lvalues (meaning that you can assign to them):

without parentheses will get you in trouble.  For example, this:

0 0 0 0 0 0 0
X<<< <<= >>> 0 0 0 0 X<<< >>= >>> 0 0 0
0 0 0

might trigger, such as from .  Other assignment operators work similarly.
The following are recognized:

of assignment.

Modifying an assignment is equivalent to doing the assignment and
then modifying the variable that was assigned to.  This is useful
for modifying a copy of something, like this:

lvalues assigned to, and a list assignment in scalar context returns
the number of elements produced by the expression on the right hand
side of the assignment.

0 0 0

its left argument, throws that value away, then evaluates its right
argument and returns that value.  This is just like C's comma operator.

both its arguments into the list.  These arguments are also evaluated
from left to right.

its left operand to be interpreted as a string if it begins with a letter
or underscore and is composed only of letters, digits and underscores.
This includes operands that might otherwise be interpreted as operators,
constants, single number v-strings or function calls. If in doubt about
this behaviour, the left operand can be quoted explicitly.

or list argument separator, according to context.

between keys and values in hashes, and other paired elements in lists.

0 0 0

parses it without error, but when you try to execute a yada yada, it
throws an exception with the text 0:

These examples of the yada yada work:

larger statement since the 0 is also the three-dot version of the
range operator (see 0). These examples of the yada
yada are still syntax errors:

between an expression and a statement. For instance, the syntax for a
block and an anonymous hash reference constructor look the same unless
there's something in the braces that give Perl a hint. The yada yada
is a syntax error if Perl doesn't guess that the 0 is a
block. In that case, it doesn't think the 0 is the yada yada
because it's expecting an expression instead of a statement:

a block and not a hash reference constructor. Now the yada yada works:

0 0

such that it controls all comma-separated expressions found there.
The only operators with lower precedence are the logical operators
"and", "or", and "not", which may be used to evaluate calls to list
operators without the need for extra parentheses:

0 0

It's the equivalent of "!" except for the very low precedence.

0 0

expressions.  It's equivalent to && except for the very low
precedence.  This means that it short-circuits: i.e., the right
expression is evaluated only if the left expression is true.

0 0
0 0
0 0

expressions.  It's equivalent to || except for the very low precedence.
This makes it useful for control flow

only if the left expression is false.  Due to its precedence, you should
probably avoid using this for assignment, only for control flow.

"||" for control flow, you probably need "or" so that the assignment
takes higher precedence.

It cannot short circuit, of course.

0 0 0
0 0

operators are typed: $, @, %, and &.)

0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 X<<< << >>>
0 0

function as operators, providing various kinds of interpolating and
pattern matching capabilities.  Perl provides customary quote characters
for these behaviors, but also provides a way for you to choose your
quote character for any of them.  In the following table, a 0 represents
any pair of delimiters you choose.

sorts of brackets (round, angle, square, curly) will all nest, which means
that

starting from Perl 5.8 part of the standard distribution) is able
to do this properly.

characters, except when 0 is being used as the quoting character.
0 is parsed as the string 0, while 0 is the
operator 0 followed by a comment.  Its argument will be taken
from the next line.  This allows you to write:

and in transliterations.
0 0 0 0 0 0 0 0 0 0 0 0
0

the braces.  See 0 below for details on which character.

character is encountered, a warning will be issued and the invalid
character and all subsequent characters (valid or invalid) within the
braces will be discarded.

the NULL character (0).  However, an explicit empty brace (0)
will not cause a warning.

0x00 to 0xFF.  See 0 below for details on which character.

by fewer than two valid digits, any valid digits will be zero-padded.  This
means that 0 will be interpreted as 0 and 0 alone will be
interpreted as 0.  Except at the end of a string, having fewer than
two valid digits will result in a warning.  Note that while the warning
says the illegal character is ignored, it is only ignored as part of the
escape and will still be used as the subsequent character in the string.
For example:

See 0.

point is 0.

table:

end of a string, because the backslash would be parsed as escaping the end
quote.

complete set of ASCII controls.  This isn't the case on EBCDIC platforms; see
0 for the complete list of what these
sequences mean on both ASCII and EBCDIC platforms.

discouraged, and some are deprecated with the intention of removing
those in Perl 5.16.  What happens for any of these
other characters currently though, is that the value is derived by inverting
the 7th bit (0x40).

See 0 below for details on which character.

and the value is based on the octal digits before it, discarding it and all
following characters up to the closing brace.  It is a fatal error if there are
no octal digits at all.

range 000 to 777 (but best to not use above 077, see next paragraph).  See
0 below for details on which character.

three digits, the first being a zero, may give unintended results.  (For
example, see 0.)  Starting in Perl 5.14, you may
use 0 instead which avoids all these problems.  Otherwise, it is best to
use this construct only for ordinals 0 and below, remembering to pad to
the left with zeros to make three digits.  For larger ordinals, either use
0 , or convert to something else, such as to hex and use 0
instead.

that what follows is ignored.  For example, 0 in the ASCII character set
is equivalent to the two characters 0, but the warning 0 will be thrown.  To avoid this warning, make sure to pad
your octal number with 0's: 0.

gives the character's position in the character set encoding (indexed from 0).
This is called synonymously its ordinal, code position, or code point).  Perl
works on platforms that have a native encoding currently of either ASCII/Latin1
or EBCDIC, each of which allow specification of 256 characters.  In general, if
the number is 255 (0xFF, 0377) or below, Perl interprets this in the platform's
native encoding.  If the number is 256 (0x100, 0400) or above, Perl interprets
it as as a Unicode code point and the result is the corresponding Unicode
character.  For example 0 and 0 both are the number 80 in
decimal, which is less than 256, so the number is interpreted in the native
character set encoding.  In ASCII the character in the 80th position (indexed
from 0) is the letter "P", and in EBCDIC it is the ampersand symbol "&".
0 and 0 are both 256 in decimal, so the number is interpreted
as a Unicode code point no matter what the native encoding is.  The name of the
character in the 100th position (indexed by 0) in Unicode is
0.

always interpreted as a Unicode code point, so that 0 is "P" even
on EBCDIC platforms.  And if L<C<0 is in effect, the
number is considered to be in that encoding, and is translated from that into
the platform's native encoding if there is a corresponding native character;
otherwise to Unicode.

the vertical tab (VT - ASCII 11), but you may use 0 or 0.  (0
does have meaning in regular expression patterns in Perl, see 0.)

but not in transliterations.
0 0 0 0 0 0

0 and 0 is taken from the current locale.  See 0.
If Unicode (for example, 0 or code points of 0x100 or
beyond) is being used, the case map used by 0, 0, 0 and
0 is as defined by Unicode.

called a "newline".  There is no such thing as an unvarying, physical
newline character.  It is only an illusion that the operating system,
device drivers, C libraries, and Perl all conspire to preserve.  Not all
systems read 0 as ASCII CR and 0 as ASCII LF.  For example,
on a Mac, these are reversed, and on systems without line terminator,
printing 0 may emit no actual data.  In general, use 0 when
you mean a "newline" for your system, but use the literal ASCII when you
need an exact character.  For example, most networking protocols expect
and prefer a CR+LF (0 or 0) for line terminators,
and although they often accept just 0, they seldom tolerate just
0.  If you get in the habit of using 0 for networking,
you may be burned some day.
0 0 0 0
0 0 0

or "0" are interpolated.  Subscripted variables such as 0 or
 are also interpolated, as are array and hash slices.
But method calls such as  are not.

separated by the value of 0, so is equivalent to interpolating
0.    "Punctuation" arrays such as 0 are only
interpolated if the name is enclosed in braces 0, but special
arrays 0, 0, and 0 are interpolated, even without braces.

interpolation and escapes are processed.

the quoting from 0 is applied after interpolation is processed,
but before escapes are processed. This allows the pattern to match
literally (except for 0 and 0). For example, the following matches:

like 0 to match them literally.

regular expression.  This is done as a second pass, after variables are
interpolated, so that regular expressions may be incorporated into the
pattern from the variables.  If this is not what you want, use 0 to
interpolate a variable literally.

multiple levels of interpolation.  In particular, contrary to the
expectations of shell programmers, back-quotes do 0 interpolate
within double quotes, nor do single quotes impede evaluation of
variables when used within double quotes.

0

matching and related activities.

0 0 0 0 0 0 0

expression.  0 is interpolated the same way as 0
in 0.  If "'" is used as the delimiter, no interpolation
is done.  Returns a Perl value which may be used instead of the
corresponding 0 expression. The returned value is a
normalized version of the original pattern. It magically differs from
a string containing the same characters: 0 returns "Regexp",
even though dereferencing the result returns undef.

operator, using  may have speed advantages in some situations,
notably if the result of  is used standalone:

the moment of  avoids a need to recompile the pattern every
time a match 0 is attempted.  (Perl has many other internal
optimizations, but none would be triggered in the above example if
we did not use  operator.)

of 'msixpluad' will be propagated appropriately.  The effect the 'o'
modifier has is not propagated, being restricted to those patterns
explicitly using it.

control the character set semantics.

for a detailed look at the semantics of regular expressions.  In
particular, all the modifiers execpt 0 are further explained in
0.  0 is described in the next section.

0 0
0 0 0 0
0 0 0 0 0 0 0 0

true if it succeeds, false if it fails.  If no string is specified
via the 0 or 0 operator, the  string is searched.  (The
string specified with 0 need not be an lvalue--it may be the
result of an expression evaluation, but remember the 0 binds
rather tightly.)  See also 0.

process modifiers are available:

you can use any pair of non-whitespace characters
as delimiters.  This is particularly useful for matching path names
that contain "/", to avoid LTS (leaning toothpick syndrome).  If "?" is
the delimiter, then a match-only-once rule applies,
described in 0 below.
If "'" is the delimiter, no interpolation is performed on the PATTERN.
When using a character valid in an identifier, whitespace is required
after the 0.

every time the pattern search is evaluated, except
for when the delimiter is a single quote.  (Note that 0, 0, and
0 are not interpolated because they look like end-of-string tests.)
Perl will not recompile the pattern unless an interpolated
variable that it contains changes.  You can force Perl to skip the
test and never recompile by adding a 0 (which stands for "once")
after the trailing delimiter.
Once upon a time, Perl would recompile regular expressions
unnecessarily, and this modifier was useful to tell it not to do so, in the
interests of speed.  But now, the only reasons to use 0 are either:

don't change, and you need to wring out the last little bit of speed by
having Perl skip testing for that.  (There is a maintenance penalty for
doing this, as mentioning 0 constitutes a promise that you won't
change the variables in the pattern.  If you change them, Perl won't
even notice.)

regardless of whether they change or not.  (But there are saner ways
of accomplishing this than using 0.)

0 matched regular expression is used instead. In this
case, only the 0 and 0 flags on the empty pattern is honoured -
the other flags are taken from the original pattern. If no match has
previously succeeded, this will (silently) act instead as a genuine
empty pattern (which will always match).

regex) is really 0 (the defined-or operator).  Perl is usually pretty
good about this, but some pathological cases might trigger this, such as
0 (is that 0 or 0?) and 0
(0 or 0?).  In all of these examples, Perl
will assume you meant defined-or.  If you meant the empty regex, just
use parentheses or spaces to disambiguate, or even prefix the empty
regex with an 0 (so 0 becomes 0).

list consisting of the subexpressions matched by the parentheses in the
pattern, i.e., (0, 0, 0...).  (Note that here 0 etc. are
also set, and that this differs from Perl 4's behavior.)  When there are
no parentheses in the pattern, the return value is the list 0 for
success.  With or without parentheses, an empty list is returned upon
failure.

remainder of the line, and assigns those three fields to , , and
.  The conditional is true if any variables were assigned, i.e., if
the pattern matched.

matching as many times as possible within the string. How it behaves
depends on the context. In list context, it returns a list of the
substrings matched by any capturing parentheses in the regular
expression. If there are no parentheses, it returns a list of all
the matched strings, as if there were parentheses around the whole
pattern.

returning true if it matches, and false if there is no further match.
The position after the last match can be read or set using the 0
function; see 0. A failed match normally resets the
search position to the beginning of the string, but you can avoid that
by adding the 0 modifier (e.g. 0). Modifying the target
string also resets the search position.

zero-width assertion that matches the exact position where the
previous 0, if any, left off. Without the 0 modifier, the
0 assertion still anchors at 0 as it was at the start of
the operation (see 0), but the match is of course only
attempted once. Using 0 without 0 on a target string that has
not previously had a 0 match applied to it is the same as using
the 0 assertion to match the beginning of the string.  Note also
that, currently, 0 is only properly supported when anchored at the
very beginning of the pattern.

without the 0 anchor would have done. Also note that the final match
did not update 0. 0 is only updated on a 0 match. If the
final match did indeed match 0, it's a good bet that you're running an
older (pre-5.6.0) Perl.

combine several regexps like this to process a string part-by-part,
doing different actions depending on which regexp matched.  Each
regexp tries to match where the previous one leaves off.

0 0

only once between calls to the  operator.  This is a useful
optimization when you want to see only the first occurrence of
something in each file of a set of files, for instance.  Only 0
patterns local to the current package are reset.

0; with any other delimiter this is the normal 0 operator.

but the resulting 0 syntax is deprecated, will warn on
usage and may be removed from a future stable release of Perl without
further notice.

0 0 0 0
0 0 0 0 0 0 0 0 0 0 0

with the replacement text and returns the number of substitutions
made.  Otherwise it returns false (specifically, the empty string).

substitution on a copy of the string and instead of returning the
number of substitutions, it returns the copy whether or not a
substitution occurred. The original string will always remain unchanged in
this case. The copy will always be a plain string, even if the input is an
object or a tied variable.

variable is searched and modified.  (The string specified with 0 must
be scalar variable, an array element, a hash element, or an assignment
to one of those, i.e., an lvalue.)

done on either the PATTERN or the REPLACEMENT.  Otherwise, if the
PATTERN contains a $ that looks like a variable rather than an
end-of-string test, the variable will be interpolated into the pattern
at run-time.  If you want the pattern compiled only once the first time
the variable is interpolated, use the 0 option.  If the pattern
evaluates to the empty string, the last successfully executed regular
expression is used instead.  See 0 for further explanation on these.

specific options:

the 0 when using a character allowed in identifiers.  If single quotes
are used, no interpretation is done on the replacement string (the 0
modifier overrides this, however).  Unlike Perl 4, Perl 5 treats backticks
as normal delimiters; the replacement text is not evaluated as a command.
If the PATTERN is delimited by bracketing quotes, the REPLACEMENT has
its own pair of quotes, which may or may not be bracketing quotes, e.g.,
0 or .  A 0 will cause the
replacement portion to be treated as a full-fledged Perl expression
and evaluated right then and there.  It is, however, syntax checked at
compile-time. A second 0 modifier will cause the replacement portion
to be 0ed before being run as a Perl expression.

0, we use the \<0 form in only the left hand side.
Anywhere else it's $<0.

to occur that you might want.  Here are two common cases:

the 0 flags.  This may change in a future version of Perl.  It
produces a warning if warnings are enabled.  To disambiguate, use a space
or change the order of the flags:

0

0 0 0 0

unless followed by the delimiter or another backslash, in which case
the delimiter or backslash is interpolated.

0 0 0 0

0 0 0 0

system command with 0 or its equivalent.  Shell wildcards,
pipes, and redirections will be honored.  The collected standard
output of the command is returned; standard error is unaffected.  In
scalar context, it comes back as a single (potentially multi-line)
string, or undef if the command failed.  In list context, returns a
list of lines (however you've defined lines with $/ or
), or an empty list if the command failed.

syntax (assuming the shell supports this) if you care to address this.
To capture a command's STDERR and STDOUT together:

important here):

but leave its STDOUT to come out the old STDERR:

to redirect them separately to files, and then read from those files
when the program is done:

For example:

double-quote interpolation, passing it on to the shell instead:

interpreter on your system.  On most platforms, you will have to protect
shell metacharacters if you want them treated literally.  This is in
practice difficult to do, as it's unclear how to escape which characters.
See 0 for a clean and safe example of a manual  and 
to emulate backticks safely.

capable of dealing with multiline commands, so putting newlines in
the string may not get you what you want.  You may be able to evaluate
multiple commands in a single line by separating them with the command
separator character, if your shell supports that (e.g. 0 on many Unix
shells; 0 on the Windows NT 0 shell).

output before starting the child process, but this may not be supported
on some platforms (see 0).  To be safe, you may need to set
0 ( in English) or call the 0 method of
0 on any open handles.

of the command line.  You must ensure your strings don't exceed this
limit after any necessary interpolations.  See the platform-specific
release notes for more details about your particular environment.

because the shell commands called vary between systems, and may in
fact not be present at all.  As one example, the 0 command under
the POSIX shell is very different from the 0 command under DOS.
That doesn't mean you should go out of your way to avoid backticks
when they're the right way to get something done.  Perl was made to be
a glue language, and one of the things it glues together is commands.
Just understand what you're getting yourself into.

0 0 0

whitespace as the word delimiters.  It can be understood as being roughly
equivalent to:

in scalar context it returns the last element in the list.  So
this expression:

put comments into a multi-line 0-string.  For this reason, the
0 pragma and the 0 switch (that is, the 0 variable)
produces warnings if the STRING contains the "," or the "#" character.

0 0 0 0 0 0

with the corresponding character in the replacement list.  It returns
the number of characters replaced or deleted.  If no string is
specified via the =~ or !~ operator, the  string is transliterated.  (The
string specified with =~ must be a scalar variable, an array element, a
hash element, or an assignment to one of those, i.e., an lvalue.)

replacement on a copy of the string and return the copy whether or not it
was modified. The original string will always remain unchanged in
this case. The copy will always be a plain string, even if the input is an
object or a tied variable.

does the same replacement as 0.
For 0 devotees, 0 is provided as a synonym for 0.  If the
SEARCHLIST is delimited by bracketing quotes, the REPLACEMENTLIST has
its own pair of quotes, which may or may not be bracketing quotes,
e.g., 0 or 0.

such as 0 or 0.  The 0 operator is not equivalent to
the  utility.  If you want to map strings between lower/upper
cases, see 0 and 0, and in general consider
using the 0 operator if you need regular expressions.

character sets--and even within character sets they may cause results
you probably didn't expect.  A sound principle is to use only ranges
that begin from and end at either alphabets of equal case (a-e, A-E),
or digits (0-4).  Anything else is unsafe.  If in doubt, spell out the
character sets in full.

is complemented.  If the 0 modifier is specified, any characters
specified by SEARCHLIST not found in REPLACEMENTLIST are deleted.
(Note that this is slightly more flexible than the behavior of some
0 programs, which delete anything they find in the SEARCHLIST,
period.) If the 0 modifier is specified, sequences of characters
that were transliterated to the same character are squashed down
to a single instance of the character.

exactly as specified.  Otherwise, if the REPLACEMENTLIST is shorter
than the SEARCHLIST, the final character is replicated till it is long
enough.  If the REPLACEMENTLIST is empty, the SEARCHLIST is replicated.
This latter is useful for counting characters in a class or for
squashing character sequences in a class.

first one is used:

the SEARCHLIST nor the REPLACEMENTLIST are subjected to double quote
interpolation.  That means that if you want to use variables, you
must use an :

0 0 0 X<<< << >>>

syntax.  Following a  you specify a string to terminate
the quoted material, and all lines following the current line down to
the terminating string are the value of the item.

quoted text.  An unquoted identifier works like double quotes.
There may not be a space between the  and the identifier,
unless the identifier is explicitly quoted.  (If you put a space it
will be treated as a null identifier, which is valid, and matches the
first empty line.)  The terminating string must appear by itself
(unquoted and with no surrounding whitespace) on the terminating line.

the treatment of the text.

the same rules as normal double quoted strings.

interpolation of its content. This is similar to single quoted
strings except that backslashes have no special meaning, with 0
being treated as two backslashes and not one as they would in every
other quoting construct.

to worry about escaping content, something that code generators
can and do make good use of.

string were embedded in backticks. Thus the content is interpolated
as though it were double quoted and then executed via the shell, with
the results of the execution returned.

to finish the statement, as Perl doesn't know you're not going to
try to do this:

use 0.

you'll need to remove leading whitespace from each line manually:

the quoted material must come on the lines following the final delimiter.
So instead of

must be sure there is a newline after it; otherwise, Perl will give the
warning 0.

related to Perl's quoting rules. 0, 0, and the like are not
supported in place of 0 and 0, and the only interpolation is for
backslashing the quoting character:

that the identifier must be a string literal.  Stick with that, and you
should be safe.

0

interpretations, Perl uses the 0 (that's "Do What I Mean")
principle to pick the most probable interpretation.  This strategy
is so successful that Perl programmers often do not suspect the
ambivalence of what they write.  But from time to time, Perl's
notions differ substantially from what the author honestly meant.

Although the most common reason to learn this is to unravel labyrinthine
regular expressions, because the initial steps of parsing are the
same for all quoting operators, they are all discussed together.

below: when processing a quoted construct, Perl first finds the end
of that construct, then interprets its contents.  If you understand
this rule, you may skip the rest of this section on the first
reading.  The other rules are likely to contradict the user's
expectations much less frequently than this first one.

their results are the same, we consider them individually.  For different
quoting constructs, Perl performs different numbers of passes, from
one to four, but these passes are always performed in the same order.

the information about the delimiters is used in parsing.
During this search, text between the starting and ending delimiters
is copied to a safe location. The text copied gets delimiter-independent.

that has a terminating string as the content. Therefore C<<<EOF> is
terminated by 0 immediately followed by 0 and starting
from the first column of the terminating line.
When searching for the terminating line of a here-doc, nothing
is skipped. In other words, lines after the here-doc syntax
are compared with the terminating string line by line.

and ending delimiters. If the starting delimiter is an opening punctuation
(that is 0, 0, 0, or ), the ending delimiter is the
corresponding closing punctuation (that is 0, 0, 0, or ).
If the starting delimiter is an unpaired character like 0 or a closing
punctuation, the ending delimiter is same as the starting delimiter.
Therefore a 0 terminates a 0 construct, while a 0 terminates
0 and 0 constructs.

and 0 are skipped. For example, while searching for terminating 0,
combinations of 0 and 0 are skipped.  If the delimiters are
bracketing, nested pairs are also skipped.  For example, while searching
for closing 0 paired with the opening 0, combinations of 0, 0,
and 0 are all skipped, and nested 0 and 0 are skipped as well.
However, when backslashes are used as the delimiters (like 0 and
0), nothing is skipped.
During the search for the end, backslashes that escape delimiters
are removed (exactly speaking, they are not copied to the safe location).

0), the search is repeated once more.
If the first delimiter is not an opening punctuation, three delimiters must
be same such as 0 and 0, in which case the second delimiter
terminates the left part and starts the right part at once.
If the left part is delimited by bracketing punctuation (that is 0,
0, 0, or ), the right part needs another pair of
delimiters such as 0 and 0.  In these cases, whitespace
and comments are allowed between both parts, though the comment must follow
at least one whitespace character; otherwise a character expected as the
start of the comment may be regarded as the starting delimiter of the right part.

Thus:

first 0 and 0, and the rest happens to be a syntax error.
Because the slash that terminated 0 was followed by a 0,
the example above is not 0, but rather 0 with no 0
modifier.  So the embedded 0 is interpreted as a literal 0.

this search. Thus the second 0 in 0 is interpreted as a part
of 0, and the following 0 is not recognized as a delimiter.
Instead, use 0 or 0 at the end of quoted constructs.

0

delimiter-independent.  There are multiple cases.

Note that the combination 0 is left intact, since escaped delimiters
are not available for here-docs.

Any backslashed sequences including 0 are treated at the stage
to 0.

Therefore 0 in 0 and 0 is treated literally
as a hyphen and no character range is available.
0 in the replacement of 0 does not work as 0.

case and quoting such as 0, 0, and 0 are not recognized.
The other escape sequences such as 0 and 0 and backslashed
characters such as 0 and 0 are converted to appropriate literals.
The character 0 is treated specially and therefore 0 is treated
as a literal 0.

converted to corresponding Perl constructs.  Thus, 0
is converted to 0 internally.
The other escape sequences such as 0 and 0 and backslashed
characters such as 0 and 0 are replaced with appropriate
expansions.

is interpolated in the usual way.  Something like 0 has
no 0 inside.  instead, it has 0, 0, and 0, so the
result is the same as for 0.  As a general rule, backslashes
between 0 and 0 may lead to counterintuitive results.  So,
0 is converted to 0, which is the same
as 0 (since TAB is not alphanumeric).  Note also that:

0 catenation operations.  Thus, 0 becomes:

quoted, there is no way to insert a literal 0 or 0 inside a
0 pair.  If protected by 0, 0 will be quoted to became
0; if not, it is interpreted as the start of an interpolated
scalar.

where the interpolated scalar ends.  For instance, whether
 really means:

spaces between components and which contains matching braces or
brackets.  because the outcome may be determined by voting based
on heuristic estimators, the result is not strictly predictable.
Fortunately, it's usually correct for ambiguous cases.

happens as with 0 constructs.

the replacement text of 0, in order to correct the incorrigible
0 hackers who haven't picked up the saner idiom yet.  A warning
is emitted if the 0 pragma or the 0 command-line flag
(that is, the 0 variable) was set.

and interpolation happens (almost) as with 0 constructs.

form for the regex compiler.  (This is because, as mentioned below, the regex
compilation may be done at execution time, and 0 is a compile-time
construct.)

are not substituted but only skipped, in order to parse them
as regular expressions at the following step.
As 0 is skipped at this step, 0 of 0 in RE is possibly
treated as an array symbol (for example 0),
even though the same text in 0 gives interpolation of 0.

a 0-comment in a 0-regular expression, no processing is
performed whatsoever.  This is the first step at which the presence
of the 0 modifier is relevant.

and 0 are not interpolated, and constructs 0 are
voted (by several different estimators) to be either an array element
or 0 followed by an RE alternative.  This is where the notation
0 comes handy: 0 is interpreted as
array element 0, not as a regular expression from the variable
0 followed by a digit, which would be the interpretation of
0.  Since voting among different estimators may occur,
the result is not predictable.

the post-processed text.  If the delimiter is 0, one cannot get
the combination 0 into the result of this step.  0 will
finish the regular expression, 0 will be stripped to 0 on
the previous step, and 0 will be left as is.  Because 0 is
equivalent to 0 inside a regular expression, this does not
matter unless the delimiter happens to be character special to the
RE engine, such as in 0, 0, or 0; or an
alphanumeric char, as in:

delimiter is 0, the modifier is 0, and after delimiter-removal the
RE is the same as for 0.  There's more than one
reason you're encouraged to restrict your delimiters to non-alphanumeric,
non-whitespace choices.

which are processed further.

0

but this one happens at run time, although it may be optimized to
be calculated at compile time if appropriate.  After preprocessing
described above, and possibly after evaluation if concatenation,
joining, casing translation, or metaquoting are involved, the
resulting 0 is passed to the RE engine for compilation.

but for the sake of continuity, we shall do so here.

relevant.  The RE engine scans the string from left to right and
converts it to a finite automaton.

literal strings (as with 0), or else they generate special nodes
in the finite automaton (as with 0).  Characters special to the
RE engine (such as 0) generate corresponding nodes or groups of
nodes.  0 comments are ignored.  All the rest is either
converted to literal strings to match, or else is ignored (as is
whitespace and 0-style comments if 0 is present).

rather different than the rule used for the rest of the pattern.
The terminator of this construct is found using the same rules as
for finding the terminator of a 0-delimited construct, the only
exception being that 0 immediately following 0 is treated as
though preceded by a backslash.  Similarly, the terminator of
0 is found using the same rules as for finding the
terminator of a 0-delimited construct.

resulting finite automaton.  See the arguments 0/0
in the C<use 0 pragma, as well as Perl's 0 command-line
switch documented in 0.

0

semantics, details of this step are not documented and are subject
to change without notice.  This step is performed over the finite
automaton that was generated during the previous pass.

mean 0.

0 0 0 0 0
 0

double-quote interpolation.  It is then interpreted as an external
command, and the output of that command is the value of the
backtick string, like in a shell.  In scalar context, a single string
consisting of all output is returned.  In list context, a list of
values is returned, one per line of output.  (You can set 0 to use
a different line terminator.)  The command is executed each time the
pseudo-literal is evaluated.  The status value of the command is
returned in 0 (see 0 for the interpretation of 0).
Unlike in 0, no translation is done on the return data--newlines
remain newlines.  Unlike in any of the shells, single quotes do not
hide variable names in the command from interpretation.  To pass a
literal dollar-sign through to the shell you need to hide it with a
backslash.  The generalized form of backticks is 0.  (Because
backticks always undergo shell expansion as well, see 0 for
security concerns.)
0 0 0 0 0

the next line from that file (the newline, if any, included), or
0 at end-of-file or on error.  When 0 is set to 0
(sometimes known as file-slurp mode) and the file is empty, it
returns 0 the first time, followed by 0 subsequently.

there is one situation where an automatic assignment happens.  If
and only if the input symbol is the only thing inside the conditional
of a 0 statement (even if disguised as a 0 loop),
the value is automatically assigned to the global variable ,
destroying whatever was there previously.  (This may seem like an
odd thing to you, but you'll use the construct in almost every Perl
script you write.)  The  variable is not implicitly localized.
You'll have to put a 0 before the loop if you want that
to happen.

is automatic or explicit) is then tested to see whether it is
defined.  The defined test avoids problems where line has a string
value that would be treated as false by Perl, for example a "" or
a "0" with no trailing newline.  If you really mean for such values
to terminate the loop, they should be tested for explicitly:

explicit 0 test or comparison elicits a warning if the
0 pragma or the 0
command-line switch (the 0 variable) is in effect.

filehandles 0, 0, and 0 will also work except
in packages, where they would be interpreted as local identifiers
rather than global.)  Additional filehandles may be created with
the  function, amongst others.  See 0 and
0 for details on this.
0 0 0

a list, a list comprising all input lines is returned, one line per
list element.  It's easy to grow to a rather large data space this
way, so use with care.

See 0.

behavior of 0 and 0.  Input from <> comes either from
standard input, or from each file listed on the command line.  Here's
how it works: the first time <> is evaluated, the @ARGV array is
checked, and if it is empty, 0 is set to "-", which when opened
gives you standard input.  The @ARGV array is then processed as a list
of filenames.  The loop

It really does shift the @ARGV array and put the current filename
into the  variable.  It also uses filehandle 0
internally. <> is just a synonym for <ARGV>, which
is magical.  (The pseudo code above doesn't work because it treats
<ARGV> as non-magical.)

it interprets special characters, so if you have a script like this:

pipe, executes the 0 command and reads 0's output from that pipe.
If you want all items in 0 to be interpreted as file names, you
can use the module 0 from CPAN.

containing the list of filenames you really want.  Line numbers (0)
continue as though the input were one big happy file.  See the example
in 0 for how to reset line numbers on each file.

This sets @ARGV to all plain text files if no @ARGV was given:

filters compressed arguments through 0:

Getopts modules or put a loop on the front like this:

If you call it again after this, it will assume you are processing another
@ARGV list, and if you haven't set @ARGV, will read input from STDIN.

<>), then that variable contains the name of the
filehandle to input from, or its typeglob, or a reference to the
same.  For example:

scalar variable containing a filehandle name, typeglob, or typeglob
reference, it is interpreted as a filename pattern to be globbed, and
either a list of filenames or the next filename in the list is returned,
depending on context.  This distinction is determined on syntactic
grounds alone.  That means  is always a  from
an indirect handle, but  is always a .
That's because  is a simple scalar variable, but 0 is
not--it's a hash element.  Even  (note the extra space)
is treated as 0, not 0.

say  because that's an indirect filehandle as explained
in the previous paragraph.  (In older versions of Perl, programmers
would insert curly brackets to force interpretation as a filename glob:
.  These days, it's considered cleaner to call the
internal function directly as 0, which is probably the right
way to have done it in the first place.)  For example:

0 extension.  Of course, the shortest way to do the above is:

starting a new list.  All values must be read before it will start
over.  In list context, this isn't important because you automatically
get them all anyway.  However, in scalar context the operator returns
the next value each time it's called, or 0 when the list has
run out.  As with filehandle reads, an automatic 0 is
generated when the glob occurs in the test part of a 0,
because legal glob returns (e.g. a file called 0) would otherwise
terminate the loop.  Again, 0 is returned only once.  So if
you're expecting a single value from a glob, it is much better to
say

returning false.

to use the  function, because the older notation can cause people
to become confused with the indirect filehandle notation.

0 0

compile time whenever it determines that all arguments to an
operator are static and have no side effects.  In particular, string
concatenation happens at compile time between literals that don't do
variable substitution.  Backslash interpolation also happens at
compile time.  You can say

you say

represents so that the interpreter won't have to.

0 0

0 and 0 are special-cased to not produce a warning in a void
context, so you can for example safely do

0

(0).

sizes, 0 and 0 ops act as though the shorter operand had
additional zero bits on the right, while the 0 op acts as though
the longer operand were truncated to the length of the shorter.
The granularity for such extension or truncation is one or more
bytes.

you're supplying bitstrings: If an operand is a number, that will imply
a 0 bitwise operation.  You may explicitly show which type of
operation you intend by using 0 or 0, as in the examples below.

in a bit vector.

0

floating point.  But by saying

(see 0 for a detailed explanation) from here to the end of
the enclosing BLOCK.  An inner BLOCK may countermand this by saying

mean everything is an integer, merely that Perl will use integer
operations for arithmetic, comparison, and bitwise operators.  For
example, even under 0, if you take the 0, you'll
still get 0") always produce integral results.  (But see also
0.)  However, 0 still has meaning for
them.  By default, their results are interpreted as unsigned integers, but
if 0 is in effect, their results are interpreted
as signed integers.  For example, 0 usually evaluates to a large
integral value.  However, 0 is 0 on two's-complement
machines.

0 0 0 0

analogous mechanism to provide automatic rounding or truncation to a
certain number of decimal places.  For rounding to a certain number
of digits,  or  is usually the easiest route.
See 0.

would call real numbers.  There are infinitely more reals than floats,
so some corners must be cut.  For example:

good idea.  Here's a (relatively expensive) work-around to compare
whether two floating-point numbers are equal to a particular number of
decimal places.  See Knuth, volume II, for a more robust treatment of
this topic.

, , and other mathematical and trigonometric functions.
The Math::Complex module (part of the standard perl distribution)
defines mathematical functions that work on both the reals and the
imaginary numbers.  Math::Complex not as efficient as POSIX, but
POSIX can't work with complex numbers.

the rounding method used should be specified precisely.  In these
cases, it probably pays not to trust whichever system rounding is
being used by Perl, but to instead implement the rounding function you
need yourself.

0

variable-precision arithmetic and overloaded operators, although
they're currently pretty slow. At the cost of some space and
considerable speed, they avoid the normal pitfalls associated with
limited-precision representations.

memory and cpu-time) unlimited or fixed precision. There are also
some non-standard modules that provide faster implementations via
external C libraries.

=encoding utf8

convenience, and the C way for precision.  The shell way also has 2- and
3-argument forms, which have different semantics for handling the filename.
The choice is yours.

redirection in the shell works.  Here are some basic examples
from the shell:

in learning that Perl directly supports these familiar constructs using
virtually the same syntax as the shell.

and the second is a single string comprising both what to open and how
to open it.  0 returns true when it works, and when it fails,
returns a false value and sets the special variable 0 to reflect
the system error.  If the filehandle was previously opened, it will
be implicitly closed first.

If omitted, Perl assumes that you want to open the file for reading.

second uses 0, which has lower precedence.  Using 0 in the latter
examples would effectively mean

any whitespace before or after the filename is ignored.  This is good,
because you wouldn't want these to do different things:

in from a different file, and forget to trim it before opening:

its style of using redirection arrows to specify how to open the file, it
also does so with respect to extra whitespace around the filename itself
as well.  For accessing files with naughty names, see
0.

special redirection characters into their own argument:

so you don't have to worry about 0 containing characters
that might influence the open mode, or whitespace at the beginning of
the filename that would be absorbed in the 2-argument version.  Also,
any reduction of unnecessary string interpolation is a good thing.

perl 5.6.0, if the argument is uninitialized, Perl will automatically
create a filehandle and put a reference to it in the first argument,
like so:

are global to the current package, two subroutines trying to open
0 will clash.  With two functions opening indirect filehandles
like 0, there's no clash and no need to worry about future
conflicts.

closes when there are no more references to it:

filehandles from subroutines:

you use the 0 function, but when opening a pipe, you use the
0 function.  But in the shell, you just use a different redirection
character.  That's also the case for Perl.  The 0 call
remains the same--just its argument differs.

command and opens a write-only filehandle leading into that command.
This lets you write into that handle and have what you write show up on
that command's standard input.  For example:

read-only filehandle leading out of that command.  This lets whatever that
command writes to its standard output show up on your handle for reading.
For example:

command?  If possible, Perl will detect the failure and set 0 as
usual.  But if the command contains special shell characters, such as
C<0 or 0, called 'metacharacters', Perl does not execute the
command directly.  Instead, Perl runs the shell, which then tries to
run the command.  This means that it's the shell that gets the error
indication.  In such a case, the 0 call will only indicate
failure if Perl can't even run the shell.  See 0 to see how to cope with
this.  There's also an explanation in 0.

library will handle this for you.  Check out
0

based on its command line arguments without relying on the shell. (Similar
to the 0 notation.) This is safer and faster than executing
a single argument pipe-command, but does not allow special shell
constructs. (It is also not supported on Microsoft Windows, Mac OS Classic
or RISC OS.)

fortune cookie as uppercase:

0 function treats a file whose name is a single minus, "-", in a
special way.  If you open minus for reading, it really means to access
the standard input.  If you open minus for writing, it really means to
access the standard output.

if you open a pipe into or out of minus?  What's the default command it
would run?  The same script as you're currently running!  This is actually
a stealth 0 hidden inside an 0 call.  See
0 for details.

add a "+" symbol in front of the redirection.  But as in the shell,
using a less-than on a file never creates a new file; it only opens an
existing one.  On the other hand, using a greater-than always clobbers
(truncates to zero length) an existing file, or creates a brand-new one
if there isn't an old one.  Adding a "+" for read-write doesn't affect
whether it only works on existing files or always clobbers existing ones.

clobber an old one.  The third one will create a new file if necessary
and not clobber an old one, and it will allow you to read at any point
in the file, but all writes will always go to the end.  In short,
the first case is substantially more common than the second and third
cases, which are almost always wrong.  (If you know C, the plus in
Perl's 0 is historically derived from the one in C's fopen(3S),
which it ultimately calls.)

a binary file as in the WTMP case above, you probably don't want to
use this approach for updating.  Instead, Perl's 0 flag comes to
the rescue.  The following command takes all the C, C++, or yacc source
or header files and changes all their foo's to bar's, leaving
the old version in the original filename with a ".orig" tacked
on the end:

the best way to update textfiles.  See the second question in
0 for more details.

even notice.  When you process the ARGV filehandle using
, Perl actually does an implicit open
on each file in @ARGV.  Thus a program called like this:

using a construct no more complex than:

up minus, that is, the standard input.  In fact, , the currently
open file during  processing, is even set to "-"
in these circumstances.

make sure it's to your liking.  One reason to do this might be to remove
command options beginning with a minus.  While you can always roll the
simple ones by hand, the Getopts modules are good for this:

argument list default to all files:

silent, of course, and you might prefer to mention them on the way.

should put changes to @ARGV in a 0 block.

call fopen(3S) or it might called popen(3S), depending on what its
argument looks like; that's why it's sometimes called "magic open".
Here's an example:

 processing employs the normal, shell-style Perl 0,
it respects all the special things we've already seen:

input (0 in this case), the 0 file, the 0 command,
and finally the 0 file.

your directory, they won't be processed as literal files by 0.
You'll need to pass them as "./-", much as you would for the 0 program,
or you could use 0 as described below.

name into pipes.  For example, to autoprocess gzipped or compressed
files by decompressing them with 0:

you can fetch URLs before processing them:

Pretty nifty, eh?

definitely the way to go.  On the other hand, if you want finer precision
than C's simplistic fopen(3S) provides you should look to Perl's
0, which is a direct hook into the  system call.
That does mean it's a bit more involved, but that's the price of
precision.

a literal path, one that doesn't pay attention to any greater-thans or
less-thans or pipes or minuses, nor ignore whitespace.  If it's there,
it's part of the path.  The FLAGS argument contains one or more values
derived from the Fcntl module that have been or'd together using the
bitwise "|" operator.  The final argument, the MASK, is optional; if
present, it is combined with the user's current umask for the creation
mode of the file.  You should usually omit this.

are 0, 1, and 2 respectively, this is known not to hold true on some
systems.  Instead, it's best to load in the appropriate constants first
from the Fcntl module, which supplies the following standard flags:

systems include 0, 0, 0, 0,
0, 0, 0, 0, 0,
0, 0 and 0.  Consult your 
manpage or its local equivalent for details.  (Note: starting from
Perl release 5.6 the 0 flag, if available, is automatically
added to the  flags because large files are the default.)

before.  We'll omit the 0 checks for clarity, but make sure
you always check the return values in real code.  These aren't quite
the same, since 0 will trim leading and trailing whitespace,
but you'll get the idea.

an old file:

a regular 0.  As you'll see, it's just a matter of controlling the
flags in the third argument.

exist:

0666.  The normal MASK to use for executables and directories should
be 0777, and for anything else, 0666.

by your process's current 0.  A umask is a number representing
0 permissions bits; that is, bits that will not be turned on
in the created file's permissions field.

disable the group from writing, and the 007 part would disable others
from reading, writing, or executing.  Under these conditions, passing
0 0666 would create a file with mode 0640, since 0
is 0640.

away the user's freedom to choose what permission new files will have.
Denying choice is almost always a bad thing.  One exception would be for
cases where sensitive or private data is being stored, such as with mail
folders, cookie files, and internal temporary files.

handle that's a duplicate of the first one.  In the shell, we place an
ampersand in front of a file descriptor number when doing redirections.
For example,  makes descriptor 2 (that's STDERR in Perl)
be redirected into descriptor 1 (which is usually Perl's STDOUT).
The same is essentially true in Perl: a filename that begins with an
ampersand is treated instead as a file descriptor if a number, or as a
filehandle if a string.

want to give it a filename because you already have the file open, you
can just pass the filehandle with a leading ampersand.  It's best to
use a fully qualified handle though, just in case the function happens
to be in a different package:

just use the already opened handle.  This differs from passing a handle,
because with a handle, you don't open the file.  Here you have something
you can pass to open.

folks are raving about, then this doesn't work because those aren't a
proper filehandle in the native Perl sense.  You'll have to use 
to pull out the proper descriptor number, assuming you can:

filehandles though:

"&" but rather with a "&=" combination, then Perl will not create a
completely new descriptor opened to the same place using the 
system call.  Instead, it will just make something of an alias to the
existing one using the fdopen(3S) library call.  This is slightly more
parsimonious of systems resources, although this is less a concern
these days.  Here's an example of that:

command line argument in @ARGV something like C<"<&=">,
but we've never seen anyone actually do this.

is an acronym for "do what I mean".  But this principle sometimes leads
to more hidden magic than one knows what to do with.  In this way, Perl
is also filled with 0, an obscure word meaning an enchantment.
Sometimes, Perl's DWIMmer is just too much like dweomer for comfort.

to 0.  To open a file with arbitrary weird characters in
it, it's necessary to protect any leading and trailing whitespace.
Leading whitespace is protected by inserting a 0 in front of a
filename that starts with whitespace.  Trailing whitespace is protected
by appending an ASCII NUL byte (0) at the end of the string.

working directory, slash the directory separator, and disallows ASCII
NULs within a valid filename.  Most systems follow these conventions,
including all POSIX systems as well as proprietary Microsoft systems.
The only vaguely popular system that doesn't work this way is the
"Classic" Macintosh system, which uses a colon where the rest of us
use a slash.  Maybe 0 isn't such a bad idea after all.

and non-magical way, you could do this first:

to mean standard input, per the standard convention.

produce messages like:

from it.  But what was the name of the file, rather than the handle?

temporarily, then all you have to do is this:

you'll get warnings more like

passive prevarication.  You see, it can also take just one argument.
If and only if the variable is a global variable, not a lexical, you
can pass 0 just one argument, the filehandle, and it will
get the path from the global scalar variable of the same name.

It's something that's been in Perl since the very beginning, if not
before.

with the program.

to a command line redirection, it won't report the error exit with a
failure status.

welcome to reopen them if you'd like.

This makes it look as though the program were initially invoked
with those redirections from the command line.

already piped into your pager.  You can also use this kind of thing
in conjunction with an implicit fork to yourself.  You might do this
if you would rather handle the post processing in your own program,
just in a different process:

output stream as you wish.

but they do affect what you do with your open files.

isn't a plain file.   We'll check whether it's a symbolic link first,
just in case.

symbolic links, named pipes, Unix-domain sockets, and block and character
devices.  Those are all files, too--just not 0 files.  This isn't
the same issue as being a text file. Not all text files are plain files.
Not all plain files are text files.  That's why there are separate 0
and 0 file tests.

process it with 0, carefully restoring the directory
name if necessary:

File::Find module.  For example, this prints out all files recursively
and adds a slash to their names if the file is a directory.

what it points to.  Or, if you want to know 0 it points to, then
0 is called for:

but their opens will normally block until there is both a reader and
a writer.  You can read more about them in 0.
Unix-domain sockets are rather different beasts as well; they're
described in 0.

We'll assume that if you're opening up a block device, you know what
you're doing.  The character devices are more interesting.  These are
typically used for modems, mice, and some kinds of printers.  This is
described in 0
It's often enough to open them carefully:

sockets, you can set them to be non-blocking using 0:

all dissimilar, if you're going to manipulate ttys, it's best to
make calls out to the  program if you have it, or else use the
portable POSIX interface.  To figure this all out, you'll need to read the
 manpage, which describes the POSIX interface to tty devices,
and then 0, which describes Perl's interface to POSIX.  There are
also some high-level modules on CPAN that can help you with these games.
Check out Term::ReadKey and Term::ReadLine.

one of Perl's two open functions.  See
0 for that.  Here's an
example.  Once you have it, you can use FH as a bidirectional filehandle.

the doctor ordered.  There's no filehandle interface, but
it's still easy to get the contents of a document:

convoluted (some would say broken) I/O models, a file isn't a file--at
least, not with respect to the C standard I/O library.  On these old
systems whose libraries (but not kernels) distinguish between text and
binary streams, to get files to behave properly you'll have to bend over
backwards to avoid nasty problems.  On such infelicitous systems, sockets
and pipes are already opened in binary mode, and there is currently no
way to turn that off.  With files, you have more options.

handles before doing regular I/O on them:

binary mode on those systems that support it.  This is the equivalent of
opening the file normally, then calling 0 on the handle.

about the non-standard system I/O library breaking your data.  It's not
a pretty picture, but then, legacy systems seldom are.  CP/M will be
with us until the end of days, and after.

enough, even unbuffered I/O using 0 and 0 might do
sneaky data mutilation behind your back.

may need 0 or 0 first.  Systems known to be free of
such difficulties include Unix, the Mac OS, Plan 9, and Inferno.

with other processes who want to do I/O on the same files as you
are working on.  You'll often need shared or exclusive locks
on files for reading and writing respectively.  You might just
pretend that only exclusive locks exist.

because there is a race condition between the test for the existence of
the file and its creation.  It's possible for another process to create
a file in the slice of time between your existence check and your attempt
to create the file.  Atomicity is critical.

whose simplicity is emulated on systems that don't directly support it
such as SysV or Windows.  The underlying semantics may affect how
it all works, so you should learn how 0 is implemented on your
system's port of Perl.

do I/O.  A file lock only locks out others trying to get a lock, not
processes trying to do I/O.  Because locks are advisory, if one process
uses locking and another doesn't, all bets are off.

A request for a shared lock will be granted as soon as there is no
exclusive locker.  A request for an exclusive lock will be granted as
soon as there is no locker of any kind.  Locks are on file descriptors,
not file names.  You can't lock a file until you open it, and you can't
hold on to a lock once the file has been closed.

for reading:

if you're going to be blocking:

careful.  We 0 the file so it can be locked before it gets
emptied.  You can get a nonblocking version using 0.

wasting cycles on useless vanity devices called hit counters, here's
how to increment a number in a file safely:

This is a new "plumbing" for all the I/O happening in Perl; for the
most part everything will work just as it did, but PerlIO also brought
in some new features such as the ability to think of I/O as "layers".
One I/O layer may in addition to just moving the data also do
transformations on the data.  Such transformations may include
compression and decompression, encryption and decryption, and transforming
between various character encodings.

tutorial, but here is how to recognize the layers being used:

second argument contains something else in addition to the usual
, , ,  and their variants,
for example:

for more detailed discussion about Unicode and I/O see 0.

the system , , , and  manpages;
the POSIX documentation.

under the same terms as Perl itself.

hereby placed into the public domain.  You are permitted and
encouraged to use this code in your own programs for fun or for profit
as you see fit.  A simple comment in the code giving credit would be
courteous but is not required.

=encoding utf8

to a user-defined template, between the guarded way Perl stores values
and some well-defined representation as might be required in the
environment of a Perl program. Unfortunately, they're also two of
the most misunderstood and most often overlooked functions that Perl
provides. This tutorial will demystify them for you.

stored. In C, for instance, you can take the address of some variable,
and the 0 operator tells you how many bytes are allocated to
the variable. Using the address and the size, you may access the storage
to your heart's content.

representational conversion provided by 0 and 0 is an
excellent alternative. The 0 function converts values to a byte
sequence containing representations according to a given specification,
the so-called "template" argument. 0 is the reverse process,
deriving some values from the contents of a string of bytes. (Be cautioned,
however, that not all that has been packed together can be neatly unpacked -
a very common experience as seasoned travellers are likely to confirm.)

in binary representation? One good reason is input and output accessing
some file, a device, or a network connection, whereby this binary
representation is either forced on you or will give you some benefit
in processing. Another cause is passing data to some system call that
is not available as a Perl function: 0 requires you to provide
parameters stored in the way it happens in a C program. Even text processing
(as shown in the next section) may be simplified with judicious usage
of these two functions.

code where the conversion is in low gear: between the contents of a byte
sequence and a string of hexadecimal digits. Let's use 0, since
this is likely to remind you of a dump program, or some desperate last
message unfortunate programs are wont to throw at you before they expire
into the wild blue yonder. Assuming that the variable 0 holds a
sequence of bytes that we'd like to inspect without assuming anything
about its meaning, we can write

corresponding to a byte:

both? Assuming that we're on a computer where ASCII (or some similar)
encoding is used: hexadecimal values in the range 0 - 0
indicate an uppercase letter, and 0 encodes a space. So we might
assume it is a piece of text, which some are able to read like a tabloid;
but others will have to get hold of an ASCII table and relive that
firstgrader feeling. Not caring too much about which way to read this,
we note that 0 with the template code 0 converts the contents
of a sequence of bytes into the customary hexadecimal notation. Since
"a sequence of" is a pretty vague indication of quantity, 0 has been
defined to convert just a single hexadecimal digit unless it is followed
by a repeat count. An asterisk for the repeat count means to use whatever
remains.

digits - is just as easily written. For instance:

pack template should contain ten pack codes. If this is run on a computer
with ASCII character coding, it will print 0.

0 collapses blank fields, you'll never know whether a record was
income or expenditure. Oops. Well, you could always use 0:

may seem; the eagle-eyed may notice that the first field should only be
10 characters wide, and the error has propagated right through the other
numbers - which we've had to count by hand. So it's error-prone as well
as horribly unfriendly.

that?

if you use the right tools. 0 and 0 are designed to help
you out when dealing with fixed-width data like the above. Let's have a
look at a solution with 0:

Where did I pull that out of?

the headers, and a handy ruler so we can keep track of where we are.

column 10 - ten characters wide. The 0-ese for "character" is
0, and ten of them are 0. So if we just wanted to extract the
dates, we could say this:

we want to skip over that. The 0 template means "skip forward", so we
want one of those. Next, we have another batch of characters, from 12 to
38. That's 27 more characters, hence 0. (Don't make the fencepost
error - there are 27 characters between 12 and 38, not 26. Count 'em!)

not expenditure might end at column 46. Hence, we don't want to tell our
0 pattern that we 0 to find another 12 characters; we'll
just say "if there's anything left, take it". As you might guess from
regular expressions, that's what the 0 means: "use everything
remaining".

template doesn't match the incoming data, Perl will scream and die.

total up our income and expenditure, and add another line to the end of
our ledger - in the same format - saying how much we've brought in and
how much we've spent:

we? Shouldn't it skip forward? Let's look at what 0 says:

character zero, and "a space", character 32. Perl's put something
between the date and the description - but unfortunately, we can't see
it!

format pads any non-existent characters with spaces, so we can use the
additional spaces to line up our fields, like this:

but they don't translate to spaces in the output.) Here's what we got
this time:

be moved further over. There's an easy way to fix this up:
unfortunately, we can't get 0 to right-justify our fields, but we
can get 0 to do it:

we've seen of 0 and 0 so far:

version; use 0 to turn a fixed-width-format string into several
pieces of data.

you've run out of things to pack, 0 will fill the rest up with
spaces.

"introduce a null byte" - that's probably not what you mean if you're
dealing with plain text.

should be affected by that format: 0 means "take 12 characters";
0 means "skip 6 bytes" or "character 0, 6 times".

left".

"consume all of the current piece of data". That's to say

the second. This is a general principle: each format character
corresponds to one piece of data to be 0ed.

and 0 are best at: handling binary formats for numbers. There is,
of course, not just one binary format  - life would be too simple - but
Perl will do all the finicky labor for you.

0 binary representation. Leaving floating point numbers
aside for the moment, the salient properties of any such representation
are:

significant byte (or: little-endian or big-endian, respectively).

computer's representation you write

this string (which is, generally, not recommended) you might see
0 or 0 (depending on your system's byte ordering) - or something
entirely different if your computer doesn't use ASCII character encoding.
Unpacking 0 with the same template returns the original integer value:

if the packed value exceeds the allotted byte capacity, high order bits
are silently discarded, and unpack certainly won't be able to pull them
back out of some magic hat. And, when you pack using a signed template
code such as 0, an excess value may result in the sign bit
getting set, and unpacking this will smartly return a negative value.

for signed and unsigned 32-bit integers. And if this is not enough and
your system supports 64 bit integers you can push the limits much closer
to infinity with pack codes 0 and 0. A notable exception is provided
by pack codes 0 and 0 for signed and unsigned integers of the
"local custom" variety: Such an integer will take up as many bytes as
a local C compiler returns for 0, but it'll use 0
32 bits.

no matter where you execute your program. This may be useful for some
applications, but it does not provide for a portable way to pass data
structures between Perl and C programs (bound to happen when you call
XS extensions or the Perl function 0), or when you read or
write binary files. What you'll need in this case are template codes that
depend on what your local C compiler compiles when you code 0 or
0, for instance. These codes and their corresponding
byte lengths are shown in the table below.  Since the C standard leaves
much leeway with respect to the relative sizes of these data types, actual
values may vary, and that's why the values are given as expressions in
C and Perl. (If you'd like to use values from 0 in your program
you have to import it with 0.)

tolerated for completeness' sake.

binary data coming from some specific architecture whereas your program could
run on a totally different system. As an example, assume you have 24 bytes
containing a stack frame as it happens on an Intel 8086:

and that's why the low order byte is stored at the lower address. To
unpack such a (unsigned) short we'll have to use code 0. A repeat
count unpacks all 12 shorts:

accessible byte registers FL, FH, AL, AH, etc.:

back up a little, and then unpack 2 bytes. Since Perl 0 nice, it
proffers the template code 0 to back up one byte. Putting this all
together, we may now write:

the contents of our frame buffer. Otherwise we'd either get undefined values,
or 0 could not unpack all. If 0 runs out of items, it will
supply null strings (which are coerced into zeroes whenever the pack code
says so).

0 for 16 bit and 0 for 32 bit integers. You use these codes
if you know that your data comes from a compliant architecture, but,
surprisingly enough, you should also use these pack codes if you
exchange binary data, across the network, with some system that you
know next to nothing about. The simple reason is that this
order has been chosen as the 0, and all standard-fearing
programs ought to follow this convention. (This is, of course, a stern
backing for one of the Lilliputian parties and may well influence the
political development there.) So, if the protocol expects you to send
a message by sending the length first, followed by just so many bytes,
you could write:

count should include the length of the count itself: then just add 4
to the data length. (But make sure to read 0 before
you really code this!)

0 to pack and unpack integers with big- or little-endian byte-order.
While this is nice, it's still rather limited because it leaves out all
kinds of signed integers as well as 64-bit integers. For example, if you
wanted to unpack a sequence of signed big-endian 16-bit integers in a
platform-independent way, you would have to write:

desire for a certain byte-order: the C<0 and C<0 modifiers.
C<0 is the big-endian modifier, while C<0 is the little-endian
modifier. Using them, we could rewrite the above code as:

nice way to remember that C<0 is the big-endian modifier. The same
obviously works for C<0, where the "little end" touches the code.

to deal with big- or little-endian C structures. Be sure to read
0 for more on that.

pack codes 0, 0, 0 and 0. 0 and 0 pack into (or unpack
from) single-precision or double-precision representation as it is provided
by your system. If your systems supports it, 0 can be used to pack and
unpack extended-precision floating point values (0), which
can offer even more resolution than 0 or 0. 0 packs an 0,
which is the floating point type used by Perl internally. (There
is no such thing as a network representation for reals, so if you want
to send your real numbers across computer boundaries, you'd better stick
to ASCII representation, unless you're absolutely sure what's on the other
end of the line. For the even more adventuresome, you can use the byte-order
modifiers from the previous section also on floating point codes.)

have to be used either as a last resort or because it is the most
convenient way to handle your data. Bit string (un)packing converts
between strings containing a series of 0 and 0 characters and
a sequence of bytes each containing a group of 8 bits. This is almost
as simple as it sounds, except that there are two ways the contents of
a byte may be written as a bit string. Let's have a look at an annotated
byte:

be written "10001100" i.e. beginning with the most significant bit, others
insist on "00110001". Well, Perl isn't biased, so that's why we have two bit
string codes:

0 always starts at the next byte boundary and "rounds up" to the
next multiple of 8 by adding zero bits as required. (If you do want bit
fields, there is 0. Or you could implement bit field
handling at the character string level, using split, substr, and
concatenation on unpacked bit strings.)

status register (a "-" stands for a "reserved" bit):

template 0. To obtain the individual bit values from the bit
string we use 0 with the "empty" separator pattern which dissects
into individual characters. Bit values from the "reserved" positions are
simply assigned to 0, a convenient notation for "I don't care where
this goes".

last 4 bits can be ignored anyway.

"uuencoded string". ("uu" is short for Unix-to-Unix.) Chances are that
you won't ever need this encoding technique which was invented to overcome
the shortcomings of old-fashioned transmission mediums that do not support
other than simple ASCII data. The essential recipe is simple: Take three
bytes, or 24 bits. Split them into 4 six-packs, adding a space (0x20) to
each. Repeat until all of the data is blended. Fold groups of 4 bytes into
lines no longer than 60 and garnish them in front with the original byte count
(incremented by 0x20) and a 0 at the end. - The 0 chef will
prepare this for you, a la minute, when you select pack code 0 on the menu:

uuencoded line, which is the maximum of 45 by default, but could be
set to some (smaller) integer multiple of three. 0 simply ignores
the repeat count.

it's used as a prefix to some other template code. Second, because it
cannot be used in 0 at all, and third, in 0, doesn't return the
data as defined by the template code it precedes. Instead it'll give you an
integer of 0 bits that is computed from the data value by
doing sums. For numeric unpack codes, no big feat is achieved:

you the trouble of a sum loop with 0 and 0:

don't put your trust in such values! Even when applied to a small number
of bytes, they won't guarantee a noticeable Hamming distance.

to good use to count set bits efficiently:

the world's languages, providing room for over one million different
characters. Unicode 3.1 specifies 94,140 characters: The Basic Latin
characters are assigned to the numbers 0 - 127. The Latin-1 Supplement with
characters that are used in several European languages is in the next
range, up to 255. After some more Latin extensions we find the character
sets from languages using non-Roman alphabets, interspersed with a
variety of symbol sets such as currency symbols, Zapf Dingbats or Braille.
(You might want to visit 0 for a look at some of
them - my personal favourites are Telugu and Kannada.)

these numbers in an equal number of bytes would more than double the
requirements for storing texts written in Latin alphabets.
The UTF-8 encoding avoids this by storing the most common (from a western
point of view) characters in a single byte while encoding the rarer
ones in three or more bytes.

Unicode string (that is internally encoded as UTF-8), you can do so by
using template code 0. As an example, let's produce the Euro currency
symbol (code number 0x20AC):

"\xe2\x82\xac". However, it contains only 1 character, number 0x20AC.
The round trip can be completed with 0:

strings.

Encode::decode_utf8 to decode a UTF-8 encoded byte string to a Perl
Unicode string, and Encode::encode_utf8 to encode a Perl Unicode string
to UTF-8 bytes. These functions provide means of handling invalid byte
sequences and generally have a friendlier interface.

encoding scheme that goes way beyond simple integers. (Details can
be found at 0, the Scarab project.)  A BER (Binary Encoded
Representation) compressed unsigned integer stores base 128
digits, most significant digit first, with as few digits as possible.
Bit eight (the high bit) is set on each byte except the last. There
is no size limit to BER encoding, but Perl won't go to extremes.

shows 01 8100 8101 81807F. Since the last byte is always less than
128, 0 knows where to stop.

0-multiplication of template strings. Now there is a better way as
we may use the pack codes 0 and 0 combined with a repeat count.
The 0 template from the Stack Frame example can simply
be written like this:

Using pack, we can write

simply

length.)

into a sequence of byte, byte, short integer we can write

several techniques. First, let's use 0 and 0 to skip forward and back:

we were when the last 0 was encountered:

endian shorts and packing them in the reverse byte order:

by prefixing the binary message length to the actual message. You'll find
that packing a length followed by so many bytes of data is a
frequently used recipe since appending a null byte won't work
if a null byte may be part of the data. Here is an example where both
techniques are used: after two null terminated strings with source and
destination address, a Short Message (to a mobile phone) is sent after
a length byte:

the Short Message (in variable 0) is all right when packing, but this
cannot be unpacked naively:

undefined! Before we let disappointment dampen the morale: Perl's got
the trump card to make this trick too, just a little further up the sleeve.
Watch this:

value from the argument list. In 0, the length of the argument is
taken and packed according to the first code while the argument itself
is added after being converted with the template code after the slash.
This saves us the trouble of inserting the 0 call, but it is
in 0 where we really score: The value of the length byte marks the
end of the string to be taken from the buffer. Since this combination
doesn't make sense except when the second pack code isn't 0, 0
or 0, Perl won't let you.

number: All the numeric binary pack codes, and even text codes such as
0 or 0:

work on older Perls you'll need to 0 to get the length,
then use it to make a new unpack string. For example

string for the template. So maybe we should introduce...

items doesn't have fixed length, an expression constructing the
template is required (whenever, for some reason, 0 cannot be used).
Here's an example: To store named string values in a way that can be
conveniently parsed by a C program, we create a sequence of names and
null terminated ASCII strings, with 0 between the name and the value,
followed by an additional delimiting null byte. Here's how:

call, creating the items we intend to stuff into the 0 buffer:
to each key (in 0) it adds the 0 separator and the hash entry value.
Each triplet is packed with the template code sequence 0 that
is repeated according to the number of keys. (Yes, that's what the 0
function returns in scalar context.) To get the very last null byte,
we add a 0 at the end of the 0 list, to be packed with 0.
(Attentive readers may have noticed that we could have omitted the 0.)

in the buffer before we can let 0 rip it apart:

name-value pairs each of which is taken apart in the 0 block.

we could precede the data with a count. Again, we pack keys and values of
a hash, preceding each with an unsigned short length count, and up front
we store the number of pairs:

unpacked with the 0 code:

template for 0 and 0 because 0 can't determine
a repeat count for a 0-group.

programming various chips, as a text file. (See
0 for a detailed description, and
0 for the Motorola
S-record format, which can be unravelled using the same technique.)
Each line begins with a colon (':') and is followed by a sequence of
hexadecimal characters, specifying a byte count 0 (8 bit),
an address (16 bit, big endian), a record type (8 bit), 0 data bytes
and a checksum (8 bit) computed as the least significant byte of the two's
complement sum of the preceding bytes. Example: 0.

of the hexadecimal data, to obtain the four fields, while checking the
checksum. No surprise here: we'll start with a simple 0 call to
convert everything to binary:

Don't slow your program down with a for loop adding the 0 values
of this string's bytes - the 0 code 0 is the thing to use
for computing the 8-bit sum of all bytes, which must be equal to zero:

problems with the first three fields - but how can we use the byte count
of the data in the first field as a length for the data field? Here
the codes 0 and 0 come to the rescue, as they permit jumping
back and forth in the string to unpack.

care of the 16-bit big-endian integer address, and 0 unpacks the
record type. Being at offset 4, where the data begins, we need the count.
0 brings us back to square one, which is the byte at offset 0.
Now we pick up the count, and zoom forth to offset 4, where we are
now fully furnished to extract the exact number of data bytes, leaving
the trailing checksum byte alone.

strings. If it were not for a couple of snags we could conclude this
section right away with the terse remark that C structures don't
contain anything else, and therefore you already know all there is to it.
Sorry, no: read on, please.

hack all your template strings manually, you'll probably want to have
a look at the CPAN module 0. Not only can it parse
your C source directly, but it also has built-in support for all the
odds and ends described further on in this section.

has been tilted in favor of faster execution. This has influenced the
way C compilers allocate memory for structures: On architectures
where a 16-bit or 32-bit operand can be moved faster between places in
memory, or to or from a CPU register, if it is aligned at an even or
multiple-of-four or even at a multiple-of eight address, a C compiler
will give you this speed benefit by stuffing extra bytes into structures.
If you don't cross the C shoreline this is not likely to cause you any
grief (although you should care when you design large data structures,
or you want your code to be portable between architectures (you do want
that, don't you?)).

C structures:

requires only 8 bytes for a 0. After investigating this further,
we can draw memory maps, showing where the extra 4 bytes are hidden:

templates have to be stuffed with 0 codes to get those extra fill bytes.

an answer. One good reason is that C compilers might provide (non-ANSI)
extensions permitting all sorts of fancy control over the way structures
are aligned, even at the level of an individual structure field. And, if
this were not enough, there is an insidious thing called 0 where
the amount of fill bytes cannot be derived from the alignment of the next
item alone.

by inserting template codes 0, which don't take a corresponding item
from the list:

integer as it is compiled by our C compiler. And even now, it will only
work for the platforms where the compiler aligns things as above.
And somebody somewhere has a platform where it doesn't.
[Probably a Cray, where 0s, 0s and 0s are all 8 bytes. :-)]

be a drag. Isn't there a way we can create the template with a simple
program? Here's a C program that does the trick:

0 saves our day by enabling us to specify the offset from the beginning
of the pack buffer to the next item: This is just the value
the 0 macro (defined in C<0stddef.h0) returns when
given a 0 type and one of its field names ("member-designator" in
C standardese).

(Just imagine what happens if the structure changes.) What we really need
is a way of saying "skip as many bytes as required to the next multiple of N".
In fluent Templatese, you say this with 0 where N is replaced by the
appropriate value. Here's the next version of our struct packaging:

integers are, and portability is far away. Rather than 0,
for instance, we want to say "however long a short is". But this can be
done by enclosing the appropriate pack code in brackets: 0. So, here's
the very best we can do:

different byte-order. First, we'll have to figure out how big the data
types on the target machine really are. Let's assume that the longs are
32 bits wide and the shorts are 16 bits wide. You can then rewrite the
template as:

just fine if you don't have too many struct members. But we could also
use the byte-order modifier on a group and write the following:

intend to have little-endian byte-order for a whole group, not only
for individual template codes. It can also be more readable and easier
to maintain.

hydra raises another ugly head when you pack arrays of structures:

nor between this and the next field 0, so why can't we simply pack
like this:

0 is four times 0! The moral of the story is that
the required alignment of a structure or array is propagated to the
next higher level where we have to consider padding 0
of each component as well. Thus the correct template is:

any of its elements. [And if you think that this doesn't affect anything
common, dismember the next cellphone that you see. Many have ARM cores, and
the ARM structure rules make 0 == 4]

sooner or later when you pack C structures. If the function you intend
to call expects a, say, 0 value, you 0 simply take
a reference to a Perl variable. (Although that value certainly is a
memory address, it's not the address where the variable's contents are
stored.)

Isn't this what we want? Let's try:

string of bytes to some C code expecting a pointer which is, after all,
nothing but a number? The answer is simple: We have to obtain the numeric
address from the bytes returned by 0.

to an unsigned long and vice versa, which frequently works but should not
be taken as a universal law. - Now that we have this pointer the next question
is: How can we put it to good use? We need a call to some C function
where a pointer is expected. The  system call comes to mind:

this Perl function copying a file to standard output:

it illustrates the point: We are able to sneak behind the scenes and
access Perl's otherwise well-guarded memory! (Important note: Perl's
0 does 0 require you to construct pointers in this roundabout
way. You simply pass a string variable, and Perl forwards the address.)

about to be unpacked: If it isn't the null pointer (which will smartly
produce the 0 value) we have a start address - but then what?
Perl has no way of knowing how long this "fixed length string" is, so
it's up to you to specify the actual size as an explicit length after 0.

Why do we need a second template code for packing pointers at all? The
answer lies behind the simple fact that an 0 with 0 promises
a null-terminated string starting at the address taken from the buffer,
and that implies a length for the data item to be returned:

implied by the string's length, a number after pack code 0 is a repeat
count, not a length as after 0.

actually stored must be used with circumspection. Perl's internal machinery
considers the relation between a variable and that address as its very own
private matter and doesn't really care that we have obtained a copy. Therefore:

that's bound to go out of scope (and thereby freeing its memory) before you
are done with using the memory at that address.

variable. Appending something to the variable, for instance, might require
reallocation of its storage, leaving you with a pointer into no-man's land.

when it is stored as an integer or double number! 0 will
force the variable's internal representation to string, just as if you
had written something like 0.

allocates an anonymous variable.

and 0:

many pairs of hex digits, and use 0 to handle the traditional
spacing - 16 bytes to a line:

=encoding utf8

which can be used with particular reference to perl programs.  While many perl
developers have come from other languages, and can use their prior knowledge
where appropriate, there are many other people who might benefit from a few
perl specific pointers.  If you want the condensed version, perhaps the best
advice comes from the renowned Japanese Samurai, Miyamoto Musashi, who said:

their code before a program actually does anything useful - this is a bad idea.
There's no point in having an extremely fast program that doesn't work.  The
first job is to get a program to 0 do something 0, (not to
mention ensuring the test suite is fully functional), and only then to consider
optimizing it.  Having decided to optimize existing working code, there are
several simple but essential steps to consider which are intrinsic to any
optimization process.

timing needs to be reliable and repeatable.  You'll probably want to use the
0 or 0 modules, or something similar, for this step,
or perhaps the Unix system 0 utility, whichever is appropriate.  See the
base of this document for a longer list of benchmarking and profiling modules,
and recommended further reading.

seems to run slowly), change the code with the intention of making it run
faster.  Using version control software, like 0, will ensure no
changes are irreversible.  It's too easy to fiddle here and fiddle there -
don't change too much at any one time or you might not discover which piece of
code 0 was the slow bit.

Rerun the code under control of the benchmarking or profiling modules, from the
first step above, and check that the new code executed the 0 in
0.  Save your work and repeat...

thing as a 0, which is why there are no rules, only guidelines.

calls, because there is less overhead, but this approach has the disadvantage
of being less maintainable and comes at the cost of greater memory usage -
there is no such thing as a free lunch.  If you are searching for an element in
a list, it can be more efficient to store the data in a hash structure, and
then simply look to see whether the key is defined, rather than to loop through
the entire array using  for instance.   may be (a lot) faster
than  but not as flexible, so you have another trade-off to access.  Your
code may contain a line which takes 0.01 of a second to execute which if you
call it 1,000 times, quite likely in a program parsing even medium sized files
for instance, you already have a 10 second delay, in just one single code
location, and if you call that line 100,000 times, your entire program will
slow down to an unbearable crawl.

you want, but will usually be slower than the built-in 0 0 and
0 C<0=0 sort operators.  It is possible to make multiple
passes over your data, building indices to make the upcoming sort more
efficient, and to use what is known as the 0 (Orcish Maneuver) to cache the
sort keys in advance.  The cache lookup, while a good idea, can itself be a
source of slowdown by enforcing a double pass over the data - once to setup the
cache, and once to sort the data.  Using 0 to extract the required sort
key into a consistent string can be an efficient way to build a single string
to compare, instead of using multiple sort keys, which makes it possible to use
the standard, written in 0 and fast, perl 0 function on the output,
and is the basis of the 0 (Guttman Rossler Transform).  Some string
combinations can slow the 0 down, by just being too plain complex for it's
own good.

tries to help with keeping things nippy, not least because it tries to 0
query the database until the latest possible moment, but always read the docs
which come with your choice of libraries.  Among the many issues facing
developers dealing with databases should remain aware of is to always use
0 placeholders and to consider pre-fetching data sets when this might
prove advantageous.  Splitting up a large file by assigning multiple processes
to parsing a single file, using say 0, 0 or 0 can also be a
useful way of optimizing your usage of the available 0 resources, though
this technique is fraught with concurrency issues and demands high attention to
detail.

no replacement for running a few tests and finding out which method works best
for your particular environment, this is why writing optimal code is not an
exact science, and why we love using Perl so much - TMTOWTDI.

sensitive to typos, and it's much clearer to dereference the variable
explicitly.  We're side-stepping the issue of working with object-oriented
programming techniques to encapsulate variable access via methods, only
accessible through an object.  Here we're just discussing the technical
implementation of choice, and whether this has an effect on performance.  We
can see whether this dereferencing operation, has any overhead by putting
comparative code in a file and running a 0 test.

the numbers settle on a numerical average, otherwise each run will naturally
fluctuate due to variations in the environment, to reduce the effect of
contention for 0 resources and network bandwidth for instance.  Running
the above code for one million iterations, we can take a look at the report
output by the 0 module, to see which approach is the most effective.

it managed to execute an average of 628,930 times a second during our test, the
direct approach managed to run an additional 204,403 times, unfortunately.
Unfortunately, because there are many examples of code written using the
multiple layer direct variable access, and it's usually horrible.  It is,
however, minusculy faster.  The question remains whether the minute gain is
actually worth the eyestrain, or the loss of maintainability.

always be much more flexible, 0, an oft underused tool, can still be a
useful.  One scenario might be replace all vowels with another character.  The
regex solution might look like this:

the fastest, using a global 0 variable to assign to the 0
variable so as to avoid perl trying to optimize any of the work away by
noticing it's assigned only the once.

fast - and it's appropriately the programmer's choice which to use.

produce more extensive reporting statistics.  This example uses the simplistic
0 program which parses a given input file and spews out a short
report on the contents.

for more than a decade, but has been replaced by a number of other modules
which have brought us back to the 21st century.  Although you're recommended to
evaluate your tool from the several mentioned here and from the CPAN list at
the base of this document, (and currently 0 seems to be the
weapon of choice - see below), we'll take a quick look at the output from
0 first, to set a baseline for Perl profiling tools.  Run the
above program under the control of 0 by using the 0 switch on
the command-line.

this file is read by the 0 program, which is already installed as part
of the 0 distribution.  If you call 0 with no options,
it will read the 0 file in the current directory and produce a human
readable statistics report of the run of your program.  Note that this may take
a little time.

0 program.  The wallclock, user and system, times are at the top of
the analysis, and after this are the main columns defining which define the
report.  Check the 0 docs for details of the many options it supports.

0, a drop-in Perl-only replacement for 0.  The
usage is very slightly different in that instead of using the special 0
flag, you pull 0 in directly as a module using 0.

0 program, thus saving the construction of a dedicated statistics
reader program.  0 usage is therefore identical to the above example.

algorithm which generates the report is different, even though the output file
format was allegedly identical.  The elapsed, user and system times are clearly
showing the time it took for 0 to execute its own run, but
the column listings feel more accurate somehow than the ones we had earlier
from 0.  The 102% figure has disappeared, for example.  This is
where we have to use the tools at our disposal, and recognise their pros and
cons, before using them.  Interestingly, the numbers of calls for each
subroutine are identical in the two reports, it's the percentages which differ.
As the author of 0 writes:

produces a line-by-line listing to show how many times each line was called,
and how long each line took to execute.  It is called by supplying the familiar
0 flag to Perl at runtime.

default.  The format of the file looks like this:

any standard text filtering utilities.  Something like the following may be
sufficient:

modules, and we start to see exactly which line of code is taking the most
time.  That regex line is looking a bit suspicious, for example.  Remember that
these tools are supposed to be used together, there is no single best way to
profile your code, you need to use the best tools for the job.

to getting a faster line profiler, than is possible with for example
0, because it's written in 0.  To use 0,
supply the 0 argument to Perl:

directory.  The output file, which can be specified, can be interpreted by using
the 0 command-line program.

identical to the 0 output, and the sequence is only very
slightly different based on the ordering of the amount of time each line took
to execute, 0 and 0, for example.  The
differences in the actual times recorded might be in the algorithm used
internally, or it could be due to system resource limitations or contention.

under the 0 namespace.

shortcomings in other tools and implementing many cool features.  First of all it
can be used as either a 0 profiler, a 0 or a 0
profiler, all at once.  It can also use sub-microsecond (100ns) resolution on
systems which provide 0.  It can be started and stopped even
by the program being profiled.  It's a one-line entry to profile 0
applications.  It's written in 0 and is probably the fastest profiler
available for Perl.  The list of coolness just goes on.  Enough of that, let's
see how to it works - just use the familiar 0 switch to plug it in and run
the code.

default.  Human readable reports can be generated from here by using the
supplied 0 (HTML output) and 0 (CSV output) programs.
We've used the Unix sytem 0 utility to convert the
0 file for convenience here.

which subroutines are using the most time.  The next gives some statistics
about the source files profiled.

various links to bore down into each subroutine and each line of code.  Because
we're using the text reporting here, and there's a whole directory full of
reports built for each source file, we'll just display a part of the
corresponding 0 file, sufficient to give an idea of the
sort of output you can expect from this cool tool.

disposal, system tools like 0 should not be overlooked as the next
example shows, where we take a quick look at sorting.  Many books, theses and
articles, have been written about efficient sorting algorithms, and this is not
the place to repeat such work, there's several good sorting modules which
deserve taking a look at too: 0, 0 spring to mind.
However, it's still possible to make some observations on certain Perl specific
interpretations on issues relating to sorting data sets and give an example or
two with regard to how sorting large data volumes can effect performance.
Firstly, an often overlooked point when sorting large amounts of data, one can
attempt to reduce the data set to be dealt with and in many cases 0 can
be quite useful as a simple filter:

sort through in the first place, and should not be too lightly disregarded
purely on the basis of its simplicity.  The 0 principle is too often
overlooked - the next example uses the simple system 0 utility to
demonstrate.  Let's take a look at an actual example of sorting the contents of
a large file, an apache logfile would do.  This one has over a quarter of a
million lines, is 50M in size, and a snippet of it looks like this:

Code, Query, Browser, Referring Url, and lastly Date.  One solution might be to
use the following code, which iterates over the files given on the
command-line.

output is correct from following test runs and use the system 0 utility
to check the overall runtime.

values 0 outputs, it's important to always use the same one, and to not
confuse what each one means.

terminates.  The elapsed time includes both user and system times, and time
spent waiting for other users and processes on the system.  Inevitably, this is
the most approximate of the measurements given.

user on this system executing this program.

routines, or system calls, on behalf of this process user.

eliminate the input and output arrays for storing all the data, and work on the
input directly as it arrives too.  Otherwise, the code looks fairly similar:

standard.  Naturally, it is important to check the output is consistent with
the first program run, this is where the Unix system 0 utility comes in.

of the runtime once, only to get a request one month later to do the same again
(true story) - you'll just have to point out your only human, even if you are a
Perl programmer, and you'll see what you can do...

with appropriately informative messages, however there exists a school of
thought which suggests that log files should be 0, as if the chain of
unbroken output somehow ensures the survival of the program.  If speed is in
any way an issue, this approach is wrong.

debug level set in the logging configuration file is zero.  Once the 
subroutine has been entered, and the internal 0 variable confirmed to
be zero, for example, the message which has been sent in will be discarded and
the program will continue.  In the example given though, the \%INC hash will
already have been dumped, and the message string constructed, all of which work
could be bypassed by a debug variable at the statement level, like this:

including a 0 subroutine to emulate typical 0 functionality.

outputting any debugging information is concerned, in other words nothing,
takes 14 seconds, and in the other case the code takes one hundredth of a
second.  Looks fairly definitive.  Use a 0 variable BEFORE you call the
subroutine, rather than relying on the smart functionality inside it.

time 0 constant.

clocking in at minus zero seconds, and generates a "warning: too few iterations
for a reliable count" message into the bargain.  To see what is really going
on, and why we had too few iterations when we thought we asked for 100000, we
can use the very useful 0 to inspect the new code:

the value of the 0 constant: zero.  The line to be tested has been
completely optimized away, and you can't get much more efficient than that.

checking whether any modifications have improved the runtime of the code.

produce a useful program which will run in zero or negative time and this basic
principle can be written as: 0 by their very
definition.  It is of course possible to write a nearly instantaneous program,
but it's not going to do very much, here's a very efficient one:

Perl here, naturally, but here's a short list of modules from the CPAN which
deserve further attention.

=encoding utf8

This document is in Pod format.  To read this, use a Pod formatter,
like "perldoc perlpod".

0 0

for Perl, Perl programs, and Perl modules.

like plain text, HTML, man pages, and more.

0,
0, and
0.

0

of text, like this one.  You can simply type in your text without
any markup whatsoever, and with just a blank line before and
after.  When it gets formatted, it will undergo minimal formatting,
like being rewrapped, probably put into a proportionally spaced
font, and maybe even justified.

0, 0, 0, and more.  Such
codes are explained in the "0"
section, below.

0 0

other text which does not require any special parsing or formatting,
and which shouldn't be wrapped.

be a space or a tab.  (And commonly, all its lines begin with spaces
and/or tabs.)  It should be reproduced exactly, with tabs assumed to
be on 8-column boundaries.  There are no special formatting codes,
so you can't italicize or anything like that.  A \ means \, and
nothing else.

0

of text, usually as headings or parts of lists.

with "=", followed by an identifier, followed by arbitrary text that
the command can use however it pleases.  Currently recognized commands
are

0 0 0 0
0 0 0 0

level.  The text in the rest of this paragraph is the content of the
heading.  For example:

head3 and head4 are recent additions, not supported in older Pod
translators.)  The text in these heading commands can use
formatting codes, as seen here:

"0" section, below.

0 0 0 0 0 0

a region specifically for the generation of a list using "=item"
commands, or for indenting (groups of) normal paragraphs.  At the end
of your list, use "=back" to end it.  The 0 option to
"=over" indicates how far over to indent, generally in ems (where
one em is the width of an "M" in the document's base font) or roughly
comparable units; if there is no 0 option, it defaults
to four.  (And some formatters may just ignore whatever 0
you provide.)  In the 0 in C<=item 0, you may
use formatting codes, as seen here:

"0" section, below.

"=back" regions:

there aren't going to be any items at all in this "=over" ... "=back"
region.

"=item *" for all of them, to produce bullets; or use "=item 1.",
"=item 2.", etc., to produce numbered lists; or use "=item foo",
"=item bar", etc.--namely, things that look nothing like bullets or
numbers.

formatters use the first "=item" type to decide how to format the
list.

0 0

then a line beginning with "=cut", and a blank
line after it.  This lets Perl (and the Pod formatter) know that
this is where Perl code is resuming.  (The blank line before the "=cut"
is not technically necessary, but many older Pod processors require it.)

0 0

signals to Perl (and Pod formatters) that a Pod block starts here.  A
Pod block starts with 0 command paragraph, so a "=pod" command is
usually used just when you want to start a Pod block with an ordinary
paragraph or a verbatim paragraph.  For example:

0 0 0 0 0 0

are not generally interpreted as normal Pod text, but are passed
directly to particular formatters, or are otherwise special.  A
formatter that can use that format will use the region, otherwise it
will be completely ignored.

command "=end 0", mean that the text/data in between
is meant for formatters that understand the special format
called 0.  For example,

specifies that the remainder of just this paragraph (starting
right after 0) is in that special format.

region.

of text (i.e., the text in "=foo targetname text..."), but with
"=begin targetname" ... "=end targetname", you can have any amount
of stuff inbetween.  (Note that there still must be a blank line
after the "=begin" command and a blank line before the "=end"
command.

include "roff", "man", "latex", "tex", "text", and "html".  (Some
formatters will treat some of these as synonyms.)

to yourself) that won't appear in any formatted version of the Pod
document:

0, or
0),
to signal that the text is not raw data, but instead 0 Pod text
(i.e., possibly containing formatting codes) that's just not for
normal formatting (e.g., may not be a normal-use paragraph, but might
be for formatting as a footnote).

0 0

users won't need this; but if your encoding isn't US-ASCII or Latin-1,
then put a C<=encoding 0 command early in the document so
that pod formatters will know how to decode the document.  For
0, use a name recognized by the 0
module.  Examples:

until the end of its 0, not its line.  So in the
examples below, you can see that every command needs the blank
line after it, to end its paragraph.

0 0
0 0

formatting codes (a.k.a. "interior sequences") can be used:

0  0 0

("C<redo I0LABEL0")

0  0 0

("C<some systems provide a B0chfn0"),
emphasis ("C<be B0careful!0"), and so on
("C<and that feature is known as B0autovivification0").

0  0 0

this represents program text ("C<C0gmtime($^T)0") or some other
form of computerese ("C<C0drwxr-xr-x0").

0  0 0

0, 0, and 0 cannot contain the characters
'/' and '|'; and any '<' or '>' should be matched.

that 0 should not contain spaces.  This syntax
is also occasionally used for references to Unix man pages, as in
C<0.

C<L0perlsyn/"For Loops"0

C<L0/"Object Methods"0

example, C<L0perlvar/$.0 or C<L0perlvar/"$."0 both
link to the section started by "0" in perlvar.  And
C<L0perlsyn/For Loops0 or C<L0perlsyn/"For Loops"0
both link to the section started by "0"
in perlsyn.

use "C<L0text|...0", as in:

C<L0Perl Error Messages|perldiag0

C<L0postfix "if"|perlsyn/"Statement Modifiers"0

or C<L0text|"sec"0

C<L0the various attributes|/"Member Data"0

C<L0The Perl Home Page|http://www.perl.org/0.

0  0 0

notably C<L0...0, and when preceded by a
capital letter.

meaning the same thing as 0 in HTML -- i.e., a lowercase
e with an acute (/-shaped) accent.

leading "0x" means that 0 is hex, as in
C<E00x201E0.  A leading "0" means that 0 is octal,
as in C<E00750.  Otherwise 0 is interpreted as being
in decimal, as in C<E01810.

hex numeric escapes, and that many formatters cannot reliably
render characters above 255.  (Some formatters may even have
to use compromised renderings of Latin-1 characters, like
rendering C<E0eacute0 as just a plain "e".)

0  0 0

0  0
0

across lines.  Example: S<C<S0 ?  : .

0  0 0

indexes.  It always renders as empty-string.
Example: C<X0absolutizing relative URLs0

0  0 0

E0...0 code sometimes.  For example, instead of
"C<NE0lt0" (for "N03") you could write
"C<NZ000" (the "Z00" breaks up the "N" and
the "0" so they can't be considered
the part of a (fictitious) "N0...0') inside of a formatting code.  This is particularly
common when using a formatting code to provide a different font-type for a
snippet of code.  As with all things in Perl, there is more than
one way to do it.  One way is to simply escape the closing bracket
using an 0" to be escaped.
Doubled angle brackets ("<<" and ">>") may be used 0  For example, the following will
do the trick:
0

long as you have the same number of them in the opening and closing
delimiters, and make sure that whitespace immediately follows the last
'<' of the opening delimiter, and immediately precedes the first '>'
of the closing delimiter.  (The whitespace is ignored.)  So the
following will also work:
0

the formatting code, only how it must end.  That means that the examples above
are also exactly the same as this:

code in 0 (code) style:

and any other pod2xxx or Pod::Xxxx translators that use
Pod::Parser 1.093 or later, or Pod::Tree 1.02 or later.

0

look like paragraphs (block format), so that they stand out
visually, and so that I could run them through 0 easily to reformat
them (that's F7 in my version of 0, or Esc Q in my version of
0).  I wanted the translator to always leave the 0 and 0 and
0 quotes alone, in verbatim mode, so I could slurp in a
working program, shift it over four spaces, and have it print out, er,
verbatim.  And presumably in a monospace font.

is just meant to be an idiot-proof common source for nroff, HTML,
TeX, and other markup languages, as used for online
documentation.  Translators exist for 0, 0,
0 (that's for  and ), 0, and
0.  Various others are available in CPAN.

0

Start your documentation with an empty line, a "=head1" command at the
beginning, and end it with a "=cut" command and an empty line.  Perl
will ignore the Pod text.  See any of the supplied library modules for
examples.  If you're going to put your Pod at the end of the file, and
you're using an __END__ or __DATA__ cut mark, make sure to put an
empty line there before the first Pod command.

have recognized the "=head1" as starting a Pod block.

0 0

and warnings.  For example, it checks for completely blank lines in
Pod blocks and for unknown commands and formatting codes.  You should
still also pass your document through one or more translators and proofread
the result, or print out the result and proofread that.  Some of the
problems found may be bugs in the translators, which you may or may not
wish to work around.

can try your hand at writing documentation in simple HTML, and converting
it to Pod with the experimental 0 module,
(available in CPAN), and looking at the resulting code.  The experimental
0 module in CPAN might also be useful.

command and after every Pod command (including "=cut"!) to be a blank
line.  Having something like this:

at all.

paragraphs like "=head2 Functions") to be separated by 0
empty lines.  If you have an apparently empty line with some spaces
on it, this might not count as a separator for those translators, and
that could cause odd formatting.

C<L0Foo::Bar0 may become "the Foo::Bar manpage", for example.
So you shouldn't write things like C<the L0foo0, if you want the translated document to read sensibly.
Instead, write C<the L0Foo::Bar|Foo::Bar0 or
C<L0the Foo::Bar documentation|Foo::Bar0, to control how the
link comes out.

wrapped by some formatters.

0, 0, 0, 0, 0.

=encoding utf8

people will only have to read 0 to know how to write
in Pod, but this document may answer some incidental questions to do
with parsing and rendering Pod.

"should not", and "may" have their conventional (cf. RFC 2119)
meanings: "X must do Y" means that if X doesn't do Y, it's against
this specification, and should really be fixed.  "X should do Y"
means that it's recommended, but X may fail to do Y, if there's a
good reason.  "X may do Y" is merely a note that X can do Y at
will (although it is up to the reader to detect any connotation of
"and I think it would be 0 if X did Y" versus "it wouldn't
really 0 me if X did Y").

parser may fail to do Y, if the calling application explicitly
requests that the parser 0 do Y.  I often phrase this as
"the parser should, by default, do Y."  This doesn't 0
the parser to provide an option for turning off whatever
feature Y is (like expanding tabs in verbatim paragraphs), although
it implicates that such an option 0 be provided.

can write a file that's nothing but Pod.

terminated by either a newline or the end of the file.

Pod parsers should understand it to mean any of CR (ASCII 13), LF
(ASCII 10), or a CRLF (ASCII 13 followed immediately by ASCII 10), in
addition to any other system-specific meaning.  The first CR/CRLF/LF
sequence in the file may be used as the basis for identifying the
newline sequence for parsing the rest of the file.

(ASCII 32) or tabs (ASCII 9), and terminated by a newline or end-of-file.
A 0 is a line containing one or more characters other
than space or tab (and terminated by a newline or end-of-file).

spaces/tabs and then a newline as a blank line. The only lines they
considered blank were lines consisting of 0,
terminated by a newline.)

tabs, and newline sequences.  (By itself, this term usually refers
to literal whitespace.  That is, sequences of whitespace characters
in Pod source, as opposed to "E0", which is a formatting
code that 0 a whitespace character.)

whether this involves calling callbacks or building a parse tree or
directly formatting it).  A 0 (or 0)
is a module or program that converts Pod to some other format (HTML,
plaintext, TeX, PostScript, RTF).  A 0 might be a
formatter or translator, or might be a program that does something
else with the Pod (like counting words, scanning for index points,
etc.).

line that matches <m/\A=[a-zA-Z]/>, and continues up to the next line
that matches 0 or up to the end of the file if there is
no 0 line.

consists of non-blank lines of text, separated by one or more blank
lines.

a Pod block:

this paragraph must match 0.  Command paragraphs are
typically one line, as in:

(i.e., after the part that matches 0), as in:

same processing to "Did You Remember to C0?" that it
would to an ordinary paragraph (i.e., formatting codes like
"C0") are parsed and presumably formatted appropriately, and
whitespace in the form of literal spaces and/or tabs is not
significant.

literal space or tab, and this paragraph must not be inside a "=begin
0", ... "=end 0" sequence unless
"0" begins with a colon (":").  That is, if a paragraph
starts with a literal space or tab, but 0 inside a
"=begin 0", ... "=end 0" region, then it's
a data paragraph, unless "0" begins with a colon.

processing, tabs are probably expanded).

if its first line matches neither 0 nor
0, 0 if it's not inside a "=begin 0",
... "=end 0" sequence unless "0" begins with
a colon (":").

0" ... "=end 0" sequence where
"0" does 0 begin with a literal colon (":").  In
some sense, a data paragraph is not part of Pod at all (i.e.,
effectively it's "out-of-band"), since it's not subject to most kinds
of Pod parsing; but it is specified here, since Pod
parsers need to be able to call an event for it, or store it in some
form in a parse tree, or at least just parse 0 it.

line of each matches 0.  "0bar"
is a verbatim paragraph, because its first line starts with a literal
whitespace character (and there's no "=begin"..."=end" region around).

paragraphs that they surround from being parsed as ordinary or verbatim
paragraphs, if 0 doesn't begin with a colon.  This
is discussed in detail in the section
L</About Data Paragraphs and "=begin0.

0.  These are the currently recognized
Pod commands:

is a heading.  That text may contain formatting codes.  Examples:

are already in the middle of a Pod block, this command has no effect at
all.)  If there is any text in this command paragraph after "=pod",
it must be ignored.  Examples:

started Pod block.  If there is any text after "=cut" on the line, it must be
ignored.  Examples:

that case, the Pod processor must halt parsing of the input file, and
must by default emit a warning.

region.  If there is any text following the "=over", it must consist
of only a nonzero positive numeral.  The semantics of this numeral is
explained in the 0 section, further
below.  Formatting codes are not expanded.  Examples:

codes are processed.  The semantics of the (optional) text in the
remainder of this paragraph are
explained in the 0 section, further
below.  Examples:

by the most recent "=over" command.  It permits no text after the
"=back" command.

formatname") as being for some special kind of processing.  Unless
"formatname" begins with a colon, the contained non-command
paragraphs are data paragraphs.  But if "formatname" 0 begin
with a colon, then non-command paragraphs are ordinary paragraphs
or data paragraphs.  This is discussed in detail in the section
L</About Data Paragraphs and "=begin0.

0.  Everything following whitespace after the
formatname is a parameter that may be used by the formatter when dealing
with this region.  This parameter must not be repeated in the "=end"
paragraph.  Implementors should anticipate future expansion in the
semantics and syntax of the first parameter to "=begin"/"=end"/"=for".

"=begin formatname" region.  If "formatname" is not the formatname
of the most recent open "=begin formatname" region, then this
is an error, and must generate an error message.  This
is discussed in detail in the section
L</About Data Paragraphs and "=begin0.

paragraph is to be treated as a normal paragraph if "formatname"
begins with a ":"; if "formatname" 0 begin with a colon,
then "text..." will constitute a data paragraph.  There is no way
to use "=for formatname text..." to express "text..." as a verbatim
paragraph.

before any non-US-ASCII data!), declares that this document is
encoded in the encoding 0, which must be
an encoding name that 0 recognizes.  (Encode's list
of supported encodings, in 0, is useful here.)
If the Pod parser cannot decode the declared encoding, it
should emit a warning and may abort parsing the document
altogether.

considered an error.  Pod processors may silently tolerate this if
the not-first "=encoding" lines are just duplicates of the
first one (e.g., if there's a "=encoding utf8" line, and later on
another "=encoding utf8" line).  But Pod processors should complain if
there are contradictory "=encoding" lines in the same document
(e.g., if there is a "=encoding utf8" early in the document and
"=encoding big5" later).  Pod processors that recognize BOMs
may also complain if they see an "=encoding" line
that contradicts the BOM (e.g., if a document with a UTF-16LE
BOM has an "=encoding shiftjis" line).

above (like "=head", or "=haed1", or "=stuff", or "=cuttlefish",
or "=w123"), that processor must by default treat this as an
error.  It must not process the paragraph beginning with that
command, must by default warn of this as an error, and may
abort the parse.  A Pod parser may allow a way for particular
applications to add to the above list of known commands, and to
stipulate, for each additional command, whether formatting
codes should be processed.

commands.

formatting codes were referred to as "interior sequences", and
this term may still be found in the documentation for Pod parsers,
and in error messages from Pod processors.)

followed by a "<", any number of characters, and ending with the first
matching ">".  Examples:

followed by two or more "<"'s, one or more whitespace characters,
any number of characters, one or more whitespace characters,
and ending with the first matching sequence of two or more ">"'s, where
the number of ">"'s equals the number of "<"'s in the opening of this
formatting code.  Examples:

and before the ">>" (or whatever letter) are 0 renderable. They
do not signify whitespace, are merely part of the formatting codes
themselves.  That is, these are all synonymous:

of nested formatting codes, meaning that the following four example lines are
identical in meaning:

(potentially nested!) formatting codes.  Implementors should
consult the code in the 0 routine in Pod::Parser as an
example of a correct implementation.

this code and its content.  Other formatters will render it with
invisible codes that can be used in building an index of
the current document.

a processor may complain if it sees C<Z0potatoes0.  Whether
or not it complains, the 0 text should ignored.

0, and implementation details are
discussed below, in L</"About L0...0.  Parsing the
contents of L0 is tricky.  Notably, the content has to be
checked for whether it looks like a URL, or whether it has to be split
on literal "|" and/or "/" (in the right order!), and so on,
0 E0 codes are resolved.

0.

complex.  What it means is that each space in the printable
content of this code signifies a non-breaking space.

"", one space, "?", one space, ":", one space, "".  The
difference is that in the latter, with the S code, those spaces
are not "normal" spaces, but instead are non-breaking spaces.

listed above (as in "N0", or "Q0", etc.), that
processor must by default treat this as an error.
A Pod parser may allow a way for particular
applications to add to the above list of known formatting codes;
a Pod parser might even allow a way to stipulate, for each additional
command, whether it requires some form of special processing, as
L0 does.

formatting codes.

closing a "C0" outside the "C" formatting code.  This
problem has since been solved by the addition of syntaxes like this:

opened in one paragraph, and no closing code is found by the end of
that paragraph, the Pod parser must close that formatting code,
and should complain (as in "Unterminated I code in the paragraph
starting at line 123: 'Time objects are not...'").  So these
two paragraphs:

code starting in one paragraph and starting in another.)  Instead,
the first paragraph should generate a warning, but that aside, the
above code must parse as if it were:

elements, whereas all Pod formatting codes are like inline-level
elements.)

and suggestions to do with Pod processing.

any length, even if that means having to break them (possibly several
times, for very long lines) to avoid text running off the side of the
page.  Pod formatters may warn of such line-breaking.  Such warnings
are particularly appropriate for lines are over 100 characters long, which
are usually not intentional.

formats: CR, LF, and CRLF.  See 0.

as signaling that the file is Unicode encoded as in UTF-16 (whether
big-endian or little-endian) or UTF-8, Pod parsers should do the
same.  Otherwise, the character encoding should be understood as
being UTF-8 if the first highbit byte sequence in the file seems
valid as a UTF-8 sequence, or otherwise as Latin-1.

how Pod can accept other encodings.  Presumably treatment of other
encodings in Pod parsing would be as in XML parsing: whatever the
encoding declared by a particular Pod file, content is to be
stored in memory as Unicode characters.

file begins with the two literal byte values 0xFE 0xFF, this is
the BOM for big-endian UTF-16.  If the file begins with the two
literal byte value 0xFF 0xFE, this is the BOM for little-endian
UTF-16.  If the file begins with the three literal byte values
0xEF 0xBB 0xBF, this is the BOM for UTF-8.

byte-sequence in a BOM-less file (whether in code or in Pod!), to see
whether that sequence is valid as UTF-8 (RFC 2279) is to check whether
that the first byte in the sequence is in the range 0xC0 - 0xFD
0 whether the next byte is in the range
0x80 - 0xBF.  If so, the parser may conclude that this file is in
UTF-8, and all highbit sequences in the file should be assumed to
be UTF-8.  Otherwise the parser should treat the file as being
in Latin-1.  In the unlikely circumstance that the first highbit
sequence in a truly non-UTF-8 file happens to appear to be UTF-8, one
can cater to our heuristic (as well as any more intelligent heuristic)
by prefacing that line with a comment line containing a highbit
sequence that is clearly 0 valid as UTF-8.  A line consisting
of simply "#", an e-acute, and any non-highbit byte,
is sufficient to establish this file's encoding.

do not apply to Pod processors running on non-ASCII platforms,
notably EBCDIC platforms.

meaning the same thing as a "=begin [label]" paragraph, content, and
an "=end [label]" paragraph.  (The parser may conflate these two
constructs, or may leave them distinct, in the expectation that the
formatter will nevertheless treat them the same.)

any format other than plaintext), a Pod formatter must insert comment
text identifying its name and version number, and the name and
version numbers of any modules it might be using to process the Pod.
Minimal examples:

release date of the Pod formatter program, the contact address for
the author(s) of the formatter, the current time, the name of input
file, the formatting options in effect, version of Perl used, etc.

besides or instead of emitting them otherwise (as in messages to
STDERR, or 0ing).

E0!") to STDERR (whether through printing to STDERR, or
0ing/0ing, or 0ing/0ing), but 0 allow
suppressing all such STDERR output, and instead allow an option for
reporting errors/warnings
in some other way, whether by triggering a callback, or noting errors
in some attribute of the document object, or some similarly unobtrusive
mechanism -- or even by appending a "Pod Errors" section to the end of
the parsed form of the document.

parse.  Even then, using 0ing/0ing is to be avoided; where
possible, the parser library may simply close the input file
and add text like "*** Formatting Aborted ***" to the end of the
(partial) in-memory document.

are understood (i.e., 0 verbatim paragraphs, but 0
ordinary paragraphs, and command paragraphs that produce renderable
text, like "=head1"), literal whitespace should generally be considered
"insignificant", in that one literal space has the same meaning as any
(nonzero) number of literal spaces, literal newlines, and literal tabs
(as long as this produces no blank lines, since those would terminate
the paragraph).  Pod parsers should compact literal whitespace in each
processed paragraph, but may provide an option for overriding this
(since some processing tasks do not require it), or may follow
additional special rules (for example, specially treating
period-space-space or period-newline sequences).

quote (") into smart quotes (little 9's, 66's, 99's, etc), nor try to
turn backtick (`) into anything else but a single backtick character
(distinct from an open quote character!), nor "--" into anything but
two minus signs.  They 0 do any of those things to text
in C0 formatting codes, and never 0 to text in verbatim
paragraphs.

that's a non-breaking hyphen, and another that's a breakable hyphen
(as in "object-oriented", which can be split across lines as
"object-", newline, "oriented"), formatters are encouraged to
generally translate "-" to non-breaking hyphen, but may apply
heuristics to convert some of these to breaking hyphens.

code from being broken across lines.  For example, "Foo::Bar" in some
formatting systems is seen as eligible for being broken across lines
as "Foo::" newline "Bar" or even "Foo::-" newline "Bar".  This should
be avoided where possible, either by disabling all line-breaking in
mid-word, or by wrapping particular words with internal punctuation
in "don't break this across lines" codes (which in some formats may
not be a single code, but might be a matter of inserting non-breaking
zero-width spaces between every pair of characters in a word.)

they are processed, before passing them to the formatter or other
processor.  Parsers may also allow an option for overriding this.

ordinary and verbatim paragraphs before passing them to the
formatter.  For example, while the paragraph you're reading now
could be considered, in Pod source, to end with (and contain)
the newline(s) that end it, it should be processed as ending with
(and containing) the period character that ends this sentence.

an approximate line number ("Nested E0's in Paragraph #52, near
line 633 of Thing/Foo.pm!"), instead of merely noting the paragraph
number ("Nested E0's in Paragraph #52 of Thing/Foo.pm!").  Where
this is problematic, the paragraph number should at least be
accompanied by an excerpt from the paragraph ("Nested E0's in
Paragraph #52 of Thing/Foo.pm, which begins 'Read/write accessor for
the C0VERSION") before being passed to the formatter or other
processor.  Parsers may also allow an option for overriding this.

parsers, it is straightforward for parsers that return parse trees.

verbatim paragraphs (under twelve lines, say) across pages.

"blank line" such as separates paragraphs.  (Some older parsers
recognized only two adjacent newlines as a "blank line" but would not
recognize a newline, a space, and a newline, as a blank line.  This
is noncompliant behavior.)

avoid writing their own Pod parser.  There are already several in
CPAN, with a wide range of interface styles -- and one of them,
Pod::Parser, comes with modern versions of Perl.

number in E0 codes, or by an equivalent mnemonic, as in
E0 which is exactly equivalent to E0.

characters (also defined there by Unicode, with the same meaning),
which all Pod formatters must render faithfully.  Characters
in the ranges 0-31 and 127-159 should not be used (neither as
literals, nor as E0 codes), except for the
literal byte-sequences for newline (13, 13 10, or 10), and tab (9).

defined there by Unicode, with the same meaning).  Characters above
255 should be understood to refer to Unicode characters.

that some formatters cannot reliably render characters outside 32-126;
and many are able to handle 32-126 and 160-255, but nothing above
255.

less-than and greater-than, Pod parsers must understand "E0"
for "/" (solidus, slash), and "E0" for "|" (vertical bar,
pipe).  Pod parsers should also understand "E0" and
"E0" as legacy codes for characters 171 and 187, i.e.,
"left-pointing double angle quotation mark" = "left pointing
guillemet" and "right-pointing double angle quotation mark" = "right
pointing guillemet".  (These look like little "<<" and ">>", and they
are now preferably expressed with the HTML/XHTML codes "E0"
and "E0".)

in the entity declarations in the most recent XHTML specification at
0.  Pod parsers must understand at least the entities
that define characters in the range 160-255 (Latin-1).  Pod parsers,
when faced with some unknown "E00" code,
shouldn't simply replace it with nullstring (by default, at least),
but may pass it through as a string consisting of the literal characters
E, less-than, 0, greater-than.  Or Pod parsers may offer the
alternative option of processing such unknown
"E00" codes by firing an event especially
for such codes, or by adding a special node-type to the in-memory
document tree.  Such "E00" may have special meaning
to some processors, or some processors may choose to add them to
a special error report.

character 34 (doublequote, "), "E0" for character 38
(ampersand, &), and "E0" for character 39 (apostrophe, ').

an htmlname, or a number in any base) must consist only of
alphanumeric characters -- that is, 0 must watch
0.  So "E0" is invalid, because
it contains spaces, which aren't alphanumeric characters.  This
presumably does not 0 special treatment by a Pod processor;
" 0 1 2 3 " doesn't look like a number in any base, so it would
presumably be looked up in the table of HTML-like names.  Since
there isn't (and cannot be) an HTML-like entity called " 0 1 2 3 ",
this will be treated as an error.  However, Pod processors may
treat "E0" or "E0" as 0
invalid, potentially earning a different error message than the
error message (or warning, or event) generated by a merely unknown
(but theoretically valid) htmlname, as in "E0"
[sic].  However, Pod parsers are not required to make this
distinction.

"codepoint 0 in the current/native character set".  It always
means only "the character represented by codepoint 0 in
Unicode."  (This is identical to the semantics of &#0; in XML.)

treatable Unicode codepoints (such as the "\xE9" for the e-acute
character) to the escape sequences or codes necessary for conveying
such sequences in the target output format.  A converter to *roff
would, for example know that "\xE9" (whether conveyed literally, or via
a E0 sequence) is to be conveyed as "e\\*'".
Similarly, a program rendering Pod in a Mac OS application window, would
presumably need to know that "\xE9" maps to codepoint 142 in MacRoman
encoding that (at time of writing) is native for Mac OS.  Such
Unicode2whatever mappings are presumably already widely available for
common output formats.  (Such mappings may be incomplete!  Implementers
are not expected to bend over backwards in an attempt to render
Cherokee syllabics, Etruscan runes, Byzantine musical symbols, or any
of the other weird things that Unicode can encode.)  And
if a Pod document uses a character not found in such a mapping, the
formatter should consider it an unrenderable character.

satisfactory pre-existing table mapping from Unicode characters to
escapes in the target format (e.g., a decent table of Unicode
characters to *roff escapes), it will be necessary to build such a
table.  If you are in this circumstance, you should begin with the
characters in the range 0x00A0 - 0x00FF, which is mostly the heavily
used accented characters.  Then proceed (as patience permits and
fastidiousness compels) through the characters that the (X)HTML
standards groups judged important enough to merit mnemonics
for.  These are declared in the (X)HTML specifications at the
www.W3.org site.  At time of writing (September 2001), the most recent
entity declaration files are:

in the range 0x2000-0x204D (consult the character tables at
www.unicode.org), and whatever else strikes your fancy.  For example,
in 0, there is the entry:

have been already handled by the Pod parser, the presence of the
character in this file means that it's reasonably important enough to
include in a formatter's table that maps from notable Unicode characters
to the codes necessary for rendering them.  So for a Unicode-to-*roff
mapping, for example, this would merit the entry:

(and formatters) will support Unicode characters directly (as (X)HTML
does with 0, 0, or 0), reducing the need
for idiosyncratic mappings of Unicode-to-0.

confronted with an unrenderable character (which is distinct from an
unknown E0 sequence that the parser couldn't resolve to
anything, renderable or not).  It is good practice to map Latin letters
with diacritics (like "E0"/"E0") to the corresponding
unaccented US-ASCII letters (like a simple character 101, "e"), but
clearly this is often not feasible, and an unrenderable character may
be represented as "?", or the like.  In attempting a sane fallback
(as from E0 to "e"), Pod formatters may use the
%Latin1Code_to_fallback table in 0, or
0, if available.

"magic is enabled if you set 0 to '0'" or as
"magic is enabled if you set 0 to '0'", or as
"magic is enabled if you set 0 to '[x20AC]', etc.

unrenderable characters were encountered.

in another E0 or in an Z0).  That is, "X0The
E0" is valid, as is "L0The
E0".

spaces as an individual character (which I'll call "NBSP"), and
others output to formats that implement non-breaking spaces just as
spaces wrapped in a "don't break this across lines" code.  Note that
at the level of Pod, both sorts of codes can occur: Pod can contain a
NBSP character (whether as a literal, or as a "E0" or
"E0" code); and Pod can contain "S0foo
I0bar0" codes, where "mere spaces" (character 32) in
such codes are taken to represent non-breaking spaces.  Pod
parsers should consider supporting the optional parsing of "S0foo
I0bar0" as if it were
"foo0I0bar00baz", and, going the other way, the
optional parsing of groups of words joined by NBSP's as if each group
were in a S0 code, so that formatters may use the
representation that maps best to what the output format demands.

implement by replacing each space in the parse tree under the content
of the S, with an NBSP.  But note: the replacement should apply 0 to
spaces in 0 text, but 0 to spaces in 0 text.  (This
distinction may or may not be evident in the particular tree/event
model implemented by the Pod parser.)  For example, consider this
unusual case:

not be broken across lines.  In other words, it's the same as this:

produce something equivalent to this:

this formatter outputs a format supporting hypertext).

especially in cases where the output format simply has no NBSP
character/code and no code for "don't break this stuff across lines".

of the existence of the other "special" character in Latin-1, the
"soft hyphen" character, also known as "discretionary hyphen",
i.e. C<E01730 = C<E00xAD0 =
C<E0shy0).  This character expresses an optional hyphenation
point.  That is, it normally renders as nothing, but may render as a
"-" if a formatter breaks the word at that point.  Pod formatters
should, as appropriate, do one of the following:  1) render this with
a code with the same meaning (e.g., "\-" in RTF), 2) pass it through
in the expectation that the formatter understands this character as
such, or 3) delete it.

or "manuscript", then it should be done as
"sig-0action" or "manu-0script"
(and if it doesn't hyphenate it, then the C<E0shy0 doesn't
show up at all).  And if it is
to hyphenate "Jarkko" and/or "Hietaniemi", it can do
so only at the points where there is a C<E0shy0 code.

often, but formatters should either support it, or delete it.

"=biblio" command), consider whether you could get the same
effect with a for or begin/end sequence: "=for biblio ..." or "=begin
biblio" ... "=end biblio".  Pod processors that don't understand
"=for biblio", etc, will simply ignore it, whereas they may complain
loudly if they see "=biblio".

the name of the documentation format.  One may also use "POD" or
"pod".  For the documentation that is (typically) in the Pod
format, you may use "pod", or "Pod", or "POD".  Understanding these
distinctions is useful; but obsessing over how to spell them, usually
is not.

code is the most complex of the Pod formatting codes.  The points below
will hopefully clarify what it means and how processors should deal
with it.

four attributes:

"L0", the link-text is "Perl Functions".
In "L0" and even "L0", there is no
link text.  Note that link text may contain formatting.)

text, then this is the text that we'll infer in its place.  (E.g., for
"L0", the name (also sometimes called the page)
is "perlfunc".  In "L0", the name is undef.)

in "L0Getopt::Std/DESCRIPTION0", "DESCRIPTION" is the section.  (Note
that this is not the same as a manpage section like the "5" in "man 5
crontab".  "Section Foo" in the Pod sense means the part of the text
that's introduced by the heading or item whose text is "Foo".)

"http://lists.perl.org" is), in which case there should be no section
attribute; a Pod name (like "perldoc" and "Getopt::Std" are); or
possibly a man page name (like "" is).

"|", "/", etc, and before E0 codes are expanded.

a requirement that these be passed as an actual list or array.)

fact that they match 0.  So
C<L0http://www.perl.com0 is a URL, but
C<L0HTTP::Response0 isn't.

older formatters have exhibited great variation in actually displaying
the link or cross reference.  For example, L0 would render
as "the 0 manpage", or "in the 0 manpage"
or just "0".

starts with:

the link and use only the renderable characters in the section name,
as in:

links from C<L0name/item0 links (and their targets).  These
have been merged syntactically and semantically in the current
specification, and 0 can refer either to a "=head0 Heading
Content" command or to a "=item Item Content" command.  This
specification does not specify what behavior should be in the case
of a given document having several things all seeming to produce the
same 0 identifier (e.g., in HTML, several things all producing
the same 0 in <a name="0...</a>
elements).  Where Pod processors can control this behavior, they should
use the first such anchor.  That is, C<L0Foo/Bar0 refers to the
0 "Bar" section in Foo.

with the HTML example, the behavior of multiple ambiguous
<a name="0...</a> is most easily just left up to
browsers to decide.

only with "L0" codes (like
L0), and must not attempt "L0" codes.  This restriction avoids many problems
in parsing and rendering L0 codes.

for formatting or for E0 escapes, as in:

C<E0...0 and C<Z00 codes may occur.  That is,
authors should not use "C<L0B0Foo::Bar00".

and all parts of an L0 (i.e., in 0, 0, 0,
and 0).

L0" should be treated as an error.

part of "L0" (and so on for L0).

hypertext, might not allow the link-text to be formatted; in
that case, formatters will have to just ignore that formatting.

either the name of a Pod page like C<L0Foo::Bar0 (which
might be a real Perl module or program in an @INC / PATH
directory, or a .pod file in those places); or the name of a Unix
man page, like C<0.  In theory, C<L0chmod0
in ambiguous between a Pod page called "chmod", or the Unix man page
"chmod" (in whatever man-section).  However, the presence of a string
in parens, as in "", is sufficient to signal that what
is being discussed is not a Pod page, and so is presumably a
Unix man page.  The distinction is of no importance to many
Pod processors, but some processors that render to hypertext formats
may need to distinguish them in order to know how to render a
given C<L0foo0 code.

C<L0Object Attributes0), which was not easily distinguishable from
C<L0name0 syntax and for C<L0"section"0 which was only
slightly less ambiguous.  This syntax is no longer in the specification, and
has been replaced by the C<L0/section0 syntax (where the slash was
formerly optional).  Pod parsers should tolerate the C<L0"section"0
syntax, for a while at least.  The suggested heuristic for distinguishing
C<L0section0 from C<L0name0 is that if it contains any
whitespace, it's a 0.  Pod processors should warn about this being
deprecated syntax.

structures.  (I use the term "region" here simply as a collective
term for everything from the "=over" to the matching "=back".)

"=back" is used for giving the formatter a clue as to how many
"spaces" (ems, or roughly equivalent units) it should tab over,
although many formatters will have to convert this to an absolute
measurement that may not exactly match with the size of spaces (or M's)
in the document's base font.  Other formatters may have to completely
ignore the number.  The lack of any explicit 0 parameter is
equivalent to an 0 value of 4.  Pod processors may
complain if 0 is present but is not a positive number
matching 0.

map to several different constructs in your output format.  For
example, in converting Pod to (X)HTML, it can map to any of
<ul>...</ul>, <ol>...</ol>, <dl>...</dl>, or
<blockquote>...</blockquote>.  Similarly, "=item" can map to <li> or
<dt>.

each followed by some number of ordinary/verbatim paragraphs, other
nested "=over" ... "=back" regions, "=for..." paragraphs, and
"=begin"..."=end" regions.

*".)  Whether "*" is rendered as a literal asterisk, an "o", or as
some kind of real bullet character, is left up to the Pod formatter,
and may depend on the level of nesting.

0 paragraphs, each one (or each group of them)
followed by some number of ordinary/verbatim paragraphs, other nested
"=over" ... "=back" regions, "=for..." paragraphs, and/or
"=begin"..."=end" codes.  Note that the numbers must start at 1
in each section, and must proceed in order and without skipping
numbers.

"=item 1.", with the period.)

commands, each one (or each group of them) followed by some number of
ordinary/verbatim paragraphs, other nested "=over" ... "=back"
regions, or "=for..." paragraphs, and "=begin"..."=end" regions.

0 or 0, nor should it
match just 0.

all, and containing only some number of
ordinary/verbatim paragraphs, and possibly also some nested "=over"
... "=back" regions, "=for..." paragraphs, and "=begin"..."=end"
regions.  Such an itemless "=over" ... "=back" region in Pod is
equivalent in meaning to a "<blockquote>...</blockquote>" element in
HTML.

"=over" ... "=back" you have, by examining the first (non-"=cut",
non-"=pod") Pod paragraph after the "=over" command.

in the "=item 0" paragraph.  In practice, most such
paragraphs are short, as in:

with no accompanying paragraph.  The middle item is an example:

treat such a heading as an error.

content.  That is, authors should not have an empty region like this:

may ignore it, or may report it as an error.

document (i.e., which has no matching "=back"), but they may warn
about such a list.

a bit difficult.  On the one hand, it could be mention of an item
"Neque", mention of another item "Porro", and mention of another
item "Quisquam Est", with just the last one requiring the explanatory
paragraph "Qui dolorem ipsum quia dolor..."; and then an item
"Ut Enim".  In that case, you'd want to format it like so:

items, "Neque", "Porro", and "Quisquam Est", followed by a paragraph
explaining them all, and then a new item "Ut Enim".  In that case, you'd
probably want to format it like so:

authors to distinguish which grouping is meant by the above
"=item"-cluster structure.  So formatters should format it like so:

items as between paragraphs (although that spacing may well be less
than the full height of a line of text).  This leaves it to the reader
to use (con)textual cues to figure out whether the "Qui dolorem
ipsum..." paragraph applies to the "Quisquam Est" item or to all three
items "Neque", "Porro", and "Quisquam Est".  While not an ideal
situation, this is preferable to providing formatting cues that may
be actually contrary to the author's intent.

to be used (typically passed through) when rendering the document to
a specific format:

"=for" paragraph:

meaning as one, and Pod parsers may parse it as one.)

expand the "E0" (in the first paragraph) as a formatting
code, just like "E0" or "E0".  But since this
is in a "=begin 0"..."=end 0" region 0
the identifier "html" doesn't begin have a ":" prefix, the contents
of this region are stored as data paragraphs, instead of being
processed as ordinary paragraphs (or if they began with a spaces
and/or tabs, as verbatim paragraphs).

supported, but suppose some processor were written to recognize it as
a way of (say) denoting a bibliographic reference (necessarily
containing formatting codes in ordinary paragraphs).  The fact that
"biblio" paragraphs were meant for ordinary processing would be
indicated by prefacing each "biblio" identifier with a colon:

region are subject to normal handling as ordinary/verbatim paragraphs
(while still tagged as meant only for processors that understand the
"biblio" identifier).  The same effect could be had with:

normally, even though the result will be for some special target".
I suggest that parser APIs report "biblio" as the target identifier,
but also report that it had a ":" prefix.  (And similarly, with the
above "html", report "html" as the target identifier, and note the
0 of a ":" prefix.)

0 begins with a colon, 0 contain commands.  For example:

region where 0 does 0 begin with a colon, should not
directly contain "=head1" ... "=head4" commands, nor "=over", nor "=back",
nor "=item".  For example, this may be considered invalid:

paragraph) is an error.  Note, however, that the following should
0 be treated as an error:

"=end :yetanotherformat" region 0 data paragraphs, because
the immediately containing region's identifier (":yetanotherformat")
begins with a colon.  In practice, most regions that contain
data paragraphs will contain 0 data paragraphs; however,
the above nesting is syntactically valid as Pod, even if it is
rare.  However, the handlers for some formats, like "html",
will accept only data paragraphs, not nested regions; and they may
complain if they see (targeted for them) nested regions, or commands,
other than "=end", "=pod", and "=cut".

the larger "=begin :biblio"..."=end :biblio" region.  Note that the
content of the "=begin html"..."=end html" region is data
paragraph(s), because the immediately containing region's identifier
("html") 0 begin with a colon.

after another (within a single region), should consider them to
be one large data paragraph that happens to contain blank lines.  So
the content of the above "=begin html"..."=end html" 0 be stored
as two data paragraphs (one consisting of
"<img src='wirth_spokesmodeling_book.png'>\n"
and another consisting of "<hr>\n"), but 0 be stored as
a single data paragraph (consisting of
"<img src='wirth_spokesmodeling_book.png'>\n\n<hr>\n").

"=begin 0"..."=end 0" regions,
empty "=begin :0"..."=end :0" regions, and
contentless "=for 0" and "=for :0"
paragraphs.  I.e., these should be tolerated:

paragraph starting with something that looks like a command.  Consider:

paragraph "=shazbot\n".  However, you can express a data paragraph consisting
of "=shazbot\n" using this code:

is, they must properly nest.  For example, this is valid:

currently open region has the formatname "inner", not "outer".  (It just
happens that "outer" is the format name of a higher-up region.)  This is
an error.  Processors must by default report this as an error, and may halt
processing the document containing that error.  A corollary of this is that
regions cannot "overlap". That is, the latter block above does not represent
a region called "outer" which contains X and Y, overlapping a region called
"inner" which contains Y and Z.  But because it is invalid (as all
apparently overlapping regions would be), it doesn't represent that, or
anything at all.

tries to close "hting" [sic].

parameter.

0

=encoding utf8

scripts and modules, based on general guidelines for writing good UNIX man
pages.  All of these guidelines are, of course, optional, but following
them will make your documentation more consistent with other documentation
on the system.

(using B00) wherever it occurs, as are all program options.
Arguments should be written in italics (I00).  Function names are
traditionally written in italics; if you write a function as ,
Pod::Man will take care of this for you.  Literal code or commands should
be in C00.  References to other man pages should be in the form
0 or C<L0manpage(section)0, and Pod::Man will
automatically format those appropriately.  The second form, with
L00, is used to request that a POD formatter make a link to the
man page if possible.  As an exception, one normally omits the section
when referring to module documentation since it's not clear what section
module documentation will be in; use C<L0Module::Name0 for module
references instead.

page references so that cross-referencing tools can provide the user with
links and the like.  It's possible to overdo this, though, so be careful not
to clutter your documentation with too much markup.  References to other
programs that are not given as man page references should be enclosed in
B00.

historically written in the rather startling ALL UPPER CASE format; this
is not mandatory, but it's strongly recommended so that sections have
consistent naming across different software packages.  Minor headers may
be included using 0, and are typically in mixed case.

functions documented by this POD page, such as:

section, so don't put anything in it except this line.  Every program or
function documented by this POD page should be listed, separated by a
comma and a space.  For a Perl module, just give the module name.  A
single dash, and only a single dash, should separate the list of programs
or functions from the description.  Do not use any markup such as
C00 or B00 anywhere in this line.  Functions should not be
qualified with 0 or the like.  The description should ideally fit on a
single line, even if a man program replaces the dash with a few tabs.

mandatory for section 3 pages.  For Perl module documentation, it's
usually convenient to have the contents of this section be a verbatim
block showing some (brief) examples of typical ways the module is used.

body of the documentation for man pages that document something else.  If
particularly long, it's a good idea to break this up into subsections
0 directives like:

provided by the module goes, usually in the form of a list with an
0 for each interface.  Depending on how many interfaces there are,
you may want to put that documentation in separate METHODS, FUNCTIONS,
CLASS METHODS, or INSTANCE METHODS sections instead and save the
DESCRIPTION section for an overview.

program.  This should be separate from the description for the use of
parsers like 0.  This is normally presented as a list, with
each option as a separate 0.  The specific option string should be
enclosed in B00.  Any values that the option takes should be
enclosed in I00.  For example, the section for the option
0=0 would be introduced with:

comma and a space on the same 0 line, or optionally listed as their
own item with a reference to the canonical name.  For example, since
0 can also be written as 0, the above would be:

The long option is long enough to draw the eye to it anyway and the short
option can otherwise get lost in visual noise.

omitted for programs whose precise exit codes aren't important, provided
they return 0 on success and non-zero on failure as is standard.  It
should always be present for functions.  For modules, it may be useful to
summarize return values from the module interface here, or it may be more
useful to discuss return values separately in the documentation of each
function or method the module provides.

Typically used for function or module documentation; program documentation
uses DIAGNOSTICS instead.  The general rule of thumb is that errors
printed to 0 or 0 and intended for the end user are
documented in DIAGNOSTICS while errors passed internal to the calling
program and intended for other programmers are documented in ERRORS.  When
documenting a function that sets errno, a full list of the possible errno
values should be given here.

may wish to follow the same documentation style as the Perl documentation;
see  for more details (and look at the POD source as well).

correct the error; documenting an error as indicating "the input buffer is
too small" without telling the user how to increase the size of the input
buffer (or at least telling them that it isn't possible) aren't very
useful.

often find this the most useful part of the documentation.  The examples
are generally given as verbatim paragraphs.

short paragraph saying what the example will do can increase the value of
the example immensely.

a list using 0, 0, and 0.  For example:

special formatting is generally needed; they're glaring enough as it is.

and what it uses them for.  File names should be enclosed in F00.
It's particularly important to document files that will be potentially
modified.

include your current e-mail address (or some e-mail address to which bug
reports should be sent) or some other contact information so that users
have a way of contacting you.  Remember that program documentation tends
to roam the wild for far longer than you expect and pick a contact method
that's likely to last.

a modification log here, but that usually gets long and is normally better
maintained in a separate file.

this licensing example is neither an endorsement or a requirement, you are
of course free to choose any licensing.

.  Normally a simple list of man pages separated by commas, or a
paragraph giving the name of a reference work.  Man page references, if
they use the standard 0 form, don't have to be enclosed in
L00 (although it's recommended), but other things in this section
probably should be when appropriate.

instructions here.

CONSTRUCTORS and METHODS sections, or CLASS METHODS and INSTANCE METHODS
sections, for detailed documentation of the parts of the library and save
the DESCRIPTION section for an overview.  Large modules with a function
interface may want to use FUNCTIONS for similar reasons.  Some people use
OVERVIEW to summarize the description if it's quite long.

(you'll break some man page systems otherwise), and NAME, SYNOPSIS,
DESCRIPTION, and OPTIONS generally always occur first and in that order if
present.  In general, SEE ALSO, AUTHOR, and similar material should be
left for last.  Some systems also move WARNINGS and NOTES to last.  The
order given above should be reasonable for most purposes.

and MT-LEVEL to note safeness for use in threaded programs or signal
handlers.  These headings are primarily useful when documenting parts of a
C library.

As documented here and in 0, you can safely leave Perl
variables, function names, man page references, and the like unadorned by
markup and the POD translators will figure it out for you.  This makes it
much easier to later edit the documentation.  Note that many existing
translators will do the wrong thing with e-mail addresses when wrapped in
L00, so don't do that.

system, see either 0 or 0 depending on your system manual
section numbering conventions.

The current version is always available from its web site at
<http://www.eyrie.org/~eagle/software/podlators/>.

taken from the documentation of the original 0 implementation by
Larry Wall and Tom Christiansen.

<rra@stanford.edu>.

it under the same terms as Perl itself.

=encoding utf8

policies about how the Perl 5 Porters collectively develop and maintain
the Perl core.

contributed to the Perl core is the result of a donation. Typically, these
donations are contributions of code or time by individual members of our
community. On occasion, these donations come in the form of corporate
or organizational sponsorship of a particular individual or project.

on the goodwill and hard work of individuals who have no obligation to
contribute to Perl.

had an unwritten covenant with the broader Perl community to support
and maintain releases of Perl.

the Perl community should expect from Perl's developers:

series.  As of the release of 5.14.0, we will "officially"
end support for Perl 5.10, other than providing security
updates as described below.

in the two most recent stable 5.x release series.  Fixes for the
current release series take precedence over fixes for the previous
release series.

/ releases for any major version of Perl whose 5.x.0 release was within
the past three years.  We can only commit to providing these for the
most recent .y release in any 5.x.y series.

releases of Perl.

Perl at the time of their code freeze.

beyond our 3 year support commitment.  We can provide limited support and
advice to you as you do so and, where possible will try to apply
those patches to the relevant -maint branches in git, though we may or
may not choose to make numbered releases or "official" patches
available.  Contact us at 0perl5-security-report@perl.org0
to begin that process.

virtue, even when the functionality in question is a design flaw.

decades.  Living with every design error we've ever made can lead
to painful stagnation.  Unwinding our mistakes is very, very
difficult.  Doing so without actively harming our users is
nearly impossible.

of Perl has come into vogue.  Sometimes, a change is proposed which
wants to usurp syntax which previously had another meaning.  Sometimes,
a change wants to improve previously-crazy semantics.

even language constructs which no well-educated developer would ever
intentionally use is tantamount to saying "you should not upgrade to
a new release of Perl unless you have 100% test coverage and can do a
full manual audit of your codebase."  If we were to have tools capable of
reliably upgrading Perl source code from one version of Perl to another,
this concern could be significantly mitigated.

years and decades, but not at the expense of our user community.

very limited circumstances.  If a given language feature's continued
inclusion in the language will cause significant harm to the language
or prevent us from making needed changes to the runtime, then it may
be considered for deprecation.

be enabled or disabled lexically.  Unless code at a given scope declares
that it wants the new behavior, that new behavior should be disabled.
Which backward-incompatible changes are controlled implicitly by a
'use v5.x.y' is a decision which should be made by the pumpking in
consultation with the community.

to change the language must be considered very, very carefully.  If it's
possible to move the old syntax or semantics out of the core language
and into XS-land, that XS module should be enabled by default unless
the user declares that they want a newer revision of Perl.

backward-compatibility -- bugward-compatibility.  Any accident of
implementation or unintentional side-effect of running some bit of code
has been considered to be a feature of the language to be defended with
the same zeal as any other feature or functionality.  No matter how
frustrating these unintentional features may be to us as we continue
to improve Perl, these unintentional features often deserve our
protection.  It is very important that existing software written in
Perl continue to work correctly.  If end-user developers have adopted a
bug as a feature, we need to treat it as such.

and syntax have a much lower bar.  They merely need to prove themselves
to be useful, elegant, well designed, and well tested.

of features or functionality from the Perl core, we have specific definitions
for a few words and phrases.

its behaviour, deprecate or remove it without notice. While we'll always
do our best to smooth the transition path for users of experimental
features, you should contact the perl5-porters mailinglist if you find
an experimental feature useful and want to help shape its future.

from the core in the next stable release series, though we may not. As of
Perl 5.12, deprecated features and modules warn the user as they're used.
If you use a deprecated feature and believe that its removal from the Perl
core would be a mistake, please contact the perl5-porters mailinglist and
plead your case.  We don't deprecate things without a good reason, but
sometimes there's a counterargument we haven't considered.  Historically,
we did not distinguish between "deprecated" and "discouraged" features.

consider to have been mistakes as 0.  Discouraged features
aren't candidates for removal in the next major release series, but
we may later deprecate them if they're found to stand in the way of a
significant improvement to the Perl core.

stable release cycle, we may remove it from the Perl core.  Unsurprisingly,
we say we've 0 these things.

If there is any question about whether a given patch might merit
inclusion in a maint release, then it almost certainly should not
be included.

hints/ are acceptable. Ports of Perl to a new platform, architecture
or OS release that involve changes to the implementation are NOT
acceptable.

explain significant bugs or deficiencies in the current implementation,
or fix broken markup.

are not acceptable.

functionality or negatively impact performance are acceptable.

be run through the perl5-security-report@perl.org mailing list
rather than applied directly.

fix crashing or security issues (as above).

installation issues are acceptable. When these changes are made
to dual-life modules for which CPAN is canonical, any changes
should be coordinated with the upstream author.

Those belong in the next stable series.

talk to a pumpking.)

into maintperl.  This has...scaling problems.  At the same time,
maintenance branches of stable versions of Perl need to be treated with
great care. To that end, we're going to try out a new process for
maint-5.12.

they send mail to perl5-porters announcing their intent to cherry-pick
a specific commit along with a rationale for doing so and at least two
other committers respond to the list giving their assent. (This policy
applies to current and former pumpkings, as well as other committers.)

of authors of packages to guide the future of their code and maintain
control over their work.  It is a recognition that authors should have
control over their work, and that it is a responsibility of the rest of
the Perl community to ensure that they retain this control.  It is an
attempt to document the standards to which we, as Perl developers, intend
to hold ourselves.  It is an attempt to write down rough guidelines about
the respect we owe each other as Perl developers.

document in any way, shape, or form.  Perl is distributed under the GNU
Public License and under the Artistic License; those are the precise legal
terms.  This statement isn't about the law or licenses.  It's about
community, mutual respect, trust, and good-faith cooperation.

the heart of Perl itself, is a joint project on the part of all of us.
From time to time, a script, module, or set of modules (hereafter referred
to simply as a "module") will prove so widely useful and/or so integral to
the correct functioning of Perl itself that it should be distributed with
the Perl core.  This should never be done without the author's explicit
consent, and a clear recognition on all parts that this means the module
is being distributed under the same terms as Perl itself.  A module author
should realize that inclusion of a module into the Perl core will
necessarily mean some loss of control over it, since changes may
occasionally have to be made on short notice or for consistency with the
rest of Perl.

involved in maintaining Perl should be aware that the module is still the
property of the original author unless the original author explicitly
gives up their ownership of it.  In particular:

work of the original author.  All patches, bug reports, and so
forth should be fed back to them.  Their development directions
should be respected whenever possible.

cooperation of the module author if and only if they are very minor,
time-critical in some fashion (such as urgent security fixes), or if
the module author cannot be reached.  Those patches must still be
given back to the author when possible, and if the author decides on
an alternate fix in their version, that fix should be strongly
preferred unless there is a serious problem with it.  Any changes not
endorsed by the author should be marked as such, and the contributor
of the change acknowledged.

possible, be the latest version of the module as distributed by the
author (the latest non-beta version in the case of public Perl
releases), although the pumpkin holder may hold off on upgrading the
version of the module distributed with Perl to the latest version
until the latest version has had sufficient testing.

say on modifications to their module whenever possible (bearing in mind
that it's expected that everyone involved will work together and arrive at
reasonable compromises when there are disagreements).

different from the vision of the pumpkin holder and perl5-porters as a
whole so as to cause serious problems for Perl, the pumpkin holder may
choose to formally fork the version of the module in the Perl core from the
one maintained by the author.  This should not be done lightly and
should 0 if at all possible be done only after direct input
from Larry.  If this is done, it must then be made explicit in the
module as distributed with the Perl core that it is a forked version and
that while it is based on the original author's work, it is no longer
maintained by them.  This must be noted in both the documentation and
in the comments in the source of the module.

happen, and every possible effort at cooperation and compromise should be
made before doing this.  If it does prove necessary to fork a module for
the overall health of Perl, proper credit must be given to the original
author in perpetuity and the decision should be constantly re-evaluated to
see if a remerging of the two branches is possible down the road.

keep in mind that the code belongs to the original author, that they may
not be on perl5-porters at any given time, and that a patch is not
official unless it has been integrated into the author's copy of the
module.  To aid with this, and with points #1, #2, and #3 above, contact
information for the authors of all contributed modules should be kept with
the Perl distribution.

ownership of code, respect for artistic control, proper credit, and active
effort to prevent unintentional code skew or communication gaps is vital
to the health of the community and Perl itself.  Members of a community
should not normally have to resort to rules and laws to deal with each
other, and this document, although it contains rules so as to be clear, is
about an attitude and general approach.  The first step in any dispute
should be open communication, respect for opposing views, and an attempt
at a compromise.  In nearly every circumstance nothing more will be
necessary, and certainly no more drastic measure should be used until
every avenue of communication and discussion has failed.

incredibly important for Perl's documentation to be reasonably coherent
and to accurately reflect the current implementation.

maintain the documentation.  Writing a particular bit of documentation
doesn't give an author control of the future of that documentation.
At the same time, just as source code changes should match the style
of their surrounding blocks, so should documentation changes.

they're explaining.  Sometimes, the best way to show how a
language feature works is with a small program the reader can
run without modification.  More often, examples will consist
of a snippet of code containing only the "important" bits.
The definition of "important" varies from snippet to snippet.
Sometimes it's important to declare 0 and 0,
initialize all variables and fully catch every error condition.
More often than not, though, those things obscure the lesson
the example was intended to teach.

documentation often contains spellings which look funny
to 0.  Choice of American/British/Other spellings
is left as an exercise for the author of each bit of
documentation.  When patching documentation, try to emulate
the documentation around you, rather than changing the existing
prose.

than what it used to do.  It's perfectly reasonable to include notes
in documentation about how behaviour has changed from previous releases,
but, with very few exceptions, documentation isn't "dual-life" --
it doesn't need to fully describe how all old versions used to work.

=encoding utf8

much in common, they also have their own unique features.

Perl code.  That way once you make a decision to write portably,
you know where the lines are drawn, and you can stay within them.

type of computer and taking advantage of a full range of them.
Naturally, as you broaden your range and become more diverse, the
common factors drop, and you are left with an increasingly smaller
area of common ground in which you can operate to accomplish a
particular task.  Thus, when you begin attacking a problem, it is
important to consider under which part of the tradeoff curve you
want to operate.  Specifically, you must decide whether it is
important that the task that you are coding have the full generality
of being portable, or whether to just get the job done right now.
This is the hardest choice to be made.  The rest is easy, because
Perl provides many choices, whichever way you want to approach your
problem.

willfully limiting your available choices.  Naturally, it takes
discipline and sacrifice to do that.  The product of portability
and convenience may be a constant.  You have been warned.

tools together, or to prototype a Macintosh application, or to manage the
Windows registry.  If it makes no sense to aim for portability for one
reason or another in a given program, then don't bother.

code.  It isn't.  Perl tries its level-best to bridge the gaps between
what's available on different platforms, and all the means available to
use those features.  Thus almost all Perl code runs on any machine
without modification.  But there are some significant issues in
writing portable code, and this document is entirely about those issues.

using a whole range of platforms, think about writing portable
code.  That way, you don't sacrifice much by way of the implementation
choices you can avail yourself of, and at the same time you can give
your users lots of platform choices.  On the other hand, when you have to
take advantage of some unique feature of a particular platform, as is
often the case with systems programming (whether for Unix, Windows,
VMS, etc.), consider writing platform-specific code.

may need to consider only the differences of those particular systems.
The important thing is to decide where the code will run and to be
deliberate in your decision.

portability (0), platform-specific issues (0), and
built-in perl functions that behave differently on various ports
(0).

transient information about idiosyncrasies of some of the ports, almost
all of which are in a state of constant evolution.  Thus, this material
should be considered a perpetual work in progress
().

Just what is used as a newline may vary from OS to OS.  Unix
traditionally uses 0, one type of DOSish I/O uses 0,
and 0 uses 0.

logical may depend on the platform in use.  In MacPerl, 0 always
means 0.  In DOSish perls, 0 usually means 0, but when
accessing a file in "text" mode, perl uses the 0 layer that
translates it to (or from) 0, depending on whether you're
reading or writing. Unix does the same thing on ttys in canonical
mode.  0 is commonly referred to as CRLF.

settings that function looks for a trailing 0 character and thus
trims in a portable way.

to explicitly set $/ to the appropriate value for your file format
before using .

in using 0 and 0 on a file accessed in "text" mode.
Stick to 0-ing to locations you got from 0 (and no
others), and you are usually free to use 0 and 0 even
in "text" mode.  Using 0 or 0 or other file operations
may be non-portable.  If you use 0 on a file, however, you
can usually 0 and 0 with arbitrary values in safety.

everywhere.  When using protocols such as common Internet protocols,
0 and 0 are called for specifically, and the values of
the logical 0 and 0 (carriage return) are not reliable.

and unsightly, as well as confusing to those maintaining the code.  As
such, the Socket module supplies the Right Thing for those who want it.

separator 0 is 0, but robust socket code will recognize as
either 0 or 0 as end of line:

be set to LF and any CR stripped later.  Better to write:

platforms--because now any 0's (0's) are stripped out
(and there was much rejoicing).

fetches a web page--should sometimes translate newlines before
returning the data, if they've not yet been translated to the local
newline representation.  A single line of code will often suffice:

and LF characters.  You can print it out and stick it in your wallet.

(like a tty) in canonical mode.  If you are, then CR on input becomes
"\n", and "\n" on output becomes CRLF.

There may well be others.  For example, on an EBCDIC implementation
such as z/OS (OS/390) or OS/400 (using the ILE, the PASE is ASCII-based)
the above material is similar to "Unix" but the code numbers change:

orders (called 0) and widths (32-bit and 64-bit being the
most common today).  This affects your programs when they attempt to transfer
numbers in binary format from one CPU architecture to another,
usually either "live" via network connection, or by storing the
numbers to secondary storage such as a disk file or tape.

little-endian host (Intel, VAX) stores 0x12345678 (305419896 in
decimal), a big-endian host (Motorola, Sparc, PA) reads it as
0x78563412 (2018915346 in decimal).  Alpha and MIPS can be either:
Digital/Compaq used/uses them in little-endian mode; SGI/Cray uses
them in big-endian mode.  To avoid this problem in network (socket)
connections use the 0 and 0 formats 0 and 0, the
"network" orders.  These are guaranteed to be portable.

to force big- or little-endian byte-order.  This is useful if you want
to store signed integers or 64-bit integers, for example.

data structure packed in native format such as:

either of the variables set like so:

endianness.  The platform of shorter width loses the upper parts of the
number.  There is no good solution for this problem except to avoid
transferring or storing raw binary numbers.

transfer and store numbers always in text format, instead of raw
binary, or else consider using modules like Data::Dumper (included in
the standard distribution as of Perl 5.005) and Storable (included as
of perl 5.8).  Keeping all data as text significantly simplifies matters.

how far EBCDIC, or more precisely UTF-EBCDIC will go.

So, it is reasonably safe to assume that all platforms support the
notion of a "path" to uniquely identify a file on the system.  How
that path is really written, though, differs considerably.

Windows, 0, OS/2, VMS, VOS, 0, and probably others.
Unix, for example, is one of the few OSes that has the elegant idea
of a single root directory.

as path separator, or in their own idiosyncratic ways (such as having
several root directories and various "unrooted" device files such NIL:
and LPT:).

symbolic links (0, 0, 0).

timestamp (meaning that about the only portable timestamp is the
modification timestamp), or one second granularity of any timestamps
(e.g. the FAT filesystem limits the time granularity to two seconds).

"creation timestamp" (which it is not in Unix).

native pathname characters greater-than, less-than, number-sign, and
percent-sign are always accepted.

separator, or go native and use 0 for path separator and 0 to
signal filesystems and disk names.

and execute are all the permissions there are, and even if they exist,
that their semantics (for example what do r, w, and x mean on
a directory) are the Unix ones.  The various Unix/POSIX compatibility
layers usually try to make interfaces like  work, but sometimes
there simply is no good mapping.

fear.  There are modules that can help.  The File::Spec modules
provide methods to do the Right Thing on whatever platform happens
to be running the program.

5.004_05.  File::Spec::Functions is only in File::Spec 0.7 and later,
and some versions of perl come with version 0.6.  If File::Spec
is not updated to 0.7 or later, you must use the object-oriented
interface from File::Spec (or upgrade File::Spec).

Making them user-supplied or read from a configuration file is
better, keeping in mind that file path syntax varies on different
machines.

which often assume 0 as a path separator for subdirectories.

splits a pathname into pieces (base filename, full path to directory,
and file suffix).

remember not to count on the existence or the contents of particular
system-specific files or directories, like 0,
0, 0, or even 0.  For
example, 0 may exist but not contain the encrypted
passwords, because the system is using some form of enhanced security.
Or it may not contain all the accounts, because the system is using NIS.
If code does need to rely on such a file, include a description of the
file and its format in the code's documentation, then make it easy for
the user to override the default location of the file.

but people forget.

case, like 0 and 0, as many platforms have
case-insensitive (or at least case-forgiving) filenames.  Also, try
not to have non-word characters (except for 0) in the names, and
keep them to the 8.3 convention, for maximum portability, onerous a
burden though this may appear.

8.3 naming and case-insensitive conventions; or, at the least,
make it so the resulting files have a unique (case-insensitively)
first 8 characters.

and even on systems where it might be tolerated, some utilities
might become confused by such whitespace.

filenames.

Always use  explicitly to open a file for reading, or even
better, use the three-arg version of open, unless you want the user to
be able to specify a pipe open.

with 0 instead of 0.  0 is magic and can
translate characters like , , and 0, which may
be the wrong thing to do.  (Sometimes, though, it's the right thing.)
Three-arg open can also help protect against this translation in cases
where it is undesirable.

their own semantics (Mac OS Classic for separating pathname components,
many networking schemes and utilities for separating the nodename and
the pathname, and so on).  For the same reasons, avoid 0, 0 and
0.

0 into one: some networking and clustering filesystems have special
semantics for that.  Let the operating system to sort it out.

hypercorrect, stay case-insensitive and within the 8.3 naming
convention (all the files and directories have to be unique within one
directory if their names are lowercased and truncated to eight
characters before the 0, if any, and to three characters after the
0, if any).  (And do not use 0s in directory names.)

that rely primarily on a Graphical User Interface (GUI) for user
interaction.  A program requiring a command line interface might
not work everywhere.  This is probably for the user of the program
to deal with, so don't stay up late worrying about it.

this limitation may also apply to changing filesystem metainformation
like file permissions or owners.  Remember to 0 files when you
are done with them.  Don't 0 or 0 an open file.  Don't
0 or 0 a file already tied or opened; 0 or 0
it first.

operating systems put mandatory locks on such files.

right to add or delete files/directories in that directory.  That is
filesystem specific: in some filesystems you need write/modify
permission also (or even just) in the file/directory itself.  In some
filesystems (AFS, DFS) the permission to add/delete directory entries
is a completely separate permission.

some filesystems (most notably the ones in VMS) have versioned
filesystems, and  removes only the most recent one (it doesn't
remove all the versions because by default the native tools on those
platforms remove just the most recent version, too).  The portable
idiom to remove all the versions of a file is

(protected, not there, and so on).

Don't count on 0 entries being case-sensitive, or even
case-preserving.  Don't try to clear %ENV by saying 0, or,
if you really have to, make it conditional on 0 since in
VMS the 0 table is much more than a per-process key-value string
table.

their key is used on a read if they did not previously exist.  The
values for 0, 0, 0, and 0,
are known to be dynamically generated.  The specific names that are
dynamically generated may vary with the version of the C library on VMS,
and more may exist than is documented.

exits.  This can cause unintended issues.

0 instead.

directories.

especially the strings values. Users may switch their locales causing
error messages to be translated into their languages.  If you can
trust a POSIXish environment, you can portably use the symbols defined
by the Errno module, like ENOENT.  And don't trust on the values of 0
at all except immediately after a failed system call.

0 or 0 can also be used to test for the existence of the
file that holds the executable code for that command or program.
First, many systems have "internal" commands that are built-in to the
shell or OS and while these commands can be invoked, there is no
corresponding file.  Second, some operating systems (e.g., Cygwin,
DJGPP, OS/2, and VOS) have required suffixes for executable files;
these suffixes are generally permitted on the command name but are not
required.  Thus, a command like "perl" might exist in a file named
"perl", "perl.exe", or "perl.pm", depending on the operating system.
The variable "_exe" in the Config module holds the executable suffix,
if any.  Third, the VMS port carefully sets up $^X and
{perlpath} so that no further processing is required.  This is
just as well, because the matching regular expression used below would
then have to deal with a possible trailing version number in the VMS
file name.

of the various operating system possibilities, say:

to the public Internet.

than 80, or some web proxy.  ftp is blocked by many firewalls.

'localhost'.  The same goes for '127.0.0.1'.  You will have to try both.

can't bind to many virtual IP addresses.

either a fully qualified hostname or a non-qualified hostname: it all
depends on how the system had been configured.  Also remember that for
things such as DHCP and NAT, the hostname you get back might not be
very useful.

is to degrade gracefully if one cannot reach the particular network
service one wants.  Croaking or hanging do not look very professional.

portable.  That means, no 0, 0, 0, 0,
0, 0, 0 with a 0, nor any of the other things
that makes being a perl hacker worth being.

most platforms (though many of them do not support any type of
forking).  The problem with using them arises from what you invoke
them on.  External tools are often named differently on different
platforms, may not be available in the same location, might accept
different arguments, can behave differently, and often present their
results in a platform-dependent way.  Thus, you should seldom depend
on them to produce consistent results. (Then again, if you're calling
0, you probably don't expect it to run on both Unix and CP/M.)

available.  But it is not fine for many non-Unix systems, and even
some Unix systems that may not have sendmail installed.  If a portable
solution is needed, see the various distributions on CPAN that deal
with it.  Mail::Mailer and Mail::Send in the MailTools distribution are
commonly used, and provide several mailing methods, including mail,
sendmail, and direct SMTP (via Net::SMTP) if a mail transfer agent is
not available.  Mail::Sendmail is a standalone module that provides
simple, platform-independent mailing.

even on all Unix platforms.

bare v-strings (such as 0) to represent IPv4 addresses:
both forms just pack the four bytes into network order.  That this
would be equal to the C language 0 struct (which is what the
socket code internally uses) is not guaranteed.  To be portable use
the routines of the Socket extension, such as 0,
0, and 0.

use a module (that may internally implement it with platform-specific
code, but expose a common interface).

libraries, header files, etc., might not be readily available or
portable, or the XS code itself might be platform-specific, just as Perl
code might be.  If the libraries and headers are portable, then it is
normally reasonable to make sure the XS code is portable, too.

availability of a C compiler on the end-user's system.  C brings
with it its own portability issues, and writing XS code will expose
you to some of those.  Writing purely in Perl is an easier way to
achieve portability.

exceptions are the CPAN module (which currently makes connections to external
programs that may not be available), platform-specific modules (like
ExtUtils::MM_VMS), and DBM modules.

SDBM_File and the others are generally available on all Unix and DOSish
ports, but not in MacPerl, where only NBDM_File and DB_File are
available.

AnyDBM_File will use whichever module it can find.  Of course, then
the code needs to be fairly strict, dropping to the greatest common
factor (e.g., not exceeding 1K for each record), so that it will
work with any DBM module.  See 0 for more details.

widely different ways.  Don't assume the timezone is stored in 0,
and even if it is, don't assume that you can control the timezone through
that variable.  Don't assume anything about the three-letter timezone
abbreviations (for example that MST would be the Mountain Standard Time,
it's been known to stand for Moscow Standard Time).  If you need to
use timezones, express them in some unambiguous format like the
exact number of minutes offset from UTC, or the POSIX timezone
format.

because that is OS- and implementation-specific.  It is better to
store a date in an unambiguous representation.  The ISO 8601 standard
defines YYYY-MM-DD as the date format, or YYYY-MM-DDTHH-MM-SS
(that's a literal "T" separating the date from the time).
Please do use the ISO 8601 instead of making us guess what
date 02/03/04 might be.  ISO 8601 even sorts nicely as-is.
A text representation (like "1987-12-18") can be easily converted
into an OS-specific value using a module like Date::Parse.
An array of values, such as those returned by 0, can be
converted to an OS-specific representation using Time::Local.

it may be appropriate to calculate an offset for the epoch.

will be some large number.  0 can then be added to a Unix time
value to get what should be the proper value on any system.

Do not use explicit code point ranges (like \xHH-\xHH); use for
example symbolic character classes like 0.

(in the numeric sense).  There may be gaps.

The lowercase letters may come before or after the uppercase letters;
the lowercase and uppercase may be interlaced so that both "a" and "A"
come before "b"; the accented and other international characters may
be interlaced so that 0 comes before "b".

more about the POSIX locale system from 0.  The locale
system at least attempts to make things a little bit more portable,
or at least more convenient and native-friendly for non-English
users.  The system affects character sets and encoding, and date
and time formatting--amongst other things.

See 0 and 0 for more information.

the "source code" of your code, to be portable you have to be explicit
about what bytes they are.  Someone might for example be using your
code under a UTF-8 locale, in which case random native bytes might be
illegal ("Malformed UTF-8 ...")  This means that for example embedding
ISO 8859-1 bytes beyond 0x7f into your strings might cause trouble
later.  If the bytes are native 8-bit bytes, you can use the 0
pragma.  If the bytes are in a string (regular expression being a
curious string), you can often also use the 0 notation instead
of embedding the bytes as-is.  (If you want to write your code in UTF-8,
you can use the 0.) The 0 and 0 pragmata are
available since Perl 5.6.0.

missing!) virtual memory systems then you want to be 0 mindful
of avoiding wasteful constructs such as:

first repeatedly grows a string, whereas the second allocates a
large chunk of memory in one go.  On some systems, the second is
more efficient that the first.

implemented at the filesystem level.  Some, however, unfortunately do
not.  Thus the notion of user id, or "home" directory,
or even the state of being logged-in, may be unrecognizable on many
platforms.  If you write programs that are security-conscious, it
is usually best to know what type of system you will be running
under so that you can write code explicitly for that platform (or
class of platforms).

system or the filesystem may be using some ACL systems, which are
richer languages than the usual rwx.  Even if the rwx exist,
their semantics might be different.

do something is silly anyway: if one tries this, there is potential
for race conditions. Someone or something might change the
permissions between the permissions check and the actual operation.
Just try the operation.)

expect the  and  (or the 0 and 0) to work
for switching identities (or memberships).

think twice: set-uid and set-gid are a known can of security worms.)

consider keeping the platform-specific code in one place, making porting
to other platforms easier.  Use the Config module and the special
variable 0 to differentiate platforms, as described in
0.

Module code may be fully portable, but its tests might not be.  This
often happens when tests spawn off other processes or call external
programs to aid in the testing, or when (as noted above) the tests
assume certain things about the filesystem and paths.  Be careful not
to depend on a specific output style for errors, such as when checking
0 after a failed system call.  Using 0 for anything else than
displaying it as output is doubtful (though see the Errno module for
testing reasonably portably for error value). Some platforms expect
a certain output format, and Perl on those platforms may have been
adjusted accordingly.  Most specifically, don't anchor a regex when
testing an error value.

different platforms.  These CPAN testers are notified by mail of each
new upload, and reply to the list with PASS, FAIL, NA (not applicable to
this platform), or UNKNOWN (unknown), along with any relevant notations.

problems in their code that crop up because of lack of testing on other
platforms; two, to provide users with information about whether
a given module works on a given platform.

indicates the operating system it was built on.  This was implemented
to help speed up code that would otherwise have to 0
and use the value of 0.  Of course, to get more
detailed information about the system, looking into 0 is
certainly recommended.

at compile time.  If perl was built in one place, then transferred
elsewhere, some values may be wrong.  The values may even have been
edited after the fact.

e.g. most of the files in the 0 directory in the source code kit).
On most of these systems, the value of 0 (hence 0,
too) is determined either by lowercasing and stripping punctuation from the
first field of the string returned by typing 0 (or a similar command)
at the shell prompt or by testing the file system for the presence of
uniquely named files such as a kernel or header file.  Here, for example,
are a few of the more popular Unix flavors:

hardware architecture, it can vary more than the value of 0.

systems like PC-DOS, MS-DOS, OS/2, and most Windows platforms you can
bring yourself to mention (except for Windows CE, if you count that).
Users familiar with 0 or 0 style shells should
be aware that each of these file specifications may have subtle
differences:

However, many command-line utilities of DOS vintage treat 0 as
the option prefix, so may get confused by filenames containing 0.
Aside from calling any external programs, 0 will work just fine,
and probably better, as it is more consistent with popular usage,
and avoids the problem of remembering what to backwhack and what
not to.

the "case-insensitive, but case-preserving" HPFS (OS/2) and NTFS (NT)
filesystems you may have to be careful about case returned with functions
like 0 or used with functions like 0 or 0.

NUL, CON, COM1, LPT1, LPT2, etc.  Unfortunately, sometimes these
filenames won't even work if you include an explicit directory
prefix.  It is best to avoid such filenames, if you want your code
to be portable to DOS and its derivatives.  It's hard to know what
these all are, unfortunately.

scripts such as 0 or 0 to
put wrappers around your scripts.

and writing to files (see 0).  0
will keep 0 translated as 0 for that filehandle.  Since it is a
no-op on other systems, 0 should be used for cross-platform code
that deals with binary data.  That's assuming you realize in advance
that your data is in binary.  General-purpose programs should
often assume nothing about their data.

DOSish perls are as follows:

via the value of the fifth element of the list returned from
Win32::.  For example:

and as of libwin32 0.19 (not part of the core Perl distribution)
Win32::.  The very portable POSIX:: will work too:

and 0.

0  Also 0.

in 0.

as 0), 0

0

specifications as in either of the following:

often requires a different set of quotation marks than Unix shells do.
For example:

you are so inclined.  For example:

perl-in-DCL script expects to do things like .

maximum length for filenames is 39 characters, and the maximum length for
extensions is also 39 characters.  Version is a number from 1 to
32767.  Valid characters are 0.

Perl simulates this by converting all filenames to lowercase internally.

Unicode characters.  Characters that could be misinterpreted by the DCL
shell or file parsing utilities need to be prefixed with the 0
character, or replaced with hexadecimal characters prefixed with the
0 character.  Such prefixing is only needed with the pathnames are
in VMS format in applications.  Programs that can accept the Unix format
of pathnames do not need the escape characters.  The maximum length for
filenames is 255 characters.  The ODS-5 file system can handle both
a case preserved and a case sensitive mode.

settings to preserve backward compatibility with Perl scripts that
assume the previous VMS limitations.

should return it in a Unix format, and when they get a VMS format
specification they should return a VMS format unless they are documented
to do a conversion.

if the C library which Perl is built on if it will be returned in VMS
format or in Unix format.

filenames without paths for VMS or Unix.  With the extended character
set available with ODS-5 there can be a significant difference.

treating VMS and Unix filenames interchangeably.  Without the extended
character set enabled, this behavior will mostly be maintained for
backwards compatibility.

Unix formatted file specifications is to that of a Unix system.

equivalent Unix file specification should not show the trailing dot.

can not depend on Perl to present the filenames in lowercase, to be
case sensitive, and that the filenames could be returned in either
Unix or VMS format.

convert it, it should return it in the same format as it found it.

When the ODS-5 support is enabled, it will return the exact case of the
filename on the disk.

0 in the default mode with a file named 0 will
return 0 when VMS is (though that file could be opened with
0).

given a Unix format directory, a file named 0 will return 0
and optionally in the exact case on the disk.  When 0 is given
a VMS format directory, then 0 should return 0, and
again with the optionally the exact case.

(allowing 16 levels overall) prior to VMS 7.2, and even with versions of
VMS on VAX up through 7.3.  Hence 0 is a
valid directory specification but 0 is
not.  0 authors might have to take this into account, but at
least they can refer to the former as 0.

directory levels have snuck into the core by running the following in the
top-level source directory:

process on VMS, is a pure Perl module that can easily be installed on
non-VMS platforms and can be helpful for conversions to and from RMS
native formats.  It is also now the only way that you should check to
see if VMS is in a case sensitive mode.

represents 0 but it could also be 0, 0, 0,
0, 0, or nothing depending on the file organization and
record format.  The VMS::Stdio module provides access to the
special  requirements of files with unusual attributes on VMS.

implemented.  UDP sockets may not be supported.

loaded if present, so even if the routines are configured, they may
return a status indicating that they are not implemented.

that you are running on without resorting to loading all of 0
you can examine the content of the 0 array like so:

on VMS_VAX or one of the 64 bit OpenVMS platforms.

logical name.  Although the VMS epoch began at 17-NOV-1858 00:00:00.00,
calls to 0 are adjusted to count offsets from
01-JAN-1970 00:00:00.00, just like Unix.

in the perl distribution (installed as 0).  Perl on VOS
can accept either VOS- or Unix-style file specifications as in
either of the following:

names, because the VOS port of Perl interprets it as a pathname
delimiting character, VOS files, directories, or links whose
names contain a slash character cannot be processed.  Such files
must be renamed before they can be processed by Perl.

names to 32 or fewer characters, prohibit file names from
starting with a 0 character, and prohibit file names from
containing any character matching .

feature known as extended names.  On these releases, file names
can contain up to 255 characters, are prohibited from starting
with a 0 character, and the set of prohibited characters is
reduced to any character matching .  There are
restrictions involving spaces and apostrophes:  these characters
must not begin or end a name, nor can they immediately precede or
follow a period.  Additionally, a space must not immediately
precede another space or hyphen.  Specifically, the following
character combinations are prohibited:  space-space,
space-hyphen, period-space, space-period, period-apostrophe,
apostrophe-period, leading or trailing space, and leading or
trailing apostrophe.  Although an extended file name is limited
to 255 characters, a path name is still limited to 256
characters.

architecture that you are running on without resorting to loading
all of 0 you can examine the content of the @INC array
like so:

comments to the comp.sys.stratus newsgroup, or use the contact
information located in the distribution files on the Stratus
Anonymous FTP site.

AS/400 minicomputers as well as OS/390, VM/ESA, and BS2000 for S/390
Mainframes.  Such computers use EBCDIC character sets internally (usually
Character Code Set ID 0037 for OS/400 and either 1047 or POSIX-BC for S/390
systems).  On the mainframe perl currently works under the "Unix system
services for OS/390" (formerly known as OpenEdition), VM/ESA OpenEdition, or
the BS200 POSIX-BC system (BS2000 is supported in perl 5.6 and greater).
See 0 for details.  Note that for OS/400 there is also a port of
Perl 5.8.1/5.9.0 or later to the PASE which is ASCII-based (as opposed to
ILE which is EBCDIC-based), see 0.

sub-systems do not support the 0 shebang trick for script invocation.
Hence, on OS/390 and VM/ESA perl scripts can be executed with a header
similar to the following simple script:

Calls to 0 and backticks can use POSIX shell syntax on all
S/390 systems.

to wrap your perl scripts in a CL procedure to invoke them like so:

QOpenSys file system.  On the AS/400 calls to 0 or backticks
must use CL syntax.

an effect on what happens with some perl functions (such as 0,
0, 0, 0, 0, 0, 0, 0), as
well as bit-fiddling with ASCII constants using operators like 0, 0
and 0, not to mention dealing with socket interfaces to ASCII computers
(see 0).

translate the 0 in the following statement to its ASCII equivalent
(0 is the same under both Unix and OS/390 & VM/ESA):

platform could include any of the following (perhaps all):

of punctuation characters since these may differ from code page to code
page (and once your module or script is rumoured to work with EBCDIC,
folks will want it to work with all EBCDIC character sets).

0.

general usage issues for all EBCDIC Perls.  Send a message body of
"subscribe perl-mvs" to majordomo@perl.org.

0
as well as on CPAN in the 0 directory.

Unix, and because Unix filename emulation is turned on by default,
most simple scripts will probably work "out of the box".  The native
filesystem is modular, and individual filesystems are free to be
case-sensitive or insensitive, and are usually case-preserving.  Some
native filesystems have name length limits, which file and directory
names are silently truncated to fit.  Scripts should be aware that the
standard filesystem currently has a name length limit of 0
characters, with up to 77 items in a directory, but other filesystems
may not impose such limitations.

the second stage of 0 interpolation in regular expressions will fall
foul of the 0 if scripts are not careful.

search lists are also allowed; hence 0 is a valid
filename, and the filesystem will prefix 0 with each section of
0 until a name is made that points to an object on disk.
Writing to a new file 0 would be allowed only if
0 contains a single item list.  The filesystem will also
expand system variables in filenames if enclosed in angle brackets, so
 would look for the file
S<0.  The obvious implication of this is
that 0 and should
be protected when 0 is used for input.

be assumed to be unique after 10 characters, Acorn implemented the C
compiler to strip the trailing 0 0 0 and 0 suffix from
filenames specified in source code and store the respective files in
subdirectories named after the suffix.  Hence files are translated:

that this sort of translation is required, and it allows a user-defined list
of known suffixes that it will transpose in this fashion.  This may
seem transparent, but consider that with these rules 0
and 0 both map to 0, and that 0 and
0 cannot and do not attempt to emulate the reverse mapping.  Other
0's in filenames are translated to 0.

the convention is that program specific environment variables are of the
form 0.  Each filesystem maintains a current directory,
and the current filesystem's current directory is the 0 current
directory.  Consequently, sociable programs don't change the current
directory but rely on full pathnames, and programs (and Makefiles) cannot
assume that they can spawn a child process which can change the current
directory without affecting its parent (and everyone else for that
matter).

allocated down from 255, with 0 being a reserved value, the Unix emulation
library emulates Unix filehandles.  Consequently, you can't rely on
passing 0, 0, or 0 to your children.

 on the command line unquoted causes problems,
too: 0 command output capture has to perform a guessing game.  It
assumes that a string  is a
reference to an environment variable, whereas anything else involving
 or  is redirection, and generally manages to be 99%
right.  Of course, the problem remains that scripts cannot rely on any
Unix tools being available, or that any tools found have Unix-like command
line arguments.

tools.  In practice, many don't, as users of the Acorn platform are
used to binary distributions.  MakeMaker does run, but no available
make currently copes with MakeMaker's makefiles; even if and when
this should be fixed, the lack of a Unix-like shell will cause
problems with makefile rules, especially lines of the form 0, and anything using quoting.

in 0 is "riscos" (because we don't like shouting).

the categories listed above.  Some, such as AmigaOS, BeOS, HP MPE/iX,
QNX, Plan 9, and VOS, have been well-integrated into the standard
Perl source code kit.  You may need to see the 0 directory
on CPAN for information, and possibly binaries, for the likes of:
aos, Atari ST, lynxos, riscos, Novell Netware, Tandem Guardian,
0  (Yes, we know that some of these OSes may fall under the
Unix category, but we are not a standards body.)

in the "OTHER" category include:

0

precompiled binary and source code form from 0
as well as from CPAN.

or else have been implemented differently on various platforms.
Following each description will be, in parentheses, a list of
platforms that the description applies to.

in doubt, consult the platform-specific README files in the Perl
source distribution, and any other documentation resources accompanying
a given port.

default from the Config module.  For example, to check whether the
platform has the 0 call, check 0.  See
0 for a full description of available variables.

which determines whether the directory can be deleted, not whether it can
be written to. Directories always have read and write access unless denied
by discretionary access control lists (DACLs).  (0)

which may not reflect UIC-based file protections.  (VMS)

rather than the current extent.  0 on an open filehandle returns the
current size.  (0)

0, 0. (Win32, VMS, 0)

(Win32, VMS, 0)

(VMS)

suffixes.  0 is meaningless.  (Win32)

(0)

wants to dispatch "safe signals" and therefore cannot interrupt
blocking system calls.  (Win32)

results for 0 may vary depending on any combination of the above.
Perl attempts to conform to the Open Group/IEEE standards for the results
returned from 0, but cannot force the issue if the system Perl is
run on does not allow it.  (Tru64, HP-UX 10.20)

0.

filehandle may be closed, or pointer may be in a different position.
(VMS)

the filehandle may be flushed. (Win32)

bits are meaningless. (Win32)

in the SYSTEM environment settings.  (Cygwin)

perl. (Win32)

(SunOS, Solaris, HP-UX)

mapping the 0 to SS (0).  This behavior may be overridden
with the pragma 0.  As with the CRTL's 
function, 0 is also mapped to an exit status of SS
(0); this mapping cannot be overridden.  Any other argument to 
is used directly as Perl's exit status.  On VMS, unless the future
POSIX_EXIT mode is enabled, the exit code should always be a valid
VMS exit code and not a generic number.  When the POSIX_EXIT mode is
enabled, a generic number will be encoded in a method compatible with
the C library _POSIX_EXIT macro so that it can be decoded by other
programs, particularly ones written in C, like the GNV package.  (VMS)

from a child process (created by 0) in 0.
A workaround is to use 0.  (Solaris)

(SunOS, Solaris, HP-UX)

to use 0. (0)

platforms.  See 0 for portability information.

because work arounds in the implementation use floating point numbers,
it will become inaccurate as the time gets larger.  This is a bug and
will be fixed in the future.

in the Winsock API does. (Win32)

a signal to the identified process like it does on Unix platforms.
Instead 0 terminates the process identified by ,
and makes it exit immediately with exit status .  As in Unix, if
 is 0 and the specified process exists, it returns true without
actually terminating it. (Win32)

recursively all child processes owned by it.  This is different from
the Unix semantics, where the signal will be delivered to all
processes in the same process group as the process specified by
. (Win32)

numbers. (VMS)

(They are sort of half-way between hard and soft links). (AmigaOS)

natively supported on Windows 2000 and later.  On Windows NT they
are implemented using the Windows POSIX subsystem support and the
Perl process will need Administrator or Backup Operator privileges
to create hard links.

rules change its accuracy for historical and future times may degrade
but usually by no more than an hour.

platforms.  (SunOS, Solaris, HP-UX)

already read before the  call will just be returned again
from a cache buffer. (Win32)

be implemented even in Unix platforms.

as '', so numeric comparison or manipulation of these fields may cause
'not numeric' warnings.

inode are not necessarily reliable.  (0)

meaningful and will differ between stat calls on the same file.  (os2)

may then attempt to stat("foo.exe") (Cygwin)

and update attributes that may have been changed through hard links.
Setting ${^WIN32_SLOPPY_STAT} to a true value speeds up  by
not performing this operation. (Win32)

syntax if it is intended to resolve to a valid path.

numeric values on some systems.  The flags exported by 0
(O_RDONLY, O_WRONLY, O_RDWR) should work everywhere though.  (0, OS/390, VM/ESA)

0.  0 spawns an external
process and immediately returns its process designator, without
waiting for it to terminate.  Return value may be used subsequently
in 0 or 0.  Failure to  a subprocess is indicated
by setting $? to "255 << 8".  0 8",
as described in the documentation).  (Win32)

to pass a command line terminated by "\n" "\r" or "\0" to the spawned
program.  Redirection such as  is performed (if at all) by
the run time library of the spawned program.  0 0 will call
the Unix emulation library's 0 emulation, which attempts to provide
emulation of the stdin, stdout, stderr in force in the parent, providing
the child program uses a compatible version of the emulation library.
0 will call the native command line direct and no such emulation
of a child Unix program will exists.  Mileage 0 vary.  (0)

(SunOS, Solaris, HP-UX)

room for a made-up value derived from the severity bits of the native
32-bit condition code (unless overridden by 0).
If the native condition code is one that has a POSIX value encoded, the
POSIX value will be decoded to extract the expected exit value.
For more details see 0. (VMS)

or Windows 2000, "system" time will be bogus, and "user" time is
actually the time returned by the  function in the C runtime
library. (Win32)

mode (i.e., use C<<< open(FH, '>>filename') >>>
or 0.  If a filename is supplied, it
should not be held open elsewhere. (Win32)

is finally closed. (AmigaOS)

library's implementation of , and the filesystem being
used.  The FAT filesystem typically does not support an "access
time" field, and it may limit timestamps to a granularity of
two seconds. (Win32)

using 0 or pseudo processes created with 0. (Win32)

its release date) from the standard source code distribution available
at 0

Perl but have been officially removed from Perl's source code
as of 5.12:

have worked in 5.12, but supporting code has been removed for 5.14:

able to build Perl from the standard source code distribution
available at 0

5.7), but we did not manage either to fix or to test these in time
for the 5.8.0 release.  There is a very good chance that many of these
will work fine with the 5.8.0.

the past (5.005_03 and earlier), but we haven't been able to verify
their status for the current release, either because the
hardware/software platforms are rare or because we don't have an
active champion on these platforms--or both.  They used to work,
though, so go ahead and try compiling them, and let perlbug@perl.org
of any trouble.

binaries available via 0

0 :

the source code, both for maximal configurability and for security,
in case you are in a hurry you can check
0 for binary distributions.

0, 0, 0, 0, 0,
0, 0, 0, 0, 0,
0, 0, 0,
0, 0, 0, 0,
0, 0, 0, 0,
0, 0, 0, 0,
0, and 0.

Charles Bailey <bailey@newman.upenn.edu>,
Graham Barr <gbarr@pobox.com>,
Tom Christiansen <tchrist@perl.com>,
Nicholas Clark <nick@ccl4.org>,
Thomas Dorner <Thomas.Dorner@start.de>,
Andy Dougherty <doughera@lafayette.edu>,
Dominic Dunlop <domo@computer.org>,
Neale Ferguson <neale@vma.tabnsw.com.au>,
David J. Fiander <davidf@mks.com>,
Paul Green <Paul.Green@stratus.com>,
M.J.T. Guy <mjtg@cam.ac.uk>,
Jarkko Hietaniemi <jhi@iki.fi>,
Luther Huffman <lutherh@stratcom.com>,
Nick Ing-Simmons <nick@ing-simmons.net>,
Andreas J. K0nig <a.koenig@mind.de>,
Markus Laker <mlaker@contax.co.uk>,
Andrew M. Langmead <aml@world.std.com>,
Larry Moore <ljmoore@freespace.net>,
Paul Moore <Paul.Moore@uk.origin-it.com>,
Chris Nandor <pudge@pobox.com>,
Matthias Neeracher <neeracher@mac.com>,
Philip Newton <pne@cpan.org>,
Gary Ng <71564.1743@CompuServe.COM>,
Tom Phoenix <rootbeer@teleport.com>,
Andr0 Pirard <A.Pirard@ulg.ac.be>,
Peter Prymmer <pvhp@forte.com>,
Hugo van der Sanden <hv@crypt0.demon.co.uk>,
Gurusamy Sarathy <gsar@activestate.com>,
Paul J. Schinder <schinder@pobox.com>,
Michael G Schwern <schwern@pobox.com>,
Dan Sugalski <dan@sidhe.org>,
Nathan Torkington <gnat@frii.com>,
John Malmberg <wb8tyw@qsl.net> 

=encoding utf8

time behaviour of Perl, such as 0 or 0. With Perl 5.10 you
are no longer limited to the built in pragmata; you can now create user
pragmata that modify the behaviour of user functions within a lexical scope.

mathematical operators, and would like to provide your own pragma that
functions much like 0 You'd like this code

to integer, whereas by default they are not, with the default behaviour being
restored via 0

this:

prevent its 0 being called.

becomes

for the user's code.

hence these two routines manipulate it. The state information in 0 is
stored in the optree, and can be retrieved read-only at runtime with 0,
at index 10 of the list of returned results. In the example pragma, retrieval
is encapsulated into the routine 0, which takes as parameter
the number of call frames to go up to find the value of the pragma in the
user's script. This uses 0 to determine the value of
0 when each line of the user's script was called, and
therefore provide the correct semantics in the subroutine implementing the
overloaded addition.

the optree will outlive the particular thread (and therefore the interpreter
instance) that created it, so true Perl scalars cannot be stored in the
optree.  Instead a compact form is used, which can only store values that are
integers (signed and unsigned), strings or 0 - references and
floating point values are stringified.  If you need to store multiple values
or complex structures, you should serialise them, for example with 0.
The deletion of a hash key from 0 is recorded, and as ever can be
distinguished from the existence of a key with value 0 with
0.

are retrieved via 0 and converted back, as this will not be threadsafe.
Accesses would be to the structure without locking (which is not safe for
Perl's scalars), and either the structure has to leak, or it has to be
freed when its creating thread terminates, which may be before the optree
referencing it is deleted, if other threads outlive it. 

=encoding utf8

0 0 0

introduction is available in 0, and a longer tutorial
introduction is available in 0.

operations, plus various examples of the same, see discussions of
0, 0, 0 and 0 in
0.

that relate to the interpretation of the regular expression inside
are listed below.  Modifiers that alter the way a regular expression
is used by Perl are detailed in 0 and
0.

0 0 0 0

the start or end of the string to matching the start or end of any
line anywhere within the string.

0 0 0
0

whatsoever, even a newline, which normally it would not match.

while still allowing "^" and "$" to match, respectively, just after
and just before newlines within the string.

0 0 0
0

current
locale for code points less than 255, and from Unicode rules for larger
code points.  However, matches that would cross the Unicode
rules/non-Unicode rules boundary (ords 255/256) will not succeed.  See
0.

under 0.  For example, 0
should match the sequence 0.  Perl is not
currently able to do this when the multiple characters are in the pattern and
are split between groupings, or when one or more are quantified.  Thus

character class, which otherwise could be highly confusing.  See
0.

recommendations, which ask that the matching be made upon the NFD
(Normalization Form Decomposed) of the text.  However, Unicode is
in the process of reconsidering and revising their recommendations.

0

Details in 0

0 0 0

${^POSTMATCH} are available for use after matching.

0 0

Unlike i, m, s and x, these two flags affect the way the regex is used
rather than the regex itself. See
0 for further explanation
of the g and c modifiers.

0 0 0 0

(Unicode, ASCII, etc.) are used, as described below in
0.

in question might not really be a slash.  The modifiers 0
may also be embedded within the regular expression itself using
the 0 construct, see 0 below.

explanation.

the regular expression parser to ignore most whitespace that is neither
backslashed nor within a character class.  You can use this to break up
your regular expression into (slightly) more readable parts.  The 0
character is also treated as a metacharacter introducing a comment,
just as in ordinary Perl code.  This also means that if you want real
whitespace or 0 characters in the pattern (outside a character
class, where they are unaffected by 0), then you'll either have to
escape them (using backslashes or 0) or encode them using octal,
hex, or 0 escapes.  Taken together, these features go a long way towards
making Perl's regular expressions more readable.  Note that you have to
be careful not to include the pattern delimiter in the comment--perl has
no way of knowing you did not intend to close the pattern early.  See
the C-comment deletion code in 0.  Also note that anything inside
a 0 stays unaffected by 0.  And note that 0 doesn't affect
space interpretation within a single multi-character construct.  For
example in 0, regardless of the 0 modifier, there can be no
spaces.  Same for a 0 such as 0 or
0.  Similarly, 0 can't have a space between the 0 and 0,
but can between the 0 and 0.  Within any delimiters for such a
construct, allowed spaces are not affected by 0, and depend on the
construct.  For example, 0 can't have spaces because hexadecimal
numbers don't have spaces in them.  But, Unicode properties can have spaces, so
in 0 there can be spaces that follow the Unicode rules, for which see
0.
0

the character set modifiers; they affect the character set semantics
used for the regular expression.

compiled, the behavior doesn't change regardless of what rules are in
effect when the regular expression is executed.  And if a regular
expression is interpolated into a larger one, the original's rules
continue to apply to it, and only it.

to any replacement done.  For example,

operates.  If 0 is in effect, the 0 will use locale
rules; if 0 is in effect, it will
use Unicode rules, etc.

matching.  For example, 0 will match the "word" characters of that
locale, and 0 case-insensitive matching will match according to
the locale's case folding rules.  The locale used will be the one in
effect at the time of execution of the pattern match.  This may not be
the same as the compilation-time locale, and can differ from one match
to another if there is an intervening call of the
0.

above 255 are treated as Unicode no matter what locale is in effect.
Under Unicode rules, there are a few case-insensitive matches that cross
the 255/256 boundary.  These are disallowed under 0.  For example,
0xFF does not caselessly match the character at 0x178, 0, because 0xFF may not be 0 in the current locale, and Perl has no way of knowing if
that character even exists in the locale, much less what code point it
is.

see 0.
0

this means that the code points between 128 and 255 take on their
Latin-1 (ISO-8859-1) meanings (which are the same as Unicode's), whereas
in strict ASCII their meanings are undefined.  Thus the platform
effectively becomes a Unicode platform, hence, for example, 0 will
match any of the more than 100_000 word characters in Unicode.

Unicode classifies all the characters that are letters 0 as
0.  For example, your locale might not think that 0 is a letter (unless you happen to speak Icelandic), but
Unicode does.  Similarly, all the characters that are decimal digits
somewhere in the world will match 0; this is hundreds, not 10,
possible matches.  And some of those digits look like some of the 10
ASCII digits, but mean a different number, so a human could easily think
a number is a different quantity than it really is.  For example,
0 (U+09EA) looks very much like an
0 (U+0038).  And, 0, may match strings of digits
that are a mixture from different writing systems, creating a security
issue.  0 can be used to sort this out.

characters.  The 0, for example matches the letters "k" and
"K"; and 0 matches the sequence "ff", which,
if you're not prepared, might make it look like a hexadecimal constant,
presenting another potential security issue.  See
0 for a detailed discussion of Unicode
security issues.

equivalent to Latin-1.  Thus this modifier changes behavior only when
the 0 modifier is also specified, and it turns out it affects only
two characters, giving them full Unicode semantics: the 0
will match the Greek capital and small letters 0, otherwise not; and
the 0 will match any of 0, 0,
0, and 0, but see
0.
0

Posix character classes are restricted to matching in the ASCII range
only.  That is, with this modifier, 0 always means precisely the
digits 0 to 0; 0 means the five characters 0;
0 means the 63 characters 0; and likewise, all the
Posix classes such as 0 match only the appropriate
ASCII-range characters.

With it, one can write 0 with confidence that it will only match
ASCII characters, and should the need arise to match beyond ASCII, you
can use 0, or 0 for 0.  There are similar
0 constructs that can match white space and Posix classes
beyond ASCII.  See 0.

the same thing as 0; in fact, all non-ASCII characters match
0, 0, and 0.  0 still means to match at the boundary
between 0 and 0, using the 0 definitions of them (similarly
for 0).

case-insensitive matching uses Unicode semantics; for example, "k" will
match the Unicode 0 under 0 matching, and code
points in the Latin1 range, above ASCII will have Unicode rules when it
comes to case-insensitive matching.

specify the "a" twice, for example 0 or 0

don't wish to be exposed to all of Unicode.  Specifying it twice
gives added protection.

or 0, but see
0.
0
0

except when there is cause to use Unicode rules instead, as follows:

0); or

used depend on various things, and as a result you can get unexpected
results.  See 0.

(at least the ones that Perl handles), they are Latin-1.

expression depends on a fairly complex set of interactions.  As
explained below in 0 it is possible to explicitly
specify modifiers that apply only to portions of a regular expression.
The innermost always has priority over any outer ones, and one applying
to the whole expression has priority over any of the default settings that are
described in the remainder of this section.

default modifiers (including these) for regular expressions compiled
within its scope.  This pragma has precedence over the other pragmas
listed below that change the defaults.

and C<0 or
C<0 (or higher) set the default to
0 when not in the same scope as either C<0
or C<0.  Unlike the mechanisms mentioned above, these
affect operations besides regular expressions pattern matching, and so
give more consistent results with other operators, including using
0, 0, etc. in substitution replacements.

0 modifier is the one in effect by default.  As this can lead to
unexpected results, it is best to specify which other rule set should be
used.

for regexes compiled within the scope of 0, and 0 was
implied otherwise.  However, interpolating a regex into a larger regex
would ignore the original compilation in favor of whatever was in effect
at the time of the second compilation.  There were a number of
inconsistencies (bugs) with the 0 modifier, where Unicode rules
would be used when inappropriate, and vice versa.  0 did not imply
Unicode rules, and neither did all occurrences of 0, until 5.12.

the Version 8 regex routines.  (The routines are derived
(distantly) from Henry Spencer's freely redistributable reimplementation
of the V8 routines.)  See 0 for
details.

meanings:
0
0 0 0 0 0 0 0 0 0

beginning of the string, the "$" character only the end (or before the
newline at the end), and Perl does certain optimizations with the
assumption that the string contains only one line.  Embedded newlines
will not be matched by "^" or "$".  You may, however, wish to treat a
string as a multi-line buffer, such that the "^" will match after any
newline within the string (except if the newline is the last character in
the string), and "$" will match before any newline.  At the
cost of a little more overhead, you can do this by using the /m modifier
on the pattern match operator.  (Older programs did this by setting 0,
but this option was removed in perl 5.9.)
0 0 0

newline unless you use the 0 modifier, which in effect tells Perl to pretend
the string is a single line--even if it isn't.
0 0

0 0 0 0 0 0 0 0

a backslashed sequence like 0, it is treated
as a regular character.  In particular, the lower bound
is not optional.)  The "*" quantifier is equivalent to 0, the "+"
quantifier to 0, and the "?" quantifier to 0.  n and m are limited
to non-negative integral values less than a preset limit defined when perl is built.
This is usually 32766 on the most common platforms.  The actual limit can
be seen in the error message generated by code such as this:

many times as possible (given a particular starting location) while still
allowing the rest of the pattern to match.  If you want it to match the
minimum number of times possible, follow the quantifier with a "?".  Note
that the meanings don't change, just the "greediness":
0 0 0
0 0 0 0 0 0 0

overall pattern to match, Perl will backtrack. However, this behaviour is
sometimes undesirable. Thus Perl provides the "possessive" quantifier form
as well.

string and won't leave any for the remaining part of the pattern. This
feature can be extremely useful to give perl hints about where it
shouldn't backtrack. For instance, the typical "match a double-quoted
string" problem can be most efficiently performed when written as:

help. See the independent subexpression
0 for more details;
possessive quantifiers are just syntactic sugar for that construct. For
instance the above example could also be written as follows:

also work:

0 0 0 0

character or character sequence whose name is 0; and similarly
when of the form C<\N{U+0, it matches the character whose Unicode
code point is 0.  Otherwise it matches any character but 0.

0 0 0
0
0
0 0 0 0 0 0

that has a 0 on one side of it and a 0 on the other side
of it (in either order), counting the imaginary characters off the
beginning and end of the string as matching a 0.  (Within
character classes 0 represents backspace rather than a word
boundary, just as it normally does in any double-quoted string.)
The 0 and 0 are just like "^" and "$", except that they
won't match multiple times when the 0 modifier is used, while
"^" and "$" will match at every internal line boundary.  To match
the actual end of the string and not ignore an optional trailing
newline, use 0.
0 0 0 0 0

0), as described in 0.
It is also useful when writing 0-like scanners, when you have
several patterns that you want to match against consequent substrings
of your string; see the previous reference.  The actual location
where 0 will match can also be influenced by using 0 as
an lvalue: see 0. Note that the rule for zero-length
matches (see 0)
is modified somewhat, in that contents to the left of 0 are
not counted when determining the length of the match. Thus the following
will not match forever:
0

be zero-width, and thus will not match at the same position twice in a
row.

loop. Take care when using patterns that include 0 in an alternation.

capture buffers). To refer to the current contents of a group later on, within
the same pattern, use 0 (or 0) for the first, 0 (or 0)
for the second, and so on.
This is called a 0.
0 0
0 0
0 0
0 0
0 0 0 0 0
0 0
0 0
0 0 
There is no limit to the number of captured substrings that you may use.
Groups are numbered with the leftmost open parenthesis being number 1, etc.  If
a group did not match, the associated backreference won't match either. (This
can happen if the group is optional, or in a different branch of an
alternation.)
You can omit the 0, and write 0, etc, but there are some issues with
this form, described below.

that 0 and 0 both refer to the immediately preceding capture
group, and 0 and 0 both refer to the group before it.  For
example:

interpolate regexes into larger regexes and not have to worry about the
capture groups being renumbered.

The notation is C<(?000 to declare and C<\g{0 to
reference.  (To be compatible with .Net regular expressions, C<\g{0 may
also be written as C<\k{0, C<\k000 or C<\k'0.)
0 must not begin with a number, nor contain hyphens.
When different groups within the same pattern have the same name, any reference
to that name assumes the leftmost defined group.  Named groups count in
absolute and relative numbering, and so can also be referred to by those
numbers.
(It's possible to do things with named capture groups that would otherwise
require 0.)

pattern until the end of the enclosing block or until the next successful
match, whichever comes first.  (See 0.)
You can refer to them by absolute number (using 0 instead of 0,
etc); or by name via the 0 hash, using C<"$+{0.

absolute or relative numbered ones.  Braces are safer when creating a regex by
concatenating smaller strings.  For example if you have 0, and 0
contained 0, and 0 contained 0, you would get 0 which
is probably not what you intended.

there were no named nor relative numbered capture groups.  Absolute numbered
groups were referred to using 0,
0, etc., and this notation is still
accepted (and likely always will be).  But it leads to some ambiguities if
there are more than 9 capture groups, as 0 could mean either the tenth
capture group, or the character whose ordinal in octal is 010 (a backspace in
ASCII).  Perl resolves this ambiguity by interpreting 0 as a backreference
only if at least 10 left parentheses have opened before it.  Likewise 0 is
a backreference only if at least 11 left parentheses have opened before it.
And so on.  0 through 0 are always interpreted as backreferences.
There are several examples below that illustrate these perils.  You can avoid
the ambiguity by always using 0 or 0 if you mean capturing groups;
and for octal constants always using 0, or for 0 and below, using 3
digits padded with leading zeros, since a leading zero implies an octal
constant.

the pattern.  See 0 below for details.

match.  0 returns whatever the last bracket match matched.
0 returns the entire matched string.  (At one point 0 did
also, but now it returns the name of the program.)  0 returns
everything before the matched string.  0 returns everything
after the matched string. And 0 contains whatever was matched by
the most-recently closed group (submatch). 0 can be used in
extended patterns (see below), for example to assign a submatch to a
variable.
0 0 0 0 0

(0, 0, 0, etc.) are dynamically scoped
until the end of the enclosing block or until the next successful
match, whichever comes first.  (See 0.)
0 0 0 0 0
0 0 0 0 0 0 0 0 0

which makes it easier to write code that tests for a series of more
specific cases and remembers the best match.

0 anywhere in the program, it has to provide them for every
pattern match.  This may substantially slow your program.  Perl
uses the same mechanism to produce 0, 0, etc, so you also pay a
price for each pattern that contains capturing parentheses.  (To
avoid this cost while retaining the grouping behaviour, use the
extended regular expression 0 instead.)  But if you never
use 0, 0 or 0, then patterns 0 capturing
parentheses will not be penalized.  So avoid 0, 0, and 0
if you can, but if you can't (and some algorithms really appreciate
them), once you've used them once, use them at will, because you've
already paid the price.  As of 5.005, 0 is not so costly as the
other two.
0 0 0

0 and 0, which are equivalent to 0, 0
and 0, 0 that they are only guaranteed to be defined after a
successful match that was executed with the 0 (preserve) modifier.
The use of these variables incurs no global performance penalty, unlike
their punctuation char equivalents, however at the trade-off that you
have to tell perl when you want to use them.
0 0

0, 0.  Unlike some other regular expression languages, there
are no backslashed symbols that aren't alphanumeric.  So anything
that looks like \\, \(, \), \<, \>, \{, or \} is always
interpreted as a literal character, not a metacharacter.  This was
once used in a common idiom to disable or quote the special meanings
of regular expression metacharacters in a string that you want to
use for a pattern. Simply quote all non-"word" characters:

Today it is more common to use the  function or the 0
metaquoting escape sequence to disable all metacharacters' special
meanings like this:

interpolated variables) between 0 and 0, double-quotish
backslash interpolation may lead to confusing results.  If you
0 to use literal backslashes within 0,
consult 0.

found in standard tools like 0 and
0.  The syntax for most of these is a
pair of parentheses with a question mark as the first thing within
the parentheses.  The character after the question mark indicates
the extension.

part of the core language for many years.  Others are experimental
and may change without warning or be completely removed.  Check
the documentation on an individual feature to verify its current
status.

construct because 1) question marks are rare in older regular
expressions, and 2) whenever you see one, you should stop and
"question" exactly what is going on.  That's psychology....

0

whitespace formatting, a simple 0 will suffice.  Note that Perl closes
the comment as soon as it sees a 0, so there is no way to put a literal
0 in the comment.

0 0

turned off, if preceded by 0) for the remainder of the pattern or
the remainder of the enclosing pattern group (if any).

configuration file, taken from an argument, or specified in a table
somewhere.  Consider the case where some patterns want to be
case-sensitive and some do not:  The case-insensitive ones merely need to
include 0 at the front of the pattern.  For example:

repetition of the previous word, assuming the 0 modifier, and no 0
modifier outside this group.

enclosing group. In other words, a pattern such as 0 does not
change the case-sensitivity of the "NAME" pattern.

expressions compiled within the scope of a 0.  See
0.

after the 0 is a shorthand equivalent to 0.  Flags (except
0) may follow the caret to override it.
But a minus sign is not legal with it.

that they can only be enabled, not disabled, and the 0, 0, 0, and
0 modifiers are mutually exclusive: specifying one de-specifies the
others, and a maximum of one (or two 0's) may appear in the
construct.  Thus, for
example, 0 will warn when compiled under 0;
0 and 0 are fatal errors.

anywhere in a pattern has a global effect.

0

0

"()", but doesn't make backreferences as "()" does.  So

characters if you don't need to.

0.  For example,

after the 0 is a shorthand equivalent to 0.  Any positive
flags (except 0) may follow the caret, so

surrounding pattern, but uses the system defaults (0),
modified by any flags specified.

expressions.  These look like

A test that looks at such stringification thus doesn't need to have the
system default flags hard-coded in it, just the caret.  If new flags are
added to Perl, the meaning of the caret's expansion will change to include
the default for those flags, so the test will still work, unchanged.

redundant.

to match at the beginning.

0 0

that the capture groups are numbered from the same starting point
in each alternation branch. It is available starting from perl 5.10.0.

construct the numbering is restarted for each branch.

following this construct will be numbered as though the construct
contained only one branch, that being the one with the most capture
groups in it.

number of alternative matches.

which group the captured content will be stored.

named captures. Named captures are implemented as being aliases to
numbered groups holding the captures, and that interferes with the
implementation of the branch reset pattern. If you are using named
captures in a branch reset pattern, it's best to use the same names,
in the same order, in each of the alternations:

named  are aliases for the group belonging to .

0 0 0 0

pattern without including it in 0. Positive assertions match when
their subpattern matches, negative assertions match when their subpattern
fails. Look-behind matches text up to the current match position,
look-ahead matches text following the current match position.

0 0 0

matches a word followed by a tab, without including the tab in 0.

0 0 0

matches any occurrence of "foo" that isn't followed by "bar".  Note
however that look-ahead and look-behind are NOT the same thing.  You cannot
use this for look-behind.

will not do what you want.  That's because the 0 is just saying that
the next thing cannot be "foo"--and it's not, it's a "bar", so "foobar" will
match.  Use look-behind instead (see below).

X<(?<=)> 0 0 0

matches a word that follows a tab, without including the tab in 0.
Works only for fixed-width look-behind.

regex engine to "keep" everything it had matched prior to the 0 and
not include it in 0. This effectively provides variable-length
look-behind. The use of 0 inside of another look-around assertion
is allowed, but the behaviour is currently not well defined.

equivalent  construct, and it is especially useful in
situations where you want to efficiently remove something following
something else in a string. For instance

X<(?<!)> 0 0

matches any occurrence of "foo" that does not follow "bar".  Works
only for fixed-width look-behind.

 0 0 0

parentheses 0 but for the additional fact that the group
can be referred to by name in various regular expression
constructs (like 0) and can be accessed by name
after a successful match via 0 or 0. See 0
for more details on the 0 and 0 hashes.

$+{NAME} will refer to the leftmost defined group in the match.

function in .NET regexes, the behavior is not. In Perl the groups are
numbered sequentially regardless of being named or not. Thus in the
pattern

the opposite which is what a .NET regex hacker might expect.

In other words, it must match 0 or
its Unicode extension (see 0),
though it isn't extended by the locale (see 0).

with the Python or PCRE regex engines, the pattern 
may be used instead of ; however this form does not
support the use of single quotes as a delimiter for the name.

the group is designated by name and not number. If multiple groups
have the same name then it refers to the leftmost defined group in
the current match.

earlier in the pattern.

with the Python or PCRE regex engines, the pattern 
may be used instead of .

0 0 0 0

experimental, and may be changed without notice. Code executed that
has side effects may not perform identically from version to version
due to the effect of future optimisations in the regex engine.

always succeeds, and its 0 is not interpolated.  Currently,
the rules to determine where the 0 ends are somewhat convoluted.

capture the results of submatches in variables without having to keep
track of the number of nested parentheses. For example:

expression is matching against. You can also use 0 to know what is
the current position of matching within this string.

is backtracked (compare 0), all changes introduced after
0ization are undone, so that

introduced value, because the scopes that restrict 0 operators
are unwound.

switch.  If 0 used in this way, the result of evaluation of
0 is put into the special variable 0.  This happens
immediately, so 0 can be used from other 0 assertions
inside the same regular expression.

value of 0 is restored if the assertion is backtracked; compare
0.

expression involves run-time interpolation of variables, unless the
perilous 0 pragma has been used (see 0), or the
variables contain results of the 0 operator (see
L<perlop/"qr/STRING0).

custom of using run-time determined strings as patterns.  For example:

this operation was completely safe from a security point of view,
although it could raise an exception from an illegal pattern.  If
you turn on the 0, though, it is no longer secure,
so you should only do so if you are also using taint checking.
Better yet, use the carefully constrained evaluation within a Safe
compartment.  See 0 for details about both these mechanisms.

broken. The result is unpredictable and will make perl unstable. The
workaround is to use global (0) variables.

was not re-entrant, so interpolated code could not
safely invoke the regex engine either directly with
0 or 0), or indirectly with functions such as
0. Invoking the regex engine in these blocks would make perl
unstable.

0
0 0 0

experimental, and may be changed without notice. Code executed that
has side effects may not perform identically from version to version
due to the effect of future optimisations in the regex engine.

at run time, at the moment this subexpression may match.  The result
of evaluation is considered a regular expression and matched as
if it were inserted instead of this construct.  Note that this means
that the contents of capture groups defined inside an eval'ed pattern
are not available outside of the pattern, and vice versa, there is no
way for the inner pattern to refer to a capture group defined outside.
Thus,

where the 0 ends are currently somewhat convoluted.

the same task.

expression involves run-time interpolation of variables, unless the
perilous 0 pragma has been used (see 0), or the
variables contain results of the 0 operator (see
L<perlop/"qr0STRING0).

delayed code could not safely invoke the regex engine either directly with
0 or 0), or indirectly with functions such as 0.

result in a fatal error.  The maximum depth is compiled into perl, so
changing it requires a custom build.

0 0 0 0 0 0 0 0
0 0 0
0

instead it treats the contents of a capture group as an independent
pattern that must match at the current position.  Capture groups
contained by the pattern will have the value as determined by the
outermost recursion.

the paren-number of the capture group to recurse to. 0 recurses to
the beginning of the whole pattern. 0 is an alternate syntax for
0. If PARNO is preceded by a plus or minus sign then it is assumed
to be relative, with negative numbers indicating preceding capture groups
and positive ones following. Thus 0 refers to the most recently
declared group, and 0 indicates the next group to be declared.
Note that the counting for relative recursion differs from that of
relative backreferences, in that with recursion unclosed groups 0
included.

balanced parentheses as the argument.

fatal error.  Recursing deeper than 50 times without consuming any input
string will also result in a fatal error.  The maximum depth is compiled
into perl, so changing it requires a custom build.

easier to embed recursive patterns inside of a 0 construct
for later use:

PCRE or Python construct of the same form. In Perl you can backtrack into
a recursed group, in PCRE and Python the recursed into group is treated
as atomic. Also, modifiers are resolved at compile time, so constructs
like (?i:(?1)) or (?:(?i)(?1)) do not affect how the sub-pattern will
be processed.

0

parenthesis to recurse to is determined by name. If multiple parentheses have
the same name, then it recurses to the leftmost.

pattern.

with the Python or PCRE regex engines the pattern 
may be used instead of .

0

a true value, matches 0 otherwise. A missing pattern always
matches.

parentheses (which is valid if the corresponding pair of parentheses
matched), a look-ahead/look-behind/evaluate zero-width assertion, a
name in angle brackets or single quotes (which is valid if a group
with the given name matched), or the special symbol (R) (true when
evaluated inside of recursion or eval). Additionally the R may be
followed by a number, (which will be true when evaluated when recursing
inside of the appropriate group), or by 0, in which case it will
be true only when evaluated during recursion in the named group.

variants).

inside of the n-th capture group. This check is the regex equivalent of

directly inside of the leftmost group with a given name (this is the same
logic used by 0 to disambiguate). It does not check the full
stack, but only the name of the innermost active recursion.

no-pattern is allowed. Similar in spirit to 0 but more efficient.
See below for details.

themselves.

yes-pattern directly, and does not allow a no-pattern. This allows one to
define subpatterns which will be executed only by the recursion mechanism.
This way, you can define a set of regular expression rules that can be
bundled into any pattern you choose.

end of the pattern, and that you name any subpatterns defined within it.

not be as efficient, as the optimiser is not very clever about
handling them.

after the recursion returns, so the extra layer of capturing groups is
necessary. Thus 0 would not be defined even though
0 would be.

0 0 0 0

that a 0 0 would match if anchored at the given
position, and it matches 0.  This
construct is useful for optimizations of what would otherwise be
"eternal" matches, because it will not backtrack (see 0).
It may also be useful in places where the "grab all you can, and do not
give anything back" semantic is desirable.

(anchored at the beginning of string, as above) will match 0
characters 0 at the beginning of string, leaving no 0 for
0 to match.  In contrast, 0 will match the same as 0,
since the match of the subgroup 0 is influenced by the following
group 0 (see 0).  In particular, 0 inside
0 will match fewer characters than a standalone 0, since
this makes the tail match.

matched. It is still possible to backtrack past the construct, but not
into it. So  will still match "bar".

0.  This matches the same substring as a standalone
0, and the following 0 eats the matched string; it therefore
makes a zero-length assertion into an analogue of .
(The difference between these two constructs is that the second one
uses a capturing group, thus shifting ordinals of backreferences
in the rest of a regular expression.)

two levels deep or less.  However, if there is no such group, it
will take virtually forever on a long string.  That's because there
are so many different ways to split a long string into several
substrings.  This is what 0 is doing, and 0 is similar
to a subpattern of the above pattern.  Consider how the pattern
above detects no-match on 0 in several
seconds, but that each extra letter doubles this time.  This
exponential performance will make it appear that your program has
hung.  However, a tiny change to this pattern

this yourself would be a productive exercise), but finishes in a fourth
the time when used on a similar string with 1000000 0s.  Be aware,
however, that, when this construct is followed by a
quantifier, it currently triggers a warning message under
the 0 pragma or 0 switch saying it
0.

effect may be achieved by negative look-ahead, as in 0.
This was only 4 times slower on a string with 1000000 0s.

in many situations where on the first sight a simple 0 looks like
the correct solution.  Suppose we parse text with comments being delimited
by 0 followed by some optional (horizontal) whitespace.  Contrary to
its appearance, 0 0 the correct subexpression to match
the comment delimiter, because it may "give up" some whitespace if
the remainder of the pattern can be made to match that way.  The correct
answer is either one of these:

one of these:

the above specification of comments.

"possessive matching".

to inside of one of these constructs. The following equivalences apply:

removal in a future version of Perl. Their usage in production code should
be noted to avoid problems during upgrades.

otherwise stated the ARG argument is optional; in some cases, it is
forbidden.

has the special behaviour that when executed it sets the current package's
0 and 0 variables. When doing so the following
rules apply:

verb pattern, if the verb was involved in the failure of the match. If the
ARG part of the pattern was omitted, then 0 will be set to the
name of the last 0 pattern executed, or to TRUE if there was
none. Also, the 0 variable will be set to FALSE.

the 0 variable will be set to the name of the last
0 pattern executed.  See the explanation for the
0 verb below for more details.

and most other regex-related variables. They are not local to a scope, nor
readonly, but instead are volatile package variables similar to 0.
Use 0 to localize changes to them to a specific scope if necessary.

argument, then 0 and 0 are not touched at all.

0 0

when backtracked into on failure. Consider the pattern 0,
where A and B are complex patterns. Until the 0 verb is reached,
A may backtrack as necessary to match. Once it is reached, matching
continues in B, which may also backtrack as necessary; however, should B
not match, then no further backtracking will take place, and the pattern
will fail outright at the current starting position.

pattern (without actually matching any of them).

at each matching starting point like so:

control backtracking. In some cases, the use of 0 can be
replaced with a  with no functional difference; however,
0 can be used to handle cases that cannot be expressed using a
 alone.

0

failure it also signifies that whatever text that was matched leading up
to the 0 pattern being executed cannot be part of 0 match
of this pattern. This effectively means that the regex engine "skips" forward
to this position on failure and tries to match again, (assuming that
there is sufficient room to match).

0 was encountered while matching, then it is that position
which is used as the "skip point". If no 0 of that name was
encountered, then the 0 operator has no effect. When used
without a name the "skip point" is where the match point was when
executing the (*SKIP) pattern.

is twice as long:

executed, the next starting point will be where the cursor was when the
0 was executed.

0 0 0

when a certain part of the pattern has been successfully matched. This
mark may be given a name. A later 0 pattern will then skip
forward to that point if backtracked into on failure. Any number of
0 patterns are allowed, and the NAME portion may be duplicated.

can be used to "label" a pattern branch, so that after matching, the
program can determine which branches of the pattern were involved in the
match.

name of the most recently executed 0 that was involved
in the match.

without using a separate capture group for each branch, which in turn
can result in a performance improvement, as perl cannot optimize
0 as efficiently as something like
0.

failing the match and has provided its own name to use, the 0
variable will be set to the name of the most recently executed
0.

0, this verb always matches, and when backtracked into on
failure, it causes the regex engine to try the next alternation in the
innermost enclosing group (capturing or otherwise).

alternation operator (0) can be used to create what is essentially a
pattern-based if/then/else block:

it acts exactly like the 0 operator.

backtrack and try C; but the 0 verb will simply fail.

0

zero-width pattern similar to 0, except that when backtracked
into on failure it causes the match to fail outright. No further attempts
to find a valid match by advancing the start pointer will occur again.
For example,

does not match, the regex engine will not try any further matching on the
rest of the string.

0 0

engine to backtrack. It is equivalent to 0, but easier to read. In
fact, 0 gets optimised into 0 internally.

0

for production code.

the point at which the 0 pattern was encountered, regardless of
whether there is actually more to match in the string. When inside of a
nested pattern, such as recursion, or in a subpattern dynamically generated
via 0, only the innermost pattern is ended immediately.

marked as ended at the point at which the 0 was encountered.
For instance:

be set. If another branch in the inner parentheses was matched, such as in the
string 'ACDE', then the 0 and 0 would have to be matched as well.

0 0

expression behavior.  For a more rigorous (and complicated) view of
the rules involved in selecting a match among possible alternatives,
see 0.

notion called 0, which is currently used (when needed)
by all regular non-possessive expression quantifiers, namely 0, 0, 0,
0, 0, and 0.  Backtracking is often optimized
internally, but the general principle outlined here is valid.

match, not just part of it.  So if the beginning of a pattern containing a
quantifier succeeds in a way that causes later parts in the pattern to
fail, the matching engine backs up and recalculates the beginning
part--that's why it's called backtracking.

word following "foo" in the string "Food is on the foo table.":

finds a possible match right at the beginning of the string, and loads up
 with "Foo".  However, as soon as the matching engine sees that there's
no whitespace following the "Foo" that it had saved in , it realizes its
mistake and starts over again one character after where it had the
tentative match.  This time it goes all the way until the next occurrence
of "foo". The complete regular expression matches this time, and you get
the expected output of "table follows foo."

everything between "foo" and "bar".  Initially, you write something
like this:

0 "foo" and the 0 "bar".  Here it's more effective
to use minimal matching to make sure you get the text between a "foo"
and the first "bar" thereafter.

of a string, and you also want to keep the preceding part of the match.
So you write this:

whole string. As 0 can match on an empty string the complete
regular expression matched successfully.

regular expression is merely a set of assertions that gives a definition
of success.  There may be 0, 1, or several different ways that the
definition might succeed against a particular string.  And if there are
multiple ways it might succeed, you need to understand backtracking to
know which variety of success you will achieve.

trickier.  Imagine you'd like to find a sequence of non-digits not
followed by "123".  You might try to write that as

claims that there is no 123 in the string.  Here's a clearer picture of
why that pattern matches, contrary to popular expectations:

general purpose version of test 1.  The important difference between
them is that test 3 contains a quantifier (0) and so can use
backtracking, whereas test 1 will not.  What's happening is
that you've asked "Is it true that at the start of , following 0 or more
non-digits, you have something that's not 123?"  If the pattern matcher had
let 0 expand to "ABC", this would have caused the whole pattern to
fail.

try to match 0 with "123", which fails.  But because
a quantifier (0) has been used in the regular expression, the
search engine can backtrack and retry the match differently
in the hope of matching the complete regular expression.

standard pattern back-off-and-retry and lets 0 expand to just "AB" this
time.  Now there's indeed something following "AB" that is not
"123".  It's "C123", which suffices.

We'll say that the first part in  must be followed both by a digit
and by something that's not "123".  Remember that the look-aheads
are zero-width expressions--they only look, but don't consume any
of the string in their match.  So rewriting this way produces what
you'd expect; that is, case 5 will fail, but case 6 succeeds:

they're ANDed together, just as you'd use any built-in assertions:  0
matches only if you're at the beginning of the line AND the end of the
line simultaneously.  The deeper underlying truth is that juxtaposition in
regular expressions always means AND, except when you write an explicit OR
using the vertical bar.  0 means match "a" AND (then) match "b",
although the attempted matches are made at different positions because "a"
is not a zero-width assertion, but a one-width assertion.

exponential time to solve because of the immense number of possible
ways they can use backtracking to try for a match.  For example, without
internal optimizations done by the regular expression engine, this will
take a painfully long time to run:

to 0 through 5 matches, then it would take forever--or until you ran
out of stack space.  Moreover, these internal optimizations are not
always applicable.  For example, if you put 0 instead of 0
on the external group, no current optimization is applicable, and the
match takes a long time to finish.

"independent group",
which does not backtrack (see 0).  Note also that
zero-length look-ahead/look-behind assertions will not backtrack to make
the tail match, since they are in "logical" context: only
whether they match is considered relevant.  For an example
where side-effects of look-ahead 0 have influenced the
following match, see 0.

0 0 0

routines, here are the pattern-matching rules not described above.

with a special meaning described here or above.  You can cause
characters that normally function as metacharacters to be interpreted
literally by prefixing them with a "\" (e.g., "\." matches a ".", not any
character; "\\" matches a "\"). This escape mechanism is also required
for the character used as the pattern delimiter.

string, so the pattern 0 would match "blurfl" in the target
string.

in 0, which will match any character from the list.  If the
first character after the "[" is "^", the class matches any character not
in the list.  Within a list, the "-" character specifies a
range, so that 0 represents all characters between "a" and "z",
inclusive.  If you want either "-" or "]" itself to be a member of a
class, put it at the start of the list (possibly after a "^"), or
escape it with a backslash.  "-" is also taken literally when it is
at the end of the list, just before the closing "]".  (The
following all specify the same class of three characters: 0,
0, and 0.  All are different from 0, which
specifies a class containing twenty-six characters, even on EBCDIC-based
character sets.)  Also, if you try to use the character
classes 0, 0, 0, 0, 0, or 0 as endpoints of
a range, the "-" is understood literally.

character sets--and even within character sets they may cause results
you probably didn't expect.  A sound principle is to use only ranges
that begin from and end at either alphabetics of equal case ([a-e],
[A-E]), or digits ([0-9]).  Anything else is unsafe.  If in doubt,
spell out the character sets in full.

used in C: "\n" matches a newline, "\t" a tab, "\r" a carriage return,
"\f" a form feed, etc.  More generally, \0, where 0 is a string
of three octal digits, matches the character whose coded character set value
is 0.  Similarly, \x0, where 0 are hexadecimal digits,
matches the character whose ordinal is 0. The expression \c0
matches the character control-0.  Finally, the "." metacharacter
matches any character except "\n" (unless you use 0).

separate them, so that 0 will match any of "fee", "fie",
or "foe" in the target string (as would 0).  The
first alternative includes everything from the last pattern delimiter
("(", "(?:", etc. or the beginning of the pattern) up to the first "|", and
the last alternative contains everything from the last "|" to the next
closing pattern delimiter.  That's why it's common practice to include
alternatives in parentheses: to minimize confusion about where they
start and end.

alternative found for which the entire expression matches, is the one that
is chosen. This means that alternatives are not necessarily greedy. For
example: when matching 0 against "barefoot", only the "foo"
part will match, as that is the first alternative tried, and it successfully
matches the target string. (This might not seem important, but it is
important when you are capturing matched text using parentheses.)

so if you write 0 you're really only matching 0.

by enclosing them in parentheses, and you may refer back to the
0th subpattern later in the pattern using the metacharacter
\0 or \g0.  Subpatterns are numbered based on the left to right order
of their opening parenthesis.  A backreference matches whatever
actually matched the subpattern in the string being examined, not
the rules for that subpattern.  Therefore, 0 will
match "0x1234 0x4321", but not "0x1234 01234", because subpattern
1 matched "0x", even though the rule 0 could potentially match
the leading 0 in the second number.

shocking the
0 addicts, but it's a dirty habit to get into.  That's because in
PerlThink, the righthand side of an 0 is a double-quoted string.  0 in
the usual double-quoted string means a control-A.  The customary Unix
meaning of 0 is kludged in for 0.  However, if you get into the habit
of doing that, you get yourself into trouble if you then add an 0
modifier.

0.  The operation of interpolation should not be confused
with the operation of matching a backreference.  Certainly they mean two
different things on the 0 side of the 0.

with most other power tools, power comes together with the ability
to wreak havoc.

loops using regular expressions, with something as innocuous as:

in the string is not moved by the match, 0 would match again and again
because of the 0 quantifier.  Another common way to create a similar cycle
is with the looping modifier 0.  The rules for this are different for lower-level
loops given by the greedy quantifiers 0, and for higher-level
ones like the 0 modifier or  operator.

broken) when Perl detects that a repeated expression matched a
zero-length substring.   Thus

iteration of the outermost 0 matches a zero-length string, it stops
the 0.

whether the last match was zero-length.  To break the loop, the following
match after a zero-length match is prohibited to have a length of zero.
This prohibition interacts with backtracking (see 0),
and so the 0 match is chosen if the 0 match is of
zero length.

match given by non-greedy 0 is the zero-length match, and the 0 match is what is matched by 0.  Thus zero-length matches
alternate with one-character-long matches.

position one notch further in the string.

the matched string, and is reset by each assignment to .
Zero-length matches at the end of the previous match are ignored
during 0.

before (such as 0 or 0) could match at most one substring
at the given position of the input string.  However, in a typical regular
expression these elementary pieces are combined into more complicated
patterns using combining operators 0, 0, 0 etc.
(in these examples 0 and 0 are regular subexpressions).

if we match a regular expression 0 against 0, will it match
substring 0 or 0?  One way to describe which substring is
actually matched is the concept of backtracking (see 0).
However, this description is too low-level and makes you think
in terms of a particular implementation.

substrings which may be matched by the given regular expression can be
sorted from the "best" match to the "worst" match, and it is the "best"
match which is chosen.  This substitutes the question of "what is chosen?"
by the question of "which matches are better, and which are worse?".

one match at a given position is possible.  This section describes the
notion of better/worse for combining operators.  In the description
below 0 and 0 are regular subexpressions.

substrings which can be matched by 0, 0 and 0 are substrings
which can be matched by 0.

match than 0.

0 is a better match for 0 than 0.

two matches for 0.

0 has capturing parentheses, and backreferences are used somewhere
else in the whole regular expression.)

only whether or not 0 can match is important.

the result of EXPR, or the pattern contained by capture group PARNO.

already determined.  The ordering of the matches is the same as for the
chosen subexpression.

One more rule is needed to understand how a match is determined for the
whole regular expression: a match at an earlier position is always better
than a match at a later position.

is not for the faint of heart, as they have to plug in at the C level.  See
0 for more details.

way to extend the functionality of the RE engine, by substituting one
pattern for another.

matches at a boundary between whitespace characters and non-whitespace
characters.  Note that C<(?=\S)(?<!\S)|(?!\S)(?<=\S)> matches exactly
at these positions, so we want to have each 0 in the place of the
more complicated version.  We can create a module 0 to do
this:

expressions, i.e., those without any runtime variable interpolations.
As documented in 0, this conversion will work only over
literal parts of regular expressions.  For 0 the variable
part of this regular expression needs to be converted explicitly
(but only if the special meaning of 0 should be enabled inside ):

to the regex syntax. While Perl programmers are encouraged to use the
Perl-specific syntax, the following are also accepted:

in Unicode rules.  See 0 under 0 above.

and utterly opaque.  The wandering prose riddled with jargon is
hard to fathom in several places.

from the reference content.

by O'Reilly and Associates. 

=encoding utf8

regular expression engines than the default one.

following format:

the appropriate structure, so that when it needs to be used Perl can find
the right routines to do so.

to an integer which (when casted appropriately) resolves to one of these
structures. When compiling, the 0 method is executed, and the
resulting regexp structure's engine field is expected to point back at
the same structure.

to provide an extra argument to the routine holding a pointer back to
the interpreter that is executing the regexp. So under threading all
routines get an extra argument.

return a pointer to a prepared 0 structure that can perform
the match. See 0 below for an explanation of
the individual fields in the REGEXP struct.

pattern. previous versions of perl would pass two 0 indicating
the start and end of the stringified pattern, the following snippet can
be used to get the old parameters:

an engine that does something with an array () or with the non-stringified form of a compiled regular
expression (). perl's own engine will always
stringify everything using the snippet above but that doesn't mean
other engines have to.

0 flags the regex was compiled with. It also contains
additional info such as whether 0 is in effect.

routine. The regex engine does not need to know whether any of these
are set as those flags should only affect what perl does with the
pattern and its match variables, not how it gets compiled and
executed.

already had effect (noted below where applicable). However most of
their effect occurs after the comp callback has run in routines that
read the  field which it populates.

compilation, although the regex engine might want to add or delete
some of them to invoke or disable some special behavior in perl. The
flags along with any special behavior they cause are documented below:

0 by 0 which will treat the subject string
as a multi-line string.

tokenizer in some cases.

in this field.  This is still experimental and subject to change, but
the current interface returns the rules by use of the in-line function
0.  The only currently documented
value returned from it is REGEX_LOCALE_CHARSET, which is set if
0 is in effect. If present in 
0 will use the locale dependent definition of whitespace under
when RXf_SKIPWHITE or RXf_WHITE are in effect. Under ASCII whitespace
is defined as per 0, and by the internal
macros 0 under UTF-8 and 0 under 0.

compilation. The perl engine for instance may upgrade non-UTF-8
strings to UTF-8 if the pattern includes constructs such as 0
that can only match Unicode values.

really means 0, see 0), perl will
set this flag. The regex engine can then check for it and set the
SKIPWHITE and WHITE extflags. To do this the perl engine does:

the 0 operator.

whitespace from the start of the subject string before it's operated
on. What is considered whitespace depends on whether the subject is a
UTF-8 string and whether the 0 flag is set.

0 under the perl engine.

(0), even under 0, see 0. Of course a
different regex engine might want to use the same optimizations
with a different syntax.

without invoking the regex engine. The definition of whitespace varies
depending on whether the target string is a UTF-8 string and on
whether RXf_PMf_LOCALE is set.

characters. The definition of character varies depending on whether
the target string is a UTF-8 string.

makes 0 much faster than it would otherwise be. It's even
faster than 0.

or possibly whether the regex engine should not be run because the
pattern can't match. This is called as appropriate by the core
depending on the values of the extflags member of the regexp
structure.

by 0 for optimising matches.

can release any resources pointed to by the 0 member of the
regexp structure. This is only responsible for freeing private data;
perl will handle releasing anything else contained in the regexp structure.

equivalents, ${^PREMATCH}, ${^POSTMATCH} and $^{MATCH}, as well as the
numbered capture groups (0, 0, ...).

for 0, 0 for 0 and so forth.

names with an additional 0 callback for efficiency. However
named capture variables are currently not tied internally but
implemented via magic.

to return, the scalar is passed as an argument rather than being
returned from the function because when it's called perl already has a
scalar to store the value, creating another one would be
redundant. The scalar can be set with 0, 0 and
friends, see 0.

taint mode (see 0). See the 0
function in 0 for how to untaint capture variables if
that's something you'd like your engine to do as well.

that is to be used as the new value. It's up to the engine to make
sure this is used as the new value (or reject it).

variables, to do this in another engine use the following callback
(copied from 0):

like it would modify a numbered capture variable. This is because the
STORE callback will not be called if perl can determine that it
doesn't have to modify the value. This is exactly how tied variables
behave in the same situation:

the transliteration won't actually execute and the program won't
0. This is different to how 5.8 and earlier versions behaved
since the capture variables were READONLY variables then, now they'll
just die when assigned to in the default engine.

for this so that perl doesn't have to do a FETCH and run 0 on
the result, since the length is (in perl's case) known from an offset
stored in  this is much more efficient:

0 does with
0.

utility functions in 0.

FETCH, STORE, DELETE, CLEAR, EXISTS and SCALAR 0 callbacks
would be on changes to 0 and 0 and 0 in the
same cases as FIRSTKEY and NEXTKEY.

operations the callbacks should respond to, the following flags are
currently defined:

0 or 0, if any:

0, if any. The first two will be combined with
0 or 0.

via 0. The methods in that package will call
back into these functions. However the usage of
0). It is recommended that engines change this to their package
name for identification regardless of whether they implement methods
on the object.

0 package in its 0.  should always
be true regardless of what engine is being used.

package as a normal object.

the 0 macro, see 0.

can be used by multiple threads. This routine is expected to handle the
duplication of any private data pointed to by the 0 member of
the regexp structure.  It will be called with the preconstructed new
regexp structure as an argument, the 0 member will point at
the 0 private structure, and it is this routine's responsibility to
construct a copy and return a pointer to it (which perl will then use to
overwrite the field as passed to this routine.)

modify the final structure if it really must.

correctly build such a structure in their 0 routine.

to properly work with the regular expression. It includes data about
optimisations that perl can use to determine if the regex engine should
really be used, and various other control info that is needed to properly
execute patterns in various contexts such as is the pattern anchored in
some way, or what flags were used during the compile, or whether the
program contains special constructs that perl needs to be aware of.

use of the regex engine that compiled the pattern. These are the
0 and 0 members. 0 is a void pointer to
an arbitrary structure whose use and management is the responsibility
of the compiling engine. perl will never modify either of these
values.

to the subroutines that are to be used for performing a match. It
is the compiling routine's responsibility to populate this field before
returning the regexp object.

0, perl's own set of callbacks can be accessed in the struct
pointed to by 0.

with, this will normally be set to the value of the flags parameter by
the 0 callback. See the 0 documentation for
valid flags.

prune the search space by not bothering to match any closer to the end of a
string than would allow a match. For instance there is no point in even
starting the regex engine if the minlen is 10 but the string is only 5
characters long. There is no way that the pattern can match.

in $& after a match.

following pattern:

required to match but is not actually included in the matched content. This
distinction is particularly important as the substitution logic uses the
0 to tell whether it can do in-place substitution which can result in
considerable speedup.

is currently only used internally by perl's engine for but might be
used in the future for all engines for optimisations.

in the pattern, which was the last open paren to be entered, and which was
the last close paren to be entered.

this is the same as 0 unless the engine chose to modify one of them.

0 structure (see 0) but a custom
engine should use something else.

matched which correspond to the 0 and 0, 0 etc. captures, the
0 struct is defined as follows:

capture group did not match.  represents 0 (or
0 under 0) and  matches 0 where
0.

was compiled and 0 its length. When a new pattern is to be
compiled (such as inside a loop) the internal 0 operator
checks whether the last compiled 0's 0 and 0
are equivalent to the new one, and if so uses the old pattern instead
of compiling a new one.

offsets. The keys are the names of the buffers the values are dualvars,
with the IV slot holding the number of buffers with the given name and the
pv being an embedded array of I32.  The values may also be contained
independently in the data array in cases where named backreferences are
used.

offset from the start of the pattern, and the longest string that must
occur at a floating offset from the start of the pattern. Used to do
Fast-Boyer-Moore searches on the string to find out if its worth using
the regex engine at all, and if so where in the string to search.

stores 0 in the case of 0.

for inline modifiers, it's probably best to have 0 stringify to
the supplied pattern, note that this will create undesired patterns in
cases such as:

engine understand a construct like 0.

purposes when embedding compiled regexes into larger patterns with 0.

regexp is automatically freed by a call to pregfree. This should be set to 1 in
each engine's 0 routine.

Bjarmason.

the same terms as Perl itself.

=encoding utf8

is found in 0.

explaining the role of the backslash, it lists all the sequences that have
a special meaning in Perl regular expressions (in alphabetical order),
then describes each of them.

purpose of this document is to have a quick reference guide describing all
backslash and escape sequences.

it either takes away the special meaning of the character following it
(for instance, 0 matches a vertical bar, it's not an alternation),
or it is the start of a backslash or escape sequence.

following the backslash is an ASCII punctuation (non-word) character (that is,
anything that is not a letter, digit, or underscore), then the backslash just
takes away any special meaning of the character following it.

then the sequence may be special; if so, it's listed below. A few letters have
not been used yet, so escaping them with a backslash doesn't change them to be
special.  A future version of Perl may assign a special meaning to them, so if
you have warnings turned on, Perl issues a warning if you use such a
sequence.  [1].

punctuation character following the backslash, not now, and not in a future
version of Perl 5. So it is safe to put a backslash in front of a non-word
character.

you have to escape the backslash with a backslash: 0 matches a single
backslash.

delimiter of your pattern (which you probably shouldn't do for readability
reasons), you have to escape the delimiter if you want to match
it. Perl won't warn then. See also 0.

as 0

table shows them, along with their ASCII code points (in decimal and hex),
their ASCII name, the control escape on ASCII platforms and a short
description.  (For EBCDIC platforms, see 0.)

character class, 0 is a word/non-word boundary.

OS's native newline character when reading from or writing to text files.

determines the value of the construct.  For example the value of 0 is
0, and the value of 0 is 0, etc.
The gory details are in 0.  A complete
list of what 0, etc. means for ASCII and EBCDIC platforms is in
0.

string) is not valid.  The backslash must be followed by another character.
That is, C<\c\0 means C< . '0 for all characters 0.

0 or 0, see 0.

value.  Use the
0 construct to specify a character by either of these values.
Certain sequences of characters also have names.

between the curly braces.  In this case, you have to 0, where 0 is a number in hexadecimal that gives the
code point that Unicode has assigned to the desired character.  It is
customary but not required to use leading zeros to pad the number to 4
digits.  Thus 0 means 0, and you will
rarely see it written without the two leading zeros.  0 means
"A" even on EBCDIC machines (where the ordinal value of "A" is not 0x41).

sequences.  For details, see 0.

C<\N{U+0.0.
The 0 means any number of these 0s separated by dots.
This represents the sequence formed by the characters.  This is an internal
form only, subject to change, and you should not try to use it yourself.)

or numbered character is considered a character without special
meaning by the regex engine, and will match "as is".

its code point specified in octal notation.

represent one or more octal digits.  It can be used for any Unicode character.

available in all Perls.  That form consists of a backslash followed by three
octal digits.  One problem with this form is that it can look exactly like an
old-style backreference (see
0
below.)  You can avoid this by making the first of the three digits always a
zero, but that makes \077 the largest code point specifiable.

interpreted as an octal escape, sometimes with a warning, and because of some
bugs, sometimes with surprising results.  Also, if you are creating a regex
out of smaller snippets concatenated together, and you use fewer than three
digits, the beginning of one snippet may be interpreted as adding digits to the
ending of the snippet before it.  See 0 for more
discussion and examples of the snippet problem.

a character without special meaning by the regex engine, and will match
"as is".

safe to use for code points through \077 when you use exactly three digits to
specify them.

potentially clash with old-style backreferences.  (see 0
below).  They both consist of a backslash followed by numbers.  So Perl has to
use heuristics to determine whether it is a backreference or an octal escape.
Perl uses the following rules to disambiguate:

has seen N capture groups, Perl considers this a backreference.  Otherwise,
it considers it an octal escape. If N has more than three digits, Perl
takes only the first three for the octal escape; the rest are matched as is.

form.  You can the force an octal interpretation always by using the 0
form, or for numbers up through \077 (= 63 decimal), by using three digits,
beginning with a "0".

with the same thing, 0.  This is followed by either exactly two hexadecimal
digits forming a number, or a hexadecimal number of arbitrary length surrounded
by curly braces. The hexadecimal number is the code point of the character you
want to express.

character without special meaning by the regex engine, and will match
"as is".

or characters following them. 0 will lowercase the character following
it, while 0 will uppercase (or, more accurately, titlecase) the
character following it. They provide functionality similar to the
functions 0 and 0.

0 or 0, which will lowercase/uppercase all characters following
them, until either the end of the pattern or the next occurrence of
0, whichever comes first. They provide functionality similar to what
the functions 0 and 0 provide.

or the end of the pattern. 0 adds a backslash to any character that
isn't a letter, digit, or underscore. This ensures that any character
between 0 and 0 shall be matched literally, not interpreted
as a metacharacter by the regex engine.

the character classes are written as a backslash sequence. We will briefly
discuss those here; full details of character classes can be found in
0.

(letters, digits, Unicode marks, and connector punctuation (like the
underscore)).  0 is a character class that matches any decimal
digit, while the character class 0 matches any whitespace character.
New in perl 5.10.0 are the classes 0 and 0 which match horizontal
and vertical whitespace characters.

depending on various pragma and regular expression modifiers.  It is
possible to restrict the match to the ASCII range by using the 0
regular expression modifier.  See 0.

character classes that match, respectively, any character that isn't a
word character, digit, whitespace, horizontal whitespace, or vertical
whitespace.

match a character that matches the given Unicode property; properties
include things like "letter", or "thai character". Capitalizing the
sequence to 0 and 0 make the sequence match a character
that doesn't match the given Unicode property. For more details, see
0 and
0.

to the part of the source string that was matched, and match exactly the
same thing. There are three ways of referring to such 0:
absolutely, relatively, and by name.

is a positive (unsigned) decimal number of any length is an absolute reference
to a capturing group.

been matched by that set of parentheses.  Thus 0 refers to the first
capture group in the regex.

which avoids ambiguity when building a regex by concatenating shorter
strings.  Otherwise if you had a regex 0, and 0 contained
0, and 0 contained 0, you would get 0 which is
probably not what you intended.

least 0 capturing groups, or else 0 is considered an octal escape
(but something like 0 is the same as 0; that is, the octal escape
0 followed by a literal digit 0).

be written as C<\g{-0.)  It refers to the 0th group before the
C<\g{-0.

patterns with references that can be interpolated in larger patterns,
even if the larger pattern also contains capture groups.

named capture group, dispensing completely with having to think about capture
buffer positions.

written as 0,  or 0.

hyphen.

match parts of the substring. There are six assertions that are written as
backslash sequences.

isn't used, then 0 is equivalent to 0. However, if the 0
modifier is used, then 0 matches internal newlines, but the meaning
of 0 isn't changed by the 0 modifier. 0 matches at the beginning
of the string regardless whether the 0 modifier is used.

used, then 0 is equivalent to 0; that is, it matches at the
end of the string, or one before the newline at the end of the string. If the
0 modifier is used, then 0 matches at internal newlines, but the
meaning of 0 isn't changed by the 0 modifier. 0 matches at
the end of the string (or just before a trailing newline) regardless whether
the 0 modifier is used.

newline. 0 matches at the end of the string only, regardless of the
modifiers used, and not just before a newline.  It is how to anchor the
match to the true end of the string under all conditions.

0 modifier is used and the match is done in scalar context, Perl
remembers where in the source string the last match ended, and the next time,
it will start the match from where it ended the previous time.

or the beginning of that string if there was no previous match.

matches at any place between characters where 0 doesn't match. 0
and 0 assume there's a non-word character before the beginning and after
the end of the source string; so 0 will match at the beginning (or end)
of the source string if the source string begins (or ends) with a word
character. Otherwise, 0 will match.

beginning of a line.  It can't, because for there to be a boundary before
the non-word "=", there must be a word character immediately previous.
All boundary determinations look for word characters alone, not for
non-words characters nor for string ends.  It may help to understand how
<\b> and <\B> work by equating them as follows:

categories above. These are:

in UTF-8 format, and the character to be matched is a multi-octet character.
0 was introduced in perl 5.6.  This is very dangerous, because it violates
the logical character abstraction and can cause UTF-8 sequences to become malformed.

not included in 0, and will not be replaced if the pattern is
used in a substitution. This lets you write 0
instead of 0 or C<s/(?<=PAT1) PAT2/REPL/x>.

that is 0 a newline.  It is a short-hand for writing 0, and is
identical to the 0 metasymbol, except under the 0 flag, which changes
the meaning of 0, but not 0.

0.

0

linebreak sequence by Unicode. This includes all characters matched by
0 (vertical whitespace), and the multi character sequence 0
(carriage return followed by a line feed, sometimes called the network
newline; it's the end of line sequence used in Microsoft text files opened
in binary mode). 0 is equivalent to . Since
0 can match a sequence of more than one character, it cannot be put
inside a bracketed character class; 0 is an error; use 0
instead.  0 was introduced in perl 5.10.0.

and more importantly because Unicode recommends such a regular expression
metacharacter, and suggests 0 as its notation.

0

would consider a single character.  As an example, consider a G with some sort
of diacritic mark, such as an arrow.  There is no such single character in
Unicode, but one can be composed by using a G followed by a Unicode "COMBINING
UPWARDS ARROW BELOW", and would be displayed by Unicode-aware software as if it
were a single character.

=encoding utf8

0

is found in 0.

classes in Perl regular expressions.

in such a way that one character of the set is matched.
It's important to remember that: matching a character class
consumes exactly one character in the source string. (The source
string is the string the regular expression is matched against.)

expressions: the dot, backslash sequences, and the form enclosed in square
brackets.  Keep in mind, though, that often the term "character class" is used
to mean just the bracketed form.  Certainly, most Perl documentation does that.

the most well-known character class. By default, a dot matches any
character, except for the newline. The default can be changed to
add matching the newline by using the 0 modifier: either
for the entire regular expression with the 0 modifier, or
locally with 0.  (The experimental 0 backslash sequence, described
below, matches any character except newline without regard to the
0 modifier.)

0 0 0 0 0 0 0 0
0 0 0 0 0
0 0

backslash.  Perl ascribes special meaning to many such sequences, and some of
these are character classes.  That is, they match a single character each,
provided that the character belongs to the specific set of characters defined
by the sequence.

are discussed in more detail below.  (For the backslash sequences that aren't
character classes, see 0.)

If the 0 modifier in effect, it matches [0-9].  Otherwise, it
matches anything that is matched by 0, which includes [0-9].
(An unlikely possible exception is that under locale matching rules, the
current locale might not have [0-9] matched by 0, and/or might match
other characters whose code point is less than 256.  Such a locale
definition would be in violation of the C language standard, but Perl
doesn't currently assume anything in regard to this.)

only matches the digits '0' - '9', but also Arabic, Devanagari, and
digits from other languages.  This may cause some confusion, and some
security issues.

have different values.  For example, BENGALI DIGIT FOUR (U+09EA) looks
very much like an ASCII DIGIT EIGHT (U+0038).  An application that
is expecting only the ASCII digits might be misled, or if the match is
0, the matched string might contain a mixture of digits from
different writing systems that look like they signify a number different
than they actually do. 0 can be used to safely
calculate the value, returning 0 if the input string contains
such a mixture.

modifier) is 0, or synonymously,
0.  Starting with Unicode version 4.1, this
is the same set of characters matched by 0.
But Unicode also has a different property with a similar name,
0, which matches a completely different set of
characters.  These characters are things such as 0
or subscripts, or are from writing systems that lack all ten digits.

that can safely be used with "normal" big-endian positional decimal
syntax, where, for example 123 means one 'hundred', plus two 'tens',
plus three 'ones'.  This positional notation does not necessarily apply
to characters that match the other type of "digit",
0, and so 0 doesn't match them.

used in old-style Tamil numbers in which they would appear no more than
one in a row, separated by characters that mean "times 10", "times 100",
etc.  (See 0.)

decimal digit) or a connecting punctuation character, such as an
underscore ("_").  It does not match a whole word.  To match a whole
word, use 0.  This isn't the same thing as matching an English word, but
in the ASCII range it is the same as a string of Perl-identifier
characters.

it matches Thai letters, Greek letters, etc.  This includes connector
punctuation (like the underscore) which connect two words together, or
diacritics, such as a 0 and the modifier letters, which
are generally used to add auxiliary markings to letters.

the locale considers to be alphanumeric.

characters.  See 0.

language identifiers beyond the ASCII range, you may wish to instead use the
more customized Unicode properties, "ID_Start", ID_Continue", "XID_Start", and
"XID_Continue".  See 0.

the newline, the form feed, the carriage return, and the space.  (Note
that it doesn't match the vertical tab, 0 on ASCII platforms.)

in the table below.

this is likely to include the vertical space, unlike non-locale 0
matching.

table below.

Note that this list doesn't include the non-breaking space.

this includes the space and tab characters and several others
listed in the table below.  0 matches any character
not considered horizontal whitespace.

this includes the carriage return and line feed characters (newline)
plus several other characters, all listed in the table below.
0 matches any character not considered vertical whitespace.

rules. It's not a character class, as it can match a multi-character
sequence. Therefore, it cannot be used inside a bracketed character
class; use 0 instead (vertical whitespace).
Details are discussed in 0.

the same characters, without regard to other factors, such as whether the
source string is in UTF-8 format.

For example, the vertical tab (0) is not matched by 0, it is
however considered vertical whitespace.

0, 0 and 0 as of Unicode 6.0.

the second column gives the (Unicode) name. The third column indicates
by which class(es) the character is matched (assuming no locale or EBCDIC code
page is in effect that changes the 0 matching).

on the rules in effect.  See
0.

character that is not a newline. The difference is that 0 is not influenced
by the 0 regular expression modifier (see 0 above).  Note
that the form 0 may mean something completely different.  When the
0 is a 0, it means to match a non-newline
character that many times.  For example, 0 means to match 3
non-newlines; 0 means to match 5 or more non-newlines.  But if 0
is not a legal quantifier, it is presumed to be a named character.  See
0 for those.  For example, none of 0, 0, and
0 contain legal quantifiers, so Perl will try to find characters whose
names are respectively 0, 0, and 0.

Unicode properties.  One letter property names can be used in the 0 form,
with the property name following the 0, otherwise, braces are required.
When using braces, there is a single form, which is just the property name
enclosed in the braces, and a compound form which looks like 0,
which means to match if the property "name" for the character has that particular
"value".
For instance, a match for a number can be written as 0 or as
0, or as 0.
Lowercase letters are matched by the property 0 which
has as short form 0. They need the braces, so are written as 0 or
0, or 0
(the underscores are optional).
0 is valid, but means something different.
It matches a two character string: a letter (Unicode property 0),
followed by a lowercase 0.

a Unicode property will force the regular expression into using Unicode
rules.

That is, adding a 0 regular expression modifier does not change what
they match.  There are two sets that are affected.  The first set is
0,
0,
and 0,
all of which match 0 under 0 matching.
The second set is
0,
0,
and 0,
all of which match 0 under 0 matching.
(The difference between these sets is that some things, such as Roman
Numerals, come in both upper and lower case so they are 0, but
aren't considered to be letters, so they aren't 0s. They're
actually 0s.)
This set also includes its subsets 0 and 0, both
of which under 0 matching match 0; for a
complete list of possible properties, see
0,
which notes all forms that have 0 differences.
It is also possible to define your own properties. This is discussed in
0.

complete numbers or words. To match a number (that consists of digits),
use 0; to match a word, use 0.  But be aware of the security
considerations in doing so, as mentioned above.

is the bracketed character class.  In its simplest form, it lists the characters
that may be matched, surrounded by square brackets, like this: 0.
This matches one of 0, 0, 0, 0 or 0.  Like the other
character classes, exactly one character is matched.* To match
a longer string consisting of characters mentioned in the character
class, follow the character class with a 0.  For
instance, 0 matches one or more lowercase English vowels.

effect; it's considered to be in the set only once.

single character.  When the class is to match caselessely under 0
matching rules, and a character inside the class matches a
multiple-character sequence caselessly under Unicode rules, the class
(when not 0) will also match that sequence.  For
example, Unicode says that the letter 0
should match the sequence 0 under 0 rules.  Thus,

is, characters that carry a special meaning like 0, 0, or 0) lose
their special meaning and can be used inside a character class without
the need to escape them. For instance, 0 matches either an opening
parenthesis, or a closing parenthesis, and the parens inside the character
class don't group or capture.

0, 0, 0, 0 and 0, and are discussed below. They can be
escaped with a backslash, although this is sometimes not needed, in which
case the backslash may be omitted.

outside the character class, 0 is an assertion indicating a point
that does not have either two word characters or two non-word characters
on either side, inside a bracketed character class, 0 matches a
backspace character.

0,
0,
0,
0,
0,
C<\N{0,
C<\N{U+0,
0,
0,
and
0
are also special and have the same meanings as they do outside a
bracketed character class.  (However, inside a bracketed character
class, if C<\N{0 expands to a sequence of characters, only the first
one in the sequence is used, with a warning.)

number.

POSIX character class (see 0 below). It normally does
not need escaping.

0 below), or it signals the end of the bracketed
character class.  If you want to include a 0 in the set of characters, you
must generally escape it.

character is a caret) character of a bracketed character class, it
does not denote the end of the class (as you cannot have an empty class)
and is considered part of the set of characters that can be matched without
escaping.

of listing all characters in the range, one may use the hyphen (0).
If inside a bracketed character class you have two characters separated
by a hyphen, it's treated as if all characters between the two were in
the class. For instance, 0 matches any ASCII digit, and 0
matches any lowercase letter from the first half of the old ASCII alphabet.

necessarily both letters or both digits. Any character is possible,
although not advisable.  0 contains a range of characters, but
most people will not know which characters that means.  Furthermore,
such ranges may lead to portability problems if the code has to run on
a platform that uses a different character set, such as EBCDIC.

instance because it is the first or the last character of the character class,
or if it immediately follows a range, the hyphen isn't special, and so is
considered a character to be matched literally.  If you want a hyphen in
your set of characters to be matched and its position in the class is such
that it could be considered part of a range, you must escape that hyphen
with a backslash.

match. You can do so by using a caret (0) as the first character in the
character class. For instance, 0 matches any character that is not a
lowercase ASCII letter, which therefore includes almost a hundred thousand
Unicode letters.  The class is said to be "negated" or "inverted".

class, but only if it is the first character of the class. So if you want
the caret as one of the characters to match, either escape the caret or
else not list it first.

that normally say that a given character matches a sequence of multiple
characters under caseless 0 matching, which otherwise could be
highly confusing:

what 0 matches under 0.  0 isn't 0, but Unicode
says that 0 is what 0 matches under 0.  So which one
"wins"? Do you fail the match because the string has 0 or accept it
because it has an 0 followed by another 0?

0 and 0) inside a bracketed character class, and it will act just
as if you had put all characters matched by the backslash sequence inside the
character class. For instance, 0 matches any decimal digit, or any
of the lowercase letters between 'a' and 'f' inclusive.

or C<\N{U+0, and NOT be the form that matches non-newlines,
for the same reason that a dot 0 inside a bracketed character class loses
its special meaning: it matches nearly anything, which generally isn't what you
want to happen.

of a range.  Thus, you can't say:

0 0 0
0 0 0 0 0 0 0
0 0 0 0 0 0 0

name, and the 0 and 0 delimiters. POSIX character classes only appear
0 bracketed character classes, and are a convenient and descriptive
way of listing a group of characters.

and the letters 0, 0, 0 and 0.
POSIX character classes can be part of a larger bracketed character class.
For example,

counterparts.  (They are not official Unicode properties, but Perl extensions
derived from official Unicode properties.)  The table below shows the relation
between POSIX character classes and these counterparts.

the table, matches only characters in the ASCII character set.

appropriate characters in the full Unicode character set.  For example,
0 matches not just the ASCII alphabetic characters, but any
character in the entire Unicode character set considered alphabetic.
The column labelled "backslash sequence" is a (short) synonym for
the Full-range Unicode form.

0 lists all
synonyms, plus all characters matched by each ASCII-range property.
For example, 0 is a synonym for 0,
and any 0 property name can be prefixed with "Is" such as 0.)

On ASCII platforms, this means they assume that the code points from 128
to 255 are Latin-1, and that means that using them under locale rules is
unwise unless the locale is guaranteed to be Latin-1 or UTF-8.  In contrast, the
POSIX character classes are useful under locale rules.  They are
affected by the actual rules in effect, as follows:

counterparts.

0.

whether or not Unicode rules are in effect would not change the
behavior:  Outside of locale or an EBCDIC code page, the POSIX classes
would behave like their ASCII-range counterparts.  If you wish to
comment on this proposal, send email to 0.

the terminal somehow: for example, newline and backspace are control characters.
In the ASCII range, characters whose code points are between 0 and 31 inclusive,
plus 127 (0) are control characters.

to be the EBCDIC equivalents of the ASCII controls, plus the controls
that in Unicode have code pointss from 128 through 159.

of all alphanumeric characters and all punctuation characters.

plus those whitespace characters which are not also controls.

non-controls, non-alphanumeric, non-space characters:
C<[-!"#$%&'()*+,./:;<=0 (although if a locale is in effect,
it could alter the behavior of 0).

set in the ASCII range, namely
0.  That is, it is missing C<[$+0=0.
This is because Unicode splits what POSIX considers to be punctuation into two
categories, Punctuation and Symbols.

0 matches in the ASCII range, plus what 0
matches.  This is different than strictly matching according to
0.  Another way to say it is that
if Unicode rules are in effect, 0 matches all characters
that Unicode considers punctuation, plus all ASCII-range characters that
Unicode considers symbols.

matching, 0 additionally
matches the vertical tab, 0.   Same for the two ASCII-only range forms.

0 and \0.  For example,
0 can be written as 0.  All are listed
in 0.

0

negate it. This is done by prefixing the class name with a caret (0).
Some examples:

depending on various factors as described in 0.

0, but does not (yet?) support them.  Any attempt to use
either construct raises an exception.

=encoding utf8

0 0 0 0 0

For a shorter, tutorial introduction to just the essential features,
see 0.

structures, because all references had to be symbolic--and even then
it was difficult to refer to a variable instead of a symbol table entry.
Perl now not only makes it easier to use symbolic references to variables,
but also lets you have "hard" references to any piece of data or code.
Any scalar may hold a hard reference.  Because arrays and hashes contain
scalars, you can now easily build arrays of arrays, arrays of hashes,
hashes of arrays, arrays of hashes of functions, and so on.

automatically freeing the thing referred to when its reference count goes
to zero.  (Reference counts for values in self-referential or
cyclic data structures may not go to zero without a little help; see
0 for a detailed explanation.)
If that thing happens to be an object, the object is destructed.  See
0 for more about objects.  (In a sense, everything in Perl is an
object, but we usually reserve the word for references to objects that
have been officially "blessed" into a class package.)

symbolic link in a Unix filesystem contains merely the name of a file.
The 0 notation is something of a symbolic reference.  (Symbolic
references are sometimes called "soft references", but please don't call
them that; references are confusing enough without useless synonyms.)
0 0
0 0

system: They are used to access an underlying object without concern for
what its (other) name is.  When the word "reference" is used without an
adjective, as in the following paragraph, it is usually talking about a
hard reference.
0 0

principle: Perl does no implicit referencing or dereferencing.  When a
scalar is holding a reference, it always behaves as a simple scalar.  It
doesn't magically start being an array or hash or subroutine; you have to
tell it explicitly to do so, by dereferencing it.

0 0

0 0

(This works much like the & (address-of) operator in C.)
This typically creates 0 reference to a variable, because
there's already a reference to the variable in the symbol table.  But
the symbol table reference might go away, and you'll still have the
reference that the backslash returned.  Here are some examples:

or dirhandle) using the backslash operator.  The most you can get is a
reference to a typeglob, which is actually a complete symbol table entry.
But see the explanation of the 0 syntax below.  However,
you can still use type globs and globrefs as though they were IO handles.

0 0 0 0
0 0 0 0

brackets:

whose final element is itself a reference to another anonymous array of three
elements.  (The multidimensional syntax described later can be used to
access this.  For example, after the above,  would have
the value "b".)

as using square brackets--instead it's the same as creating
a list of references!

of 0, not a reference to 0 itself.  Likewise for 0,
except that the key references are to copies (since the keys are just
strings rather than full-fledged scalars).

0 0 0 0
0 0 0 0 0

brackets:

produce as complicated a structure as you want.  The multidimensional
syntax described below works for these too.  The values above are
literals, but variables and expressions would work just as well, because
assignment operators in Perl (even within  or ) are executable
statements, not compile-time declarations.

including BLOCKs, you may occasionally have to disambiguate braces at the
beginning of a statement by putting a 0 or a 0 in front so
that Perl realizes the opening brace isn't starting a BLOCK.  The economy and
mnemonic value of using curlies is deemed worth this occasional extra
hassle.

reference to it, you have these options:

the expression to mean either the HASH reference, or the BLOCK.

0 0 0
0 0 0 0

0 without a subname:

inside not being immediately executed, a 0 is not so much a
declaration as it is an operator, like 0 or 0.  (However, no
matter how many times you execute that particular line (unless you're in an
0),  will still have a reference to the 0
anonymous subroutine.)

that is, variables lexically visible within the current scope.  Closure
is a notion out of the Lisp world that says if you define an anonymous
function in a particular lexical context, it pretends to run in that
context even when it's called outside the context.

you define it as well as when you call it.  It's useful for setting up
little bits of code to run later, such as callbacks.  You can even
do object-oriented stuff with it, though Perl already provides a different
mechanism to do that--see 0.

template without using .  Here's a small example of how
closures work:

into  0 "my " having gone out of scope by the
time the anonymous subroutine runs.  That's what a closure is all
about.

continue to work as they have always worked.  Closure is not something
that most Perl programmers need trouble themselves about to begin with.

0 0

objects are just references to a special type of object that happens to know
which package it's associated with.  Constructors are just special subroutines
that know how to create that association.  They do so by starting with an
ordinary reference, and it remains an ordinary reference even while it's also
being an object.  Constructors are often named 0.  You 0 call them
indirectly:

better to use the direct method invocation approach:

0

dereference them in a context that assumes they exist.  Because we haven't
talked about dereferencing yet, we can't show you any examples yet.

0 0

the *foo{THING} syntax.  *foo{THING} returns a reference to the THING
slot in *foo (which is the symbol table entry which holds everything
known as foo).

the IO handle, used for file handles (0), sockets
(0 and 0), and directory
handles (0).  For compatibility with previous
versions of Perl, 0 is a synonym for 0, though it
is deprecated as of 5.8.0.  If deprecation warnings are in effect, it will warn
of its use.

except in the case of scalars.  0 returns a reference to an
anonymous scalar if  hasn't been used yet.  This might change in a
future release.

0 for passing filehandles
into or out of subroutines, or storing into larger data structures.
Its disadvantage is that it won't create a new filehandle for you.
Its advantage is that you have less risk of clobbering more than
you want to with a typeglob assignment.  (It still conflates file
and directory handles, though.)  However, if you assign the incoming
value to a scalar instead of a typeglob as we do in the examples
below, there's no risk of that happening.

0 0 0

know how to use references to get back to your long-lost data.  There
are several basic methods.

of a variable or subroutine name, you can replace the identifier with
a simple scalar variable containing a reference of the correct type:

0 or 0 there.  The dereference of the
scalar variable happens 0 it does any key lookups.  Anything more
complicated than a simple scalar variable must use methods 2 or 3 below.
However, a "simple scalar" includes an identifier that itself uses method
1 recursively.  Therefore, the following prints "howdy".

variable or subroutine name, you can replace the identifier with a
BLOCK returning a reference of the correct type.  In other words, the
previous examples could be written like this:

the BLOCK can contain any arbitrary expression, in particular,
subscripted expressions:

people often make the mistake of viewing the dereferencing symbols as
proper operators, and wonder about their precedence.  If they were,
though, you could use parentheses instead of braces.  That's not the case.
Consider the difference below; case 0 is a short-hand version of case 1,
0 case 2:

called %hashref, not dereferencing through  to the hash
it's presumably referencing.  That would be case 3.

enough that it gets cumbersome to use method 2.  As a form of
syntactic sugar, the examples for method 2 may be written:

including a previous dereference.  Note that 0 is 0 the
same thing as  here:

spring into existence when in an lvalue context.  Before this
statement, 0 may have been undefined.  If so, it's
automatically defined with a hash reference so that we can look up
0 in it.  Likewise  will automatically get
defined with an array reference so that we can look up 0 in it.
This process is called 0.

subscripts, so you can shrink the above down to

multidimensional arrays just like C's:

to grow its arrays on demand.  Perl does.

probably methods to access the things referred to, and you should probably
stick to those methods unless you're in the class package that defines the
object's methods.  In other words, be nice, and don't violate the object's
encapsulation without a very good reason.  Perl does not enforce
encapsulation.  We are not totalitarians here.  We do expect some basic
civility though.

as explained above.  Using a reference as a number produces an
integer representing its storage location in memory.  The only
useful thing to be done with this is to compare two references
numerically to see whether they refer to the same location.
0

including any package blessing as described in 0, as well
as the numeric address expressed in hex.  The  operator returns
just the type of thing the reference is pointing to, without the
address.  See 0 for details and examples of its use.
0

points to with a package functioning as an object class.  See 0.

the dereference syntax always indicates the type of reference desired.
So 0 and 0 both indicate the same scalar variable.

string, it's evaluated as a block.  The block creates a reference to an
anonymous array containing the results of the call to 0.  So
the whole block returns a reference to an array, which is then
dereferenced by 0 and stuck into the double-quoted string. This
chicanery is also useful for arbitrary expressions:

dereferenced via 0. Thus, the above expression may be written
as:

0 0
0 0

undefined, but we didn't say what happens if a value used as a
reference is already defined, but 0 a hard reference.  If you
use it as a reference, it'll be treated as a symbolic
reference.  That is, the value of the scalar is taken to be the 0
of a variable, rather than a direct link to a (possibly) anonymous
value.

to intend (with the utmost sincerity) to use a hard reference, and
accidentally use a symbolic reference instead.  To protect against
that, you can say

block.  An inner block may countermand that with

symbolic references.  Lexical variables (declared with ) aren't in
a symbol table, and thus are invisible to this mechanism.  For example:

variables, which are all "global" to the package.

brackets around a symbolic reference behave more like quotes, just as they
always have within a string.  That is,

a reserved word.  This has been generalized to work the same outside
of quotes, so that

Perl 5.000, though Perl 4 allowed it in the spaceless form.)  This
construct is 0 considered to be a symbolic reference when you're
using strict refs:

words, we've applied the same rule to any bareword that is used for
subscripting a hash.  So now, instead of writing

rare event that you do wish to do something like

makes it more than a bareword:

interprets a reserved word as a string.
But it will no longer warn you about using lowercase words, because the
string is effectively quoted.

0 0 0

remains available.

0 0 0 0
0 0 0 0

variables visible when that function was compiled, creates a closure.  It
retains access to those variables even though it doesn't get run until
later, such as in a signal handler or a Tk callback.

that act similarly.  Suppose you wanted functions named after the colors
that generated HTML font changes for the various colors:

we'll assign a closure to a typeglob of the name of the function we're
trying to build.

call , , , , , etc.  This technique saves on
both compile time and memory use, and is less error-prone as well, since
syntax checks happen at compile time.  It's critical that any variables in
the anonymous subroutine be lexicals in order to create a proper closure.
That's the reasons for the 0 on the loop iteration variable.

much sense.  If you wanted to impose scalar context on the arguments of
these functions (probably not a wise idea for this particular example),
you could have written it this way instead:

above happens too late to be of much use.  You could address this by
putting the whole loop of assignments within a BEGIN block, forcing it
to occur during compilation.

above, basically aliases to elements from the surrounding lexical scopes--
only works with anonymous subs, not with named subroutines. Generally
said, named subroutines do not nest properly and should only be declared
in the main package scope.

lexical variables get assigned to the parent lexicals from the first
execution of the parent block. If a parent scope is entered a second
time, its lexicals are created again, while the nested subs still
reference the old ones.

operator, as they are created on the fly. If you are accustomed to using
nested subroutines in other programming languages with their own private
variables, you'll have to work at it a bit in Perl.  The intuitive coding
of this type of thing incurs mysterious warnings about "will not stay
shared" due to the reasons explained above.
For example, this won't work:

temporary assignments of the anonymous subroutine. But when it does,
it has normal access to the lexical variable  from the scope of
 at the time outer is invoked.

function, something not normally supported in Perl.

0 0

converted into a string:

you won't accomplish what you're attempting.  You might want to do something
more like

real refs, instead of the , which won't.

Some pathological examples of the use of references can be found
in the 0 regression test in the Perl source directory.

complex data structures, and 0, 0, and 0
for how to use them to create objects. 

=encoding utf8

manage complicated data structures like multidimensional arrays and
nested hashes.  To enable these, Perl 5 introduced a feature called
`references', and using references is the key to managing complicated,
structured data in Perl.  Unfortunately, there's a lot of funny syntax
to learn, and the main manual page can be hard to follow.  The manual
is quite complete, and sometimes people find that a problem, because
it can be hard to tell what is important and what isn't.

90% of the benefit.  This page will show you that 10%.

hash whose values were lists.  Perl 4 had hashes, of course, but the
values had to be scalars; they couldn't be lists.

have a file of city and country names, like this:

once, and then an alphabetical list of the cities in that country:

names.  Associated with each country name key is a list of the cities in
that country.  Each time you read a line of input, split it into a country
and a city, look up the list of cities already known to be in that
country, and append the new city to the list.  When you're done reading
the input, iterate over the hash as usual, sorting each list of cities
before you print it out.

be lists; they can only be strings.  You lose.  You'd probably have to
combine all the cities into a single string somehow, and then when
time came to write the output, you'd have to break the string into a
list, sort the list, and turn it back into a string.  This is messy
and error-prone.  And it's frustrating, because Perl already has
perfectly good lists that would solve the problem if only you could
use them.

design: Hash values must be scalars.  The solution to this is
references.

entire hash (or to just about anything else).  Names are one kind of
reference that you're already familiar with.  Think of the President
of the United States: a messy, inconvenient bag of blood and bones.
But to talk about him, or to represent him in a computer program, all
you need is the easy, convenient scalar string "Barack Obama".

Perl's private, internal names, so you can be sure they're
unambiguous.  Unlike "Barack Obama", a reference only refers to one
thing, and you always know what it refers to.  If you have a reference
to an array, you can recover the entire array from it.  If you have a
reference to a hash, you can recover the entire hash.  But the
reference is still an easy, compact scalar value.

scalars.  We're stuck with that.  But a single reference can refer to
an entire array, and references are scalars, so you can have a hash of
references to arrays, and it'll act a lot like a hash of arrays, and
it'll be just as useful as a hash of arrays.

some syntax for managing references.

it once you have it.

reference to that variable.

can copy it or store it just the same as any other scalar value:

Sometimes you want to make an array or a hash that doesn't have a
name.  This is analogous to the way you like to be able to use the
string 0 or the number 80 without having to store it in a named
variable first.

that array.  0 makes a new, anonymous hash, and returns a
reference to that hash.

references that you get from rule 1:

that it doesn't create the superfluous array variable 0.

If you write just 0, you get a new, empty anonymous hash.

value, and we've seen that you can store it as a scalar and get it back
again just like any scalar.  There are just two more ways to use it:

the name of an array.  For example, 0 instead of 0.

left-hand versions operate on the array 0.  The right-hand
versions operate on the array that is referred to by 0.  Once
they find the array they're operating on, both versions do the same
things to the arrays.

to do it.  You just write the Perl code that you would have written
for doing the same thing to a regular array or hash, and then replace
the array or hash name with 0.  "How do I loop over an
array when all I have is a reference?"  Well, to loop over an array, you
would write

reference?"  First write the code for printing out a hash:

absolutely everything you ever need to do with references.  But the
most common thing to do with an array or a hash is to extract a single
element, and the 0 notation is cumbersome.  So there is an
abbreviation.

instead.

 instead.

the fourth element of the array.  Don't confuse this with 0,
which is the fourth element of a totally different array, one
deceptively named 0.  0 and 0 are unrelated the
same way that 0 and 0 are.

the scalar variable 0, perhaps even one with no name.
0 is part of the deceptively named 0 hash.  It's
easy to forget to leave out the , and if you do, you'll get
bizarre results when your program gets array and hash elements out of
totally unexpected hashes and arrays that weren't the ones you wanted
to use.

0, and gives you a reference to that array.

another array.

containing 0, and because it is a reference to an array,
0 says that we can write  to get the
third element from that array.   is the 6.
Similarly,  is the 2.  What we have here is like a
two-dimensional array; you can write  to get
or set the element in any row and any column of the array.

abbreviation:

same thing.  Instead of , we can write
0; it means the same thing.

had to write 0 instead of 0.  For
three-dimensional arrays, they let us write 0 instead of
the unreadable 0.

file of city and country names.

structure, and lines 8-13 analyze the data and print out the report.
We're going to have a hash, 0, whose keys are country names,
and whose values are references to arrays of city names.  The data
structure will look like this:

how do we print it out?

ordinary hash, and we get a list of keys from it, sort the keys, and
loop over the keys as usual.  The only use of references is in line 10.
0 looks up the key 0 in the hash
and gets the value, which is a reference to an array of cities in that country.
0 says that
we can recover the array by saying
0.  Line 10 is just like

0.  The 0 tells Perl to get the entire array.
Having gotten the list of cities, we sort it, join it, and print it
out as usual.

place.  Here they are again:

country is already present as a key in the hash.  If it's not, the
program uses the 0 notation (0) to manufacture a new,
empty anonymous array of cities, and installs a reference to it into
the hash under the appropriate key.

0 now holds a reference to the array of cities seen
in that country so far.  Line 6 is exactly like

0.  The 0 adds a city name to the end of the
referred-to array.

get rid of it.

then nothing is different.  Line 6 will locate the value in
0, which is a reference to an array, and push
0 into the array.  But
what does it do when
0 holds a key, say 0, that is not yet in 0?

to push 0 onto an array that doesn't exist, so it helpfully
makes a new, empty, anonymous array for you, installs it into
0, and then pushes 0 onto it.  This is called
`autovivification'--bringing things to life automatically.  Perl saw
that they key wasn't in the hash, so it created a new hash entry
automatically. Perl saw that you wanted to use the hash value as an
array, so it created a new empty array and installed a reference to it
in the hash automatically.  And as usual, Perl made the array one
element longer to hold the new city name.

that means I left out 90% of the details.  Now that you have an
overview of the important parts, it should be easier to read the
0 manual page, which discusses 100% of the details.

other references.

inside them is an atomic scalar variable like 0.  For example,
0 is the same as 0, and 0 is the same as
0.  If you're just starting out, you may want to adopt
the habit of always including the curly brackets.

 and then look at
 you'll see the change.

0 is assigned a reference to the new array.  The new array is
initialized with the contents of the array referred to by 0.

returns true if its argument is a reference.  Actually it's a little
better than that: It returns 0 for hash references and 0
for array references.

printed out a reference by mistake.

if two references refer to the same thing.  (But you should usually use
0 instead because it's much faster.)

0 as an array reference, it's taken to be a reference to the
array 0.  This is called a 0 or 0.  The declaration 0 disables this
feature, which can cause all sorts of trouble if you use it by accident.

discusses lists of lists and multidimensional arrays in detail.  After
that, you should move on to 0; it's a Data Structure Cookbook
that shows recipes for using and printing out arrays of hashes, hashes
of arrays, and other kinds of data.

them is with references.  There are four important rules for managing
references: Two for making references and two for using them.  Once
you know these rules you can do most of the important things you need
to do with references.

( http://www.tpj.com/ ) volume 3, #2.  Reprinted with permission.

under the same terms as Perl itself.

hereby placed into the public domain.  You are permitted and
encouraged to use this code in your own programs for fun or for profit
as you see fit.  A simple comment in the code giving credit would be
courteous but is not required.

=encoding utf8

engine and how it works. The regex engine represents a significant chunk
of the perl codebase, but is relatively poorly understood. This document
is a meagre attempt at addressing this situation. It is derived from the
author's experience, comments in the source code, other papers on the
regex engine, feedback on the perl5-porters mail list, and no doubt other
places as well.

structures discussed in this represents the state of the engine as the
author understood it at the time of writing. It is 0 an API
definition, it is purely an internals guide for those who want to hack
the regex engine, or understand how the regex engine works. Readers of
this document are expected to understand perl's regex syntax and its
usage in detail. If you want to learn about the basics of Perl's
regular expressions, see 0. And if you want to replace the
regex engine with your own, see 0.

document we will use the term "regex" unless there is a special reason
not to, in which case we will explain why.

code form and their internal form. In this document we will use the term
"pattern" when we speak of their textual, source code form, and the term
"program" when we speak of their internal representation. These
correspond to the terms 0 and 0 that Mark Jason
Dominus employs in his paper on "Rx" ([1] in 0).

specified in a mini-language, and then applies those constraints to a
target string, and determines whether or not the string satisfies the
constraints. See 0 for a full definition of the language.

something the computer can efficiently use to find the matching point in
the string, and the second part is performing the search itself.

need to execute the program to find the point in the string that
matches. And we need to do the whole thing efficiently.

is worth taking a look at a comment that has
been in 0

diagram/charts", or "railroad diagram/charts" being more common terms.
Nevertheless it provides a useful mental image of a regex program: each
node can be thought of as a unit of track, with a single entry and in
most cases a single exit point (there are pieces of track that fork, but
statistically not many), and the whole forms a layout with a
single entry and single exit point. The matching process can be thought
of as a car that moves along the track, with the particular route through
the system being determined by the character read at each possible
connector point. A car can fall off the track at any point but it may
only proceed as long as it matches the track.

following chart:

much more complex than this kind of structure, but visualising it this way
can help when trying to get your bearings, and it matches the
current implementation pretty closely.

of a graph. Each node in the graph corresponds to part of
the original regex pattern, such as a literal string or a branch,
and has a pointer to the nodes representing the next component
to be matched. Since "node" and "opcode" already have other meanings in the
perl source, we will call the nodes in a regex program "regops".

more of which represent a single regop of the program. Struct
0 is the smallest struct needed, and has a field structure which is
shared with all the other larger structures.

a "next" pointer with a 0 on both ends of it is connecting two
alternatives.  [Here we have one of the subtle syntax dependencies: an
individual 0 (as opposed to a collection of them) is never
concatenated with anything because of operator precedence.]

it is a regop leading into a sub-program.  In particular, the operand
of a 0 node is the first regop of the branch.

structure:  the tail of the branch connects to the thing following the
set of 0es.  It is a like a single line of railway track that
splits as it goes into a station or railway yard and rejoins as it comes
out the other side.

are almost like subclasses in that they have the same fields as
0, with possibly additional fields following in
the structure, and in some cases the specific meaning (and name)
of some of base fields are overridden. The following is a more
complete description.

four-byte argument; 0 structures contain two two-byte
arguments instead:

with a one-byte length and then the string data. Strings are padded on
the end with zero bytes so that the total length of the node is a
multiple of four bytes:

which have a four-byte argument and then a 32-byte (256-bit) bitmap
indicating which characters are included in the class.

POSIX char classes called 0 which has an
additional 4-byte (32-bit) bitmap indicating which POSIX char classes
have been included.

of each opcode in units of 0 (4-byte). A macro is used
to calculate the size of an 0 node based on its 0 field.

0 by 0. Currently the maximum possible number
of distinct regops is restricted to 256, with about a quarter already
used.

easier and more consistent. These include 0, which is used to determine
the type of a 0-like structure; 0, which is the offset to
the next node (more on this later); 0, 0, 0, 0,
and equivalents for reading and setting the arguments; and 0,
0 and 0 for manipulating strings and regop bearing
types.

it is important to keep them clear.

rarely useful except that sometimes it matches up in terms of value
with one of the others, and that sometimes the code assumes this to
always be so.

regop physically located after the current one, as determined by
the size of the current regop. This is often useful, such as when
dumping the structure we use this order to traverse. Sometimes the code
assumes that the "next regnode" is the same as the "next regop", or in
other words assumes that the sizeof a given regop type is always going
to be one regnode large.

is reached by jumping forward by the value of 0,
or in a few cases for longer jumps by the 0 field of the 0
structure. The subroutine 0 handles this transparently.
This is the logical successor of the node, which in some cases, like
that of the 0 regop, has special meaning.

involves the following steps:

determined by whether the pattern involves interpolating any string
variables. If interpolation occurs, then compilation happens at run time. If it
does not, then compilation is performed at compile time. (The 0 modifier changes this,
as does 0 to a certain extent.) The engine doesn't really care that
much.

0, 0 and 0.

wrapper which farms work out to two other routines for the heavy lifting: the
first is 0, which is the start point for parsing; the second,
0, is responsible for optimisation.

of a special structure, 0 (defined in 0).
Almost all internally-used routines in 0 take a pointer to one
of these structures as their first argument, with the name 0.
This structure is used to store the compilation state and contains many
fields. Likewise there are many macros which operate on this
variable: anything that looks like 0 is a macro that operates on
this pointer/structure.

space is needed for each regop we would need to emit. The size is also
used to determine whether long jumps will be required in the program.

construction phase, except that most routines are short-circuited to
change the size field 0 and not do anything else.

again, but this time for real. Now 0 will be false, and the
actual construction can occur.

parsing an arbitrary chunk of pattern up to either the end of the
string, or the first closing parenthesis it encounters in the pattern.
This means it can be used to parse the top-level regex, or any section
inside of a grouping parenthesis. It also handles the "special parens"
that perl's regexes have. For instance when parsing 0 0
will at one point be called to parse from the "?" symbol up to and
including the ")".

branches from the pattern, and for "finishing them off" by correctly
setting their next pointers. In order to do the parsing, it repeatedly
calls out to 0, which is responsible for handling up to the
first 0 symbol it sees.

handles "things" followed by a quantifier. In order to parse the
"things", 0 is called. This is the lowest level routine, which
parses out constant strings, character classes, and the
various special symbols like 0. If 0 encounters a "("
character it in turn calls 0.

in order to "set the tail pointer" correctly. When executing and
we get to the end of a branch, we need to go to the node following the
grouping parens. When parsing, however, we don't know where the end will
be until we get there, so when we do we must go back and update the
offsets as appropriate. 0 is used to make this easier.

originally parsed into an alternation with a single branch. It is only
afterwards that the optimiser converts single branch alternations into the
simpler form.

to see some trace information about the parse process. We will start with some
simple patterns and build up to more complex patterns.

left shows what is being parsed, and the number indicates where the next regop
would go. The stuff on the right is the trace output of the graph. The
names are chosen to be short to make it less dense on the screen. 'tsdy'
is a special form of 0 which does some extra analysis.

only an atom. The final program shows us how things work. We have an 0 regop,
followed by an 0 regop. The number in parens indicates where the 0 of
the node goes. The 0 of an 0 regop is unused, as 0 regops mean
we have successfully matched. The number on the left indicates the position of
the regop in the regnode array.

0. We will see that 0 calls 0 twice.

because if it matches it should try to match itself again. The 0 regop
handles the actual failure of the 0 regop and acts appropriately (going
to regnode 6 if the 0 matched at least once, or failing if it didn't).

play. At regnode 10 we see an example where a character class with only
one character in it was turned into an 0 node. We can also see where
an entire alternation was turned into a 0 node. As a consequence,
some of the regnodes have been marked as optimised away. We can see that
the 0 symbol has been converted into an 0 regop, a special piece of
code that looks for 0 or the end of the string.

execution should go if the branch fails. When executing, if the engine
tries to traverse from a branch to a 0 that isn't a branch then
the engine will know that the entire set of branches has failed.

strings and complex patterns it can end up having to do a lot of work
to find a match, and even more to decide that no match is possible.
Consider a situation like the following pattern.

every time because there is no 0 in the string. So obviously we can
avoid using the regex engine unless there is a 0 in the string.
Likewise in a pattern like:

followed by 0. We can use Fast Boyer-Moore matching as implemented
in 0 to find the location of these strings. If they don't exist
then we don't need to resort to the much more expensive regex engine.
Even better, if they do exist then we can use their positions to
reduce the search space that the regex engine needs to cover to determine
if the entire pattern matches.

optimisations along these lines:

optimisation, where inefficient constructs are replaced by more efficient
constructs. The 0 regops which are used during parsing to mark the end
of branches and the end of groups are examples of this. These regops are used
as place-holders during construction and "always match" so they can be
"optimised away" by making the things that point to the 0 point to the
thing that 0 points to, thus "skipping" the node.

where two consecutive 0 nodes are merged into a single
regop. An even more aggressive form of this is that a branch
sequence of the form 0 can be converted into a
0 regop.

structure 0 to store the analysis that it has performed, and
does the "peep-hole" optimisations as it goes.

finding the start point in the string where we should match from,
and the second being running the regop interpreter.

interpreter at all. Likewise, if we know from the analysis phase that we
cannot detect a short-cut to the start position, we go straight to the
interpreter.

have a somewhat incestuous relationship with overlap between their functions,
and 0 may even call 0 on its own. Nevertheless
other parts of the perl source code may call into either, or both.

efforts of Dave Mitchell in the 5.9.x development track, that has changed: now an
internal stack is maintained on the heap and the routine is fully
iterative. This can make it tricky as the code is quite conservative
about what state it stores, with the result that two consecutive lines in the
code can actually be running in totally different contexts due to the
simulated recursion.

optimisations as determined by the results of the analysis done by
0 (and described in 0).

end-points of where the pattern could match, and to ensure that the string
is long enough to match the pattern. It tries to use more efficient
methods over less efficient methods and may involve considerable
cross-checking of constraints to find the place in the string that matches.
For instance it may try to determine that a given fixed string must be
not only present but a certain number of chars before the end of the
string, or whatever.

Fast Boyer Moore matching and 0 which is responsible for
finding the start using the first mandatory regop in the program.

to perform the match.

support for initialising the regex interpreter's state, running
0 if needed, and running the interpreter on the string
from various start positions as needed. When it is necessary to use
the regex interpreter 0 calls 0.

as arguments a pointer to a 0 structure and a pointer to
a string.  It returns an integer 1 for success and a 0 for failure.
It is basically a set-up wrapper around 0.

basically a giant switch statement that implements a state machine, where
the possible states are the regops themselves, plus a number of additional
intermediate and failure states. A few of the states are implemented as
subroutines but the bulk are inline code.

using an eight-bit character set, perl uses an internal representation
that is a permissive version of Unicode's UTF-8 encoding[2]. This uses single
bytes to represent characters from the ASCII character set, and sequences
of two or more bytes for all other characters. (See 0
for more information about the relationship between UTF-8 and perl's
encoding, utf8. The difference isn't important for this discussion.)

regex engine. Tricks that might be fine when you have 256 possible
characters often won't scale to handle the size of the UTF-8 character
set.  Things you can take for granted with ASCII may not be true with
Unicode. For instance, in ASCII, it is safe to assume that
0, but in UTF-8 it isn't. Unicode case folding is
vastly more complex than the simple rules of ASCII, and even when not
using Unicode but only localised single byte encodings, things can get
tricky (for example, 0 (U+00DF, 0)
should match 'SS' in localised case-insensitive matching).

regex engine (as it was to perl) and this necessarily  made things a lot
more complicated. Obviously it is easier to design a regex engine with
Unicode support in mind from the beginning than it is to retrofit it to
one that wasn't.

two cases, one for UTF-8, and one not. In fact, it's often more complex
than that, as the pattern may be UTF-8 as well.

UTF-8 properly, both at compile time and at execution time, including
when the string and pattern are mismatched.

tricky this can be:

regex engines. Two of its fields that are intended for the private use
of the regex engine that compiled the pattern. These are the
0 and pprivate members. The 0 is a void pointer to
an arbitrary structure whose use and management is the responsibility
of the compiling engine. perl will never modify either of these
values. In the case of the stock engine the structure pointed to by
0 is called 0.

specific to each engine.

One, the 0 structure described in 0 is populated by
the engine currently being. used and some of its fields read by perl to
implement things such as the stringification of 0.

0 and is in addition to 0 in the same struct
considered to be the property of the regex engine which compiled the
regular expression;

to properly work with the regular expression. It includes data about
optimisations that perl can use to determine if the regex engine should
really be used, and various other control info that is needed to properly
execute patterns in various contexts such as is the pattern anchored in
some way, or what flags were used during the compile, or whether the
program contains special constructs that perl needs to be aware of.

of the regex engine that compiled the pattern. These are the 0
and pprivate members. The 0 is a void pointer to an arbitrary
structure whose use and management is the responsibility of the compiling
engine. perl will never modify either of these values.

will be a pointer to a regexp_internal structure which holds the compiled
program and any additional data that is private to the regex engine
implementation.

regex engine. Since it is specific to perl it is only of curiosity
value to other engine implementations.

0 struct. This was used when the last successful match
was from the same pattern as the current pattern, so that a partial
match didn't overwrite the previous match's results, but it caused a
problem with re-entrant code such as trying to build the UTF-8 swashes.
Currently unused and left for backward compatibility with 5.10.0.

to offset in the 0 string. This is only used by ActiveState's
visual regex debugger.

can match at a certain position. For instance if the regex engine knows
that the pattern must start with a 'Z' then it can scan the string until
it finds one and then launch the regex engine from there. The routine
that handles this is called 0. Sometimes this field
points at a regop embedded in the program, and sometimes it points at
an independent synthetic regop that has been constructed by the optimiser.

needs to handle specially during a clone or free operation on the compiled
product. Each element in the data array has a corresponding element in the
what array. During compilation regops that need special structures stored
will add an element to each array using the  routine and then store
the index in the regop.

treated as a single blob.

Ronald J. Kimball, Dave Mitchell, Dominic Dunlop, Mark Jason Dominus,
Stephen McCamant, and David Landgren.

=encoding utf8

using regular expressions ('regexes') in Perl.

characters.  A regex consisting of a word matches any string that
contains that word:

0 tells Perl to search a string for a match.  The operator
0 associates the string with the regex match and produces a true
value if the regex matched, or false if the regex did not match.  In
our case, 0 matches the second word in 0, so the
expression is true.  This idea has several variations.

arbitrary delimiters by putting an 0 out front:

statement to be true:

called 0, are reserved for use in regex notation.
The metacharacters are

because it is used to delimit the regex.

Common examples are 0 for a tab, 0 for a newline, and 0
for a carriage return.  Arbitrary bytes are represented by octal
escape sequences, e.g., 0, or hexadecimal escape sequences,
e.g., 0:

substitution works:

string, it was considered a match.  To specify 0 it should
match, we would use the 0 metacharacters 0 and 0.  The
anchor 0 means match at the beginning of the string and the anchor
0 means match at the end of the string, or before a newline at the
end of the string.  Some examples:

just a single character, to match at a particular point in a regex.
Character classes are denoted by brackets 0, with the set of
characters to be possibly matched inside.  Here are some examples:

the class, the earliest point at which the regex can match is 0.

the match case-insensitive.

sets of ordinary and special characters inside a character class are
different than those outside a character class.  The special
characters for a character class are 0 and are matched using an
escape:

classes, so that the unwieldy 0 and 0
become the svelte 0 and 0:

treated as an ordinary character.

denotes a 0, which matches any character but
those in the brackets.  Both 0 and 0 must match a
character, or the match fails.  Then

definitions are those that Perl uses in ASCII mode with the 0 modifier.
See 0 for details.)

of character classes.  Here are some in use:

character and a non-word character 0 or 0:

boundary.

metacharacter 0.  To match 0 or 0, we form the regex
0.  As before, Perl will try to match the regex at the
earliest possible point in the string.  At each character position,
Perl will first try to match the first alternative, 0.  If
0 doesn't match, Perl will then try the next alternative, 0.
If 0 doesn't match either, then the match fails and Perl moves to
the next position in the string.  Some examples:

0 is able to match earlier in the string.

regex match to succeed will be the one that matches. Here, all the
alternatives match at the first string position, so the first matches.

treated as a single unit.  Parts of a regex are grouped by enclosing
them in parentheses.  The regex 0 means match
0 followed by either 0 or 0.  Some more examples
are

parts of a string that matched.  For each grouping, the part that
matched inside goes into the special variables 0, 0, etc.
They can be used just as ordinary variables:

list of matched values 0.  So we could rewrite it as

leftmost opening parenthesis, 0 the next opening parenthesis,
etc.  For example, here is a complex regex and the matching variables
indicated below it:

the 0 0, 0, ...  Backreferences are
matching variables that can be used 0 a regex:

0, ... only inside a regex.

to determine the number of repeats of a portion of a regex we
consider to be a match.  Quantifiers are put immediately after the
character, character class, or grouping that we want to specify.  They
have the following meanings:

times.

while still allowing the regex to match.  So we have

while still having the regex match. The second quantifier 0 has
no string left to it, so it matches 0 times.

operators.
The global modifier 0 allows the matching operator to match
within a string as many times as possible.  In scalar context,
successive matches against a string will have 0 jump from match
to match, keeping track of position in the string as it goes along.
You can get or set the position with the 0 function.
For example,

you don't want the position reset after failure to match, add the
0, as in 0.

there are no groupings, a list of matches to the whole regex.  So

The 0 is a Perl double-quoted string that replaces in the
string whatever is matched with the 0.  The operator 0 is
also used here to associate a string with 0.  If matching
against 0, the S<0 can be dropped.  If there is a match,
0 returns the number of substitutions made; otherwise it returns
false.  Here are a few examples:

are immediately available for use in the replacement expression. With
the global modifier, 0 will search and replace all occurrences
of the regex in the string:

to be returned instead of modifying 0 (or whatever variable the
substitute was bound to with 0):

replacement string and the evaluated result is substituted for the
matched substring.  Some examples:

0 and 0, and even 0.  If single quotes are used
0, then the regex and replacement are treated as single-quoted
strings.

and returns that list.  The regex determines the character sequence
that 0 is split with respect to.  For example, to split a
string into words, use

characters.  If the regex has groupings, then the list produced contains
the matched substrings from the groupings as well:

an empty initial element to the list.

regexes, see 0 and for the reference page, see 0.

All rights reserved.

Ilya Zakharevich, Brad Hughes, and Mike Giroux for all their helpful
comments.

=encoding utf8

For full information see 0 and 0, as well
as the 0 section in this document.

In its absence,  is used.

and negates the result of the match; it returns
false if the match succeeds, and true if it fails.

applying the given options.

regex is used. Delimiters other than '/' may be used for both this
operator and the following ones. The leading 0 can be omitted
if the delimiter is '/'.

or pass one around. Modifiers as for 0, and are stored
within the regex.

'pattern' with 'replacement'. Modifiers as for 0,
with two additions:

as a double quoted string unless a single-quote (0) is the delimiter.

delimiters can be used.  Must be reset with .

The first six are locale aware, all are Unicode aware. See 0
and 0 for details.

in 0

matched by a pattern with a possessive quantifier will not be backtracked
into, even if that causes the whole match to fail.

within your program. Consult 0 for 0
to see equivalent expressions that won't cause slow down.
See also 0. Starting with Perl 5.10, you
can also use the equivalent variables 0, 0
and 0, but for them to be defined, you have to
specify the 0 (preserve) modifier on your regular expression.

0, and 0.  For Titlecase, see 0.

certain characters like the German "sharp s" there is a difference.

debugging.

for details on regexes and internationalisation.

(0) for a thorough grounding and
reference on the topic.

Richard Soderberg,
Sean M. Burke,
Tom Christiansen,
Jim Cromie,
and
Jeffrey Goff
for useful advice.

=encoding utf8

using regular expressions in Perl.  It serves as a complement to the
reference page on regular expressions 0.  Regular expressions
are an integral part of the 0, 0, 0 and 0
operators and so this tutorial also overlaps with
0 and 0.

expressions are one of the big factors behind this fame.  Perl regular
expressions display an efficiency and flexibility unknown in most
other computer languages.  Mastering even the basics of regular
expressions will allow you to manipulate text with surprising ease.

that describes a pattern.  Patterns are in common use these days;
examples are the patterns typed into a search engine to find web pages
and the patterns used to list files in a directory, e.g., 0
or 0.  In Perl, the patterns described by regular expressions
are used to search strings, extract desired parts of strings, and to
do search and replace operations.

and difficult to understand.  Regular expressions are constructed using
simple concepts like conditionals and loops and are no more difficult
to understand than the corresponding 0 conditionals and 0
loops in the Perl language itself.  In fact, the main challenge in
learning regular expressions is just getting used to the terse
notation used to express these concepts.

expression concepts, along with their notation, one at a time and with
many examples.  The first part of the tutorial will progress from the
simplest word searches to the basic regular expression concepts.  If
you master the first part, you will have all the tools needed to solve
about 98% of your needs.  The second part of the tutorial is for those
comfortable with the basics and hungry for more power tools.  It
discusses the more advanced regular expression operators and
introduces the latest cutting-edge innovations.

regexp or regex.  Regexp is a more natural abbreviation than regex, but
is harder to pronounce.  The Perl pod documentation is evenly split on
regexp vs regex; in Perl, there is more than one way to abbreviate it.
We'll use regexp in this tutorial.

characters.  A regexp consisting of a word matches any string that
contains that word:

double-quoted string.  0 is the regular expression and the
0 enclosing 0 tells Perl to search a string for a match.
The operator 0 associates the string with the regexp match and
produces a true value if the regexp matched, or false if the regexp
did not match.  In our case, 0 matches the second word in
0, so the expression is true.  Expressions like this
are useful in conditionals:

be reversed by using the 0 operator:

0 part can be omitted:

to arbitrary delimiters by putting an 0 out front:

same thing.  When, e.g., the quote (0) is used as a delimiter, the forward
slash 0 becomes an ordinary character and can be used in this regexp
without trouble.

case-sensitive.  The second regexp matches because the substring
S<0 occurs in the string S<0.  The space
character ' ' is treated like any other character in a regexp and is
needed to match in this case.  The lack of a space character is the
reason the third regexp 0 doesn't match.  The fourth regexp
0 doesn't match because there is a space at the end of the
regexp, but not at the end of the string.  The lesson here is that
regexps must match a part of the string 0 in order for the
statement to be true.

always match at the earliest possible point in the string:

need to know about.   First of all, not all characters can be used 'as
is' in a match.  Some characters, called 0, are reserved
for use in regexp notation.  The metacharacters are

in the rest of the tutorial, but for now, it is important only to know
that a metacharacter can be matched by putting a backslash before it:

because it is used to delimit the regexp.  This can lead to LTS
(leaning toothpick syndrome), however, and it is often more readable
to change delimiters.

be backslashed:

which don't have printable character equivalents and are instead
represented by 0.  Common examples are 0 for a
tab, 0 for a newline, 0 for a carriage return and 0 for a
bell (or alert).  If your string is better thought of as a sequence of arbitrary
bytes, the octal escape sequence, e.g., 0, or hexadecimal escape
sequence, e.g., 0 may be a more natural representation for your
bytes.  Here are some examples of escapes:

may seem familiar.  Similar escape sequences are used in double-quoted
strings and in fact the regexps in Perl are mostly treated as
double-quoted strings.  This means that variables can be used in
regexps as well.  Just like double-quoted strings, the values of the
variables in the regexp will be substituted in before the regexp is
evaluated for matching purposes.  So we have:

searches with just about any literal string regexp you can dream up.
Here is a 0 emulation of the Unix grep program:

way to invoke a perl program from the shell.
S<0 saves the first command line argument as the
regexp to be used, leaving the rest of the command line arguments to
be treated as files.  S<> loops over all the lines in
all the files.  For each line, S<0 prints the
line if the regexp matches the line.  In this line, both 0 and
0 use the default variable 0 implicitly.

string, it was considered a match.  Sometimes, however, we'd like to
specify 0 in the string the regexp should try to match.  To do
this, we would use the 0 metacharacters 0 and 0.  The
anchor 0 means match at the beginning of the string and the anchor
0 means match at the end of the string, or before a newline at the
end of the string.  Here is how they are used:

match only at the beginning of the string, but 0 has
keeper starting in the middle.  The third regexp does match, since the
0 constrains 0 to match only at the end of the string.

match both the beginning and the end of the string, i.e., the regexp
matches the whole string.  Consider

0.  Since the second regexp is exactly the string, it
matches.  Using both 0 and 0 in a regexp forces the complete
string to match, so it gives you complete control over which strings
match and which don't.  Suppose you are looking for a fellow named
bert, off in a string by himself:

use the string comparison S<0 and it would be
more efficient.   The  0 regexp really becomes useful when we
add in the more powerful regexp tools below.

regexps above, we've only scratched the surface of regular expression
technology.  In this and subsequent sections we will introduce regexp
concepts (and associated metacharacter notations) that will allow a
regexp to represent not just a single character sequence, but a 0 of them.

allows a set of possible characters, rather than just a single
character, to match at a particular point in a regexp.  Character
classes are denoted by brackets 0, with the set of characters
to be possibly matched inside.  Here are some examples:

the class, 0 matches because the first character position in the
string is the earliest point at which the regexp can match.

match.  Perl provides a way of avoiding all those brackets by simply
appending an 0 to the end of the match.  Then 0
can be rewritten as 0.  The 0 stands for
case-insensitive and is an example of a 0 of the matching
operation.  We will meet other modifiers later in the tutorial.

represented themselves, and special characters, which needed a
backslash 0 to represent themselves.  The same is true in a
character class, but the sets of ordinary and special characters
inside a character class are different than those outside a character
class.  The special characters for a character class are 0 (and
the pattern delimiter, whatever it is).
0 is special because it denotes the end of a character class.  0 is
special because it denotes a scalar variable.  0 is special because
it is used in escape sequences, just like above.  Here is how the
special characters 0 are handled:

the dollar sign, so the character class has two members 0 and 0.
In 0, the backslash is protected, so 0 is treated as a
variable and substituted in double quote fashion.

classes, so that a contiguous set of characters can be written as a
range.  With ranges, the unwieldy 0 and 0
become the svelte 0 and 0.  Some examples are

treated as an ordinary character; 0, 0 and 0 are
all equivalent.

denotes a 0, which matches any character but
those in the brackets.  Both 0 and 0 must match a
character, or the match fails.  Then

interest of saving keystrokes and making regexps more readable, Perl
has several abbreviations for common character classes, as shown below.
Since the introduction of Unicode, unless the 0 modifier is in
effect, these character classes match more than just a few characters in
the ASCII range.

but also digits and characters from non-roman scripts

in effect, as explained below).

regardless of whether the modifier 0 is in effect.

restrict the matches of \d, \s, and \w to just those in the ASCII range.
It is useful to keep your program from being needlessly exposed to full
Unicode (and its accompanying security considerations) when all you want
is to process English-like text.  (The "a" may be doubled, 0, to
provide even more restrictions, preventing case-insensitive matching of
ASCII with non-ASCII characters; otherwise a Unicode "Kelvin Sign"
would caselessly match a "k" or "K".)

of character classes.  Here are some in use:

as an ordinary period. Because, for example, 0 and 0 are sets
of characters, it is incorrect to think of 0 as 0; in
fact 0 is the same as 0, which is the same as
0. Think DeMorgan's laws.

0.  This matches a boundary between a word character and a non-word
character 0 or 0:

boundary.

every character? The reason is that often one is matching against
lines and would like to ignore the newline characters.  For instance,
while the string 0 represents one line, we would like to think
of it as empty.  Then

newlines when we count and match characters in a line.  Sometimes,
however, we want to keep track of newlines.  We might even want 0
and 0 to anchor at the beginning and end of lines within the
string, rather than just the beginning and end of the string.  Perl
allows us to choose between ignoring and paying attention to newlines
by using the 0 and 0 modifiers.  0 and 0 stand for
single line and multi-line and they determine whether a string is to
be treated as one continuous string, or as a set of lines.  The two
modifiers affect two aspects of how the regexp is interpreted: 1) how
the 0 character class is defined, and 2) where the anchors 0
and 0 are able to match.  Here are the four possible combinations:

except 0.  0 matches only at the beginning of the string and
0 matches only at the end or before a newline at the end.

any character, even 0.  0 matches only at the beginning of
the string and 0 matches only at the end or before a newline at the
end.

matches any character except 0.  0 and 0 are able to match
at the start or end of 0 line within the string.

detect multiple lines.  0 matches any character, even
0.  0 and 0, however, are able to match at the start or end
of 0 line within the string.

0 are occasionally very useful.  If 0 is being used, the start
of the string can still be matched with 0 and the end of the string
can still be matched with the anchors 0 (matches both the end and
the newline before, like 0), and 0 (matches only the end):

regexp.  What about choices among words or character strings? Such
choices are described in the next section.

possible words or character strings.  This is accomplished by using
the 0 metacharacter 0.  To match 0 or 0, we
form the regexp 0.  As before, Perl will try to match the
regexp at the earliest possible point in the string.  At each
character position, Perl will first try to match the first
alternative, 0.  If 0 doesn't match, Perl will then try the
next alternative, 0.  If 0 doesn't match either, then the
match fails and Perl moves to the next position in the string.  Some
examples:

0 is able to match earlier in the string.

first alternative is the one that matches.  If some of the
alternatives are truncations of the others, put the longest ones first
to give them a chance to match.

alternations of characters.  At a given character position, the first
alternative that allows the regexp match to succeed will be the one
that matches.

itself it is unsatisfying.  The reason is that each alternative is a whole
regexp, but sometime we want alternatives for just part of a
regexp.  For instance, suppose we want to search for housecats or
housekeepers.  The regexp 0 fits the bill, but is
inefficient because we had to type 0 twice.  It would be nice to
have parts of the regexp be constant, like 0, and some
parts have alternatives, like 0.

allows parts of a regexp to be treated as a single unit.  Parts of a
regexp are grouped by enclosing them in parentheses.  Thus we could solve
the 0 by forming the regexp as
0.  The regexp 0 means match
0 followed by either 0 or 0.  Some more examples
are

string position, the leftmost alternative that allows the regexp to
match is taken.  So in the last example at the first string position,
0 matches the second alternative, but there is nothing left over
to match the next two digits 0.  So Perl moves on to the next
alternative, which is the null alternative and that works, since
0 is two digits.

moving on to the next alternative, while going back in the string
from where the previous alternative was tried, if it doesn't, is called
0.  The term 'backtracking' comes from the idea that
matching a regexp is like a walk in the woods.  Successfully matching
a regexp is like arriving at a destination.  There are many possible
trailheads, one for each string position, and each one is tried in
order, left to right.  From each trailhead there may be many paths,
some of which get you there, and some which are dead ends.  When you
walk along a trail and hit a dead end, you have to backtrack along the
trail to an earlier point to try another trail.  If you hit your
destination, you stop immediately and forget about trying all the
other trails.  You are persistent, and only if you have tried all the
trails from all the trailheads and not arrived at your destination, do
you declare failure.  To be concrete, here is a step-by-step analysis
of what Perl does when it tries to match the regexp

end.  So backtrack two characters and pick the second alternative in
the first group 'abc'.

and have satisfied the first group. Set  to 'abc'.

'df'.

end.  Backtrack one character and pick the second alternative in the
second group 'd'.

'd'.

matched 'abcd' out of the string "abcde".

third alternative in the second group 'de' also allows a match, but we
stopped before we got to it - at a given character position, leftmost
wins.  Second, we were able to get a match at the first character
position of the string 'a'.  If there were no matches at the first
position, Perl would move to the second character position 'b' and
attempt the match all over again.  Only when all possible paths at all
possible character positions have been exhausted does Perl give
up and declare S<0 to be false.

speed things up, Perl compiles the regexp into a compact sequence of
opcodes that can often fit inside a processor cache.  When the code is
executed, these opcodes can then run at full throttle and search very
quickly.

different function: they allow the extraction of the parts of a string
that matched.  This is very useful to find out what matched and for
text processing in general.  For each grouping, the part that matched
inside goes into the special variables 0, 0, etc.  They can be
used just as ordinary variables:

S<0 returns a true or false
value.  In list context, however, it returns the list of matched values
0.  So we could write the code more compactly as

leftmost opening parenthesis, 0 the next opening parenthesis,
etc.  Here is a regexp with nested groups:

0, 0 is either set to 0 or 0, 0 equals either
0 or 0, and 0 is either set to 0, just like 0,
or it remains undefined.

0, 0,... that got assigned (and, somewhat related, 0 to the
value of the 0, 0,... most-recently assigned; i.e. the 0,
0,... associated with the rightmost closing parenthesis used in the
match).

the 0 0, 0,...  Backreferences are simply
matching variables that can be used 0 a regexp.  This is a
really nice feature; what matches later in a regexp is made to depend on
what matched earlier in the regexp.  Suppose we wanted to look
for doubled words in a text, like 'the the'.  The following regexp finds
all 3-letter doubles with a space in between:

is used for both parts.

combinations, then 3-letter combinations, etc., and uses 0 to look for
a repeat.  Although 0 and 0 represent the same thing, care should be
taken to use matched variables 0, 0,... only 0 a regexp
and backreferences 0, 0,... only 0 a regexp; not doing
so may lead to surprising and unsatisfactory results.

backreference is errorprone as soon as there is more than one
capturing group.  A more convenient technique became available
with Perl 5.10: relative backreferences. To refer to the immediately
preceding capture group one now may write 0, the next but
last is available via 0, and so on.

for using relative backreferences is illustrated by the following example,
where a simple pattern for matching peculiar strings is used:

tempted to use it as a part of some other pattern:

after inserting the interpolated 0 and looking at the resulting
full text of the regexp is it obvious that the backreferences have
backfired. The subexpression 0 has snatched number 1 and
demoted the groups in 0 by one rank. This can be avoided by
using relative backreferences:

To attach a name to a capturing group, you write either
 or .  The backreference may
then be written as 0.  It is permissible to attach the
same name to more than one group, but then only the leftmost one of the
eponymous set can be referenced.  Outside of the pattern a named
capture group is accessible through the 0 hash.

of the three formats yyyy-mm-dd, mm/dd/yyyy or dd.mm.yyyy, we can write
three suitable patterns where we use 'd', 'm' and 'y' respectively as the
names of the groups capturing the pertaining components of a date. The
matching operation combines the three patterns as alternatives:

three key-value pairs.

deals with the problem of referring to groups within a set of alternatives.
Consider a pattern for matching a time of the day, civil or military style:

whether 0 and 0 or 0 and 0 contain the goodies. It would
be easier if we could use group numbers 1 and 2 in second alternative as
well, and this is exactly what the parenthesized construct 0,
set around an alternative achieves. Here is an extended version of the
previous pattern:

position for each alternative. After the group, numbering continues
with one higher than the maximum reached across all the alternatives.

positions of what was matched as contents of the 0 and 0
arrays. 0 is the position of the start of the entire match and
0 is the position of the end. Similarly, 0 is the
position of the start of the 0 match and 0 is the position
of the end. If 0 is undefined, so are 0 and 0. Then
this code

find out what exactly matched in a string.  If you use them, Perl
will set 0 to the part of the string before the match, will set 0
to the part of the string that matched, and will set 0 to the part
of the string after the match.  An example:

first character position in the string and stopped; it never saw the
second 'the'.  It is important to note that using 0 and 0
slows down regexp matching quite a bit, while 0 slows it down to a
lesser extent, because if they are used in one regexp in a program,
they are generated for 0 regexps in the program.  So if raw
performance is a goal of your application, they should be avoided.
If you need to extract the corresponding substrings, use 0 and
0 instead:

variables may be used. These are only set if the 0 modifier is present.
Consequently they do not penalize the rest of the program.

useful as a capturing group.  If it isn't, it just creates a superfluous
addition to the set of available capture group values, inside as well as
outside the regexp.  Non-capturing groupings, denoted by 0,
still allow the regexp to be treated as a single unit, but don't establish
a capturing group at the same time.  Both capturing and non-capturing
groupings are allowed to co-exist in the same regexp.  Because there is
no extraction, non-capturing groupings are faster than capturing
groupings.  Non-capturing groupings are also handy for choosing exactly
which parts of a regexp are to be extracted to matching variables:

elements gathered from a split operation where parentheses are
required for some reason:

were only matching 3-letter words, or chunks of words of 4 letters or
less.  We'd like to be able to match words or, more generally, strings
of any length, without writing out tedious alternatives like
0.

0, 0, and 0 were created for.  They allow us to delimit the
number of repeats for a portion of a regexp we consider to be a
match.  Quantifiers are put immediately after the character, character
class, or grouping that we want to specify.  They have the following
meanings:

times.

string as possible, while still allowing the regexp to succeed.  Thus
with 0, Perl will first try to match the regexp with the 0
present; if that fails, Perl will try to match the regexp without the
0 present.  For the quantifier 0, we get the following:

string and locks onto it.  Consider, however, this regexp:

stop there, but that wouldn't give the longest possible string to the
first quantifier 0.  Instead, the first quantifier 0 grabs as
much of the string as possible while still having the regexp match.  In
this example, that means having the 0 sequence with the final 0
in the string.  The other important principle illustrated here is that,
when there are two or more elements in a regexp, the 0
quantifier, if there is one, gets to grab as much of the string as
possible, leaving the rest of the regexp to fight over scraps.  Thus in
our example, the first quantifier 0 grabs most of the string, while
the second quantifier 0 gets the empty string.   Quantifiers that
grab as much of the string as possible are called 0 or
0 quantifiers.

the principles above to predict which way the regexp will match:

earliest possible position in the string.

that allows a match for the whole regexp will be the one used.

0 will in general match as much of the string as possible while
still allowing the whole regexp to match.

leftmost greedy quantifier, if any, will match as much of the string
as possible while still allowing the whole regexp to match.  The next
leftmost greedy quantifier, if any, will try to match as much of the
string remaining available to it as possible, while still allowing the
whole regexp to match.  And so on, until all the regexp elements are
satisfied.

will be matched as early as possible, with the other principles
determining how the regexp matches at that earliest character
position.

might think that 0, being leftmost in the alternation, would be
matched, but 0 produces the longest string in the first quantifier.

0. 0 is the first quantifier, so it gets to match
a maximal 0.

quantifier 0 grabs as much as possible, leaving just a single
0 for the second quantifier 0.

position in the string, 0 in 0, leaving 0
the opportunity to match both 0's. Finally,

string.  If you definitely want to match at least one 0, use
0, not 0.

match a 0 piece of string, rather than a maximal piece.  For
this purpose, Larry Wall created the 0 or
0 quantifiers 0, 0, 0, and 0.  These are
the usual quantifiers with a 0 appended to them.  They have the
following meanings:

but as few times as possible

as few times as possible

times, as few times as possible

possible

0 times, 0 is equivalent to 0 and is just there for
notational consistency.

and the alternation to match is 0, with the alternation 0
matching 0.  The second quantifier 0 is free to gobble up the
rest of the string.

0 in 0. At this position, the minimal 0
matches just one 0.  Although the second quantifier 0 would
prefer to match no characters, it is constrained by the end-of-string
anchor 0 to match the rest of the string.

to match the empty string, because it is not constrained by a 0
anchor to match the beginning of the word.  Principle 0 applies here,
however.  Because it is possible for the whole regexp to match at the
start of the string, it 0 match at the start of the string.  Thus
the first quantifier has to match everything up to the first 0.  The
second minimal quantifier matches just one 0 and the third
quantifier matches the rest of the string.

earliest at position 0, so it does.  The second quantifier is
greedy, so it matches 0, and the third matches the rest of the
string.

quantifiers:

leftmost greedy (non-greedy) quantifier, if any, will match as much
(little) of the string as possible while still allowing the whole
regexp to match.  The next leftmost greedy (non-greedy) quantifier, if
any, will try to match as much (little) of the string remaining
available to it as possible, while still allowing the whole regexp to
match.  And so on, until all the regexp elements are satisfied.

backtracking.  Here is a step-by-step analysis of the example

string 'the cat in the hat'.

string.  Backtrack one character.

letter of the string 't', so backtrack one more character.

the string and '.*' can match 0 times, assign it the empty string.

quickly and searching is fast. There are some pathological regexps,
however, whose execution time exponentially grows with the size of the
string.  A typical structure that blows up in your face is of the form

different ways of partitioning a string of length n between the 0
and 0: one repetition with 0 of length n, two repetitions with
the first 0 length k and the second with length n-k, m repetitions
whose bits add up to length n, etc.  In fact there are an exponential
number of ways to partition a string as a function of its length.  A
regexp may get lucky and match early in the process, but if there is
no match, Perl will try 0 possibility before giving up.  So be
careful with nested 0's, 0's, and 0's.  The book
0 by Jeffrey Friedl gives a wonderful
discussion of this and other efficiency issues.

of time, particularly when the match is bound to fail.  Consider
the simple pattern

pattern's expectations such as S<0 or S<0,
the regex engine will backtrack, approximately once for each character
in the string.  But we know that there is no way around taking 0
of the initial word characters to match the first repetition, that 0
spaces must be eaten by the middle part, and the same goes for the second
word.

have a way of instructing the regex engine not to backtrack, with the
usual quantifiers with a 0 appended to them.  This makes them greedy as
well as stingy; once they succeed they won't give anything back to permit
another solution. They have the following meanings:

as many times as possible, and don't give anything up. 0 is short
for 0

and don't give anything up. 0 is short for 0 and 0 is
short for 0.

notational consistency.

concept, the 0, see below.

matching a quoted string, as it appears in several programming languages.
The backslash is used as an escape character that indicates that the
next character is to be taken literally, as another character for the
string.  Therefore, after the opening quote, we expect a (possibly
empty) sequence of alternatives: either some character except an
unescaped quote or backslash or an escaped character.

give a more involved example of a regular expression.  We will build a
regexp that matches numbers.

and what we want to exclude.  In our case, we want to match both
integers and floating point numbers and we want to reject any string
that isn't a number.

are easily converted into a regexp.

with an optional sign in front.  The digits we can represent with
0 and the sign can be matched with 0.  Thus the integer
regexp is

decimal point, a fractional part, and an exponent.  One or more of these
parts is optional, so we need to check out the different
possibilities.  Floating point numbers which are in proper form include
123., 0.345, .34, -1e6, and 25.4E-72.  As with integers, the sign out
front is completely optional and can be matched by 0.  We can
see that if there is no exponent, floating point numbers must have a
decimal point, otherwise they are integers.  We might be tempted to
model these with 0, but this would also match just a single
decimal point, which is not a number.  So the three cases of floating
point number without exponent are

0.  If 0 were first, the regexp would happily match that
and ignore the fractional part of the number.

observation here is that 0 integers and numbers with decimal
points are allowed in front of an exponent.  Then exponents, like the
overall sign, are independent of whether we are matching numbers with
or without decimal points, and can be 'decoupled' from the
mantissa.  The overall form of the regexp now becomes clear:

exponent regexp is

decipher.  In complex situations like this, the 0 modifier for a
match is invaluable.  It allows one to put nearly arbitrary whitespace
and comments into a regexp without affecting their meaning.  Using it,
we can rewrite our 'extended' regexp in the more pleasing form

characters in an extended regexp? The answer is to backslash it
S<0 or put it in a character class S<0.  The same thing
goes for pound signs: use 0 or 0.  For instance, Perl allows
a space between the sign and the mantissa or integer, and we could add
this to our regexp as follows:

alternation.  Alternatives 1, 2, and 4 all start with 0, so it
could be factored out:

program.  This makes perfect sense, because regular expressions are
essentially programs written in a little computer language that specifies
patterns.

programs.  Where do they fit into Perl syntax?

0 and arbitrary delimiter 0 forms.  We have used
the binding operator 0 and its negation 0 to test for string
matches.  Associated with the matching operator, we have discussed the
single line 0, multi-line 0, case-insensitive 0 and
extended 0 modifiers.  There are a few more things you might
want to know about matching operators.

will ignore it.  If you don't want any substitutions at all, use the
special delimiter 0:

0 delimiters act like quotes.  If the regexp evaluates to the empty string,
the regexp in the 0 is used instead.  So we have

0 and 0, concern multiple matches.
The modifier 0 stands for global matching and allows the
matching operator to match within a string as many times as possible.
In scalar context, successive invocations against a string will have
0 jump from match to match, keeping track of position in the
string as it goes along.  You can get or set the position with the
0 function.

a string that consists of words separated by spaces.  If we know how
many words there are in advance, we could extract the words using
groupings:

of task 0 was made for.  To extract all words, form the simple
regexp 0 and loop over all matches with 0:

you don't want the position reset after failure to match, add the
0, as in 0.  The current position in the string is
associated with the string, not the regexp.  This means that different
strings have different positions and their respective positions can be
set or read independently.

there are no groupings, a list of matches to the whole regexp.  So if
we wanted just the words, we could use

0 anchor matches at the point where the previous 0 match left
off.  0 allows us to easily do context-sensitive matching:

bit at a time and use arbitrary Perl logic to decide what to do next.
Currently, the 0 anchor is only fully supported when used to anchor
to the start of the pattern.

regexps.  Suppose we have a snippet of coding region DNA, encoded as
base pair letters 0 and we want to find all the stop
codons 0.  In a coding region, codons are 3-letter sequences, so
we can think of the DNA snippet as a sequence of 3-letter records.  The
naive regexp

the match is aligned with codon boundaries, e.g., the substring
S<0 gives a match.  A better solution is

real match.  Then the regexp will fail to match a synchronized 0
and start stepping ahead one character position at a time, not what we
want.  The solution is to use 0 to anchor the match to the codon
alignment:

important not only to match what is desired, but to reject what is not
desired.

0, 0, and 0, but their specialized uses are beyond the
scope of this introduction.  )

operations in Perl.  Search and replace is accomplished with the
0 operator.  The general form is
0, with everything we know about
regexps and modifiers applying in this case as well.  The
0 is a Perl double-quoted string that replaces in the
string whatever is matched with the 0.  The operator 0 is
also used here to associate a string with 0.  If matching
against 0, the S<0 can be dropped.  If there is a match,
0 returns the number of substitutions made; otherwise it returns
false.  Here are a few examples:

inside the single quotes was grouped.  With the 0 operator, the
matched variables 0, 0, etc. are immediately available for use
in the replacement expression, so we use 0 to replace the quoted
string with just what was quoted.  With the global modifier, 0
will search and replace all occurrences of the regexp in the string:

the following program to replace it:

occurrences of the regexp on each line.  (Even though the regular
expression appears in a loop, Perl is smart enough to compile it
only once.)  As with 0, both the
0 and the 0 use 0 implicitly.

the non-destructive substitute modifier, 0.  This changes the
behavior so that 0 returns the final substituted string
(instead of the number of substitutions):

0 variable has not been affected. The overall
result of the substitution is instead stored in 0. If the
substitution doesn't affect anything then the original string is
returned:

substitutions:

0 evaluation modifier.  0 treats the
replacement text as Perl code, rather than a double-quoted
string.  The value that the code returns is substituted for the
matched substring.  0 is useful if you need to do a bit of
computation in the process of replacing text.  This example counts
character frequencies in a line:

such as 0 and 0, and even 0.  If single quotes are
used 0, then the regexp and replacement are
treated as single-quoted strings and there are no
variable substitutions.  0 in list context
returns the same thing as in scalar context, i.e., the number of
matches.

0 separates the 0 operand into
a list of substrings and returns that list.  The regexp must be designed
to match whatever constitutes the separators for the desired substrings.
The 0, if present, constrains splitting into no more than 0
number of strings.  For example, to split a string into words, use

the string is split into individual characters.  If the regexp has
groupings, then the resulting list contains the matched substrings from the
groupings as well.  For instance,

an empty initial element to the list.

tools needed to use regular expressions to solve a wide range of text
processing problems.  If this is your first time through the tutorial,
why not stop here and play around with regexps a while....  0
concerns the more esoteric aspects of regular expressions and those
concepts certainly aren't needed right at the start.

matching regular expressions is analogous to a walk in the woods, then
the tools discussed in Part 1 are analogous to topo maps and a
compass, basic tools we use all the time.  Most of the tools in part 2
are analogous to flare guns and satellite phones.  They aren't used
too often on a hike, but when we are stuck, they can be invaluable.

capabilities of Perl regexps.  In Part 2, we will assume you are
comfortable with the basics and concentrate on the advanced features.

haven't covered yet.

between upper and lower case, and they are also available within
patterns.  0 and 0 convert the next character to lower or
upper case, respectively:

terminated by 0 or thrown over by another 0 or 0:

string. The regexps 0 or 0 convert the first
character of 0 to uppercase and the rest of the characters to
lowercase.

character would be matched with 0.  The escape sequence
0...0 quotes, or protects most non-alphabetic characters.   For
instance,

substituted.

double-quotish syntax, and not part of regexp syntax proper.  They will
work if they appear in a regular expression embeddded directly in a
program, but not when contained in a string that is interpolated in a
pattern.

standard ASCII character set.  Perl now supports 0, a standard
for representing the alphabets from virtually all of the world's written
languages, and a host of symbols.  Perl's text strings are Unicode strings, so
they can contain characters with a value (codepoint or character number) higher
than 255.

much about Perl's internal representation of strings.  But they do need
to know 1) how to represent Unicode characters in a regexp and 2) that
a matching operation will treat the string to be searched as a sequence
of characters, not bytes.  The answer to 1) is that Unicode characters
greater than 0 are represented using the 0 notation, because
\x hex (without curly braces) doesn't go further than 255.  (Starting in Perl
5.14, if you're an octal fan, you can also use 0 to use any Unicode features.  This is no more the case: for
almost all Unicode processing, the explicit 0 pragma is not
needed.  (The only case where it matters is if your Perl script is in
Unicode and encoded in UTF-8, then an explicit 0 is needed.)

or deciphering someone else's hexadecimal Unicode regexp is about as
much fun as programming in machine code.  So another way to specify
Unicode characters is to use the 0 escape
sequence C<\N{0.  0 is a name for the Unicode character, as
specified in the Unicode standard.  For instance, if we wanted to
represent or match the astrological sign for the planet Mercury, we
could use

(available at 0).

uses Unicode characters.  (For messy backward compatibility reasons,
most but not all semantics of a match will assume Unicode, unless,
starting in Perl 5.14, you tell it to use full Unicode.  You can do this
explicitly by using the 0 modifier, or you can ask Perl to use the
modifier implicitly for all regexes in a scope by using 0 (or
higher) or 0.)  If you want to handle
Unicode properly, you should ensure that one of these is the case.)
Internally, this is encoded to bytes using either UTF-8 or a native 8
bit encoding, depending on the history of the string, but conceptually
it is a sequence of characters, not bytes. See 0 for a
tutorial about that.

characters, there are named Unicode character classes represented by the
0 escape sequence.  Closely associated is the 0
character class, which is the negation of the 0 class.  For
example, to match lower and uppercase characters,

traditional Unicode classes:

0, like 0 for Unicode 'letters', 0 for uppercase
letters, or 0 for non-digits.  If a 0 is just one
letter, the braces can be dropped.  For instance, 0 is the
character class of Unicode 'marks', for example accent marks.
For the full list see 0.

which you can test with 0 (in) and 0 (not in).
To test whether a character is (or is not) an element of a script
you would use the script name, for example 0, 0,
or 0.

classes.  There is also a compound form which you may run into.  These
look like 0 or 0 (the equals sign and colon
can be used interchangeably).  These are more general than the single form,
and in fact most of the single forms are just Perl-defined shortcuts for common
compound forms.  For example, the script examples in the previous paragraph
could be written equivalently as 0, 0, and
0 (case is irrelevant between the 0 braces).  You may
never have to use the compound forms, but sometimes it is necessary, and their
use can make your code easier to understand.

a Unicode 0.  This represents a "logical character":
what appears to be a single character, but may be represented internally by more
than one.  As an example, using the Unicode full names, e.g., S<0 is a grapheme cluster with base character 0 and combining character
S<0, which translates in Danish to A with the circle atop it,
as in the word Angstrom.

Unicode standard, or the Unicode Consortium's website 0

character classes.  These have the form 0, with 0 the
name of the POSIX class.  The POSIX classes are 0, 0,
0, 0, 0, 0, 0, 0, 0,
0, 0, and 0, and two extensions, 0 (a Perl
extension to match 0), and 0 (a GNU extension).  The 0
modifier restricts these to matching just in the ASCII range; otherwise
they can match the same as their corresponding Perl Unicode classes:
0 is the same as 0, etc.  (There are some
exceptions and gotchas with this; see 0 for a full
discussion.) The 0, 0, and
0 correspond to the familiar 0, 0, and 0
character classes.  To negate a POSIX class, put a 0 in front of
the name, so that, e.g., 0 corresponds to 0 and, under
Unicode, 0.  The Unicode and POSIX character classes can
be used just like 0, with the exception that POSIX character
classes can only be used inside of a character class:

sequence of opcodes.  Thus, a compiled regexp is a data structure
that can be stored once and used again and again.  The regexp quote
0 does exactly that: 0 compiles the 0 as a
regexp and transforms the result into a form that can be assigned to a
variable:

delimiters, e.g., 0, 0 or 0.  Apostrophes
as delimiters (0) inhibit any interpolation.

don't need to be recompiled each time they are encountered.  Using
pre-compiled regexps, we write a 0 program which greps
for a sequence of patterns, advancing to the next pattern as soon
as one has been satisfied.

simply loop through the regexps without any recompilation, thus gaining
flexibility without sacrificing speed.

expressions.  If there are several regular expressions and a match with
any of them is acceptable, then it is possible to combine them into a set
of alternatives.  If the individual expressions are input data, this
can be done by programming a join operation.  We'll exploit this idea in
an improved version of the 0 program: a program that matches
multiple patterns:

that is to be analyzed and use the permissible values on the left
hand side of the matching operations.  As an example for this somewhat
paradoxical situation, let's assume that our input contains a command
verb which should match one out of a set of available command verbs,
with the additional twist that commands may be abbreviated as long as
the given string is unique. The program below demonstrates the basic
algorithm.

combined set of keywords against the input.  The pattern matching
operation S<0 does several things at the
same time. It makes sure that the given command begins where a keyword
begins (0). It tolerates abbreviations due to the added 0. It
tells us the number of matches (0) and all the keywords
that were actually matched.  You could hardly ask for more.

0.  These are extensions to the traditional regular
expression syntax that provide powerful new tools for pattern
matching.  We have already seen extensions in the form of the minimal
matching constructs 0, 0, 0, 0, and 0.  Most
of the extensions below have the form 0, where the
0 is a character that determines the type of extension.

comment into the regular expression without affecting its meaning.  The
comment should not have any closing parentheses in the text.  An
example is

freeform commenting that is allowed with the 0 modifier.

combination thereof) can also be embedded in
a regexp using 0, 0, 0, and 0.  For instance,

modifiers.  Embedded modifiers allow a custom set of modifiers to
0 regexp pattern.  This is great for matching an array of regexps
that must have different modifiers:

modifies the entire regexp) only affect the regexp
inside the group the embedded modifier is contained in.  So grouping
can be used to localize the modifier's effects:

by using, e.g., 0.  Modifiers can also be combined into
a single expression, e.g., 0 turns on single line mode and
turns off case insensitivity.

0 is a non-capturing grouping that matches 0
case insensitively and turns off multi-line mode.

a little background.

amount of string when they match.  For instance, the regexp element
0 eats up one character of the string when it matches, in the
sense that Perl moves to the next character position in the string
after the match.  There are some elements, however, that don't eat up
characters (advance the character position) if they match.  The examples
we have seen so far are the anchors.  The anchor 0 matches the
beginning of the line, but doesn't eat any characters.  Similarly, the
word boundary anchor 0 matches wherever a character matching 0
is next to a character that doesn't, but it doesn't eat up any
characters itself.  Anchors are examples of 0:
zero-width, because they consume
no characters, and assertions, because they test some property of the
string.  In the context of our walk in the woods analogy to regexp
matching, most regexp elements move us along a trail, but anchors have
us stop a moment and check our surroundings.  If the local environment
checks out, we can proceed forward.  But if the local environment
doesn't satisfy us, we must backtrack.

looking behind, or both.  0 looks behind, to see that there are no
characters before.  0 looks ahead, to see that there are no
characters after.  0 looks both ahead and behind, to see if the
characters on either side differ in their "word-ness".

anchor concept.  Lookahead and lookbehind are zero-width assertions
that let us specify which characters we want to test for.  The
lookahead assertion is denoted by 0 and the lookbehind
assertion is denoted by .  Some examples are

non-capturing, since these are zero-width assertions.  Thus in the
second regexp, the substrings captured are those of the whole regexp
itself.  Lookahead 0 can match arbitrary regexps, but
lookbehind  only works for regexps of fixed
width, i.e., a fixed number of characters long.  Thus
 is fine, but  is not.  The
negated versions of the lookahead and lookbehind assertions are
denoted by 0 and  respectively.
They evaluate true if the regexps do 0 match:

treacherous definition of 0 would become even more so
when going backwards.

numbers and single dashes is to be split into its components.
Using 0 alone won't work, because spaces are not required between
dashes, or a word or a dash. Additional places for a split are established
by looking ahead and behind:

context of a larger regular expression, that function independently of
the larger regular expression.  That is, they consume as much or as
little of the string as they wish without regard for the ability of
the larger regexp to match.  Independent subexpressions are represented
by .  We can illustrate their behavior by first
considering an ordinary regexp:

subexpression 0 first grabbed the 0.  Doing so, however,
wouldn't allow the whole regexp to match, so after backtracking, 0
eventually gave back the 0 and matched the empty string.  Here, what
0 matched was 0 on what the rest of the regexp matched.

of the regexp, so it sees an 0 and grabs it.  Then the rest of the
regexp 0 cannot match.  Because  is independent, there
is no backtracking and the independent subexpression does not give
up its 0.  Thus the match of the regexp as a whole fails.  A similar
behavior occurs with completely independent regexps:

one regexp to the other.  Regexps with an independent subexpression are
much like this, with a handoff of the string to the independent
subexpression, and a handoff of the string back to the enclosing
regexp.

can be quite useful.  Suppose we want to match a non-empty string
enclosed in parentheses up to two levels deep.  Then the following
regexp matches:

alternation, and a close parenthesis.  The alternation is two-way, with
the first alternative 0 matching a substring with no
parentheses and the second alternative 0  matching a
substring delimited by parentheses.  The problem with this regexp is
that it is pathological: it has nested indeterminate quantifiers
of the form 0.  We discussed in Part 1 how nested quantifiers
like this could take an exponentially long time to execute if there
was no match possible.  To prevent the exponential blowup, we need to
prevent useless backtracking at some point.  This can be done by
enclosing the inner quantifier as an independent subexpression:

by gobbling up as much of the string as possible and keeping it.   Then
match failures fail much more quickly.

that allows one to choose which patterns are to be matched, based on
some condition.  There are two types of conditional expression:
0 and
0.  0 is
like an S<0 statement in Perl.  If the 0 is true,
the 0 will be matched.  If the 0 is false, the
0 will be skipped and Perl will move onto the next regexp
element.  The second form is like an S<0 statement
in Perl.  If the 0 is true, the 0 will be
matched, otherwise the 0 will be matched.

integer in parentheses 0.  It is true if the corresponding
backreference 0 matched earlier in the regexp.  The same
thing can be done with a name associated with a capture group, written
as  or .  The second form is a bare
zero-width assertion 0, either a lookahead, a lookbehind, or a
code assertion (discussed in the next section).  The third set of forms
provides tests that return true if the expression is executed within
a recursion (0) or is being called from some capturing group,
referenced either by number (0, 0,...) or by name
(0).

with more flexibility, what to match based on what matched earlier in the
regexp. This searches for words of the form 0 or 0:

an earlier part of the match to influence a later part of the
match.  For instance,

other base pair combination and 0.  Note that the form is
 and not ; for the
lookahead, lookbehind or code assertions, the parentheses around the
conditional are not needed.

Starting with Perl 5.10, it is possible to define named subpatterns in
a section of the pattern so that they can be called up by name
anywhere in the pattern.  This syntactic pattern for this definition
group is .  An insertion
of a named pattern is written as 0.

floating point numbers that was presented earlier on.  The three
subpatterns that are used more than once are the optional sign, the
digit sequence for an integer and the decimal fraction.  The DEFINE
group at the end of the pattern contains their definition.  Notice
that the decimal fraction pattern is the first place where we can
reuse the integer pattern.

power of Perl's pattern matching.  By referring to some other
capture group anywhere in the pattern with the construct
0, the 0 within the referenced group is used
as an independent subpattern in place of the group reference itself.
Because the group reference may be contained 0 the group it
refers to, it is now possible to apply pattern matching to tasks that
hitherto required a recursive parser.

a string contains a palindrome. (This is a word or a sentence that,
while ignoring spaces, interpunctuation and case, reads the same backwards
as forwards. We begin by observing that the empty string or a string
containing just one word character is a palindrome. Otherwise it must
have a word character up front and the same at its end, with another
palindrome in between.

have the full pattern:

The entire pattern can be reinserted with 0 or 0.
If you prefer to name your groups, you can use 0 to
recurse into that group.

0 expressions turn that around by allowing
arbitrary Perl code to be a part of a regexp.  A code evaluation
expression is denoted 0, with 0 a string of Perl
statements.

changed without notice.

depends on their environment.  There are two possibilities: either the
code expression is used as a conditional in a conditional expression
0, or it is not.  If the code expression is a
conditional, the code is evaluated and the result (i.e., the result of
the last statement) is used to determine truth or falsehood.  If the
code expression is not used as a conditional, the assertion always
evaluates true and the result is put into the special variable
0.  The variable 0 can then be used in code expressions later
in the regexp.  Here are some silly examples:

the 0 isn't going to match the target string. But look at this
example:

the above pattern should be effectively (almost) the same as the last one;
enclosing the 0 in a character class isn't going to change what it
matches. So why does the first not print while the second one does?

case, all the engine sees are plain old characters (aside from the
0 construct). It's smart enough to realize that the string 'ddd'
doesn't occur in our target string before actually running the pattern
through. But in the second case, we've tricked it into thinking that our
pattern is more complicated. It takes a look, sees our
character class, and decides that it will have to actually run the
pattern to determine whether or not it matches, and in the process of
running it hits the print statement before it discovers that we don't
have a match.

section 0 below.

backtracks in the process of searching for a match.  If the regexp
backtracks over a code expression and if the variables used within are
localized using 0, the changes in the variables produced by the
code expression are undone! Thus, if we wanted to count how many times
a character got matched inside a group, we could use, e.g.,

S<0, the variable changes are 0 undone
during backtracking, and we get

effects of code expression execution are permanent.  Thus

properly in the presence of backtracking.

definite article, either 'the' in English or 'der|die|das' in German:

0.  In other words, in the case of a
code expression, we don't need the extra parentheses around the
conditional.

may surprise you:

(2) a variable that interpolates a code expression, Perl treats the
regexp as an error. If the code expression is precompiled into a
variable, however, interpolating is ok. The question is, why is this
an error?

together pose a security risk.  The combination is dangerous because
many programmers who write search engines often take user input and
plug it directly into a regexp:

then execute arbitrary Perl code.  For instance, some joker could
search for S<0 to erase your files.  In this
sense, the combination of interpolation and code expressions 0
your regexp.  So by default, using both interpolation and code
expressions in the same regexp is not allowed.  If you're not
concerned about malicious users, it is possible to bypass this
security check by invoking S<0:

The pattern code expression is like a regular code expression, except
that the result of the code evaluation is treated as a regular
expression and matched immediately.  A simple example is

expressions.  It detects whether a binary string 0 has a
Fibonacci spacing 0,1,1,2,3,5,...  of the 0's:

completed capture group. This prints

regexp is compiled, as happens for ordinary variables outside a code
expression.  Rather, the code expressions are evaluated when Perl
encounters them during the search for a match.

when working with code and conditional expressions, the extended form of
regexps is almost necessary in creating and debugging regexps.

detailed control over the backtracking process, by directly influencing
the regexp engine and by providing monitoring techniques.  As all
the features in this group are experimental and subject to change or
removal in a future version of Perl, the interested reader is
referred to 0 for a
detailed description.

which may be abbreviated as 0. If this is inserted in a regexp
it will cause it to fail, just as it would at some
mismatch between the pattern and the string. Processing
of the regexp continues as it would after any "normal"
failure, so that, for instance, the next position in the string or another
alternative will be tried. As failing to match doesn't preserve capture
groups or produce results, it may be necessary to use this in
combination with embedded code.

this matches, a statement like 0 is executed, incrementing
the letter's counter. Then 0 does what it says, and
the regexp engine proceeds according to the book: as long as the end of
the string hasn't been reached, the position is advanced before looking
for another vowel. Thus, match or no match makes no difference, and the
regexp engine proceeds until the entire string has been inspected.
(It's remarkable that an alternative solution using something like

and debug regexps in Perl.  We have already encountered one pragma in
the previous section, S<0, that allows variable
interpolation and code expressions to coexist in a regexp.  The other
pragmas are

variable to be tainted as well.  This is not normally the case, as
regexps are often used to extract the safe bits from a tainted
variable.  Use 0 when you are not extracting safe bits, but are
performing some other processing.  Both 0 and 0 pragmas
are lexically scoped, which means they are in effect only until
the end of the block enclosing the pragmas.

5.14) turns on the given regular expression flags
until the end of the lexical scope.  See 0 for more
detail.

detailed debugging info about regexp compilation and
execution.  0 is the same as debug, except the debugging
information is displayed in color on terminals that can display
termcap color sequences.  Here is example output:

what the different parts of the debugging output tell you.  The first
part

starred object, in this case 0, and if it matches, goto line 4,
i.e., 0.  The middle lines describe some heuristics and
optimizations performed before a match:

process:

part of the string matched and  the part not yet
matched.  The S<> says that Perl is at line number 1
in the compilation list above.  See
0 for much more detail.

statements within the regexp.  This provides a blow-by-blow account of
the backtracking in an alternation:

are 0.  Don't use them in production code.  Yet.

expressions, see the 0 regular expressions reference page.

operators, see 0.  For
information on the 0 operation, see 0.

regular expressions, see the book 0 by
Jeffrey Friedl (published by O'Reilly, ISBN 1556592-257-3).

All rights reserved.

code example in chapter 7 of 0.

Haworth, Ronald J Kimball, and Joe Smith for all their helpful
comments.

=encoding utf8

executable, or else by passing the name of the source file as an
argument on the command line.  (An interactive Perl environment
is also possible--see 0 for details on how to do that.)
Upon startup, Perl looks for your program in one of the following
places:

(Note that systems supporting the #! notation invoke interpreters this
way. See 0.)

no filename arguments--to pass arguments to a STDIN-read program you
must explicitly specify a "-" for the program name.

beginning, unless you've specified a 0 switch, in which case it
scans for the first line starting with #! and containing the word
"perl", and starts there instead.  This is useful for running a program
embedded in a larger message.  (In this case you would indicate the end
of the program using the 0 token.)

parsed.  Thus, if you're on a machine that allows only one argument
with the #! line, or worse, doesn't even recognize the #! line, you
still can get consistent switch behavior regardless of how Perl was
invoked, even if 0 was used to find the beginning of the program.

kernel interpretation of the #! line after 32 characters, some
switches may be passed in on the command line, and some may not;
you could even get a "-" without its letter, if you're not careful.
You probably want to make sure that all your switches fall either
before or after that 32-character boundary.  Most switches don't
actually care if they're processed redundantly, but getting a "-"
instead of a complete switch could cause Perl to try to execute
standard input instead of your program.  And a partial 0 switch
could also cause odd results.

combinations of 0 and 0.  Either put all the switches after
the 32-character boundary (if applicable), or replace the use of
00 by 0.

The sequences "-*" and "- " are specifically ignored so that you could,
if you were so inclined, say

getting whatever version is first in the user's path.  If you want
a specific version of Perl, say, perl5.005_57, you should place
that directly in the #! line's path.

the #! is executed instead of the Perl interpreter.  This is slightly
bizarre, but it helps people on machines that don't do #!, because they
can tell a program that their SHELL is 0, and Perl will then
dispatch the program to the correct interpreter for them.

internal form.  If there are any compilation errors, execution of the
program is not attempted.  (This is unlike the typical shell script,
which might run part-way through before finding a syntax error.)

runs off the end without hitting an  or  operator, an implicit
0 is provided to indicate successful completion.

0 0

`extproc' handling).

0 (see the 0 file in the source
distribution for more information).

will modify the Registry to associate the 0 extension with the perl
interpreter.  If you install Perl by other means (including building from
the sources), you may have to modify the Registry yourself.  Note that
this means you can no longer tell the difference between an executable
Perl program and a Perl library file.

want to pass to Perl.  You can now invoke the program directly, by saying
0, or as a DCL procedure, by saying 0 (or implicitly
via 0 by just using the name of the program).

you if you say 0.

on quoting than Unix shells.  You'll need to learn the special
characters in your command-interpreter (0, 0 and 0 are
common) and how to protect whitespace and these characters to run
one-liners (see 0 below).

which you must 0 do on Unix or Plan 9 systems.  You might also
have to change a single % to a %%.

command and it is entirely possible neither works.  If 0 were
the command shell, this would probably work better:

when nobody was looking, but just try to find documentation for its
quoting rules.

0

easily find it.  When possible, it's good for both 0
and 0 to be symlinks to the actual binary.  If
that can't be done, system administrators are strongly encouraged
to put (symlinks to) perl and its accompanying utilities into a
directory typically found along a user's PATH, or in some other
obvious and convenient place.

will stand in for whatever method works on your system.  You are
advised to use a specific path if you care about a specific version.

like this at the top of your program:

0 0

clustered with the following switch, if any.

0 0

hexadecimal number.  If there are no digits, the null character is the
separator.  Other switches may precede or follow the digits.  For
example, if you have a version of 0 which can print filenames
terminated by the null character, you can say this:

Any value 0400 or above will cause Perl to slurp files whole, but by convention
the value 0777 is the one normally used for this purpose.

0, where the 0 are valid hexadecimal digits.  Unlike the octal
form, this one may be used to specify any Unicode character, even those beyond
0xFF.
(This means that you cannot use the 0 with a directory name that
consists of hexadecimal digits.)

0 0

split command to the @F array is done as the first thing inside the
implicit while loop produced by the 0 or 0.

0

of option letters.  The letters, their numeric values, and effects
are as follows; listing the letters is equal to summing the numbers.

perl.h gives W/128 as PERL_UNICODE_WIDESYSCALLS "/* for Sarathy */"

perltodo mentions Unicode in %ENV and filenames. I guess that these will be
options e and f (or F).

STDOUT and STDERR.  Repeating letters is just redundant, not cumulative
nor toggling.

operations) in the current file scope will have the 0 PerlIO layer
implicitly applied to them, in other words, UTF-8 is expected from any
input stream, and UTF-8 is produced to any output stream.  This is just
the default, with explicit layers in  and with  one can
manipulate streams as usual.

empty string 0 for the 0 environment variable, has the
same effect as 0.  In other words, the standard I/O handles and
the default 0 layer are UTF-8-fied 0 only if the locale
environment variables indicate a UTF-8 locale.  This behaviour follows
the 0 (and problematic) UTF-8 behaviour of Perl 5.8.0.

disable all the above Unicode features.

of this setting.  This variable is set during Perl startup and is
thereafter read-only.  If you want runtime effects, use the three-arg
 (see 0), the two-arg  (see 0),
and the 0 pragma (see 0).

that enabled the use of Unicode-aware "wide system call" Win32 APIs.
This feature was practically unused, however, and the command line
switch was therefore "recycled".)

must be specified on the command line as well, since the standard streams
are already set up at this point in the execution of the perl interpreter.
You can also use  to set the encoding of an I/O stream.

0

executing it.  Actually, it 0 execute 0, 0,
0, and 0 blocks, because these are considered as occurring
outside the execution of your program.  0 and 0 blocks,
however, will be skipped.

0 0

If 0 is specified, it indicates to the debugger that threads
will be used in the code being debugged.

0 0

tracing module installed as Devel::foo. E.g., 0 executes
the program using the Devel::DProf profiler.  As with the 0
flag, options may be passed to the Devel::foo package where they
will be received and interpreted by the Devel::foo::import routine.
Again, like 0, use -d:-foo to call Devel::foo::unimport instead of import.
The comma-separated list of options must follow a 0 character.
If 0 is specified, it indicates to the debugger that threads
will be used in the code being debugged.
See 0.

0 0 0

0.  (This works only if debugging is compiled into your
Perl.)  Another nice value is 0, which lists your compiled
syntax tree.  And 0 displays compiled regular expressions;
the format of the output is explained in 0.

0 is equivalent to 0):

executable (but see 0 in 0 or 0
which may change this).
See the 0 file in the Perl source distribution
for how to do this.  This flag is automatically set if you include 0
option when 0 asks you about optimizer/debugger flags.

as it executes, the way that 0 provides for shell scripts,
you can't use Perl's 0 switch.  Instead do this

0

will not look for a filename in the argument list.  Multiple 0
commands may be given to build up a multi-line script.  Make sure
to use semicolons where you would in a normal program.

0

optional features (in the main compilation unit). See 0.

0 0 0

0 at startup (in a BEGIN block).
This is a hook that allows the sysadmin to customize how perl behaves.
It can for instance be used to add entries to the @INC array to make perl
find modules in non-standard locations.

doesn't need to return a true value. The code is run in package 0,
in its own lexical scope. However, if the script dies, 0 will not
be set.

read from 0, which is not loaded.

0 will show up in the output of `perl -V`. Of course, 0
blocks will be likewise executed very late.

perl, you can check the value of 0.

0

pattern may be surrounded by 0, 0, or 0, otherwise it will be
put in single quotes. You can't use literal whitespace in the pattern.

0

0 0

edited in-place.  It does this by renaming the input file, opening the
output file by the original name, and selecting that output file as the
default for  statements.  The extension, if supplied, is used to
modify the name of the old file to make a backup copy, following these
rules:

overwritten.

end of the current filename as a suffix.  If the extension does
contain one or more 0 characters, then each 0 is replaced
with the current filename.  In Perl terms, you could think of this
as:

addition to) a suffix:

directory (provided the directory already exists):

know when the filename has changed.  It does, however, use ARGVOUT for
the selected filehandle.  Note that STDOUT is restored as the default
output filehandle after the loop.

is actually changed.  So this is just a fancy way to copy files:

or

file, in case you want to append to each file, or reset line numbering
(see example in 0).

specified in the extension then it will skip that file and continue on
with the next one (if it exists).

see 0.

files.

folks use it for their backup files:

creating a new file of the same name, Unix-style soft and hard links will
not be preserved.

files are given on the command line.  In this case, no backup is made
(the original file cannot, of course, be determined) and processing
proceeds from STDIN to STDOUT as might be expected.

0 0

modules (0).

0 0 0

effects.  First, it automatically chomps 0 (the input record
separator) when used with 0 or 0.  Second, it assigns 0
(the output record separator) to have the value of 0 so
that any print statements will have that separator added back on.
If 0 is omitted, sets 0 to the current value of
0.  For instance, to trim lines to 80 columns:

so the input record separator can be different than the output record
separator if the 0 switch is followed by a 0 switch:

0 0

program.

program.  You can use quotes to add extra code after the module name,
e.g., 0.

then the 'use' is replaced with 'no'.

0 or 0 as a shortcut for
0.  This avoids the need to use quotes when
importing symbols.  The actual code generated by 0 is
0.  Note that the 0 form
removes the distinction between 0 and 0.

(unless 0 itself is set up to do a version check, which
could happen for example if Foo inherits from Exporter.)

0

makes it iterate over filename arguments somewhat like 0 or
0:

lines printed.  If a file named by an argument cannot be opened for
some reason, Perl warns you about it and moves on to the next file.

0, which doesn't necessarily interpret them as file names.
See  0 for possible security implications.

at least a week:

have to start a process on every filename found.  It does suffer from
the bug of mishandling newlines in pathnames, which you can fix if
you follow the example under 0.

the implicit program loop, just as in 0.

0

makes it iterate over filename arguments somewhat like 0:

warns you about it, and moves on to the next file.  Note that the
lines are printed automatically.  An error occurring during printing is
treated as fatal.  To suppress printing use the 0 switch.  A 0
overrides a 0 switch.

the implicit loop, just as in 0.

0

line after the program name but before any filename arguments (or before
an argument of 0).  Any switch found there is removed from @ARGV and sets the
corresponding variable in the Perl program.  The following program
prints "1" if the program is invoked with a 0 switch, and "abc"
if it is invoked with 0.

with 0.  Also, when using this option on a script with
warnings enabled you may get a lot of spurious "used only once" warnings.

0

program (unless the name of the program contains directory separators).

filename while searching for it.  For example, on Win32 platforms,
the ".bat" and ".cmd" suffixes are appended if a lookup for the
original name fails, and if the name does not already end in one
of those suffixes.  If your Perl was compiled with DEBUGGING turned
on, using the -Dp switch to Perl shows how the search progresses.

support #!.  Its also convenient when debugging a script that uses #!,
and is thus normally found by the shell's  search mechanism.

Bourne shell:

which proceeds to try to execute the Perl program as a shell script.
The shell executes the second line as a normal shell command, and thus
starts up the Perl interpreter.  On some systems  doesn't always
contain the full pathname, so the 0 tells Perl to search for the
program if necessary.  After Perl locates the program, it parses the
lines and ignores them because the variable 
is never true.  If the program will be interpreted by csh, you will need
to replace 0 with 0, even though that doesn't understand
embedded spaces (and such) in the argument list.  To start up sh rather
than csh, some systems may have to replace the #! line with a line
containing just a colon, which will be politely ignored by Perl.  Other
systems can't control that, and need a totally devious construct that
will work under any of 0, 0, or Perl, such as the following:

absolute or relative pathname), and if that file is not found,
platforms that append file extensions will do so and try to look
for the file with those extensions added, one by one.

separators, it will first be searched for in the current directory
before being searched for on the PATH.  On Unix platforms, the
program will be searched for strictly on the PATH.

0

errors.  These warnings can be controlled normally with 0.

used as a temporary development aid while securing legacy code:
for real production code and for new secure code written from scratch
always use the real 0.

0

these checks are done only when running setuid or setgid.  It's a
good idea to turn them on explicitly for programs that run on behalf
of someone else whom you might not necessarily trust, such as CGI
programs or any internet servers you might write in Perl.  See
0 for details.  For security reasons, this option must be
seen by Perl quite early; usually this means it must appear early
on the command line or in the #! line for systems which support
that construct.

0

program.  You can then in theory take this core dump and turn it
into an executable file by using the 0 program (not supplied).
This speeds startup at the expense of some disk space (which you
can minimize by stripping the executable).  (Still, a "hello world"
executable comes out to about 200K on my machine.)  If you want to
execute a portion of your program before dumping, use the 
operator instead.  Note: availability of 0 is platform
specific and may not be available for a specific port of Perl.

0

operations are attempting to unlink directories while running as
superuser, and running setuid programs with fatal taint checks turned
into warnings.  Note that the 0 switch (or the 0 variable)
must be used along with this option to actually 0 the
taint-check warnings.

0

0

values of @INC.

with multiples when your configvar argument looks like a regex (has
non-letters).  For example:

trailing colon suppresses the linefeed and terminator ';', allowing
you to embed queries into shell commands.  (mnemonic: PATH separator
':'.)

you to map to the name you need.  (mnemonic: empty label)

positional parameter values without the names.  Note that in the case
below, the PERL_API params are returned in alphabetical order.

0

that are mentioned only once and scalar variables that are used
before being set, redefined subroutines, references to undefined
filehandles or filehandles opened read-only that you are attempting
to write on, values used as a number that don't look like numbers,
using an array as though it were a scalar, if your subroutines
recurse more than 100 deep, and innumerable other things.

can disable or promote into fatal errors specific warnings using
0 hooks, as described in 0 and 0.
See also 0 and 0.  A new, fine-grained warning
facility is also available if you want to manipulate entire classes
of warnings; see 0 or 0.

0

See 0.

0

See 0.

0

ASCII text, such as in a mail message.  Leading garbage will be
discarded until the first line that starts with #! and contains the
string "perl".  Any meaningful switches on that line will be applied.

will treat the #! line as the first line.
Thus a warning on the 2nd line of the program (which is on the 100th
line in the file) will be reported as line 2, and not as line 100.
This can be overridden by using the #line directive.
(See 0)

before running the program.  The 0 switch controls only the
disposal of leading garbage.  The program must be terminated with
0 if there is trailing garbage to be ignored (the program
can process any or all of the trailing garbage via the DATA filehandle
if desired).

with no intervening whitespace.

0

0

0

0

used.

0

files before looking in the standard library and the current
directory.  Any architecture-specific directories under the specified
locations are automatically included if they exist (this lookup
being done at interpreter startup time.)

(like in PATH) by a colon on Unixish platforms and by a semicolon on
Windows (the proper path separator being given by the command 0).

or setgid, or the 0 or 0 switch was specified), neither variable
is used. The program should instead say:

0

as if they were on every Perl command line.  Only the 0
switches are allowed.  When running taint checks (because the program
was running setuid or setgid, or the 0 switch was used), this
variable is ignored.  If PERL5OPT begins with 0, tainting will be
enabled, and any subsequent options ignored.

0

to use PerlIO system for IO (the default) these layers effect perl's IO.

emphasise their similarity to variable "attributes". But the code that parses
layer specification strings (which is also used to decode the PERLIO
environment variable) treats the colon as a separator.

your platform, for example 0 on Unix-like systems
and 0 on Windows and other DOS-like systems.

layers can appear in this list, as external layers (such as :) need
IO in  order to load them!. See 0 for how to add external
encodings as defaults.

variable are briefly summarised below. For more details see 0.

0

Unlikely to be useful on its own in the global PERLIO environment variable.
You perhaps were thinking of 0 or 0.

0

"binary" files in the manner of MS-DOS and similar operating systems.
(It currently does 0 mimic MS-DOS as far as treating of Control-Z
as being an end-of-file marker.)

0

make (whole) file appear in the process's address space, and then
using that as PerlIO's "buffer".

0

PerlIO "layer".  As such it will call whatever layer is below it for
its operations (typically 0).

0

Use with the same care as is reserved for nitroglycerin.

0

layer is equivalent to calling 0.  It makes the stream
pass each byte as-is without any translation.  In particular CRLF
translation, and/or :utf8 intuited from locale are disabled.

just the inverse of 0 - other layers which would affect the
binary nature of the stream are also removed or disabled.

0

library calls. The layer provides both buffering and IO.
Note that 0 layer does 0 do CRLF translation even if that
is platforms normal behaviour. You will need a 0 layer above it
to do that.

0

0

that output should be in utf8 and that input should be regarded as
already in valid utf8 form. It does not check for validity and as such
should be handled with caution for input. Generally 0 is
the best option when reading UTF-8 encoded data.

0

rather than unix-like numeric file descriptor layer. Known to be
buggy in this release.

Configure is setup to prefer "stdio" implementation if system's library
provides for fast access to the buffer, otherwise it uses the "unix perlio"
implementation.

has a number of bugs/mis-features for perl IO which are somewhat
C compiler vendor/version dependent. Using our own 0 layer as
the buffer avoids those issues and makes things more uniform.
The 0 layer provides CRLF to/from "\n" conversion as well as
buffering.

compiler's numeric file descriptor routines. There is an experimental native
0 layer which is expected to be enhanced and should eventually be
the default under Win32.

is run in taint mode.

0

sub-system will be logged to that file (opened as append). Typical uses
are Unix:

with 0.

0

files before looking in the standard library and the current directory.
If PERL5LIB is defined, PERLLIB is not used.

is run in taint mode.

0

a bare 0 switch.

0

debugged uses threads.

0

executing "backtick" commands or .  Default is 0
on WindowsNT and 0 on Windows95.  The value is considered
to be space-separated.  Precede any character that needs to be protected
(like a space or backslash) with a backslash.

COMSPEC has a high degree of variability among users, leading to
portability concerns.  Besides, perl can use a shell that may not be
fit for interactive use, and setting COMSPEC to such a shell may
interfere with the proper functioning of other programs (which usually
look in COMSPEC to find a shell fit for interactive use).

when running external commands.  It is recommended that
you explicitly set (or delete) 0 when running
in taint mode under Windows.

0

Perl normally searches for an IFS-compatible LSP because this is required
for its emulation of Windows sockets as real filehandles.  However, this may
cause problems if you have a firewall such as McAfee Guardian which requires
all applications to use its LSP which is not IFS-compatible, because clearly
Perl will normally avoid using such an LSP.
Setting this environment variable to 1 means that Perl will simply use the
first suitable LSP enumerated in the catalog, which keeps McAfee Guardian
happy (and in that particular case Perl still works too because McAfee
Guardian's LSP actually plays some other games which allow applications
requiring IFS compatibility to work).

0

distribution (that is, if 0 is 'define').
If set, this causes memory statistics to be dumped after execution.  If set
to an integer greater than one, also causes memory statistics to be dumped
after compilation.

0

this controls the behavior of global destruction of objects and other
references.  See 0 for more information.

0

a dynamic library.  The default behaviour is to resolve symbols when
they are used.  Setting this variable is useful during testing of
extensions as it ensures that you get an error on misspelled function
names even if the test suite doesn't call it.

0

PERL_ENCODING environment variable is consulted for an encoding name.

0

To emulate the pre-5.8.1 behaviour, set to an integer (zero means
exactly the same order as 5.8.0).  "Pre-5.8.1" means, among other
things, that hash keys will always have the same ordering between
different runs of perl.

On a hash by hash basis, if pathological data is detected during a hash
key insertion, then that hash will switch to an alternative random hash
seed.

If perl has been compiled with 0, the default
behaviour is 0 to randomise unless the PERL_HASH_SEED is set.

the pseudorandom seed supplied by the operating system and libraries.

randomized to protect against local and remote attacks against Perl
code. By manually setting a seed this protection may be partially or
completely lost.

0 for more information.

0

the hash seed at the beginning of execution.  This, combined with
0 is intended to aid in debugging nondeterministic
behavior caused by hash randomization.

can craft a denial-of-service attack against Perl code, even remotely,
see 0 for more information.
0 to people who don't need to know it.
See also  of 0.

0

the environment variable 0 enables logging debug
messages. The value has the form , where
0 is the filedescriptor number you want to write to (2 is
default), and the combination of letters specifies that you want
information about (m)emory and/or (s)v, optionally with
(t)imestamps. For example 0 will log all
information to stdout. You can write to other opened filedescriptors
too, in a variety of ways;

0

logical device for the @INC path on VMS only.  Other logical names that
affect perl on VMS include PERLSHR, PERL_ENV_TABLES, and
SYS but are optional and discussed further in
0 and in 0 in the Perl source distribution.

0

signals behaviour (immediate but unsafe) is restored.  If set to
0 the safe (or deferred) signals are used.
See 0.

0

a boolean variable. Setting this to 0 is not the right way to
"enable Unicode" (whatever that would mean).  You can use 0 to
"disable Unicode", though (or alternatively unset PERL_UNICODE in
your shell before starting Perl).  See the description of the 0
switch for more information.

0

specific to particular natural languages.  See 0.

to make them available to the program being executed, and to child
processes.  However, programs running setuid would do well to execute
the following lines before doing anything else, just to keep people
honest:

=encoding utf8

with extra privileges, like setuid or setgid programs.  Unlike most
command line shells, which are based on multiple substitution passes on
each line of the script, Perl uses a more conventional evaluation scheme
with fewer hidden snags.  Additionally, because the language has more
builtin functionality, it can rely less upon external (and possibly
untrustworthy) programs to accomplish its purposes.

perl5-security-report@perl.org with details.  This points to a closed
subscription, unarchived mailing list.  Please only use this address for
security issues in the Perl core, not for modules independently distributed on
CPAN.

mode>, when it detects its program running with differing real and effective
user or group IDs.  The setuid bit in Unix permissions is mode 04000, the
setgid bit mode 02000; either or both may be set.  You can also enable taint
mode explicitly by using the 0 command line flag. This flag is
0 to prevent both obvious and subtle traps.  Some of these checks
are reasonably simple, such as verifying that path directories aren't
writable by others; careful programmers have always used checks like
these.  Other checks, however, are best supported by the language itself,
and it is these checks especially that contribute to making a set-id Perl
program more secure than the corresponding C program.

something else outside your program--at least, not by accident.  All
command line arguments, environment variables, locale information (see
0), results of certain system calls (0,
0, the variable of 0, the messages returned by
0, the password, gcos and shell fields returned by the
0 calls), and all file input are marked as "tainted".
Tainted data may not be used directly or indirectly in any command
that invokes a sub-shell, nor in any command that modifies files,
directories, or processes, 0:

unless you want external data to affect your control flow.  Unless
you carefully limit what these symbolic values are, people are able
to call functions 0 your Perl code, such as POSIX::system,
in which case they are able to run arbitrary external code.

whether data is tainted.  If an expression contains tainted data,
any subexpression may be considered tainted, even if the value
of the subexpression is not itself affected by the tainted data.

elements of an array or hash can be tainted and others not.
The keys of a hash are 0 tainted.

something like "Insecure dependency" or "Insecure {PATH}".

expression" is with the ternary conditional operator 0.  Since code
with a ternary conditional

thus trigger an "Insecure dependency" message, you can use the
0 function of the Scalar::Util module, available in your
nearby CPAN mirror, and included in Perl starting from the release 5.8.0.
Or you may be able to use the following 0 function.

anywhere within an expression renders the entire expression tainted.  It
would be inefficient for every operator to test every argument for
taintedness.  Instead, the slightly more efficient and conservative
approach is used that if any tainted value has been accessed within the
same expression, the whole expression is considered tainted.

to clear your data's taintedness.  Values may be untainted by using them
as keys in a hash; otherwise the only way to bypass the tainting
mechanism is by referencing subpatterns from a regular expression match.
Perl presumes that if you reference a substring using , , etc., that
you knew what you were doing when you wrote the pattern.  That means using
a bit of thought--don't just blindly untaint anything, or you defeat the
entire mechanism.  It's better to verify that the variable has only good
characters (for certain values of "good") rather than checking whether it
has any bad characters.  That's because it's far too easy to miss bad
characters that you never thought of.

characters (alphabetics, numerics, and underscores), a hyphen, an at sign,
or a dot.

metacharacters, nor are dot, dash, or at going to mean something special
to the shell.  Use of 0 would have been insecure in theory because
it lets everything through, but Perl doesn't check for that.  The lesson
is that when untainting, you must be exceedingly careful with your patterns.
Laundering data using regular expression is the 0 mechanism for
untainting dirty data, unless you use the strategy detailed below to fork
a child of lesser privilege.

because the characters matched by 0 are determined by the locale.
Perl considers that locale definitions are untrustworthy because they
contain data from outside the program.  If you are writing a
locale-aware program, and want to launder data with a regular expression
containing 0, put 0 ahead of the expression in the same
block.  See 0 for further discussion and examples.

command, the system will pass switches to perl from the script's #!
line.  Perl checks that any command line switches given to a setuid
(or setgid) script actually match the ones set on the #! line.  Some
Unix and Unix-like environments impose a one-switch limit on the #!
line, so you may need to use something like 0 instead of 0
under such systems.  (This issue should arise only in Unix or
Unix-like environments that support #! and setuid or setgid scripts.)

from 0, and the environment variables 0 and 0
are ignored by Perl. You can still adjust 0 from outside the
program by using the 0 command line option as explained in
0. The two environment variables are ignored because
they are obscured, and a user running a program could be unaware that
they are set, whereas the 0 option is clearly visible and
therefore permitted.

the 0 pragma, e.g.:

will automagically remove any duplicated directories, while the later
will not.

problem will be reported:

a known value, and each directory in the path must be absolute and
non-writable by others than its owner and group.  You may be surprised to
get this message even if the pathname to your executable is fully
qualified.  This is 0 generated because you didn't supply a full path
to the program; instead, it's generated because you never set your PATH
environment variable, or you didn't set it to something that was safe.
Because Perl can't guarantee that the executable in question isn't itself
going to turn around and execute some other program that is dependent on
your PATH, it makes sure you set the PATH.

Because some shells may use the variables IFS, CDPATH, ENV, and
BASH_ENV, Perl checks that those are either empty or untainted when
starting subprocesses. You may wish to add something like this to your
setid and taint-checking scripts.

care whether they use tainted values.  Make judicious use of the file
tests in dealing with any user-supplied filenames.  When possible, do
opens and such 0 properly dropping any special user (or group!)
privileges. Perl doesn't prevent you from opening tainted filenames for reading,
so be careful what you print out.  The tainting mechanism is intended to
prevent stupid mistakes, not to remove the need for thought.

and 0 explicit parameter lists instead of strings with possible shell
wildcards in them.  Unfortunately, the 0, 0, and
backtick functions provide no such alternate calling convention, so more
subterfuge will be required.

or setgid program: just create a child process with reduced privilege who
does the dirty work for you.  First, fork a child using the special
0 syntax that connects the parent and child by a pipe.  Now the
child resets its ID set and any other per-process attributes, like
environment variables, umasks, current working directories, back to the
originals or known safe values.  Then the child process, which no longer
has any special permissions, does the 0 or other system call.
Finally, the child passes the data it managed to access back to the
parent.  Because the file or pipe was opened in the child while running
under less privilege than the parent, it's not apt to be tricked into
doing something it shouldn't.

not called with a string that the shell could expand.  This is by far the
best way to call something that might be subjected to shell escapes: just
never call the shell at all.

you can use 0 instead.

written a program to give away the farm, you don't necessarily trust those
who end up using it not to try to trick it into doing something bad.  This
is the kind of security checking that's useful for set-id programs and
programs launched on someone else's behalf, like CGI programs.

code not to try to do something evil.  That's the kind of trust needed
when someone hands you a program you've never seen before and says, "Here,
run this."  For that kind of safety, you might want to check out the Safe
module, included standard in the Perl distribution.  This module allows the
programmer to set up special compartments in which all system operations
are trapped and namespace access is carefully controlled.  Safe should
not be considered bullet-proof, though: it will not prevent the foreign
code to set up infinite loops, allocate gigabytes of memory, or even
abusing perl bugs to make the host interpreter crash or behave in
unpredictable ways. In any case it's better avoided completely if you're
really concerned about security.

systems as flexible as scripts, on many versions of Unix, set-id scripts
are inherently insecure right from the start.  The problem is a race
condition in the kernel.  Between the time the kernel opens the file to
see which interpreter to run and when the (now-set-id) interpreter turns
around and reopens the file to interpret it, the file in question may have
changed, especially if you have symbolic links on your system.

Unfortunately, there are two ways to disable it.  The system can simply
outlaw scripts with any set-id bit set, which doesn't help much.
Alternately, it can simply ignore the set-id bits on scripts.

complain loudly that your set-id script is insecure.  You'll need to
either disable the kernel set-id script feature, or put a C wrapper around
the script.  A C wrapper is just a compiled program that does nothing
except call your Perl program.   Compiled programs are not subject to the
kernel bug that plagues set-id scripts.  Here's a simple wrapper, written
in C:

than your script setuid or setgid.

inherent security bug.  On such systems, when the kernel passes the name
of the set-id script to open to the interpreter, rather than using a
pathname subject to meddling, it instead passes 0.  This is a
special file already opened on the script, so that there can be no race
condition for evil scripts to exploit.  On these systems, Perl should be
compiled with 0.  The 0
program that builds Perl tries to figure this out for itself, so you
should never have to specify this yourself.  Most modern releases of
SysVr4 and BSD 4.4 use this approach to avoid the kernel race condition.

with varying levels of "security".

the source code has to be readable in order to be compiled and
interpreted.  (That doesn't mean that a CGI script's source is
readable by people on the web, though.)  So you have to leave the
permissions at the socially friendly 0755 level.  This lets
people on your local system only see your source.

insecure things, and relies on people not knowing how to exploit those
insecurities, it is not secure.  It is often possible for someone to
determine the insecure things and exploit them without viewing the
source.  Security through obscurity, the name for hiding your bugs
instead of fixing them, is little security indeed.

or Filter::Util::Call and Filter::Simple since Perl 5.8).
But crackers might be able to decrypt it.  You can try using the byte
code compiler and interpreter described below, but crackers might be
able to de-compile it.  You can try using the native-code compiler
described below, but crackers might be able to disassemble it.  These
pose varying degrees of difficulty to people wanting to get at your
code, but none can definitively conceal it (this is true of every
language, not just Perl).

bottom line is that nothing but a restrictive license will give you
legal security.  License your software and pepper it with threatening
statements like "This is unpublished proprietary software of XYZ Corp.
Your access to it does not give you permission to use it blah blah
blah."  You should see a lawyer to be sure your license's wording will
stand up in court.

certain security pitfalls.  See 0 for an overview and
0 for details, and 0 for security implications in particular.

be attacked by choosing the input carefully to consume large amounts
of either time or space or both.  This can lead into the so-called
0 (DoS) attacks.

changed several times during the development of Perl, mainly to be
reasonably fast.  In Perl 5.8.1 also the security aspect was taken
into account.

hash keys would cause Perl to consume large amounts of time because
internal structure of hashes would badly degenerate.  In Perl 5.8.1
the hash function is randomly perturbed by a pseudorandom seed which
makes generating such naughty hash keys harder.
See 0 for more information.

5.8.2 it is only used on individual hashes if the internals detect the
insertion of pathological data. If one wants for some reason emulate the
old behaviour (and expose oneself to DoS attacks) one can set the
environment variable PERL_HASH_SEED to zero to disable the protection
(or any other integer to force a known perturbation, rather than random).
One possible reason for wanting to emulate the old behaviour is that in the
new behaviour consecutive runs of Perl will order hash keys differently,
which may confuse some applications (like Data::Dumper: the outputs of two
different runs are no longer identical).

ordering has already changed several times during the lifetime of
Perl 5.  Also, the ordering of hash keys has always been, and
continues to be, affected by the insertion order.

randomised, this "pseudoordering" should 0 be used for
applications like shuffling a list randomly (use List::Util::
for that, see 0, a standard core module since Perl 5.8.0;
or the CPAN module Algorithm::Numerical::Shuffle), or for generating
permutations (use e.g. the CPAN modules Algorithm::Permute or
Algorithm::FastPermute), or for any cryptographic applications.

(Non-deterministic Finite Automaton), which among other things means that
it can rather easily consume large amounts of both time and space if the
regular expression may match in several ways.  Careful crafting of the
regular expressions can help but quite often there really isn't much
one can do (the book "Mastering Regular Expressions" is required
reading, see 0).  Running out of space manifests itself by
Perl running out of memory.

implement the  function is very easy to trick into misbehaving
so that it consumes a lot of time.  Starting from Perl 5.8.0 a different
sorting algorithm, mergesort, is used by default.  Mergesort cannot
misbehave on any input.

and any computer science textbook on algorithmic complexity.

=encoding utf8

Consistent formatting of this file is achieved with:

on the Perl core, this will help you find what you're looking for.

tree. There are a few platform-specific directories which contain C code. In
addition, some of the modules shipped with Perl include C or XS code.

interpreter, as well as details on how it works.

these directories contain modules that live in the core, and two contain
modules that can also be released separately on CPAN. Modules which can be
released on cpan are known as "dual-life" modules.

the core. This directory contains 0 of the modules and their tests,
unlike other core modules.

the core. These modules generally have their 0 and are laid out
more like a typical CPAN module.

canonical. Note that some modules in this directory may not yet have been
released separately on CPAN.

canonical. Do not patch these modules directly! Changes to these modules
should be submitted to the maintainer of the CPAN module. Once those changes
are applied and released, the new version of the module will be incorporated
into the core.

or the blead source is canonical. Until that is done, those modules should be
in 0.

modules with tests), you may need to update the 0 file so that the
tests are run.

itself. For example, we have 0 and 0.

subdirectories for each module, like a standard CPAN distribution.

file reads and writes, simple regexes, etc. These are run first in the test
suite and if any of them fail, something is 0 broken.

subroutines, etc.

other directories.

t/op).

handling of PERL* environment variables.

tests that everyone who is listed in the git log has a corresponding entry in
the 0 file.

here. There are still some bits and pieces hanging around in here that
need to be moved. Perhaps you could move them?  Thanks!

0. Individual modules in 0, 0, 0, and 0
usually have their own documentation, either in the 0 file or an
accompanying 0 file.

0 to find out more information about a
dual-life module.

directory.

directories like 0, 0, etc.

0.

maintained separately from the Perl core.

in 0 for more details.

Perl. See 0 for more details.

should add your name to this file as part of the patch.

file in the Perl core, as well as a brief description of each file.

=encoding utf8

regards to formatting, but there are some general guidelines that will
make your programs easier to read, understand, and maintain.

flag at all times.  You may turn it off explicitly for particular
portions of code via the 0 pragma or the 0 variable
if you must.  You should also always run under 0 or know the
reason why not.  The 0 and even 0 pragmas
may also prove useful.

cares strongly about is that the closing curly bracket of
a multi-line BLOCK should line up with the keyword that started the construct.
Beyond that, he has other preferences that aren't so strong:

everyone else's mind works the same as his does.

you 0 do it that way.  Perl is designed to give you several
ways to do anything, so consider picking the most readable one.  For
instance

modifier.  On the other hand

doesn't mean that you have to make use of the defaults.  The defaults
are there for lazy systems programmers writing one-shot programs.  If
you want your program to be readable, consider supplying the argument.

places doesn't mean that you ought to:

schmuck bounce on the % key in 0.

who has to maintain the code after you, and who will probably put
parentheses in the wrong place.

bottom, when Perl provides the 0 operator so you can exit in
the middle.  Just "outdent" it a little to make it more visible:

readability as well as to allow multilevel loop breaks.  See the
previous example.

when you just throw away their return values.  Those functions all
have return values, so use them.  Otherwise use a 0 loop or
the 0 function instead.

every machine, test the construct in an eval to see if it fails.  If
you know what version or patchlevel a particular feature was
implemented, you can test 0 (0 in 0) to see if it
will be there.  The 0 module will also let you interrogate values
determined by the 0 program when Perl was installed.

you've got a problem.

separate words in longer identifiers.  It is generally easier to read
0 than 0, especially for
non-native speakers of English. It's also a simple rule that works
consistently with 0.

reserves lowercase module names for "pragma" modules like 0 and
0.  Other modules should begin with a capital letter and use mixed
case, but probably without underscores due to limitations in primitive
file systems' representations of module names as files that must fit into a
few sparse bytes.

or nature of a variable. For example:

E.g., C<-0.

function should not be used outside the package that defined it.

put in some whitespace to make it look a little less like line noise.
Don't use slash as a delimiter when your regexp has slashes or backslashes.

list operators so much, and to reduce the incidence of punctuation
operators like 0 and 0.  Call your subroutines as if they were
functions or list operators to avoid excessive ampersands and parentheses.

to fit on one line anyway.

go to 0, include which program caused the problem, what the failed
system call and arguments were, and (VERY IMPORTANT) should contain the
standard system error message for what went wrong.  Here's a simple but
sufficient example:

might want to do something like it again?  Consider generalizing your
code.  Consider writing a module or object class.  Consider making your
code run cleanly with 0 and 0 (or 0) in
effect.  Consider giving away your code.  Consider changing your whole
world view.  Consider... oh, never mind.

are commonly expected conventions:

generally anything that can be considered part of code, like filehandles
or specific values). Note that function names are considered more readable
with parentheses after their name, that is 0.

be the only Pod code for file names, but as most Pod formatters render it
as italic, Unix and Windows paths with their slashes and backslashes may
be less readable, and better rendered with C<C00.

=encoding utf8

0 0

0 0

0

0

0 0

These may be located anywhere in the main program, loaded in from
other files via the 0, 0, or 0 keywords, or
generated on the fly using 0 or anonymous subroutines.
You can even call a function indirectly using a variable containing
its name or a CODE reference.

functions are passed as parameters one single flat list of scalars, and
all functions likewise return to their caller one single flat list of
scalars.  Any arrays or hashes in these call and return lists will
collapse, losing their identities--but you may always use
pass-by-reference instead to avoid this.  Both call and return lists may
contain as many or as few scalar elements as you'd like.  (Often a
function without an explicit return statement is called a subroutine, but
there's really no difference from Perl's perspective.)
0 0

you called a function with two arguments, those would be stored in
0 and 0.  The array 0 is a local array, but its
elements are aliases for the actual scalar parameters.  In particular,
if an element 0 is updated, the corresponding argument is
updated (or an error occurs if it is not updatable).  If an argument
is an array or hash element which did not exist when the function
was called, that element is created only when (and if) it is modified
or a reference to it is taken.  (Some earlier versions of Perl
created the element whether or not the element was assigned to.)
Assigning to the whole array 0 removes that aliasing, and does
not update any arguments.
0 0 0

specifying the returned value, which will be evaluated in the
appropriate context (list, scalar, or void) depending on the context of
the subroutine call.  If you specify no return value, the subroutine
returns an empty list in list context, the undefined value in scalar
context, or nothing in void context.  If you return one or more
aggregates (arrays and hashes), these will be flattened together into
one large indistinguishable list.

value is returned. If the last statement is a loop control structure
like a 0 or a 0, the returned value is unspecified. The
empty sub returns the empty list.
0 0 0

do is assign to a 0 list of these.  Variables that aren't
declared to be private are global variables.  For gory details
on creating private variables, see 0
and 0.  To create protected
environments for a set of functions in a separate package (and
probably a separate file), see 0.
0 0

of turning call-by-reference into call-by-value.  Otherwise a
function is free to do in-place modifications of 0 and change
its caller's values.
0 0

argument were actually literal and you tried to change it, you'd take a
(presumably fatal) exception.   For example, this won't work:
0 0

were written to return a copy of its parameters instead
of changing them in place:

passed real scalars or arrays.  Perl sees all arguments as one big,
long, flat parameter list in 0.  This is one area where
Perl's simple argument-passing style shines.  The 0
function would work perfectly well without changing the 0
definition even if we fed it things like this:

flattened on return.  So all you have managed to do here is stored
everything in 0 and made 0 empty.  See
0 for alternatives.

0 is optional in modern Perl, as are parentheses if the
subroutine has been predeclared.  The 0 is 0 optional
when just naming the subroutine, such as when it's used as
an argument to  or .  Nor is it optional when you
want to do an indirect subroutine call with a subroutine name or
reference using the 0 or 0 constructs,
although the  notation solves that problem.
See 0 for more about all that.
0

using the 0 form, the argument list is optional, and if omitted,
no 0 array is set up for the subroutine: the 0 array at the
time of the call is visible to subroutine instead.  This is an
efficiency mechanism that new users may wish to avoid.
0

disables any prototype checking on arguments you do provide.  This
is partly for historical reasons, and partly for having a convenient way
to cheat if you know what you're doing.  See 0 below.
0

core, as are modules whose names are in all lower case.  A subroutine in
all capitals is a loosely-held convention meaning it will be called
indirectly by the run-time system itself, usually due to a triggered event.
Subroutines that do special, pre-defined things include 0, 0,
0 plus all functions mentioned in 0 and 0.

are not so much subroutines as named special code blocks, of which you
can have more than one in a package, and which you can 0 call
explicitly.  See 0

0 0 0 0 0
0 0

evolving.  The current semantics and interface are subject to change.
See 0 and 0.

confined to the enclosing block, conditional (0),
loop (0), subroutine, 0,
or 0'd file.  If more than one value is listed, the
list must be placed in parentheses.  All listed elements must be
legal lvalues.  Only alphanumeric identifiers may be lexically
scoped--magical built-ins like 0 must currently be 0ized
with 0 instead.

variables declared with 0 are totally hidden from the outside
world, including any called subroutines.  This is true if it's the
same subroutine called from itself or elsewhere--every call gets
its own copy.
0

enclosing lexical scope would be invisible.  Only dynamic scopes
are cut off.   For example, the 0 function below has access
to the lexical  variable because both the 0 and the 0
occurred at the same scope, presumably file scope.

being evaluated in, so long as the names aren't hidden by declarations within
the 0 itself.  See 0.
0

to initialize your variables.  (If no initializer is given for a
particular variable, it is created with the undefined value.)  Commonly
this is used to name input parameters to a subroutine.  Examples:

you do assign to variables in its argument list, 0 doesn't
change whether those variables are viewed as a scalar or an array.  So

the current statement.  Thus,

the expression

braces that delimit their controlled blocks; control expressions are
part of that scope, too.  Thus in the loop

the loop construct (including the 0 clause), but not beyond
it.  Similarly, in the conditional

of that conditional, including any 0 and 0 clauses,
but not beyond it.  See 0 for information
on the scope of variables in statements with modifiers.

in the manner of 0.  However, if the index variable is
prefixed with the keyword 0, or if there is already a lexical
by that name in scope, then a new lexical is created instead.  Thus
in the loop
0 0

rendering the value of  inaccessible within 0.
0 0

As an aid to catching implicit uses to package variables,
which are always global, if you say

block must either refer to a lexical variable, be predeclared via
0 or 0, or else must be fully qualified with the package name.
A compilation error results otherwise.  An inner block may countermand
this with 0.

time, the compiler takes notice of it.  The principal usefulness
of this is to quiet 0, but it is also essential
for generation of closures as detailed in 0.  Actual
initialization is delayed until run time, though, so it gets executed
at the appropriate time, such as each time through a loop, for
example.

never fully qualified with the package name.  In particular, you're not
allowed to try to make a package variable (or other global) lexical:

are still accessible using the fully qualified 0 notation even while a
lexical of the same name is also visible:

to hide any such identifiers from the world outside that file.  This
is similar in spirit to C's static variables when they are used at
the file level.  To do this with a subroutine requires the use of
a closure (an anonymous function that accesses enclosing lexicals).
If you want to create a private subroutine that cannot be called
from outside that block, it can declare a lexical variable containing
an anonymous sub reference:

module, no outside module can see the subroutine, because its name is not in
any package's symbol table.  Remember that it's not 0 called
0 or anything; it's just ,
unqualified and unqualifiable.

have to be in the symbol table of some package to be found.  See
0 for something of a work-around to
this.

0 0 0 0 0 0

First, you can simply use the 0 feature. Or, you can use closures,
if you want to stay compatible with releases older than 5.10.

keyword in place of 0. For that to work, though, you must have
enabled that feature beforehand, either by using the 0 pragma, or
by using 0 on one-liners. (see 0)

each time the  function is called:

code outside.

variables (as in 0) is executed only the first time.  When such
statements are evaluated subsequent times, the assignment is ignored.  The
behavior of this sort of assignment to non-scalar variables is undefined.

scoped to its enclosing block, 0, or 0 FILE, this doesn't mean that
within a function it works like a C static.  It normally works more
like a C auto, but with implicit garbage collection.

necessarily get recycled just because their scope has exited.
If something more permanent is still aware of the lexical, it will
stick around.  So long as something else references a lexical, that
lexical won't be freed--which is as it should be.  You wouldn't want
memory being free until you were done using it, or kept around once you
were done.  Automatic garbage collection takes care of this for you.

variables, whereas to return a pointer to a C auto is a grave error.
It also gives us a way to simulate C's function statics.  Here's a
mechanism for giving a function private variables with both lexical
scoping and a static lifetime.  If you do want to create something like
C's static variables, just enclose the whole function in an extra block,
and put the static variable outside the function but in the block.

via 0 or 0, then this is probably just fine.  If it's
all in the main program, you'll need to arrange for the 0
to be executed early, either by putting the whole block above
your main program, or more likely, placing merely a 0
code block around it to make sure it gets executed before your program
starts to run:

special triggered code blocks, 0, 0, 0,
0 and 0.

work somewhat like C's file statics.  They are available to all
functions in that same file declared below them, but are inaccessible
from outside that file.  This strategy is sometimes used in modules
to create private variables that the whole module can see.

0 0 0 0
0

it's faster and safer.  Exceptions to this include the global punctuation
variables, global filehandles and formats, and direct manipulation of the
Perl symbol table itself.  0 is mostly used when the current value
of a variable must be visible to called subroutines.

enclosing block, 0, or 0--and to 0.  A 0 just gives temporary
values to global (meaning package) variables.  It does 0 create
a local variable.  This is known as dynamic scoping.  Lexical scoping
is done with 0, which works more like C's auto declarations.

and slices, conditionals (provided that their result is always
localizable), and symbolic references.  As for simple variables, this
creates new, dynamically scoped values.

placed in parentheses.  This operator works
by saving the current values of those variables in its argument list on a
hidden stack and restoring them upon exiting the block, subroutine, or
eval.  This means that called subroutines can also reference the local
variable, but not the global one.  The argument list may be assigned to if
desired, which allows you to initialize your local variables.  (If no
initializer is given for a particular variable, it is created with an
undefined value.)

through a loop.  Consequently, it's more efficient to localize your
variables outside the loop.

0

a 0ized variable, the 0 doesn't change whether its list is viewed
as a scalar or an array.  So

0

but its magic won't go away.  That means that all side-effects related
to this magic still work with the localized value.

example, the following statement dies, as of perl 5.9.0, with an error
0, because the  variable is
magical and read-only :

0 will always strip all magic from , to make it possible
to safely reuse  in a subroutine.

work as described.
This will be fixed in a future release of Perl; in the meantime, avoid
code that relies on any particular behaviour of localising tied arrays
or hashes (localising individual elements is still okay).
See 0 for more
details.
0

0 0

current package.  That means that all variables in its glob slot (,
@name, %name, &name, and the 0 filehandle) are dynamically reset.

those variables is locally lost.  In other words, saying 0
will not have any effect on the internal value of the input record
separator.

0 0 0

0ize a member of a composite type (i.e. an array or hash element).
In this case, the element is 0ized 0. This means that
when the scope of the 0 ends, the saved value will be
restored to the hash element whose key was named in the 0, or
the array element whose index was named in the 0.  If that
element was deleted while the 0 was in effect (e.g. by a
0 from a hash or a 0 of an array), it will spring
back into existence, possibly extending an array and filling in the
skipped elements with 0.  For instance, if you say

types is subject to change in future.

0 0 0 0

constructs to delete a composite type entry for the current block and restore
it when it ends. They return the array/hash value before the localization,
which means that they are respectively equivalent to

also accepted.

0 0

implementation may change in future versions of Perl.

To do this, you have to declare the subroutine to return an lvalue.

side of assignment is determined as if the subroutine call is replaced
by a scalar. For example, consider:

circumspect.

falling out of subroutine scope. (see comment in example above).  This
is usually not a problem, but it disallows an explicit return out of a
deeply nested loop, which is sometimes a nice way out.

argument before setting the attribute it is protecting, an lvalue
subroutine never gets that chance.  Consider;

0 0

the only way to simulate pass-by-reference in older versions of
Perl.  While it still works fine in modern versions, the new reference
mechanism is generally easier to work with.  See below.

but rather the name of it, so that the subroutine can modify the global
copy of it rather than working with a local copy.  In perl you can
refer to all objects of a particular name by prefixing the name
with a star: 0.  This is often known as a "typeglob", because the
star on the front can be thought of as a wildcard match for all the
funny prefix characters on variables and subroutines and such.

all the objects of that name, including any filehandle, format, or
subroutine.  When assigned to, it causes the name mentioned to refer to
whatever 0 value was assigned to it.  Example:

scalar arguments without using this mechanism by referring explicitly
to 0 etc.  You can modify all the elements of an array by passing
all the elements as scalars, but you have to use the 0 mechanism (or
the equivalent reference mechanism) to 0, 0, or change the size of
an array.  It will certainly be faster to pass the typeglob (or reference).

passing multiple arrays in a single LIST, because normally the LIST
mechanism will merge all the array values so that you can't extract out
the individual arrays.  For more on typeglobs, see
0.

0 0

0 operator still shines.  In fact, in these three places, you
0 use 0 instead of 0.

0ized with 0.  This block reads in 0, and splits
it up into chunks separated by lines of equal signs, which are placed
in 0.

to it.  Look out for implicit assignments in 0 conditionals.

0 on a complete typeglob.   This can be used to create new symbol
table entries:

entries.

can be used to create what is effectively a local function, or at least,
a local alias.

functions by name in this way.

is done on dynamics:

this operation could on occasion misbehave.

0 0 0

return them from it--and have them maintain their integrity, then
you're going to have to use an explicit pass-by-reference.  Before you
do that, you need to understand references as detailed in 0.
This section may not make much sense to you otherwise.

to a function and have it 0 all of then, returning a new list
of all their former last elements:

list of keys occurring in all the hashes passed to it:

What happens if you want to pass or return a hash?  Well,
if you're using only one of them, or you don't mind them
concatenating, then the normal calling convention is ok, although
a little expensive.

or

clears the 0 or 0.  Plus the function didn't get passed
into two separate arrays or hashes: it got one long list in 0,
as always.

cleaner code, although not so nice to look at.  Here's a function that
takes two array references as arguments, returning the two array elements
in order of how many elements they have in them:

a tad subtle, though, and also won't work if you're using 0
variables, because only globals (even in disguise as 0s)
are in the symbol table.

typeglob, like 0, but typeglobs references work, too.
For example:

Notice to pass back just the bare *FH, not its reference.

0 0

using function prototyping.  If you declare

function declaration must be visible at compile time.  The prototype
affects only interpretation of new-style calls to the function,
where new-style is defined as not using the 0 character.  In
other words, if you call it like a built-in function, then it behaves
like a built-in function.  If you call it like an old-fashioned
subroutine, then it behaves like an old-fashioned subroutine.  It
naturally falls out from this rule that prototypes have no influence
on subroutine references like 0 or on indirect subroutine
calls like 0 or .

function to be called is indeterminate at compile time, since
the exact code called depends on inheritance.

subroutines that work like built-in functions, here are prototypes
for some other functions that parse almost exactly like the
corresponding built-in.

that must start with that character (optionally preceded by 0,
0 or 0), with the exception of 0, which will accept a
hash or array element even without a dollar sign, such as
. The value passed as part of 0 will be a
reference to the actual argument given in the subroutine call,
obtained by applying 0 to that argument.

allowed argument type. For example:

a scalar, an array, a hash, a code, or a glob.

unbackslashed 0 or 0 eats all remaining arguments, and forces
list context.  An argument represented by 0 forces scalar context.  An
0 requires an anonymous subroutine, which, if passed as the first
argument, does not require the 0 keyword or a subsequent comma.

typeglob, or a reference to a typeglob in that slot.  The value will be
available to the subroutine either as a simple scalar, or (in the latter
two cases) as a reference to the typeglob.  If you wish to always convert
such arguments to a typeglob reference, use Symbol:: as
follows:

0 when given a literal array or hash variable, but will otherwise
force scalar context on the argument.  This is useful for functions which
should accept either a literal array or an array reference as the argument:

is of an acceptable type.

It is redundant before 0 or 0, which gobble up everything else.

use 0 in place of 0: if this argument is not provided, 0 will be
used instead.

specially by the parser.  0 is parsed as a true list
operator, 0 is parsed as a true unary operator with unary
precedence the same as 0, and 0 is truly without
arguments, just like 0.  That is, if you say

without a prototype.

provided it's in the initial position:
0

issues having to do with visibility of 0.  I'm ignoring that
question for the moment.  (But note that if we make 0 lexically
scoped, those anonymous subroutines can act like closures... (Gee,
is this sounding a little Lispish?  (Never mind.))))

0

been intentionally left out of prototypes for the express purpose of
someday in the future adding named, formal parameters.  The current
mechanism's main goal is to let module writers provide better diagnostics
for module users.  Larry feels the notation quite understandable to Perl
programmers, and that it will not intrude greatly upon the meat of the
module, nor make it harder to read.  The line noise is visually
encapsulated into a small pill that's easy to swallow.

generate an optional warning - "Illegal character in prototype...".
Unfortunately earlier versions of Perl allowed the prototype to be
used as long as its prefix was a valid prototype.  The warning may be
upgraded to a fatal error in a future version of Perl once the
majority of offending code is fixed.

into older ones.  That's because you must be especially careful about
silent impositions of differing list versus scalar contexts.  For example,
if you decide that a function should take just one parameter, like this:

returning a list:

argument, which can be more than a bit surprising.  The old 0
which used to hold one thing doesn't get passed in.  Instead,
0 now gets passed in a 0; that is, the number of elements
in 0.  And the 0 gets called in scalar context so it
starts scribbling on your 0 parameter list.  Ouch!

to make the world a better place.

0

inlining.  If the result after optimization and constant folding
is either a constant or a lexically-scoped scalar which has no other
references, then it will be used in place of function calls made
without 0.  Calls made using 0 are never inlined.  (See
0 for an easy way to declare most constants.)

the constant folding doesn't reduce them to a single constant:

a mandatory warning.  (You can use this warning to tell whether or not a
particular subroutine is considered constant.)  The warning is
considered severe enough not to be optional because previously compiled
invocations of the function will still be using the old value of the
function.  If you need to be able to redefine the subroutine, you need to
ensure that it isn't inlined, either by dropping the 0 prototype
(which changes calling semantics, so beware) or by thwarting the
inlining mechanism in some other way, such as

0 0 0 0

only occasionally and for good reason.  Typically this might be
done by a package attempting to emulate missing built-in functionality
on a non-Unix system.

compile time--ordinary predeclaration isn't good enough.  However, the
0 pragma lets you, in effect, predeclare subs
via the import syntax, and these names may then override built-in ones:

built-in name with the special package qualifier 0.  For example,
saying 0 always refers to the built-in 0, even
if the current package has imported some other subroutine called
0 from elsewhere.  Even though it looks like a regular
function call, it isn't: you can't take a reference to it, such as
the incorrect 0 might appear to produce.

or 0 as part of their default 0 list, because these may
sneak into someone else's namespace and change the semantics unexpectedly.
Instead, if the module adds that name to 0, then it's
possible for a user to import the name explicitly, but not implicitly.
That is, they could say

deliberately, to the package that requests the import.  There is a second
method that is sometimes applicable when you wish to override a built-in
everywhere, without regard to namespace boundaries.  This is achieved by
importing a sub into the special namespace 0.  Here is an
example that quite brazenly replaces the 0 operator with something
that understands regular expressions.

By overriding 0 globally, you would be forcing the new (and
subversive) behavior for the 0 operator for 0 namespace,
without the complete cognizance or cooperation of the modules that own
those namespaces.  Naturally, this should be done with extreme caution--if
it must be done at all.

cleanly override perl's 0 operator.  The built-in 0 has
different behaviors depending on whether it appears in a scalar or list
context, but our 0 doesn't.  Indeed, many perl built-in have such
context sensitive behaviors, and these must be adequately supported by
a properly written override.  For a fully functional example of overriding
0, study the implementation of 0 in the standard
library.

possible) with the built-in native syntax.  You can achieve this by using
a suitable prototype.  To get the prototype of an overridable built-in,
use the 0 function with an argument of 0
(see 0).

prototype (such as 0 or 0).  If you override them you won't
be able to fully mimic their original syntax.

to special magic, their original syntax is preserved, and you don't have
to define a prototype for their replacements.  (You can't override the
0 syntax, though).

0 replacement as 0, it will actually receive
the argument 0 in @_.  See 0.

0, the  glob operator is overridden as well.

the equivalent I/O operator . Also, overriding
0 also overrides the operators 0 and 0.

0 0

get an immediate, fatal error complaining that the subroutine doesn't
exist.  (Likewise for subroutines being used as methods, when the
method doesn't exist in any base class of the class's package.)
However, if an 0 subroutine is defined in the package or
packages used to locate the original subroutine, then that
0 subroutine is called with the arguments that would have
been passed to the original subroutine.  The fully qualified name
of the original subroutine magically appears in the global 
variable of the same package as the 0 routine.  The name
is not passed as an ordinary argument because, er, well, just
because, that's why.  (As an exception, a method call to a nonexistent
0 or 0 method is just skipped instead.  Also, if
the AUTOLOAD subroutine is an XSUB, 0 is not populated;
instead, you should call  on the
0 for 0 to retrieve the method name.)

subroutine using , then execute that subroutine using a special
form of  that erases the stack frame of the 0 routine
without a trace.  (See the source to the standard module documented
in 0, for example.)  But an 0 routine can
also just emulate the routine and never define it.   For example,
let's pretend that a function that wasn't defined should just invoke
0 with those arguments.  All you'd do is:

even need parentheses:

can treat undefined subroutine calls as calls to external programs.

into autoloadable files.  See the standard AutoLoader module
described in 0 and in 0, the standard
SelfLoader modules in 0, and the document on adding C
functions to Perl code in 0.

0 0 0

associated with it.  If such an attribute list is present, it is
broken up at space or colon boundaries and treated as though a
0 had been seen.  See 0 for details
about what attributes are currently supported.
Unlike the limitation with the obsolescent 0, the
0 syntax works to associate the attributes with
a pre-declaration, and not just with a subroutine definition.

punctuation other than the '_' character).  They may have a parameter
list appended, which is only checked for whether its parentheses ('(',')')
nest properly.

which associates them with the subroutine.  In particular, the second example
of valid syntax above currently looks like this in terms of how it's
parsed and invoked:

see 0 and 0.

See 0 if you'd like to learn about calling C subroutines from Perl.
See 0 if you'd like to learn about calling Perl subroutines from C.
See 0 to learn about bundling up your functions in separate files.
See 0 to learn what library modules come standard on your system.
See 0 to learn how to make object method calls. 

=encoding utf8

0

which run from the top to the bottom.  Loops, subroutines and other
control structures allow you to jump around within the code.

you like.  Whitespace mostly serves to separate tokens, unlike
languages like Python where it is an important part of the syntax.

requiring you to put parentheses around every function call and
declare every variable, you can often leave such explicit elements off
and Perl will figure out what you meant.  This is known as 0, abbreviated 0.  It allows programmers to be 0 and to
code in a style with which they are comfortable.

Bourne Shell, Smalltalk, Lisp and even English.  Other
languages have borrowed syntax from Perl, particularly its regular
expression extensions.  So if you have programmed in another language
you will see familiar pieces in Perl.  They often work the same, but
see 0 for information about how they differ.

0 0 0 0

subroutines (and sometimes not even subroutines).  A variable holds
the undefined value (0) until it has been assigned a defined
value, which is anything other than 0.  When used as a number,
0 is treated as 0; when used as a string, it is treated as
the empty string, 0; and when used as a reference that isn't being
assigned to, it is treated as an error.  If you enable warnings,
you'll be notified of an uninitialized value whenever you treat
0 as a string or a number.  Well, usually.  Boolean contexts,
such as:

definedness).  Operators such as 0, 0, 0,
0, and 0, that operate on undefined left values such as:

the execution of the primary sequence of statements--declarations all
take effect at compile time.  Typically all the declarations are put at
the beginning or the end of the script.  However, if you're using
lexically-scoped private variables created with 0, you'll
have to make sure
your format or subroutine definition is within the same block scope
as the my if you expect to be able to access those private variables.

list operator from that point forward in the program.  You can declare a
subroutine without defining it by saying 0, thus:
0

so be careful to use 0 instead of 0 in this case.  However, if
you were to declare the subroutine as 0, then
0 would function as a unary operator, so either 0 or
0 would work.

or both loaded and imported into your namespace with a 0 statement.
See 0 for details on this.

variables, but apart from declaring a variable name, the declaration acts
like an ordinary statement, and is elaborated within the sequence of
statements as if it were an ordinary statement.  That means it actually
has both compile-time and run-time effects.

0 0

and is ignored.  Exceptions include 0 inside a string or regular
expression.

0 0 0 0

side effects.  Every simple statement must be terminated with a
semicolon, unless it is the final statement in a block, in which case
the semicolon is optional.  (A semicolon is still encouraged if the
block takes up more than one line, because you may eventually add
another line.)  Note that there are some operators like 0 and
0 that look like compound statements, but aren't (they're just
TERMs in an expression), and thus need an explicit termination if used
as the last item in a statement.

0 0 0 0 0 0 0 0

0 are all false in a boolean context. All other values are true.
Negation of a true value by 0 or 0 returns a special false value.
When evaluated as a string it is treated as 0, but as a number, it
is treated as 0.

0 0 0 0 0
0 0 0 0

just before the terminating semicolon (or block ending).  The possible
modifiers are:

Its truth or falsehood determines how the modifier will behave.

true.  0 is the opposite, it executes the statement 0
the condition is true (i.e., if the condition is false).

then either 0s out if it's enclosed in a 0 scope or skips
to the 0 element when it lies directly inside a 0 loop.
See also 0.

for each item in the LIST (with 0 aliased to each item in turn).

0 does the opposite, it repeats the statement 0 the
condition is true (or while the condition is false):

semantics (conditional evaluated first), except when applied to a
0-BLOCK (or to the deprecated 0-SUBROUTINE statement), in
which case the block executes once before the conditional is
evaluated.  This is so that you can write loops like:

later will 0 work in this construct, because modifiers don't take
loop labels.  Sorry.  You can always put another block inside of it
(for 0) or around it (for 0) to do that sort of thing.
For 0, just double the braces:
0 0 0

0

modifier conditional or loop construct (e.g. 0) is
0.  The value of the 0 variable may be 0, any
previously assigned value, or possibly anything else.  Don't rely on
it.  Future versions of perl might do something different from the
version of perl you try it out on.  Here be dragons.
0

0 0 0 0 0
0 0 0 0 0 0 0 0 0

Sometimes a block is delimited by the file containing it (in the case
of a required file, or the program as a whole), and sometimes a block
is delimited by the extent of a string (in the case of an eval).

We will call this syntactic construct a BLOCK.

not statements.  This means that the curly brackets are 0--no
dangling statements allowed.  If you want to write conditionals without
curly brackets there are several other ways to do it.  The following
all do the same thing:

bounded by curly brackets, there is never any ambiguity about which
0 an 0 goes with.  If you use 0 in place of 0,
the sense of the test is reversed. Like 0, 0 can be followed
by 0. 0 can even be followed by one or more 0
statements, though you may want to think twice before using that particular
language construct, as everyone reading your code will have to think at least
twice before they can understand what's going on.

0.
The 0 statement executes the block as long as the expression is
false.
The LABEL is optional, and if present, consists of an identifier followed
by a colon.  The LABEL identifies the loop for the loop control
statements 0, 0, and 0.
If the LABEL is omitted, the loop control statement
refers to the innermost enclosing loop.  This may include dynamically
looking back your call-stack at run time to find the LABEL.  Such
desperate behavior triggers a warning if you use the 0
pragma or the 0 flag.

conditional is about to be evaluated again.  Thus it can be used to
increment a loop variable, even when the loop has been continued via
the 0 statement.

kinds of compound statement.  These are introduced by a keyword which
the extension recognizes, and the syntax following the keyword is
defined entirely by the extension.  If you are an implementor, see
0 for the mechanism.  If you are using such
a module, see the module's documentation for details of the syntax that
it defines.

0 0 0 0 0 0

0 block, if any, is not executed:

conditional again.  The 0 block, if any, is 0 executed.
This command is normally used by programs that want to lie to themselves
about what was just input.

If your input lines might end in backslashes to indicate continuation, you
want to skip ahead and get the next record.

get executed only on lines discarded by the regex (since redo skips the
continue block). A continue block is often used to reset line counters
or 0 one-time matches:

test is reversed, but the conditional is still tested before the first
iteration.

they aren't loops.  You can double the braces to make them such, though.

executes once, see 0.

available.   Replace any occurrence of 0 by 0.

0 0

that means that this:

in the initialization section of the 0, the lexical scope of
those variables is exactly the 0 loop (the body of the loop
and the control sections).
0

to many other interesting applications.  Here's one that avoids the
problem you get into if you explicitly test for end-of-file on
an interactive file descriptor causing your program to appear to
hang.
0 0 0

conditional of a 0 loop is shorthand for the following.  This
behaviour is the same as a 0 loop conditional.
0 

0 0

variable VAR to be each element of the list in turn.  If the variable
is preceded with the keyword 0, then it is lexically scoped, and
is therefore visible only within the loop.  Otherwise, the variable is
implicitly local to the loop and regains its former value upon exiting
the loop.  If the variable was previously declared with 0, it uses
that variable instead of the global one, but it's still localized to
the loop.  This implicit localization occurs 0 in a 0
loop.
0 0

you can use 0 for readability or 0 for brevity.  (Or because
the Bourne shell is more familiar to you than 0, so writing 0
comes more naturally.)  If VAR is omitted, 0 is set to each value.
0

VAR inside the loop.  Conversely, if any element of LIST is NOT an
lvalue, any attempt to modify that element will fail.  In other words,
the 0 loop index variable is an implicit alias for each item
in the list that you're looping over.
0

you add or remove elements within the loop body, for example with
0.   So don't do that.
0

special variable.   Don't do that either.

do it:

cleaner because it's less noisy.  It's safer because if code gets added
between the inner and outer loops later on, the new code won't be
accidentally executed.  The 0 explicitly iterates the other loop
rather than merely terminating the inner one.  And it's faster because
Perl executes a 0 statement more rapidly than it would the
equivalent 0 loop.

0

loop that executes once.  Thus you can use any of the loop control
statements in it to leave or restart the block.  (Note that this is
0 true in 0, 0, or contrary to popular belief
0 blocks, which do 0 count as loops.)  The 0
block is optional.

of Perl had no official 0 statement.

0 0 0 0 0

Perl 6 proposal.

to 0 and 0 in other languages, so the code
above could be written as

within the lexical scope of the block, so it's similar to

successful 0 or an explicit 0.

0, i.e. 0. (See 0 for more
information on smart matching.) But when EXPR is one of the below
exceptional cases, it is used directly as a boolean:

or a negated regular expression match (0 or 0).

(or of course 0)

exclusive-or 0.

that return numerical values, not boolean ones.

decide whether to use smart matching for each one by applying the above test to
the operands:

is applied recursively to both operands. If 0
operands pass the test, then the expression is treated
as boolean; otherwise, smart matching is used.

is applied recursively to the first operand (which may be a
higher-precedence AND operator, for example). If the first operand
is to use smart matching, then both operands will do so; if it is
not, then the second argument will not be either.

you want. For example:

an explicit test on  will be treated as boolean.

other uses smart matching, and that wins.

Watch out for this one, then, because an arrayref is always a true value, which
makes it effectively redundant.

tempted to write

though the rules say to use a smart match on 0). For an alternation like
this, an array ref will work, because this will instigate smart matching:

functionality (not to be confused with 0 fallthrough functionality - see
below), wherein the same block is used for several 0 statements.

or hash as the argument to 0, it is turned into a
reference. So 0 is the same as 0,
for example.

to say that it always matches.

0 block.  Every 0 block is implicitly ended with
a 0.

case to the next:

when it's the last statement of a block), it evaluates to :

0/0 clause, if there's one.

condition is true.

was applied to the 0 block.

evaluate to an empty list.

may be addressed in a future version of perl.

For example, here's one way to count how many times a particular
string occurs in an array:

You can override that with an explicit 0 if you're only
interested in the first match.

as in 0. You have to use the default
variable 0. (You can use 0.)

are. The behaviour is determined by the following table: the first row
that applies determines the match behaviour (which is thus mostly
determined by the type of the right operand). Note that the smart match
implicitly dereferences any non-blessed hash or array ref, so the "Hash"
and "Array" entries apply in those cases. (For blessed references, the
"Object" entries apply.)

example, the smart match operator short-circuits whenever possible, but
0 does not.

the 0 operator. This may alter the usual smart match semantics.

don't overload it (in order to avoid relying on the object's
underlying structure).

overloading, so if 0 has smart match overloading, then

instead the table above is consulted as normal, and based in the type of X,
overloading may or may not be invoked.

absolutely identical to their Perl 6 analogues. The most visible
difference is that, in Perl 5, parentheses are required around
the argument to 0 and 0 (except when this last
one is used as a statement modifier). Parentheses in Perl 6
are always optional in a control construct such as 0,
0, or 0; they can't be made optional in Perl
5 without a great deal of potential confusion, because Perl 5
would parse the expression

0, interpreting the braces as hash-element syntax.

Perl 6 specification, mainly due to the differences between Perl 6's
and Perl 5's data models.

with its argument, whilst it is convenient in Perl 5 to
suppress this implicit smart match in certain situations,
as documented above. (The difference is largely because Perl 5
does not, even internally, have a boolean type.)

0

statement.  There are three forms: 0-LABEL, 0-EXPR, and
0-&NAME.  A loop's LABEL is not actually a valid target for
a 0; it's just the name of the loop.

execution there.  It may not be used to go into any construct that
requires initialization, such as a subroutine or a 0 loop.  It
also can't be used to go into a construct that is optimized away.  It
can be used to go almost anywhere else within the dynamic scope,
including out of subroutines, but it's usually better to use some other
construct such as 0 or 0.  The author of Perl has never felt the
need to use this form of 0 (in Perl, that is--C is another matter).

dynamically.  This allows for computed 0s per FORTRAN, but isn't
necessarily recommended if you're optimizing for maintainability:

named subroutine for the currently running subroutine.  This is used by
0 subroutines that wish to load another subroutine and then
pretend that the other subroutine had been called in the first place
(except that any modifications to 0 in the current subroutine are
propagated to the other subroutine.)  After the 0, not even 0
will be able to tell that this routine was called first.

structured control flow mechanisms of 0, 0, or 0 instead of
resorting to a 0.  For certain applications, the catch and throw pair of
0 and  for exception processing can also be a prudent approach.

0 0

While it's expecting the beginning of a new statement, if the compiler
encounters a line that begins with an equal sign and a word, like this

beginning with 0 will be ignored.  The format of the intervening
text is described in 0.

and your documentation text freely, as in

with a pod directive (it makes parsing easier), whereas the compiler
actually knows to look for pod escapes even in the middle of a
paragraph.  This means that the following secret stuff will be
ignored by both the compiler and the translators.

Not all pod translators are well-behaved in this regard, and perhaps
the compiler will become pickier.

of code.

0 0 0 0 0

this, one can control Perl's idea of filenames and line numbers in
error or warning messages (especially for strings that are processed
with 0).  The syntax for this mechanism is almost the same as for
most C preprocessors: it matches the regular expression

the optional filename (specified with or without quotes). Note that
no whitespace may precede the , unlike modern C preprocessors.

Debuggers and profilers will only show the last source line to appear
at a particular line number in a given file.  Care should be taken not
to cause line number collisions in code you'd like to debug later.

shell:

=encoding utf8

referred to as 0) that was first introduced in Perl 5.6.0.  In this
model, each thread runs in its own Perl interpreter, and any data sharing
between threads must be explicit.  The user-level interface for 0
uses the 0 class.

that used the 0 class.  This old model was known to have problems, is
deprecated, and was removed for release 5.10.  You are
strongly encouraged to migrate any existing 5.005 threads code to the new
model as soon as possible.

running 0 and looking at the 0 section.
If you have 0 you have ithreads, if you
have 0 you have 5.005 threads.
If you have neither, you don't have any thread support built in.
If you have both, you are in trouble.

distribution.  Additionally, they are maintained as a separate modules on
CPAN, so you can check there for any updates.

execution point.

Threads are one of the pieces of a process.  Every process has at least
one thread and, up until now, every process running Perl had only one
thread.  With 5.8, though, you can create extra threads.  We're going
to show you how, when, and why.

program.  Which model you choose depends on what you need your program
to do.  For many non-trivial threaded programs, you'll need to choose
different models for different pieces of your program.

0 threads.  The boss thread gathers or generates tasks that need
to be done, then parcels those tasks out to the appropriate worker
thread.

waits for some event and then passes that event to the appropriate
worker threads for processing.  Once the event has been passed on, the
boss thread goes back to waiting for another event.

necessarily performed faster than with any other method, it tends to
have the best user-response times.

essentially the same thing to different pieces of data.  It closely
mirrors classical parallel processing and vector processors, where a
large array of processors do the exact same thing to many pieces of
data.

will distribute multiple threads across different processors.  It can
also be useful in ray tracing or rendering engines, where the
individual threads can pass on interim results to give the user visual
feedback.

passes the results of one step on to the thread processing the
next.  Each thread does one thing to each piece of data and passes the
results to the next thread in line.

or more threads will be executing in parallel, though it can often
make sense in other contexts as well.  It tends to keep the individual
tasks small and simple, as well as allowing some parts of the pipeline
to block (on I/O or system calls, for example) while other parts keep
going.  If you're running different parts of the pipeline on different
processors you may also take advantage of the caches on each
processor.

rather than having a subroutine call itself, it instead creates
another thread.  Prime and Fibonacci generators both map well to this
form of the pipeline model. (A version of a prime number generator is
presented later on.)

find that things aren't quite what you expect.  It's very important to
remember when dealing with Perl threads that 0 for all values of X.  They aren't POSIX threads, or
DecThreads, or Java's Green threads, or Win32 threads.  There are
similarities, and the broad concepts are the same, but if you start
looking for implementation details you're going to be either
disappointed or confused.  Possibly both.

everything that's ever come before. They're not.  Perl's threading
model owes a lot to other thread models, especially POSIX.  Just as
Perl is not C, though, Perl threads are not POSIX threads.  So if you
find yourself looking for mutexes, or thread priorities, it's time to
step back a bit and think about what you want to do and how Perl can
do it.

do things unless your operating system's threads allow it. So if your
system blocks the entire process on 0, Perl usually will, as well.

substantially. There are implications for people who write
modules with XS code or external libraries. However, since Perl data is
not shared among threads by default, Perl modules stand a high chance of
being thread-safe or can be made thread-safe easily.  Modules that are not
tagged as thread-safe should be tested or code reviewed before being used
in production code.

always assume a module is unsafe unless the documentation says
otherwise.  This includes modules that are distributed as part of the
core.  Threads are a relatively new feature, and even some of the standard
modules aren't thread-safe.

to work well with threads. A module could possibly be rewritten to utilize
the new features in threaded Perl to increase performance in a threaded
environment.

can protect yourself by using it from one, and only one thread at all.
If you need multiple threads to access such a module, you can use semaphores and
lots of programming discipline to control access to it.  Semaphores
are covered in 0.

threaded programs.  In the following sections, we'll cover the basics,
showing you what you need to do to create a threaded program.   After
that, we'll go over some of the features of the 0 module that
make threaded programming easier.

turned on or off when Perl is built at your site, rather than when
your programs are compiled. If your Perl wasn't compiled with thread
support enabled, then any attempt to use threads will fail.

enabled. If your program can't run without them, you can say something
like:

have code like this:

messy, it's best to isolate the thread-specific code in its own
module.  In our example above, that's what 0 is, and it's
only imported if we're running on a threaded Perl.

executing before the program exits.  That care has 0 been taken in these
examples in the interest of simplicity.  Running these examples 0 will
produce error messages, usually caused by the fact that there are still
threads running when the program exits.  You should not be alarmed by this.

threads.  Like any other module, you need to tell Perl that you want to use
it; 0 imports all the pieces you need to create basic
threads.

thread that starts executing in the referenced subroutine.  Control
then passes both to the subroutine and the caller.

part of the thread startup.  Just include the list of parameters as
part of the C<threads-0 call, like this:

off several threads using the same subroutine.  Each thread executes
the same subroutine, but in a separate thread with a separate
environment and potentially separate arguments.

for a thread to exit and extract any values it might return, you can
use the 0 method:

ends.  In addition to waiting for a thread to finish and gathering up
any values that the thread might have returned, 0 also performs
any OS cleanup necessary for the thread.  That cleanup might be
important, especially for long-running programs that spawn lots of
threads.  If you don't want the return values and don't want to wait
for the thread to finish, you should call the 0 method
instead, as described next.

that the thread creation call be made in list context (i.e., 0).
See  and 0 for more
details on thread context and return values.

after it, and returns any data the thread may have produced.  But what
if you're not interested in the thread's return values, and you don't
really care when the thread finishes? All you want is for the thread
to get cleaned up after when it's done.

it'll run until it's finished; then Perl will clean up after it
automatically.

that it might have produced (if it was done and waiting for a join) is
lost.

detach itself:

run to completion, assuming that is what you want.

threads.   and  have this property,
and perl does an exit when the main thread exits,
perhaps implicitly by falling off the end of your code,
even if that's not what you want.

"Perl exited with active threads: 2 running and unjoined":

topic: Data.  Threading introduces a couple of complications to data
access that non-threaded programs never need to worry about.

threading, or for that matter, to most other threading systems out there,
is that by default, no data is shared. When a new Perl thread is created,
all the data associated with the current thread is copied to the new
thread, and is subsequently private to that new thread!
This is similar in feel to what happens when a Unix process forks,
except that in this case, the data is just copied to a different part of
memory within the same process rather than a real fork taking place.

at least some data between themselves. This is done with the
0 module and the 0. Both 0 and 0 access the global variable 0, once
to read and once to write.  Depending on factors ranging from your
thread implementation's scheduling algorithm to the phase of the moon,
0 can be 2 or 3.

data.  Without explicit synchronization, there's no way to be sure that
nothing has happened to the shared data between the time you access it
and the time you update it.  Even this simple code fragment has the
possibility of error:

at any point, or be executed in any order.  At the end, 0 could be 3
or 4, and both 0 and 0 could be 2 or 3.

by other threads, you must take steps to coordinate access or risk
data inconsistency and race conditions. Note that Perl will protect its
internals from your race conditions, but it won't protect you from you.

between themselves and their data, to avoid race conditions and the like.
Some of these are designed to resemble the common techniques used in thread
libraries such as 0; others are Perl-specific. Often, the
standard techniques are clumsy and difficult to get right (such as
condition waits). Where possible, it is usually easier to use Perlish
techniques such as queues, which remove some of the hard work involved.

No other thread may lock the variable until the variable is unlocked
by the thread holding the lock. Unlocking happens automatically
when the locking thread exits the block that contains the call to the
0 function.  Using 0 is straightforward: This example has
several threads doing some calculations in parallel, and occasionally
updating a running total:

available.  When 0 returns, your thread can be sure that no other
thread can lock that variable until the block containing the
lock exits.

in question, only lock attempts.  This is in keeping with Perl's
longstanding tradition of courteous programming, and the advisory file
locking that 0 gives you.

though, will not block subsequent locks on array elements, just lock
attempts on the array itself.

lock a variable more than once.  The lock will last until the outermost
0 on the variable goes out of scope. For example:

variable is to allow it to go out of scope.

being locked, or it can be used to guard something else, like a section
of code. In this latter case, the variable in question does not hold any
useful data, and exists only for the purpose of being locked. In this
respect, the variable behaves like the mutexes and basic semaphores of
traditional thread libraries.

properly is the key to safe shared data.  Unfortunately, locks aren't
without their dangers, especially when multiple locks are involved.
Consider the following code:

won't hang is if one of the two threads acquires both locks
first.  A guaranteed-to-hang version is more complicated, but the
principle is the same.

the second thread has probably had time to do some work, try to grab a
lock on 0.  Meanwhile, the second thread grabs a lock on 0, then later
tries to grab a lock on 0.  The second lock attempt for both threads will
block, each waiting for the other to release its lock.

more threads are trying to get locks on resources that the others
own.  Each thread will block, waiting for the other to release a lock
on a resource.  That never happens, though, since the thread with the
resource is itself waiting for a lock to be released.

way is to always have all threads acquire locks in the exact same
order.  If, for example, you lock variables 0, 0, and 0, always lock
0 before 0, and 0 before 0.  It's also best to hold on to locks for
as short a period of time to minimize the risks of deadlock.

similar problems.

end and take it out the other without having to worry about
synchronization issues.  They're pretty straightforward, and look like
this:

add lists of scalars onto the end with 0, and pop scalars off
the front of it with 0.  A queue has no fixed size, and can grow
as needed to hold everything pushed on to it.

something.  This makes queues ideal for event loops and other
communications between threads.

form, they behave very much like lockable scalars, except that they
can't hold data, and that they must be explicitly unlocked. In their
advanced form, they act like a kind of counter, and can allow multiple
threads to have the 0 at any one time.

count, while 0 increments it. Calls to 0 will block if the
semaphore's current count would decrement below zero.  This program
gives a quick demonstration:

semaphore, though, makes sure that only one thread is accessing the
global variable at once.

0 them at a time.  However, there are other uses for semaphores.

created with the counter set to one, 0 decrements the counter by
one, and 0 increments by one. However, we can override any or all
of these defaults simply by passing in different values:

the counter is large enough.  Note that while a semaphore can be created
with a starting count of zero, any 0 or 0 always changes the
counter by at least one, and so  is the same as
.

create a semaphore with a starting count that's not one, or why
decrement or increment it by more than one? The answer is resource
availability.  Many resources that you want to manage access for can be
safely used by more than one thread at once.

it uses to synchronize access to the display, so only one thread is
ever drawing at once.  Handy, but of course you don't want any thread
to start drawing until things are properly set up.  In this case, you
can create a semaphore with a counter set to zero, and up it when
things are ready for drawing.

establishing quotas.  Say, for example, that you have a number of
threads that can do I/O at once.  You don't want all the threads
reading or writing at once though, since that can potentially swamp
your I/O channels, or deplete your process's quota of filehandles.  You
can use a semaphore initialized to the number of concurrent I/O
requests (or open files) that you want at any one time, and have your
threads quietly block and unblock themselves.

thread needs to check out or return a number of resources at once.

can be used in conjunction with locks to notify
co-operating threads that a resource has become available. They are
very similar in use to the functions found in 0. However
for most purposes, queues are simpler to use and more intuitive. See
0 for more details.

explicitly give up the CPU to another thread.  You may be doing something
processor-intensive and want to make sure that the user-interface thread
gets called frequently.  Regardless, there are times that you might want
a thread to give up the processor.

this. 0 is pretty straightforward, and works like this:

it depends on your hardware, OS and threading libraries what actually happens.
0  Therefore it is important
to note that one should not build the scheduling of the threads around
0 calls. It might work on your platform but it won't work on another
platform.

with these tools you should be well on your way to writing threaded
code and packages.  There are a few useful little pieces that didn't
really fit in anyplace else.

get an object representing the thread it's currently in.  You can use this
object in the same way as the ones returned from thread creation.

thread the object represents.  Thread IDs are integers, with the main
thread in a program being 0.  Currently Perl assigns a unique TID to
every thread ever created in your program, assigning the first thread
to be created a TID of 1, and increasing the TID by 1 for each new
thread that's created.  When used as a class method, C<threads-0
can be used by a thread to get its own TID.

if the objects represent the same thread, and false if they don't.

comparison on them as you would with normal objects.

that's currently running and not detached.  Handy for a number of things,
including cleaning up at the end of your program (from the main Perl thread,
of course):

ends, Perl will warn you about it and die, since it is impossible for Perl
to clean up itself while other threads are running.

does not appear in the list returned by C<threads-0.

things we've covered.  This program finds prime numbers using threads.

thread in the pipeline has an input queue that feeds numbers to be
checked, a prime number that it's responsible for, and an output queue
into which it funnels numbers that have failed the check.  If the thread
has a number that's failed its check and there's no child thread, then
the thread must have found a new prime number.  In that case, a new
child thread is created for that prime and stuck on the end of the
pipeline.

go through this program piece by piece and see what it does.  (For
those of you who might be trying to remember exactly what a prime
number is, it's a number that's only evenly divisible by itself and 1.)

takes a reference to its input queue and a prime number that it's
responsible for.  After pulling in the input queue and the prime that
the subroutine is checking (line 11), we create a new queue (line 13)
and reserve a scalar for the thread that we're likely to create later
(line 12).

queue and checks against the prime this thread is responsible
for.  Line 15 checks to see if there's a remainder when we divide the
number to be checked by our prime.  If there is one, the number
must not be evenly divisible by our prime, so we need to either pass
it on to the next thread if we've created one (line 17) or create a
new thread if we haven't.

the queue we've created, and the prime number we've found.  In lines 21
through 24, we check to make sure that our new thread got created, and
if not, we stop checking any remaining numbers in the queue.

queue, which serves as a note to terminate), we pass on the notice to our
child, and wait for it to exit if we've created a child (lines 27 and
30).

queue up all the numbers from 3 to 1000 for checking, plus a termination
notice.  Then all we have to do to get the ball rolling is pass the queue
and the first prime to the 0 subroutine (line 34).

the explanation is much longer than the program.

viewpoint.  There are three basic categories of threads: user-mode threads,
kernel threads, and multiprocessor kernel threads.

its libraries.  In this model, the OS knows nothing about threads.  As
far as it's concerned, your process is just a process.

start.  The big disadvantage is that, since the OS knows nothing about
threads, if one thread blocks they all do.  Typical blocking activities
include most system calls, most I/O, and things like 0.

about kernel threads, and makes allowances for them.  The main
difference between a kernel thread and a user-mode thread is
blocking.  With kernel threads, things that block a single thread don't
block other threads.  This is not the case with user-mode threads,
where the kernel blocks at the process level and not the thread level.

performance boost over non-threaded programs.  Threads that block
performing I/O, for example, won't block threads that are doing other
things.  Each process still has only one thread running at once,
though, regardless of how many CPUs a system might have.

uncover some of the implicit locking assumptions you may make in your
program.  For example, something as simple as 0 can behave
unpredictably with kernel threads if 0 is visible to other
threads, as another thread may have changed 0 between the time it
was fetched on the right hand side and the time the new value is
stored.

support.  With multiprocessor kernel threads on a machine with multiple
CPUs, the OS may schedule two or more threads to run simultaneously on
different CPUs.

since more than one thread will be executing at the same time.  As a
tradeoff, though, any of those nagging synchronization issues that
might not have shown with basic kernel threads will appear with a
vengeance.

different OSes (and different thread implementations for a particular
OS) allocate CPU cycles to threads in different ways.

if one of two things happen.  If a thread calls a yield function, it
gives up control.  It also gives up control if the thread does
something that would cause it to block, such as perform I/O.  In a
cooperative multitasking implementation, one thread can starve all the
others for CPU time if it so chooses.

while the system decides which thread should run next.  In a preemptive
multitasking system, one thread usually won't monopolize the CPU.

running simultaneously. (Threads running with realtime priorities
often behave cooperatively, for example, while threads running at
normal priorities behave preemptively.)

models is the fact that for each new thread created, a complete copy of
all the variables and data of the parent thread has to be taken. Thus,
thread creation can be quite expensive, both in terms of memory usage and
time spent in creation. The ideal way to reduce these costs is to have a
relatively short number of long-lived threads, all created fairly early
on (before the base thread has accumulated too much data). Of course, this
may not always be possible, so compromises have to be made. However, after
a thread has been created, its performance and extra memory usage should
be little different than ordinary code.

use a little more memory and are a little slower than ordinary variables.

Perl data is thread-private unless explicitly shared, the threads can
affect process-scope state, affecting all the threads.

directory using 0.  One thread calls 0, and the working
directory of all the threads changes.

the root directory of all the threads changes, and no thread can
undo it (as opposed to 0).

changing uids and gids.

until the feeling passes.  Be aware that the semantics of 0 vary
between platforms.  For example, some Unix systems copy all the current
threads into the child process, while others only copy the thread that
called 0. You have been warned!

Implementations are platform-dependent, and even the POSIX
semantics may not be what you expect (and Perl doesn't even
give you the full POSIX API).  For example, there is no way to
guarantee that a signal sent to a multi-threaded Perl application
will get intercepted by any particular thread.  (However, a recently
added feature does provide the capability to send signals between
threads.  See 0 for more details.)

of Perl.  Calls often suffering from not being thread-safe include:
0, 0,  functions fetching user, group and
network information (such as 0, 0,
0 and so on), 0, 0, and 0. In
general, calls that depend on some global external state.

calls, they will be used.  Beyond that, Perl is at the mercy of
the thread-safety or -unsafety of the calls.  Please consult your
C library call documentation.

result buffer is too small (for example the user group databases may
be rather large, and the reentrant interfaces may have to carry around
a full snapshot of those databases).  Perl will start with a small
buffer, but keep retrying and growing the result buffer
until the result fits.  If this limitless growing sounds bad for
security or memory consumption reasons you can recompile Perl with
0 defined to the maximum number of bytes you will
allow.

but with what we've covered in this introduction, you should be well
on your way to becoming a threaded Perl expert.

0

0

0

0

0

Threads. Digital Equipment Corporation, 1989, DEC-SRC Research Report
#35 online as
ftp://ftp.dec.com/pub/DEC/SRC/research-reports/SRC-035.pdf
(highly recommended)

Guide to Concurrency, Communication, and
Multithreading. Prentice-Hall, 1996.

Pthreads. Prentice Hall, 1997, ISBN 0-13-443698-9 (a well-written
introduction to threads).

Hall, 1991, ISBN 0-13-590464-1.

Pthreads Programming. O'Reilly & Associates, 1996, ISBN 156592-115-1
(covers POSIX threads).

LoVerso. Programming under Mach. Addison-Wesley, 1994, ISBN
0-201-52739-1.

1995, ISBN 0-13-219908-4 (great textbook).

4th ed. Addison-Wesley, 1995, ISBN 0-201-59292-4

ed. Addison-Wesley, 1998, ISBN 0-201-31006-6.

0

Collection on Virtually Shared Memory Architectures" in Memory
Management: Proc. of the International Workshop IWMM 92, St. Malo,
France, September 1992, Yves Bekkers and Jacques Cohen, eds. Springer,
1992, ISBN 3540-55940-X (real-life thread applications).

0

Sarathy, Ilya Zakharevich, Benjamin Sugars, Jürgen Christoffel, Joshua
Pritikin, and Alan Burlison, for their help in reality-checking and
polishing this article.  Big thanks to Tom Christiansen for his rewrite
of the prime number generator.

about thread-safety of Perl code.

less emphasis on .

Journal #10, and is copyright 1998 The Perl Journal. It appears courtesy
of Jon Orwant and The Perl Journal.  This document may be distributed
under the same terms as Perl itself.

=encoding utf8

0

to connect an on-disk database in the standard Unix dbm(3x)
format magically to a %HASH in their program.  However, their Perl was either
built with one particular dbm library or another, but not both, and
you couldn't extend this mechanism to other packages or types of variables.

the implementation for access methods for that variable.  Once this magic
has been performed, accessing a tied variable automatically triggers
method calls in the proper class.  The complexity of the class is
hidden behind magic methods calls.  The method names are in ALL CAPS,
which is a convention that Perl uses to indicate that they're called
implicitly rather than explicitly--just like the  and 
functions.

enchanted.  0 is the name of a class implementing objects of
the correct type.  Any additional arguments in the 0 are passed to
the appropriate constructor method for that class--meaning ,
, , or .  (Typically these are arguments
such as might be passed to the  function of C.) The object
returned by the "new" method is also returned by the  function,
which would be useful if you wanted to access other methods in
0. (You don't actually have to return a reference to a right
"type" (e.g., HASH or 0) so long as it's a properly blessed
object.)  You can also retrieve a reference to the underlying object
using the  function.

for you--you need to do that explicitly yourself.

0

TIESCALAR, FETCH, STORE, and possibly UNTIE and/or DESTROY.

scalars that allows the user to do something like:

system priority is retrieved and returned.  If those variables are set,
then the process's priority is changed!

included) to access the PRIO_PROCESS, PRIO_MIN, and PRIO_MAX constants
from your system, as well as the  and  system
calls.  Here's the preamble of the class.

0

expected to return a blessed reference to a new scalar
(probably anonymous) that it's creating.  For example:

exception if its constructor should fail.  While this is how  works,
other classes may well not wish to be so forgiving.  It checks the global
variable 0 to see whether to emit a bit of noise anyway.

0

(read).  It takes no arguments beyond its self reference, which is the
object representing the scalar we're dealing with.  Because in this case
we're using just a SCALAR ref for the tied scalar object, a simple $
allows the method to get at the real value stored there.  In our example
below, that real value is the process ID to which we've tied our variable.

fails--there's no place for us to return an error otherwise, and it's
probably the right thing to do.

0

(assigned).  Beyond its self reference, it also expects one (and only one)
argument: the new value the user is trying to assign. Don't worry about
returning a value from STORE; the semantic of assignment returning the
assigned value is implemented with FETCH.

0

if the class needs to know when no further calls will be made. (Except DESTROY
of course.) See L<The 0 below for more details.

0

As with other object classes, such a method is seldom necessary, because Perl
deallocates its moribund object's memory for you automatically--this isn't
C++, you know.  We'll use a DESTROY method here for debugging purposes only.

is to it, because we've done a few nice things here for the sake
of completeness, robustness, and general aesthetics.  Simpler
TIESCALAR classes are certainly possible.

0

methods: TIEARRAY, FETCH, STORE, FETCHSIZE, STORESIZE and perhaps UNTIE and/or DESTROY.

equivalent 0 access.

required if the perl operator with the corresponding (but lowercase) name
is to operate on the tied array. The 0 class can be used as a
base class to implement the first five of these in terms of the basic
methods above.  The default implementations of DELETE and EXISTS in
0 simply 0.

allocation in a real array.

size at creation.  If you try to create an element larger than the fixed
size, you'll take an exception.  For example:

0

return a blessed reference through which the new array (probably an
anonymous ARRAY ref) will be accessed.

ARRAY reference, we'll choose a HASH reference to represent our object.
A HASH works out well as a generic record type: the 0 field will
store the maximum element size allowed, and the 0 field will hold the
true ARRAY ref.  If someone outside the class tries to dereference the
object returned (doubtless thinking it an ARRAY ref), they'll blow up.
This just goes to show you that you should respect an object's privacy.

0

is accessed (read).  It takes one argument beyond its self reference: the
index whose value we're trying to fetch.

will be translated to a positive one internally by calling FETCHSIZE
before being passed to FETCH.  You may disable this feature by
assigning a true value to the variable 0 in the
tied array class.

for all accesses, even though the constructors differ in names (TIESCALAR
vs TIEARRAY).  While in theory you could have the same class servicing
several tied types, in practice this becomes cumbersome, and it's easiest
to keep them at simply one tie type per class.

0

(written).  It takes two arguments beyond its self reference: the index at
which we're trying to store something and the value we're trying to put
there.

spaces so we have a little more work to do here:

0

object 0. (Equivalent to 0).  For example:

0

object 0 to be 0. If this makes the array larger then
class's mapping of 0 should be returned for new positions.
If the array becomes smaller then entries beyond count should be
deleted.

C<-0 number of spaces.  Observe:

0

Can be used to optimize allocation. This method need do nothing.

entries, so 0 will make use of 0 to fill elements
as needed:

0

C<-0 spaces only, it does not exist:

0

0

object 0.  For example:

0

0

0

and return it.  For example:

0

up to make room.  For example:

0

from the end of the array.

0

0

As with the scalar tie class, this is almost never needed in a
language that does its own garbage collection, so this time we'll
just leave it out.

0

implementing a tied hash should define the following methods: TIEHASH is
the constructor.  FETCH and STORE access the key and value pairs.  EXISTS
reports whether a key is present in the hash, and DELETE deletes one.
CLEAR empties the hash by deleting all the key and value pairs.  FIRSTKEY
and NEXTKEY implement the  and  functions to iterate over all
the keys. SCALAR is triggered when the tied hash is evaluated in scalar
context. UNTIE is called when 0 happens, and DESTROY is called when
the tied variable is garbage collected.

standard Tie::StdHash module for most of your methods, redefining only the
interesting ones.  See 0 for details.

and the key existing in the hash but having a corresponding value of
0.  The two possibilities can be tested with the 0 and
0 functions.

a hash representing a particular user's dot files.  You index into the hash
with the name of the file (minus the dot) and you get back that dot file's
contents.  For example:

hash for the object containing several important
fields, of which only the 0 field will be what the
user thinks of as the real hash.

during development.  We keep also one convenience function around
internally to help print out warnings;  returns the function name
that calls it.

0

return a blessed reference through which the new object (probably but not
necessarily an anonymous hash) will be accessed.

return values out of a readdir, you'd better prepend the directory
in question.  Otherwise, because we didn't  there, it would
have been testing the wrong file.

0

accessed (read).  It takes one argument beyond its self reference: the key
whose value we're trying to fetch.

would probably be more portable to open the file manually (and somewhat
more efficient).  Of course, because dot files are a Unixy concept, we're
not that concerned.

0

(written).  It takes two arguments beyond its self reference: the index at
which we're trying to store something, and the value we're trying to put
there.

them try to overwrite the file unless they've called the 
method on the original object reference returned by .

use the  function, so they might alternately have set clobber
using:

0

typically by using the  function.  Again, we'll
be careful to check whether they really want to clobber files.

to .  If you want to emulate the normal behavior of ,
you should return whatever FETCH would have returned for this key.
In this example, we have chosen instead to return a value which tells
the caller whether the file was successfully deleted.

0

assigning the empty list to it.

dangerous thing that they'll have to set CLOBBER to something higher than
1 to make it happen.

0

on a particular hash.  In our example, we'll look at the 0
hash element for this:

0

to iterate through the hash, such as via a  or 
call.

0

second argument which is the last key that had been accessed.  This is
useful if you're carrying about ordering or calling the iterator from more
than one sequence, or not really storing things in a hash anywhere.

thing, but we'll have to go through the LIST field indirectly.

0

to mimic the behaviour of untied hashes, this method should return a
false value when the tied hash is considered empty. If this method does
not exist, perl will make some educated guesses and return true when
the hash is inside an iteration. If this isn't the case, FIRSTKEY is
called, and the result will be a false value if FIRSTKEY returns the empty
list, true otherwise.

thing. Particularly, perl will mistakenly return true when you clear the
hash by repeatedly calling DELETE until it is empty. You are therefore
advised to supply your own SCALAR method when you want to be absolutely
sure that your hash behaves nicely in scalar context.

referenced by C<-0:

0

0

scope.  You don't really need it unless you're trying to add debugging
or have auxiliary state to clean up.  Here's a very simple function:

when used on large objects, like DBM files.  You may prefer to use the
 function to iterate over such.  Example:

0

methods: TIEHANDLE, at least one of PRINT, PRINTF, WRITE, READLINE, GETC,
READ, and possibly CLOSE, UNTIE and DESTROY.  The class can also provide: BINMODE,
OPEN, EOF, FILENO, SEEK, TELL - if the corresponding perl operators are
used on the handle.

and error messages.  This feature is temporarily disabled during the call,
which means you can use 0 inside PRINT without starting a recursive
loop.  And just like 0 and 0 handlers, STDERR's PRINT
method may be called to report parser errors, so the caveats mentioned under
0 apply.

program, where output to STDOUT and STDERR may have to be redirected
in some special way.  See nvi and the Apache module for examples.

asterisk. So, if you are tying STDOUT, use 0. If you have assigned
it to a scalar variable, say 0, use 0. 0
works, too, but that is considered a bug and will be fixed in Perl 5.16. It
is supposed to tie the scalar 0, not the handle inside it.
0 emits a deprecation warning as of Perl 5.14.

0

return a blessed reference of some sort. The reference can be used to
hold some internal information.

0

0 function.

0

with the 0 or 0 functions.  Beyond its self reference
it also expects the list that was passed to the print function.

you need do nothing special to handle 0 in 0.

0

with the 0 function.
Beyond its self reference it also expects the format and list that was
passed to the printf function.

0

or 0 functions.

0

or 0.

the next line, or 0 for no more data.  In list context it should
return all remaining lines, or an empty list for no more data.  The strings
returned should include the input record separator 0 (see 0),
unless it is 0 (which means "slurp" mode).

0

0

will be zero if 0 is called without parameter; 0 if 0 is given
a filehandle as a parameter, e.g. 0; and 0 in the very special
case that the tied filehandle is 0 and 0 is called with an empty
parameter list, e.g. 0.

0

function.

0

It may be appropriate to "auto CLOSE" when this occurs.  See
L<The 0 below.

0

tied handle is about to be destroyed. This is useful for debugging and
possibly cleaning up.

0

at .  See L<The 0 below.

0

, and if the tie's target class defines a destructor, there is a
subtle gotcha you 0 guard against.

tie; all it does is use a file to keep a log of the values assigned to
a scalar.

spotted that the tied object hasn't been used so far.  So lets add an
extra method to the Remember class to allow comments to be included in
the file; say, something like this:

(which requires the tied object):

return value of the TIESCALAR, TIEARRAY, or TIEHASH function.  This
object normally has only one reference, namely, the implicit reference
from the tied variable.  When  is called, that reference is
destroyed.  Then, as in the first example above, the object's
destructor (DESTROY) is called, which is normal for objects that have
no more valid references; and thus the file is closed.

the tied object in .  That means that when  gets called
there will still be a valid reference to the object in existence, so
the destructor is not called at that time, and thus the file is not
closed.  The reason there is no output is because the file buffers
have not been flushed to disk.

Prior to the introduction of the optional UNTIE method the only way
was the good old 0 flag. Which will spot any instances where you call
 and there are still valid references to the tied object.  If
the second script above this near the top 0
or was run with the 0 flag, Perl prints this
warning message:

there are no valid references to the tied object 0  is
called:

class functionality are really associated with 0 and which with
the object being destroyed. What makes sense for a given class depends
on whether the inner references are being kept so that non-tie-related
methods can be called on the object. But in most cases it probably makes
sense to move the functionality that would have been in DESTROY to the UNTIE
method.

UNTIE method is passed the count of "extra" references and can issue its own
warning if appropriate. e.g. to replicate the no UNTIE case this method can
be used:

A good starting point for many  implementations is with one of the
modules 0, 0, 0, or 0.

available.  What this means is that using %tied_hash in boolean
context doesn't work right (currently this always tests false,
regardless of whether the hash is empty or hash elements).

scope the arrays or the hashes are not restored.

or 0) is inefficient since it needs to iterate
through all the entries with FIRSTKEY/NEXTKEY.

tie methods for slice operations.

hashes) to a dbm file.  The first problem is that all but GDBM and
Berkeley DB have size limitations, but beyond that, you also have problems
with how references are to be represented on disk.  One
module that does attempt to address this need is DBM::Deep.  Check your
nearest CPAN site as described in 0 for source code.  Note
that despite its name, DBM::Deep does not use dbm.  Another earlier attempt
at solving the problem is MLDBM, which is also available on the CPAN, but
which has some fairly serious limitations.

, ,  and -X can't currently be trapped.

=encoding utf8

is at 0

to work on any of these, but it's a good idea to first contact
0 to avoid duplication of effort, and to learn from
any previous attempts. By all means contact a pumpking privately first if you
prefer.

the list are also encouraged. Check the perl5-porters archives for past
ideas, and any discussion about them. One set of archives may be found at
0

not, but if your patch is incorporated, then we'll add your name to the
0 file, which ships in the official distribution. How many other
programming languages offer you 1 line of immortality?

functions. As explained in 0, tests in 0 are
written in a particular way to test that more complex constructions actually
work before using them routinely. Hence they don't use 0, but
instead there is an intentionally simpler library, 0. However,
quite a few tests in 0 have not been refactored to use it. Refactoring
any of these tests, one at a time, is a useful thing TODO.

basic tests, should be excluded from this task.

It's mostly manually generated currently, but some of that could be
automated with a bit of perl, specifically the generation of

some variation on the big block of 0 checks.  We can safely put this
into a file, change it to build an 0 hash and require it.  Maybe just put
it into 0. Throw in the handy tainting subroutines.

can be. It's not actually 0 simple as it sounds, particularly with the
flexibility POD allows for 0, but it would be good to improve the
visual appeal of the HTML generated, and to avoid it having any validation
errors. See also 0, as the layout of installation tree
is needed to improve the cross-linking.

easier to complete.

to work your way though the code from bottom to top, or if necessary adding
extra 0 blocks, and turning on strict within them.

Schwern has promised to donate to  to TPF. We may need volunteers to
hold him upside down and shake vigorously in order to actually extract the
cash.

tests that are currently missing.

would be useful to have a reasonable general benchmarking suite that roughly
represented what current perl programs do, and measurably reported whether
tweaks to the core improve, degrade or don't really affect performance, to
guide people attempting to optimise the guts of perl. Gisle would welcome
new tests for perlbench.

0).

distribution needs to be dual lifed. Anything else can be too. Figure out what
changes would be needed to package that module and its tests up for CPAN, and
do so. Test it with older perl releases, and fix the problems you find.

0.

various times worked to cut it down. There is probably still fat to cut out -
for example POSIX passes Exporter some very memory hungry data structures.

all of Perl's symbols in a consistent way, to provide some semblance of
namespace support in 0. Functions are declared in 0, variables
in 0. Quite a few of the functions and variables
are conditionally declared there, using 0. However, 0
doesn't understand the C macros, so the rules about which symbols are present
when is duplicated in 0. Writing things twice is bad, m'kay.
It would be good to teach 0 to understand the conditional
compilation, and hence remove the duplication, and the mistakes it has caused.

be more consistent (and less surprising) to arrange for all lexical pragmas
in force at the __END__ block to be in force within each autoloaded subroutine.

told is something Perl is good at. So it would be nice to know what it is doing
that is taking so much CPU, and where possible address it.

are times when it would be useful to quash a single warning, not a
whole category.

base...

"experimental". It would be good to get this tested, make it work reliably, and
remove the "experimental" tag. This would include

In particular that links work between the modules (files with POD in 0)
and the core documentation (files in 0)

group, preferably with general case code that could be used elsewhere.
Challenges here are correctly identifying the groups of functions that go
together, and making the right named external cross-links point to the right
page. Things to be aware of are 0, groups such as 0 to
0, two or more 0 giving the different parameter lists, such
as

the system does compressed man pages (same directory/different directory?
same filename/different filename), as well as tweaking the 0 script
to compress as necessary.

to do this manually are roughly

(see 0 for how to do this)

coverage you need to

0

(Including down in the subdirectories of 0

to get their stats into the cover_db directory.

wanted to perform perl level coverage, and another to specify C level
coverage, and have 0 and the 0 do all the right things
automatically.

compilers.  People install a free compiler, such as gcc. To work out how to
build extensions, Perl interrogates 0, so in this situation
0 describes compilers that aren't there, and extension building
fails. This forces people into choosing between re-compiling perl themselves
using the compiler they have, or only using modules that the vendor ships.

possibly involving probing at install time or later, so that the 0 in
a binary distribution better describes the installed machine, when the
installed machine differs from the build machine in some significant way.

symbols to the linker, so the core already has the infrastructure in place to
do this for generating shared perl libraries. My understanding is that the
GNU toolchain can accept an optional linker specification file, and restrict
visibility just to symbols declared in that file. It would be good to extend
0 to support this format, and to provide a means within
0 to enable it. This would allow Unix users to test that the
export list is correct, and to build a perl that does not pollute the global
namespace with private symbols, and will fail in the same way as msvc or mingw
builds or when using PERL_DL_NONLAZY=1.

arranges for building 0 for TARGET machine, so this 0 is
assumed then to be copied to TARGET machine and used as a replacement of full
0 executable.

HOST and then full 0 with extensions should be compiled for TARGET.
This, however, might require extra trickery for %Config: we have one config
first for HOST and then another for TARGET.  Tools like MakeMaker will be
mightily confused.  Having around two different types of executables and
libraries (HOST and TARGET) makes life interesting for Makefiles and
shell (and Perl) scripts.  There is {run}, normally empty, which
can be used as an execution wrapper.  Also note that in some
cross-compilation/execution environments the HOST and the TARGET do
not see the same filesystem(s), the {run} may need to do some
file/directory copying back and forth.

can resolve multiple global references that happen to have the same
name.  Usual values are 0 and 0.
Fervent ANSI compilers may be called 0.  AIX has 0.

libraries for dynamic loading.  On some systems, it is 0.
On ELF systems, it should be 0.  Mostly, we'll try to respect
the hint file setting.

something, that 0 is also the correct command for linking object files
together to make an executable. This may be true on Unix, but it's not true
on other platforms, and there are a maze of work arounds in other places (such
as 0) to cope with this.

linker program, probe for it in 0, and centralise all the special
case logic there or in hints files.

taken (arguably for the wrong thing now, but on SunOS 4.1 it is the command
for creating dynamically-loadable modules) and 0 could be confused with
the Unix command line executable of the same name, which does something
completely different. Andy Dougherty makes the counter argument "In parrot, I
tried to call the command used to link object files and  libraries into an
executable 0, since that's what my vaguely-remembered DOS and VMS
experience suggested. I don't think any real confusion has ensued, so it's
probably a reasonable name for perl5 to use."

since now the module building utilities would have to look for
0 and institute a fall-back plan if it weren't found."
Although I can see that as confusing, given that 0 is true
when (hard) links are available.

config.h for compiling Perl.  Makefiles are also hard-coded and need to be
hand edited prior to building Perl. While this makes it easy to create a perl.exe
that works across multiple Windows versions, being able to accurately
configure a perl.exe for a specific Windows versions and VS C++ would be
a nice enhancement.  With PowerShell available on Windows XP and up, this
may now be possible.  Step 1 might be to investigate whether this is possible
and use this to clean up our current makefile situation.  Step 2 would be to
see if there would be a way to use our existing metaconfig units to configure a
Windows Perl or whether we go in a separate direction and make it so.  Of
course, we all know what step 3 is.

flags if it spots 0 in the optimiser flags. The pre-processor directive
0 enables 0's command line 0 options, but in the process
makes 0 slower. It would be good to disentangle this logic, so that
C-level debugging with 0 and Perl level debugging with 0 can easily
be enabled independently.

background or experience with XS, or how the Perl interpreter works

unused arguments. Often the arguments can't be removed, as there is an
external constraint that determines the prototype of the function, so this
approach is valid. However, there are some cases where 0
could be removed. Specifically

macro used can be changed.

modules without overwriting files. This causes problems for binary
package builders.  One possible proposal is laid out in this
message:
0

On these systems, it might be the default compilation mode, and there
is currently no guarantee that passing no use64bitall option to the
Configure process will build a 32bit perl. Implementing -Duse32bit*
options would be nice for perl 5.14.

identify and optimise the hotspots. It would be good to measure the
performance of the Perl interpreter using free tools such as cachegrind,
gprof, and dtrace, and work to reduce the bottlenecks they reveal.

the ops that are most commonly used. The idea is that by grouping them, their
object code will be adjacent in the executable, so they have a greater chance
of already being in the CPU cache (or swapped in) due to being near another op
already in use.

as part of exercising your skills with coverage and profiling tools you might
want to determine what ops 0 are the most commonly used. And in turn
suggest evictions and promotions to achieve a better 0.

All 0 implementations have space overheads, and are now as fast as
custom allocates so it would both use less memory and less CPU to allocate
the various OP structures from arenas. The SV arena code can probably be
re-used for this.

 to pack optrees into a contiguous block, which is
probably superior to the use of OP arenas, esp. from a cache locality
standpoint.  See 0.

identical in both 0 and 0 files, which can't
be good.

that they were "unsafe" and introduced differently named secure versions of
them as replacements, e.g. instead of writing

-D_CRT_SECURE_NO_DEPRECATE to the CFLAGS. It would be nice to remove that
warning suppressant and actually make use of the new secure CRT functions.

been deprecated in favour of ISO C++ conformant names like _fileno. These
warnings are also currently suppressed by adding -D_CRT_NONSTDC_NO_DEPRECATE. It
might be nice to do as Microsoft suggest here too, although, unlike the secure
functions issue, there is presumably little or no benefit in this case.

correctly in situations where access is restricted by DACLs (as opposed to the
read-only attribute).

read-only attribute set depending on what CRT library is being used. For
example, the  function in the VC6 and VC7 CRTs (wrongly) claim that
such directories are not writable, whereas in fact all directories are writable
unless access is denied by DACLs. (In the case of directories, the read-only
attribute actually only means that the directory cannot be deleted.) This CRT
bug is fixed in the VC8 and VC9 CRTs (but, of course, the directory may still
not actually be writable if access is indeed denied by DACLs).

0

the correct answer.

been written so that it reflects the state of the read-only attribute, even
for directories (whatever CRT is being used), for symmetry with .)

none of the above (nor , , or *SHUDDER* )
ever creep back to libperl.a.

is using those naughty interfaces.

(4.1 onwards?) supports 0, both of which give
protection against various kinds of buffer overflow problems.
These should probably be used for compiling Perl whenever available,
Configure and/or hints files should be adjusted to probe for the
availability of these features and enable them as appropriate.

It might be a speed or memory saving to change to using arenas. Or it might
not. It would need some suitable benchmarking first. In particular, 0s
can probably be changed with minimal compatibility impact (probably nothing
outside of the core, or even outside of 0 allocates them), but they
probably aren't allocated/deallocated often enough for a speed saving. Whereas
0 is allocated/deallocated more often, but in turn, is also something
more externally visible, so changing the rules here may bite external code.

PVHV, and PVCV and PVFM. It should be possible to allocate and return same
sized bodies from the same actual arena, rather than maintaining one arena for
each. This could save 4-6K per thread, of memory no longer tied up in the
not-yet-allocated part of an arena.

the perl API that comes from writing modules that use XS to interface to
C.

demonstrate common tasks and good practices.  (Some of these might be
extracted from perlguts.) The target audience should be XS novices, who need
more examples than perlguts but something less overwhelming than perlapi.
Recipes should provide "one pretty good way to do it" instead of TIMTOWTDI.

should probably focus on how to optimize Perl routines by re-writing them
in XS.  This will likely be more motivating to those who mostly work in
Perl but are looking to take the next step into XS.

bootstrap a cookbook.  (List::Util? Class::XSAccessor? Tree::Ternary_XS?)
Another option could be deconstructing the implementation of some simpler
functions in op.c.

XSUB itself. The tokeniser already has the ability to inline constant
subroutines - it would be good to provide a way to inline other subroutines.

alternative implementation of itself as a custom OP. A new flag bit in
0 would signal to the peephole optimiser to take an optree
such as this:

pointer to the custom OP that provides the direct implementation, and re-
write the optree something like:

path, and the 0 OP has been replaced by the custom op.

tight loops. Initially one would have to write the OP alternative
implementation by hand, but it's likely that this should be reasonably
straightforward for the type of XSUB that would benefit the most. Longer
term, once the run-time implementation is proven, it should be possible to
progressively update ExtUtils::ParseXS to generate OP implementations for
some XSUBs.

structures, such as 0s, 0s and 0s. Currently, the dumping code
0 0s for its temporary buffers, which was a logical initial
implementation choice, as they provide ready made memory handling.

trying to debug is seen by the code in 0, correctly or incorrectly, as
a temporary scalar it can use for a temporary buffer. It's also not possible
to dump scalars before the interpreter is properly set up, such as during
ithreads cloning. It would be good to progressively replace the use of scalars
as string accumulation buffers with something much simpler, directly allocated
by 0. The 0 code is (or should be) only producing 7 bit
US-ASCII, so output character sets are not an issue.

to re-write the internals of the PerlIO subsystem to avoid using 0s for
0 buffers, use of which can cause problems similar to those of 0,
at similar times.

SA_SIGINFO feature in Perl, passing the extra data to the Perl signal handler.

signals, by the time Perl gets to run the signal handler, the extra
information has been lost. Moreover, it's not easy to store it somewhere,
as you can't call mutexs, or do anything else fancy, from inside a signal
handler.

pipe, store the reader in one, the writer in the other

the 0 pointer non-0, and the writer file handle is open,

about) into a small auto char buff

to the current per-signal-number counts

the pipe", read the data out, deserialise, build the Perl structures on
the stack (code in 0, the "unsafe" handler), and call as
usual.

of running Perl code inside the signal handler context. (With all the dangers
of things like 0 corruption that that currently offers us)

0

opendir, qx, readdir, readlink, rename, rmdir, stat, symlink, sysopen,
system, truncate, unlink, utime, -X.  All these could potentially accept
Unicode filenames either as input or output (and in the case of system
and qx Unicode in general, as input or output to/from the shell).
Whether a filesystem - an operating system pair understands Unicode in
filenames varies.

Microsoft NTFS, Apple HFS+ (In Mac OS 9 and X) and Apple UFS (in Mac
OS X), NFS v4 is rumored to be Unicode, and of course Plan 9.  How to
create Unicode filenames, what forms of Unicode are accepted and used
(UCS-2, UTF-16, UTF-8), what (if any) is the normalization form used,
and so on, varies.  Finding the right level of interfacing to Perl
requires some thought.  Remember that an OS does not implicate a
filesystem.

temporarily retired in 5.8.1, and the -C has been repurposed, see
0.)

0.

See 0.

are always byte strings.  See 0.

Particularly perl should be able to give memory back.

solution might be just to make 0 work to share the string buffer
of SvPVs. That way large constant strings can be shared between ithreads,
such as the configuration information in 0.

allow taint to "leak" everywhere within an expression.

running a shell.  (the function behind qx//) could be similarly
extended.

types, as all bets are off during global destruction.

would require extending the PerlIO vtable.

about , or /, , or .

would mean.)

, , , , ; ,
.

given that all perl command line options are strict ASCII, and -C changes
only the interpretation of non-ASCII characters, and not for the script file
handle. To make it work needs some investigation of the ordering of function
calls during startup, and (by implication) a bit of tweaking of that order.

reorganizing and formalizing so that each error message has its
stable-for-all-eternity unique id, categorized by severity, type, and
subsystem.  (The error messages would be listed in a datafile outside
of the Perl source code, and the source code would only refer to the
messages by the id.)  This clean-up and regularizing should apply
for all  messages.

of the messages (though please do keep in mind the caveats of
0 about too straightforward approaches to
translation), filtering by severity, and instead of grepping for a
particular error message one could look for a stable error id.  (Of
course, changing the error messages by default would break all the
existing software depending on some particular error message...)

inspiration for example in the  system, possibly even use it
if available-- but 0 if available, all platforms will 0
have .

also the warning messages (see 0, 0).

or a willingness to learn.

labels with keyword names, or if it would be better to always treat
bareword expressions after a "goto" as a label and never as a keyword.

be 0 instead. (This is changed in 0)

non-overloaded object breaks encapsulation". It would be nice to allow
to bypass this by using explicitly the syntax 0 or
0.

that by giving it any meaning. However, it's not reported very helpfully:

0 is parsed where it is not legal as a statement terminator (ie inside
0 used as a hashref, 0 or 0) it issues an error something like
0. See the thread starting at
0

warnings.  An unworked RT ticket (#5087) has been open for almost seven
years for this discrepancy.

there are especially many problems.  The swash data structure could be
replaced my something better.  Inversion lists and maps are likely
candidates.  The whole Unicode database could be placed in-core for a
huge speed-up.  Only minimal work was done on the optimizer when utf8
was added, with the result that the synthetic start class often will
fail to narrow down the possible choices when given non-Latin1 input.

variable names are stored in stashes as raw bytes, without the utf-8 flag
set. The pad API only takes a 0 pointer, so that's all bytes too. The
tokeniser ignores the UTF-8-ness of 0, or any SVs returned from
source filters.  All this could be fixed.

semantics, which is tricky to implement in Perl 5 as currently they produce
the same opcode trees. The Perl 6 design is firm, so it would be good to
implement the necessary code in Perl 5. There are comments in
0 that show the code paths taken by various assignment
constructions involving state variables.

understand numeric (and maybe alphanumeric) ranges.

would also tell whether something can be dereferenced as an
array/hash/etc., or used as a regexp, etc.
0

formats.

features enabled by -E. More generally hints (0 and 0) aren't
propagated to the debugger. Probably it would be a good thing to propagate
hints from the innermost non-0 scope: this would make code eval'ed
in the debugger see the features (and strictures, etc.) currently in
scope.

program if you pass the process ID. It would be good to do this with the Perl
debugger on a running Perl program, although I'm not sure how it would be
done." ssh and screen do this with named pipes in /tmp. Maybe we can too.

slices. This would be good to fix.

its performance to be measured, and its bugs to be easily demonstrated.

arrays as alternations. With it, 0 would be roughly equivalent to:

0
for the discussion.

it walks the optree - genuine peephole optimisations, and necessary fixups of
ops. It would be good to find an efficient way to switch out the
optimisations whilst keeping the fixups.

place to pass in the number of return values wanted. It would be useful to
have a general mechanism for this, backwards compatible and little speed hit.
This would allow proposals such as short circuiting sort to be implemented
as a module on CPAN.

perl and XS subroutines. Subroutine implementations rarely change between
perl and XS at run time, so investigate using 2 ops to enter subs (one for
XS, one for perl) and swap between if a sub is redefined.

the causes of these could be tracked down and self-ties on all types
reinstated.

(, , , , , etc.)  At the very
least these interfaces should take SVs as "name" arguments instead of
bare char pointers; probably the most flexible and extensible way
would be for the Perl-facing interfaces to accept HVs.  The system
needs to be per-operating-system and per-file-system
hookable/filterable, preferably both from XS and Perl level
(0 is good reading at this point,
in fact, all of 0 is.)

take a look at 0 and 0.  While all Win32
variants go through a set of "vtables" for operating system access,
non-Win32 systems currently go straight for the POSIX/Unix-style
system/library call.  Similar system as for Win32 should be
implemented for all platforms.  The existing Win32 implementation
probably does not need to survive alongside this proposed new
implementation, the approaches could be merged.

enable is using Unicode for filenames, and other "names" like %ENV,
usernames, hostnames, and so forth.
(See 0.)

virtual filesystems, virtual networks, and "sandboxes" (though as long
as dynamic loading of random object code is allowed, not very safe
sandboxes since external code of course know not of Perl's vtables).
An example of a smaller "sandbox" is that this feature can be used to
implement per-thread working directories: Win32 already does this.

hash key scalars. Under ithreads, something is undoing this work.
See
0

I hope that I got that "current pad" part correct

could solve this by always using the op slab allocator, and walking it to
free ops. Dave comments that as some ops are already freed during optree
creation one would have to mark which ops are freed, and not double free them
when walking the slab. He notes that one problem with this is that for some ops
you have to know which pad was current at the time of allocation, which does
change. I suggested storing a pointer to the current pad in the memory allocated
for the slab, and swapping to a new slab each time the pad changes. Dave thinks
that this would work.

removal of NULL ops, and optimal ordering of OPs with respect to cache-line
filling.  The slab allocator could be reused for this purpose.  I think that
the best way to do this is to make it an optional step just before the
completed optree is attached to anything else, and to use the slab allocator
unchanged, so that freeing ops is identical whether or not this step runs.
Note that the slab allocator allocates ops downwards in memory, so one would
have to actually "allocate" the ops in reverse-execution order to get them
contiguous in memory in execution order.

0

cause their slabs to be freed, which would eliminate possible memory wastage if
the previous suggestion is implemented, and we swap slabs more frequently.

Rafael fixed this - the problem arose because there was no nextstate OP
between the execution of the 0 and the 0, hence 0 still
reports that the currently executing line is line 4. The solution was to inject
a nextstate OPs for each 0, although it turned out that the nextstate
OP needed to be a nulled OP, rather than a live nextstate OP, else other line
numbers became misreported. (Jenga!)

most common and the most confusing). Ideally this code

(at least) line number information.

BASEOP structure, with a flag bit in the op to say whether it's present.
Initially during compile every OP would carry its line number. Then add a late
pass to the optimiser (potentially combined with 0) which
looks at the two ops on every edge of the graph of the execution path. If
the line number changes, flags the destination OP with this information.
Once all paths are traced, replace every op with the flag with a
nextstate-light op (that just updates 0), which in turn then passes
control on to the true op. All ops would then be replaced by variants that
do not store the line number. (Which, logically, why it would work best in
conjunction with 0, as that is already copying/reallocating
all the OPs)

case is worth it)

anywhere that  is called, the outer return can
be replaced by a goto, and foo will return directly to the outer
caller, saving (conservatively) 25% of perl's call&return cost, which
is relatively higher than in C.  The scheme language is known to do
this heavily.  B::Concise provides good insight into where this
optimization is possible, ie anywhere entersub,leavesub op-sequence
occurs.

combines the code in pp_entersub, pp_leavesub.  This should probably
be done 1st in XS, and using B::Generate to patch the new OP into the
optrees.

0, parallel to the existing construct to specify hex constants
0

of 5.14"

will be greatly appreciated.

without a 0 function (in sv.c:Perl_dirp_dup).

specifically will be able to COW new ithreads. If this can be implemented
it would be a good thing.

=encoding utf8

of wanting common state shared by all objects of that class.
Such 0 act somewhat like global variables for the entire
class, but unlike program-wide globals, class attributes have meaning only to
the class itself.

still extant.

method.

all ATMs in a network in a given day.

or to retrieve a list of all objects.

Instead, their state should be inspected, and perhaps altered, only
through the mediated access of 0.  These class attributes
accessor methods are similar in spirit and function to accessors used
to manipulate the state of instance attributes on an object.  They provide a
clear firewall between interface and implementation.

name or any object of that class.  If we assume that  is of
type Some_Class, and the &Some_Class::population_count method accesses
class attributes, then these two invocations should both be possible,
and almost certainly equivalent.

Unlike more restrictive languages like C++, where these are called
static data members, Perl provides no syntactic mechanism to declare
class attributes, any more than it provides a syntactic mechanism to
declare instance attributes.  Perl provides the developer with a broad
set of powerful but flexible features that can be uniquely crafted to
the particular demands of the situation.

of two complementary feature sets: a package for interfacing with the
outside world, and a lexical file scope for privacy.  Either of these
two mechanisms can be used to implement class attributes.  That means you
get to decide whether to put your class attributes in package variables
or to put them in lexical variables.

variables, you can make your class attribute accessor methods either ignorant
of inheritance or sensitive to it.  If you choose lexical variables,
you can elect to permit access to them from anywhere in the entire file
scope, or you can limit direct data access exclusively to the methods
implementing those attributes.

do it for you!  In this case, Class::Data::Inheritable (available on a
CPAN near you) offers a canned solution to the class data problem
using closures.  So before you wade into this document, consider
having a look at that module.

to hold class attributes is the most natural choice.  This makes it simple
for each class to have its own class attributes.  Let's say you have a class
called Some_Class that needs a couple of different attributes that you'd
like to be global to the entire class.  The simplest thing to do is to
use package variables like ::CData1 and ::CData2
to hold these attributes.  But we certainly don't want to encourage
outsiders to touch those data directly, so we provide methods
to mediate access.

argument--that part to the left of the arrow on method invocation, which
is either a class name or an object reference.

to even the novice Perl programmer.  By fully qualifying the package
variables, they stand out clearly when reading the code.  Unfortunately,
if you misspell one of these, you've introduced an error that's hard
to catch.  It's also somewhat disconcerting to see the class name itself
hard-coded in so many places.

pragma, then pre-declare your package variables.  (The 0 operator
will be new in 5.6, and will work for package globals just like 0
works for scoped lexicals.)

package variables with capital letters.  This helps clarity somewhat, but
by no longer fully qualifying the package variables, their significance
can be lost when reading the code.  You can fix this easily enough by
choosing better names than were used here.

grows tedious after the first few (see 0), so too does the
repetition begin to grate when listing out accessor methods for class
data.  Repetition runs counter to the primary virtue of a programmer:
Laziness, here manifesting as that innate urge every programmer feels
to factor out duplicate code whenever possible.

table (see 0), now clone an accessor method for each key in
the %ClassData hash.  Each of these methods is used to fetch or store
values to the specific, named class attribute.

method, but this approach is unlikely to prove satisfactory.  Your
function would have to distinguish between class attributes and object
attributes; it could interfere with inheritance; and it would have to
careful about DESTROY.  Such complexity is uncalled for in most cases,
and certainly in this one.

manipulating the package's symbol table to introduce new function names
using symbolic references (indirect naming), which the strict pragma
would otherwise forbid.  Normally, symbolic references are a dodgy
notion at best.  This isn't just because they can be used accidentally
when you aren't meaning to.  It's also because for most uses
to which beginning Perl programmers attempt to put symbolic references,
we have much better approaches, like nested hashes or hashes of arrays.
But there's nothing wrong with using symbolic references to manipulate
something that is meaningful only from the perspective of the package
symbol table, like method names or package variables.  In other
words, when you want to refer to the symbol table, use symbol references.

They're easy to spot, initialize, and change.  The aggregation also
makes them convenient to access externally, such as from a debugger
or a persistence package.  The only possible problem is that we don't
automatically know the name of each class's class object, should it have
one.  This issue is addressed below in 0.

data using an inherited method call.  Should that end up referring
to the base class's attributes, or to those in the derived class?
How would it work in the earlier examples?  The derived class inherits
all the base class's methods, including those that access class attributes.
But what package are the class attributes stored in?

which those methods were compiled.  When you invoke the &CData1 method
on the name of the derived class or on one of that class's objects, the
version shown above is still run, so you'll access ::CData1--or
in the method cloning version, 0.

class, not in that of their derived class.  Sometimes this is exactly
what you want.  If Feline subclasses Carnivore, then the population of
Carnivores in the world should go up when a new Feline is born.
But what if you wanted to figure out how many Felines you have apart
from Carnivores?  The current approach doesn't support that.

for class attributes to be package-relative.  If you want it to be so,
then stop ignoring the first argument to the function.  Either it will
be a package name if the method was invoked directly on a class name,
or else it will be an object reference if the method was invoked on an
object reference.  In the latter case, the  function provides the
class of that object.

etc.) that you wish to access as package variables in the invoking package
instead of the compiling package as we had previously.

otherwise we couldn't use the fully-qualified symbolic name for
the package global.  This is perfectly reasonable: since all package
variables by definition live in a package, there's nothing wrong with
accessing them via that package's symbol table.  That's what it's there
for (well, somewhat).

methods?  What would that look like?  The only difference would be the
closure used to produce new method entries for the class's symbol table.

neither the most imaginative nor the most intuitive of names.  Is there
something else that might make more sense, be more useful, or both?

a package variable of the same name as the package itself.  Within the
scope of a package Some_Class declaration, we'll use the eponymously
named hash %Some_Class as that class's meta-object.  (Using an eponymously
named hash is somewhat reminiscent of classes that name their constructors
eponymously in the Python or C++ fashion.  That is, class Some_Class would
use &Some_Class::Some_Class as a constructor, probably even exporting that
name as well.  The StrNum class in Recipe 13.14 in 0
does this, if you're looking for an example.)

identifier to aid in debugging, transparent persistence,
or checkpointing.  It's also the obvious name for monadic classes and
translucent attributes, discussed later.

hash storing the meta-object is the same as the name of the package
used to implement the class.

two reasons.  First, to avoid hardcoding the literal package name
in the code in case we later want to change that name.  Second, to
clarify to the reader that what matters here is the package currently
being compiled into, not the package of the invoking object or class.
If the long sequence of non-alphabetic characters bothers you, you can
always put the __PACKAGE__ in a variable first.

folks tend to become unnerved when they see so many places with strict
ref checking disabled.  Given a symbolic reference, you can always
produce a real reference (the reverse is not true, though).  So we'll
create a subroutine that does this conversion for us.  If invoked as a
function of no arguments, it returns a reference to the compiling class's
eponymous hash.  Invoked as a class method, it returns a reference to
the eponymous hash of its caller.  And when invoked as an object method,
this function returns a reference to the eponymous hash for whatever
class the object belongs to.

a reference to each package variable on the object itself.  This is
a strategy you've probably seen before, such as in 0 and
0, but there may be variations in the example below that you
haven't thought of before.

will consequently access package variables in the base class's package.
This is not necessarily expected behavior in all circumstances.  Here's an
example that uses a variable meta-object, taking care to access the
proper package's data.

seems to make the code cleaner.  Unlike the previous version, this one
does something interesting in the face of inheritance: it accesses the
class meta-object in the invoking class instead of the one into which
the method was initially compiled.

it easy to dump the complete class state using an external mechanism such
as when debugging or implementing a persistent class.  This works because
the class meta-object is a package variable, has a well-known name, and
clusters all its data together.  (Transparent persistence
is not always feasible, but it's certainly an appealing idea.)

invoked on a class name.  If strict ref checking is enabled, you'd
blow up.  If not, then you get the eponymous meta-object.  What you do
with--or about--this is up to you.  The next two sections demonstrate
innovative uses for this powerful feature.

without any attribute methods whatsoever.  The most commonly used module
not numbered amongst the pragmata, the Exporter module, is a class with
neither constructors nor attributes.  Its job is simply to provide a
standard interface for modules wishing to export part of their namespace
into that of their caller.  Modules use the Exporter's &import method by
setting their inheritance list in their package's @ISA array to mention
"Exporter".  But class Exporter provides no constructor, so you can't
have several instances of the class.  In fact, you can't have any--it
just doesn't make any sense.  All you get is its methods.  Its interface
contains no statefulness, so state data is wholly superfluous.

a unique instance.  Such classes are called 0, or less
formally, 0 or 0.

its attributes?  How do you make sure that there's never more than
one instance?  While you could merely use a slew of package variables,
it's a lot cleaner to use the eponymously named hash.  Here's a complete
example of a monadic class:

accessors look no different than they would if this were a regular class
instead of a monadic one.  The crux of the matter is there's nothing
that says that  must hold a reference to a blessed object.  It merely
has to be something you can invoke methods on.  Here the package name
itself, Cosmos, works as an object.  Look at the &supernova method.  Is that
a class method or an object method?  The answer is that static analysis
cannot reveal the answer.  Perl doesn't care, and neither should you.
In the three attribute methods, 0 is really accessing the %Cosmos
package variable.

and unrelated universes, then you can invoke the &bigbang method yourself
at any time to start everything all over again.  You might think of
&bigbang as more of an initializer than a constructor, since the function
doesn't allocate new memory; it only initializes what's already there.
But like any other constructor, it does return a scalar value to use
for later method invocations.

isn't enough.  You could write a new class from scratch, but you already
have an existing class that does what you want--except that it's monadic,
and you want more than just one cosmos.

the new code is:

Cosmos class, we can now reuse it without touching a single line of code
when it comes time to write our Multiverse class.  The same code that
worked when invoked as a class method continues to work perfectly well
when invoked against separate instances of a derived class.

returned by the &bigbang "constructor" is not a reference to a blessed
object at all.  It's just the class's own name.  A class name is, for
virtually all intents and purposes, a perfectly acceptable object.
It has state, behavior, and identity, the three crucial components
of an object system.  It even manifests inheritance, polymorphism,
and encapsulation.  And what more can you ask of an object?

unification of what other programming languages might think of as class
methods and object methods into just plain methods.  "Class methods"
and "object methods" are distinct only in the compartmentalizing mind
of the Perl programmer, not in the Perl language itself.

is one reason why Perl has no pre-ordained name for them.  "Constructor"
is just an informal term loosely used to describe a method that returns
a scalar value that you can make further method calls against.  So long
as it's either a class name or an object reference, that's good enough.
It doesn't even have to be a reference to a brand new object.

name them whatever you care to.  Blindly and obediently using 
for each and every constructor you ever write is to speak Perl with
such a severe C++ accent that you do a disservice to both languages.
There's no reason to insist that each class have but one constructor,
or that a constructor be named , or that a constructor be
used solely as a class method and not an object method.

from any formal distinction between class method calls and object method
calls, both in constructors and in accessor methods.

per-class, global state data.  It can also serve as a sort of template
containing default settings for object attributes.  These default
settings can then be used in constructors for initialization of a
particular object.  The class's eponymous hash can also be used to
implement 0.  A translucent attribute is one
that has a class-wide default.  Each object can set its own value for the
attribute, in which case  returns that value.
But if no value has been set, then  returns
the class-wide default.

attributes.  If you're just fetching values from them, you get
translucency.  But if you store a new value to them, that new value is
set on the current object.  On the other hand, if you use the class as
an object and store the attribute value directly on the class, then the
meta-object's value changes, and later fetch operations on objects with
uninitialized values for those attributes will retrieve the meta-object's
new values.  Objects with their own initialized values, however, won't
see any change.

show how to implement them.  Suppose that a class named Some_Class
had a translucent data attribute called "color".  First you set the color
in the meta-object, then you create three objects using a constructor
that happens to be named &spawn.

meta-object's value for that attribute, and these objects do not have
individual color values set.

previously created.

take the color its parent held, which now happens to be "chartreuse".
That's because the constructor uses the invoking object as its template
for initializing attributes.  When that invoking object is the
class name, the object used as a template is the eponymous meta-object.
When the invoking object is a reference to an instantiated object, the
&spawn constructor uses that existing object as a template.

new object.  But attributes undefined in the template object, being
translucent, will remain undefined and consequently translucent in the
new one as well.

were still translucently accessing the meta-object's values.  The second
pair had per-object initialized colors, and so didn't change.

in translucent attributes in the entire class, but what about
changes to discrete objects?  If you change the color of , does the
value of  see that change?  Or vice-versa.  If you change the color
of , does then the value of  shift?

do that.  Good taste aside, we want the answer to the question posed in
the comment above to be "chartreuse", not "amethyst".  So we'll treat
these attributes similar to the way process attributes like environment
variables, user and group IDs, or the current working directory are
treated across a .  You can change only yourself, but you will see
those changes reflected in your unspawned children.  Changes to one object
will propagate neither up to the parent nor down to any existing child objects.
Those objects made later, however, will see the changes.

make that object's attribute value translucent again, what do you do?
Let's design the class so that when you invoke an accessor method with
0 as its argument, that attribute returns to translucency.

accessor methods at all.  They're used to detect accessibility of data
attributes.  The &is_translucent method determines whether a particular
object attribute is coming from the meta-object.  The &has_attribute
method detects whether a class implements a particular property at all.
It could also be used to distinguish undefined properties from non-existent
ones.

use of the upper-case versus lower-case convention to register into the
package appropriate methods cloned from generic closures.

have been left as exercises for the reader.  Be sure to send us mail as
soon as you're done.

examples, we didn't prefix the package variables used for class attributes
with an underscore, nor did we do so for the names of the hash keys used
for instance attributes.  You don't need little markers on data names to
suggest nominal privacy on attribute variables or hash keys, because these
are 0 notionally private!  Outsiders have no business whatsoever
playing with anything within a class save through the mediated access of
its documented interface; in other words, through method invocations.
And not even through just any method, either.  Methods that begin with
an underscore are traditionally considered off-limits outside the class.
If outsiders skip the documented method interface to poke around the
internals of your class and end up breaking something, that's not your
fault--it's theirs.

Perl respects you enough to let you choose your own preferred level of
pain, or of pleasure.  Perl believes that you are creative, intelligent,
and capable of making your own decisions--and fully expects you to
take complete responsibility for your own actions.  In a perfect world,
these admonitions alone would suffice, and everyone would be intelligent,
responsible, happy, and creative.  And careful.  One probably shouldn't
forget careful, and that's a good bit harder to expect.  Even Einstein
would take wrong turns by accident and end up lost in the wrong part
of town.

hanging out there for anyone to reach over and alter them.  Some folks
live in constant fear that someone somewhere might do something wicked.
The solution to that problem is simply to fire the wicked, of course.
But unfortunately, it's not as simple as all that.  These cautious
types are also afraid that they or others will do something not so
much wicked as careless, whether by accident or out of desperation.
If we fire everyone who ever gets careless, pretty soon there won't be
anybody left to get any work done.

be a problem for some people.  We can take the edge off their discomfort
by providing the option of storing class attributes as lexical variables
instead of as package variables.  The  operator is the source of
all privacy in Perl, and it is a powerful form of privacy indeed.

provides no data hiding, that it affords the class designer no privacy
nor isolation, merely a rag-tag assortment of weak and unenforceable
social conventions instead.  This perception is demonstrably false and
easily disproven.  In the next section, we show how to implement forms
of privacy that are far stronger than those provided in nearly any
other object-oriented language.

That means that the only code able to access that variable is code
residing textually below the  operator through the end of its block
if it has one, or through the end of the current file if it doesn't.

document, we replace  variables with  versions.

Those are gone now, replaced with lexicals.  No one outside the
scope can reach in and alter the class state without resorting to the
documented interface.  Not even subclasses or superclasses of
this one have unmediated access to .  They have to invoke the &CData1
method against Some_Class or an instance thereof, just like anybody else.

several classes together into the same file scope, nor strewn your class
implementation across several different files.  Accessibility of those
variables is based uniquely on the static file scope.  It has nothing to
do with the package.  That means that code in a different file but
the same package (class) could not access those variables, yet code in the
same file but a different package (class) could.  There are sound reasons
why we usually suggest a one-to-one mapping between files and packages
and modules and classes.  You don't have to stick to this suggestion if
you really know what you're doing, but you're apt to confuse yourself
otherwise, especially at first.

composite structure, you're perfectly free to do so.

again register closures into the package symbol table to create accessor
methods for them.

probably a good thing.  But demanding and expecting that everyone else,
be they subclass or superclass, friend or foe, will all come to your
object through mediation is more than just a good idea.  It's absolutely
critical to the model.  Let there be in your mind no such thing as
"public" data, nor even "protected" data, which is a seductive but
ultimately destructive notion.  Both will come back to bite at you.
That's because as soon as you take that first step out of the solid
position in which all state is considered completely private, save from the
perspective of its own accessor methods, you have violated the envelope.
And, having pierced that encapsulating envelope, you shall doubtless
someday pay the price when future changes in the implementation break
unrelated code.  Considering that avoiding this infelicitous outcome was
precisely why you consented to suffer the slings and arrows of obsequious
abstraction by turning to object orientation in the first place, such
breakage seems unfortunate in the extreme.

Another_Class.  If you invoke a &CData method on the derived class or
on an object of that class, what do you get?  Would the derived class
have its own state, or would it piggyback on its base class's versions
of the class attributes?

would 0 have its own state data.  As before, whether you consider
this a good thing or a bad one depends on the semantics of the classes
involved.

lexical is for the derived class to override its base class's version
of the method that accesses the class attributes.  Since the actual method
called is the one in the object's derived class if this exists, you
automatically get per-class state this way.  Any urge to provide an
unadvertised method to sneak out a reference to the %ClassData hash
should be strenuously resisted.

derived class always has the option of invoking its base class's
version of the method in addition to its own.  Here's an example:

about there being more than one override.

to the function directly, you can use this directly
for a significant performance improvement:

reference appropriately.

file-scoped lexical %ClassData can alter that hash directly.  Is that
ok?  Is it acceptable or even desirable to allow other parts of the
implementation of this class to access class attributes directly?

class.  If the &supernova method had directly altered ::Stars or
0, then we wouldn't have been able to reuse the
class when it came to inventing a Multiverse.  So letting even the class
itself access its own class attributes without the mediating intervention of
properly designed accessor methods is probably not a good idea after all.

not enforceable even in strongly object-oriented languages.  But in Perl,
you can.

attributes without the mediation of the managing accessor method, since
only that method has access to the lexical variable it's managing.
This use of mediated access to class attributes is a form of privacy far
stronger than most OO languages provide.

at our Laziness, so we'll again use closures to create similar
methods.

the &UNIVERSAL::can method and SUPER as shown previously.

eponymously named %Vermin, as its meta-object.  If you prefer to
use absolutely no package variables beyond those necessary to appease
inheritance or possibly the Exporter, this strategy is closed to you.
That's too bad, because translucent attributes are an appealing
technique, so it would be valuable to devise an implementation using
only lexicals.

package hash.  If you use class names with double-colons in them, you
would end up poking around somewhere you might not have meant to poke.

the hash in the current package.  But in the second case, instead of
getting some hash in the current package, we got the hash %Noxious in
the Vermin package.  (The noxious vermin just invaded another package and
sprayed their data around it. :-) Perl doesn't support relative packages
in its naming conventions, so any double-colons trigger a fully-qualified
lookup instead of just looking in the current package.

package variable named %Noxious that you just blew away.  If you're
still mistrustful, you could always stake out your own territory
where you know the rules, such as using Eponymous::Vermin::Noxious or
Hieronymus::Vermin::Boschious or Leave_Me_Alone::Vermin::Noxious as class
names instead.  Sure, it's in theory possible that someone else has
a class named Eponymous::Vermin with its own %Noxious hash, but this
kind of thing is always true.  There's no arbiter of package names.
It's always the case that globals like @Cwd::ISA would collide if more
than one class uses the same Cwd package.

we have another solution for you.  There's nothing that says that you
have to have a package variable to hold a class meta-object, either for
monadic classes or for translucent attributes.  Just code up the methods
so that they access a lexical instead.

to those given previously, but this time using no package variables.

forethought and design.  Aggregation instead of inheritance is often a
better approach.

or the AutoLoader, because they alter the lexical scope in which the
module's methods wind up getting compiled.

up names of object attributes.  For example, 
should probably be , but that
would just confuse the examples.

worth checking out.

All rights reserved.

under the same terms as Perl itself.

are hereby placed into the public domain.  You are permitted and
encouraged to use this code in your own programs for fun
or for profit as you see fit.  A simple comment in the code giving
credit would be courteous but is not required.

and Stephen Warren all contributed suggestions and corrections to this
piece.  Thanks especially to Damian Conway for his ideas and feedback,
and without whose indirect prodding I might never have taken the time
to show others how much Perl has to offer in the way of objects once
you start thinking outside the tiny little box that today's "popular"
object-oriented languages enforce.

=encoding utf8

would rather have objects than sliced bread.  Why is that?  What's so
special about an object?  Just what 0 an object anyway?

a neat little easy-to-use bundle.  (This is what professors call
abstraction.) Smart people who have nothing to do but sit around for
weeks on end figuring out really hard problems make these nifty
objects that even regular people can use. (This is what professors call
software reuse.)  Users (well, programmers) can play with this little
bundle all they want, but they aren't to open it up and mess with the
insides.  Just like an expensive piece of hardware, the contract says
that you void the warranty if you muck with the cover.  So don't do that.

full of data and functions.  A class is a set of related routines that
addresses some problem area.  You can think of it as a user-defined type.
The Perl package mechanism, also used for more traditional modules,
is used for class modules as well.  Objects "live" in a class, meaning
that they belong to some package.

These bundles are objects.  They know whose class they belong to,
and how to behave.  Users ask the class to do something, like "give
me an object."  Or they can ask one of these objects to do something.
Asking a class to do something for you is calling a 0.
Asking an object to do something for you is calling an 0.
Asking either a class (usually) or an object (sometimes) to give you
back an object is calling a 0, which is just a
kind of method.

Perl data type?  Just what is an object 0; that is, what's its
fundamental type?  The answer to the first question is easy.  An object
is different from any other data type in Perl in one and only one way:
you may dereference it using not merely string or numeric subscripts
as with simple arrays and hashes, but with named subroutine calls.
In a word, with 0.

any reference, mind you, but one whose referent has been ed
into a particular class (read: package).  What kind of reference?  Well,
the answer to that one is a bit less concrete.  That's because in Perl
the designer of the class can employ any sort of reference they'd like
as the underlying intrinsic data type.  It could be a scalar, an array,
or a hash reference.  It could even be a code reference.  But because
of its inherent flexibility, an object is usually a hash reference.

because the class (package) name governs the name of the file used to
house it, just as with regular modules.  Then, that class (package)
should provide one or more ways to generate objects.  Finally, it should
provide mechanisms to allow users of its objects to indirectly manipulate
these objects from a distance.

the file Person.pm.  If it were called a Happy::Person class, it would
be stored in the file Happy/Person.pm, and its package would become
Happy::Person instead of just Person.  (On a personal computer not
running Unix or Plan 9, but something like Mac OS or VMS, the directory
separator may be different, but the principle is the same.)  Do not assume
any formal relationship between modules based on their directory names.
This is merely a grouping convenience, and has no effect on inheritance,
variable accessibility, or anything else.

a well-behaved class module that doesn't export anything at all.
In order to manufacture objects, a class needs to have a 0.  A constructor gives you back not just a regular data type,
but a brand-new object in that class.  This magic is taken care of by
the  function, whose sole purpose is to enable its referent to
be used as an object.  Remember: being an object really means nothing
more than that methods may now be called against it.

programmers seem to like to call theirs .  However,  is not
a reserved word, and a class is under no obligation to supply such.
Some programmers have also been known to use a function with
the same name as the class as the constructor.

record, a C struct, or a C++ class is an anonymous hash.  That's because a
hash has an arbitrary number of data fields, each conveniently accessed by
an arbitrary name of your own devising.

struct-like emulation, you would likely go about it something like this:

by up-casing the hash keys:

 to get at "Norbert", "Rhys", and "Phineas".
(Have you ever noticed how many 23-year-old programmers seem to
be named "Jason" these days? :-)

the pinnacle of programming propriety for folks from outside the
class to come waltzing into an object, brazenly accessing its data
members directly.  Generally speaking, an object should be considered
an opaque cookie that you use 0 to access.  Visually,
methods look like you're dereffing a reference using a function name
instead of brackets or braces.

but Perl does not.  It relies on you to read the documentation of each
class.  If you try to call an undefined method on an object, Perl won't
complain, but the program will trigger an exception while it's running.
Likewise, if you call a method expecting a prime number as its argument
with a non-prime one instead, you can't expect the compiler to catch this.
(Well, you can expect it all you like, but it's not going to happen.)

someone who has read the docs that explain the prescribed
interface.  Here's how they might use the Person class:

business paying attention to the fact) that the object has one particular
implementation or another.  The interface to the class and its objects
is exclusively via methods, and that's all the user of the class should
ever play with.

the class.  It implements methods that the programmer uses to access
the object.  Here's how to implement the Person class using the standard
hash-ref-as-an-object idiom.  We'll make a class method called  to
act as the constructor, and three object methods called , , and
 to get at per-object data hidden away in our anonymous hash.

and .  These are all substantially similar.  If called with an
argument, they set the appropriate field; otherwise they return the
value held by that field, meaning the value of that hash key.

you're going to worry about inheritance.  (You can safely ignore this
for now and worry about it later if you'd like.)  To ensure that this
all works out smoothly, you must use the double-argument form of .
The second argument is the class into which the referent will be blessed.
By not assuming our own class as the default second argument and instead
using the class passed into us, we make our constructor inheritable.

to life, returning neat little opaque bundles to the user to be used in
subsequent method calls.

story is its constructor, explicitly called when the object comes into
existence.  But the ending of its story is the 0, a method
implicitly called when an object leaves this life.  Any per-object
clean-up code is placed in the destructor, which must (in Perl) be called
DESTROY.

Because while a constructor is explicitly called, a destructor is not.
Destruction happens automatically via Perl's garbage collection (GC)
system, which is a quick but somewhat lazy reference-based GC system.
To know what to call, Perl insists that the destructor be named DESTROY.
Perl's notion of the right time to call a destructor is not well-defined
currently, which is why your destructors should not rely on when they are
called.

function names as a convention to indicate that the function will
be automatically called by Perl in some way.  Others that are called
implicitly include BEGIN, END, AUTOLOAD, plus all methods used by
tied objects, described in 0.

care when the destructor is called.  It just happens when it's supposed
to.  In low-level languages without any GC at all, there's no way to
depend on this happening at the right time, so the programmer must
explicitly call the destructor to clean up memory and state, crossing
their fingers that it's the right time to do so.   Unlike C++, an
object destructor is nearly never needed in Perl, and even when it is,
explicit invocation is uncalled for.  In the case of our Person class,
we don't need a destructor because Perl takes care of simple matters
like memory deallocation.

when there's a circularity in the data structure, such as:

your program not to leak memory.  While admittedly error-prone, this is
the best we can do right now.  Nonetheless, rest assured that when your
program is finished, its objects' destructors are all duly called.
So you are guaranteed that an object 0 gets properly
destroyed, except in the unique case of a program that never exits.
(If you're running Perl embedded in another application, this full GC
pass happens a bit more frequently--whenever a thread shuts down.)

else simple "data methods", interfaces to data stored in the object.
These are a bit like an object's data members in the C++ world, except
that strangers don't access them as data.  Instead, they should only
access the object's data indirectly via its methods.  This is an
important rule: in Perl, access to an object's data should 0
be made through methods.

The public-versus-private distinction is by convention, not syntax.
(Well, unless you use the Alias module described below in
0.)  Occasionally you'll see method names beginning or ending
with an underscore or two.  This marking is a convention indicating
that the methods are private to that class alone and sometimes to its
closest acquaintances, its immediate subclasses.  But this distinction
is not enforced by Perl itself.  It's up to the programmer to behave.

Methods can do anything at all.  The key point is that they're invoked
against an object or a class.  Let's say we'd like object methods that
do more than fetch or set one particular field.

may not be critical.  There are tradeoffs to be made.  Using direct
hash access is faster (about an order of magnitude faster, in fact), and
it's more convenient when you want to interpolate in strings.  But using
methods (the external interface) internally shields not just the users of
your class but even you yourself from changes in your data representation.

What would you want that for?  Well, in your Person class, you might
like to keep track of the total people alive.  How do you implement that?

only reason you'd do that would be if you 0 people to be able to
get at your class data directly.  They could just say ::Census
and play around with it.  Maybe this is ok in your design scheme.
You might even conceivably want to make it an exported variable.  To be
exportable, a variable must be a (package) global.  If this were a
traditional module rather than an object-oriented one, you might do that.

generally considered rather poor form in most object modules.  In an
object module, you should set up a protective veil to separate interface
from implementation.  So provide a class method to access class data
just as you provide object methods to access object data.

others to honor the contract of the module and therefore not play around
with its implementation.  You could even be supertricky and make  a
tied object as described in 0, thereby intercepting all accesses.

file-scoped lexical.  To do so, simply put this at the top of the file:

it was declared is done (in this case the whole file being required or
used), Perl's deep binding of lexical variables guarantees that the
variable will not be deallocated, remaining accessible to functions
declared within that scope.  This doesn't work with global variables
given temporary values via , though.

it instead a file-scoped lexical, you should make these
changes to your Person:: constructor:

when Person is destroyed, the  goes down.  Here's how
this could be done:

something that Perl takes care of for you all by itself.

CPAN.

class data.  A good scalable rule is that 0.  Otherwise you aren't building a
scalable, inheritable class.  The object must be the rendezvous point
for all operations, especially from an object method.  The globals
(class data) would in some sense be in the "wrong" package in your
derived classes.  In Perl, methods execute in the context of the class
they were defined in, 0 that of the object that triggered them.
Therefore, namespace visibility of package globals in methods is unrelated
to inheritance.

(well, inherited) the DESTROY method as it was defined above.  When those
objects are destroyed, the original  variable will be altered,
not the one in the new class's package namespace.  Perhaps this is what
you want, but probably it isn't.

value accessed by the hash key "_CENSUS".  Why the underscore?  Well,
mostly because an initial underscore already conveys strong feelings
of magicalness to a C programmer.  It's really just a mnemonic device
to remind ourselves that this field is special and not to be used as
a public data member in the same way that NAME, AGE, and PEERS are.
(Because we've been developing this code under the strict pragma, prior
to perl version 5.004 we'll have to quote the field name.)

you might want to see when objects are created or destroyed.  To do that,
add a debugging variable as a file-scoped lexical.  For this, we'll pull
in the standard Carp module to emit our warnings and fatal messages.
That way messages will come out with the caller's filename and
line number instead of our own; if we wanted them to be from our own
perspective, we'd just use  and  directly instead of 
and  respectively.

way you could call both of these:

works on both classes 0 objects.  Therefore, adjust the 
and DESTROY methods as follows:

methods from this Person base class?  Then , when called
as a class method, manipulates ::Debugging not ::Debugging.

you want a bit of cleanup when the entire class is shut down, which
currently only happens when the program exits.  To make such a
0, create a function in that class's package named
END.  This works just like the END function in traditional modules,
meaning that it gets called whenever your program exits unless it execs
or dies of an uncaught signal.  For example,

be called in the opposite order that they were loaded in (LIFO order).

Person class.  Its 0 would be its documentation.  Usually this
means putting it in pod ("plain old documentation") format right there
in the same file.  In our Person example, we would place the following
docs anywhere in the Person.pm file.  Even though it looks mostly like
code, it's not.  It's embedded documentation such as would be used by
the pod2man, pod2html, or pod2text programs.  The Perl compiler ignores
pods entirely, just as the translators ignore code.  Here's an example of
some pods describing the informal interface:

A programmer who opens up the module and plays around with all the private
little shiny bits that were safely locked up behind the interface contract
has voided the warranty, and you shouldn't worry about their fate.

Perhaps you'd like to support both given names (called Christian names,
irrespective of one's religion) and family names (called surnames), plus
nicknames and titles.  If users of your Person class have been properly
accessing it through its documented interface, then you can easily change
the underlying implementation.  If they haven't, then they lose and
it's their fault for breaking the contract and voiding their warranty.

the Fullname class look like?  To answer that question, you have to
first figure out how you want to use it.  How about we use it this way:

a full name field this way:

of using a hash reference to hold data fields, and methods
by the appropriate name to access them:

inheritance.  Inheritance means allowing one class to piggy-back on
top of another one so you don't have to write the same code again and
again.  It's about software reuse, and therefore related to Laziness,
the principal virtue of a programmer.  (The import/export mechanisms in
traditional modules are also a form of code reuse, but a simpler one than
the true inheritance that you find in object modules.)

language, and sometimes it's not.  Perl has no special syntax for
specifying the class (or classes) to inherit from.  Instead, it's all
strictly in the semantics.  Each package can have a variable called @ISA,
which governs (method) inheritance.  If you try to call a method on an
object or class, and that method is not found in that object's package,
Perl then looks to @ISA for other packages to go looking through in
search of the missing method.

@EXPORT, @EXPORT_OK, @EXPORT_FAIL, %EXPORT_TAGS, and ), the @ISA
array 0 be a package-scoped global and not a file-scoped lexical
created via .  Most classes have just one item in their @ISA array.
In this case, we have what's called "single inheritance", or SI for short.

class and stating that this one will inherit methods from that
other class if need be.  We have given it none of its own methods.
We rely upon an Employee to behave just like a Person.

that is, making a derived class that does nothing but inherit from a
base class.  If the original base class has been designed properly,
then the new derived class can be used as a drop-in replacement for the
old one.  This means you should be able to write a program like this:

avoiding direct access of global data, and not exporting anything.  If you
look back at the Person:: function we defined above, we were careful
to do that.  There's a bit of package data used in the constructor,
but the reference to this is stored on the object itself and all other
methods access package data via that reference, so we should be ok.

a method?  Well, in principle, yes.  A method is just a function that
expects as its first argument a class name (package) or object
(blessed reference).   Person:: is the function that both the
 method and the  method end
up calling.  Understand that while a method call looks a lot like a
function call, they aren't really quite the same, and if you treat them
as the same, you'll very soon be left with nothing but broken programs.
First, the actual underlying calling conventions are different: method
calls get an extra argument.  Second, function calls don't do inheritance,
but methods do.

So let's add some other methods.  We'll give our employee
data fields to access their salary, their employee ID, and their
start date.

methods just to get at the object's data, do not despair.  Later,
we'll describe several different convenience mechanisms for shortening
this up.  Meanwhile, here's the straight-forward way:

method defined?  Well, then you get the derived class's version of that
method.  For example, let's say that we want the  method called on
an employee to act a bit differently.  Instead of just returning the list
of peer names, let's return slightly different strings.  So doing this:

circles as 0.  We've taken on the form and behaviour of
an existing object, and then we've altered it to suit our own purposes.
This is a form of Laziness.  (Getting polymorphed is also what happens
when the wizard decides you'd look better as a frog.)

derived class (also known as "subclass") version as well as its base class
(also known as "superclass") version.  In practice, constructors and
destructors are likely to want to do this, and it probably also makes
sense in the  method we showed previously.

But this is far too fragile for good design.  What if Person doesn't
have a  function, but is inheriting 0  method
from elsewhere?  It would have been slightly better to say

in Person.  This strategy is more often seen on overridden object methods
than on overridden class methods.

superclass's name.  This in particular is bad if you change which classes
you inherit from, or add others.  Fortunately, the pseudoclass SUPER
comes to the rescue here.

from 0 a method call, though.  Don't try to access anything
in SUPER:: from anywhere else, because it doesn't exist outside
an overridden method call. Note that 0 refers to the superclass of
the current package, 0 to the superclass of 0.

we shouldn't?  As before, one way to test whether we're designing
a decent class is via the empty subclass test.  Since we already have
an Employee class that we're trying to check, we'd better get a new
empty subclass that can derive from Employee.  Here's one:

object in a nice format, somewhat like the way the 'x' command works in
the debugger, you could use the Data::Dumper module from CPAN this way:

and ID fields?  Well, we never set them to anything, even undef, so they
don't show up in the hash's keys.  The Employee class has no  method
of its own, and the  method in Person doesn't know about Employees.
(Nor should it: proper OO design dictates that a subclass be allowed to
know about its immediate superclass, but never vice-versa.)  So let's
fix up Employee:: this way:

that new fields show up there now.

time to confess that Perl's object system includes that controversial
notion known as multiple inheritance, or MI for short.  All this means
is that rather than having just one parent class who in turn might
itself have a parent class, etc., that you can directly inherit from
two or more parents.  It's true that some uses of MI can get you into
trouble, although hopefully not quite so much trouble with Perl as with
dubiously-OO languages like C++.

name in your @ISA array.  When it comes time for Perl to go finding
methods for your object, it looks at each of these packages in order.
Well, kinda.  It's actually a fully recursive, depth-first order by
default (see 0 for alternate method resolution orders).
Consider a bunch of @ISA arrays like this:

Because the search is depth-first, classes will be looked up
in the following order: Third, First, Alpha, Second, and Beta.

make use of MI.  One nearly always chooses simple containership of
one class within another over MI.  That's why our Person
object 0 a Fullname object.  That doesn't mean
it 0isa('UNIVERSAL') will return
false.

0), method resolution within UNIVERSAL / @UNIVERSAL::ISA will
still occur in the default depth-first left-to-right manner,
after the class's C3 mro is exhausted.

happens during method lookup, which is roughly like this
ugly pseudo-code:

search in UNIVERSAL itself, only in the package's actual
@ISA.

can be any sort of reference so long as its referent has been suitably
blessed.  That means scalar, array, and code references are also fair
game.

would work for most cases, but makes inheritance a bit dodgy because
you have to invent new indices for the derived classes.

interface, then you can change its underlying interface if you feel
like it.  Here's another implementation that conforms to the same
interface specification.  This time we'll use an array reference
instead of a hash reference to represent the object.

hash access, but they're actually comparable.  The array is a 0
bit faster, but not more than ten or fifteen percent, even when you
replace the variables above like  with literal numbers, like 1.
A bigger difference between the two approaches can be found in memory use.
A hash representation takes up more memory than an array representation
because you have to allocate memory for the keys as well as for the values.
However, it really isn't that bad, especially since as of version 5.004,
memory is only allocated once for a given hash key, no matter how many
hashes have that key.  It's expected that sometime in the future, even
these differences will fade into obscurity as more efficient underlying
representations are devised.

is enough to make some programmers choose an array representation
for simple classes.  There's still a little problem with
scalability, though, because later in life when you feel
like creating subclasses, you'll find that hashes just work
out better.

possibilities.  We can create a new anonymous function (closure) who
alone in all the world can see the object's data.  This is because we
put the data into an anonymous hash that's lexically visible only to
the closure we create, bless, and return as the object.  This object's
methods turn around and call the closure as a regular subroutine call,
passing it the field we want to affect.  (Yes,
the double-function call is slow, but if you wanted fast, you wouldn't
be using objects at all, eh? :-)

different:

mysterious to those whose background is more firmly rooted in standard
procedural or object-based programming languages than in functional
programming languages whence closures derive.  The object
created and returned by the  method is itself not a data reference
as we've seen before.  It's an anonymous code reference that has within
it access to a specific version (lexical binding and instantiation)
of the object's data, which are stored in the private variable .
Although this is the same function each time, it contains a different
version of .

zeroth argument is the invoking object--just as it is with all method
calls.  But in this case, it's our code reference (something like a
function pointer in C++, but with deep binding of lexical variables).
There's not a lot to be done with a code reference beyond calling it, so
that's just what we do when we say 0.  This is just a regular
function call, not a method call.  The initial argument is the string
"NAME", and any remaining arguments are whatever had been passed to the
method itself.

the  hash reference suddenly becomes visible.  The closure grabs
its first argument ("NAME" in this case because that's what the 
method passed it), and uses that string to subscript into the private
hash hidden in its unique version of .

be able to get at this hidden data.  Well, nearly nothing.  You 0
single step through the program using the debugger and find out the
pieces while you're in the method, but everyone else is out of luck.

what will.  Translation of this technique into C++, Java, or any other
braindead-static language is left as a futile exercise for aficionados
of those camps.

make the closure refuse to operate unless called via its own package.
This would no doubt satisfy certain fastidious concerns of programming
police and related puritans.

programmer, would come into play, here you have it. (More seriously,
Hubris is just the pride in craftsmanship that comes from having written
a sound bit of well-designed code.)

routine may choose to create a new function on the fly, either loaded
from disk or perhaps just ed right there.  This define-on-the-fly
strategy is why it's called autoloading.

have the autoloaded method itself directly provide the
requested service.  When used in this way, you may think
of autoloaded methods as "proxy" methods.

and that function is not defined, it looks for a function in
that same package called AUTOLOAD.  If one exists, it's called
with the same arguments as the original function would have had.
The fully-qualified name of the function is stored in that package's
global variable .  Once called, the function can do anything
it would like, including defining a new function by the right name, and
then doing a really fancy kind of 0 right to it, erasing itself
from the call stack.

functions, not methods.  Well, since a method is just a function with
an extra argument and some fancier semantics about where it's found,
we can use autoloading for methods, too.  Perl doesn't start looking
for an AUTOLOAD method until it has exhausted the recursive hunt up
through @ISA, though.  Some programmers have even been known to define
a UNIVERSAL::AUTOLOAD method to trap unresolved method calls to any
kind of object.

code way back earlier when we first showed you the Person class, and
then later the Employee class.  Each method used to access the
hash fields looked virtually identical.  This should have tickled
that great programming virtue, Impatience, but for the time,
we let Laziness win out, and so did nothing.  Proxy methods can cure
this.

we'll use the autoload mechanism to generate (actually, mimic) methods on
the fly.  To verify that we're accessing a valid member, we will check
against an 0 (pronounced "under-permitted") field, which
is a reference to a file-scoped lexical (like a C file static) hash of permitted fields in this record
called %fields.  Why the underscore?  For the same reason as the _CENSUS
field we once used: as a marker that means "for internal use only".

constructor will look like when taking this approach:

where current we have 0 in the %fields hash.

Remember that it's important to access class data through the object
itself instead of having any method reference %fields directly, or else
you won't have a decent inheritance.

will handle all calls to undefined methods for objects of class Person
(or subclasses of Person).  It has to be called AUTOLOAD.  Again, it's
all caps because it's called for us implicitly by Perl itself, not by
a user directly.

is modify %fields.  No new functions need be written.

wanted to demonstrate how to store a reference to class data on the
object so you wouldn't have to access that class data
directly from an object method.

class similarly?  Yes, so long as we're careful enough.

AUTOLOAD function in the Employee package, because
we'll grab Person's version of that via inheritance,
and it will all work out just fine.

more struct-like classes than tediously coding up data methods as
functions, it still leaves a bit to be desired.  For one thing, it means
you have to handle bogus calls that you don't mean to trap via your proxy.
It also means you have to be quite careful when dealing with inheritance,
as detailed above.

class construction classes.  These metaclasses are classes
that create other classes.  A couple worth looking at are
Class::Struct and Alias.  These and other related metaclasses can be
found in the modules directory on CPAN.

interface were sketched out long before perl5 even solidified into a
real thing.  What it does is provide you a way to "declare" a class
as having objects whose fields are of a specific type.  The function
that does this is called, not surprisingly enough, .  Because
structures or records are not base types in Perl, each time you want to
create a class to provide a record-like data object, you yourself have
to define a  method, plus separate data-access methods for each of
that record's fields.  You'll quickly become bored with this process.
The Class::Struct:: function alleviates this tedium.

user-defined types (classes).  User types will be initialized by calling
that class's  method.

0 class's  method, so you should specify a 0 object
when you create an instance of 0.

wanted to override Perl's idea of  and  so
that they would return objects that acted like C structures.  We don't
care about high-falutin' OO gunk.  All we want is for these objects to
act like structs in the C sense.

The crux is going to be this call:

It even creates a  method for us.

type, instead of an anonymous array.  The array is faster and smaller,
but the hash works out better if you eventually want to do inheritance.
Since for this struct-like object we aren't planning on inheritance,
this time we'll opt for better speed and size over better flexibility.

class creation, like overriding core functions, import/export bits,
function prototyping, short-cut function call via 0, and
function replacement with 0.  These all mostly make
sense from the perspective of a traditional module, but as you can see,
we can also use them in an object module.

functions in the 5.004 release of Perl in File::stat, Net::hostent,
Net::netent, Net::protoent, Net::servent, Time::gmtime, Time::localtime,
User::grent, and User::pwent.  These modules have a final component
that's all lowercase, by convention reserved for compiler pragmas,
because they affect the compilation and change a builtin function.
They also have the type names that a C programmer would most expect.

get at an object's data members as simple variables from within a method.
The Alias module provides for this, as well as a good bit more, such
as the possibility of private methods that the object can call but folks
outside the class cannot.

When you update these magical instance variables, you automatically
update value fields in the hash.  Convenient, eh?

is play with package globals with the same name as the fields.  To use
globals while 0 is in effect, you have to predeclare them.
These package variables are localized to the block enclosing the 
call just as if you'd used a  on them.  However, that means that
they're still considered global variables with temporary values, just
as with any other .

something like Class::Struct or Class::MethodMaker.

are used to describe only a few different concepts.  If you're not
already an object programmer, then you don't need to worry about all
these fancy words.  But if you are, then you might like to know how to
get at the same concepts in Perl.

and to call those objects' methods 0.  Data fields
peculiar to each object are often called 0 or 0, and data fields common to all members of that class are
0, 0, or 0.

the same notion, whereas 0, 0, and
0 describe the other related one.

but Perl only has 0 and 0.
Actually, Perl only has methods.  Whether a method gets used
as a class or object method is by usage only.  You could accidentally
call a class method (one expecting a string argument) on an
object (one expecting a reference), or vice versa.

This, by the way, is why they are never checked for function
prototypes in the argument list as regular builtin and user-defined
functions can be.

taken as describing both a "class as meta-object" (also called 0) philosophy and the "class as type definition" (0
behaviour, not 0 mechanism) idea.  C++ supports the latter
notion, but not the former.

background for this one:
0,
0,
0,
0,
0,
and
0.

programming.

Class::Class, Class::Contract, Class::Data::Inheritable,
Class::MethodMaker and Tie::SecureHash

All rights reserved.

under the same terms as Perl itself.

are hereby placed into the public domain.  You are permitted and
encouraged to use this code in your own programs for fun
or for profit as you see fit.  A simple comment in the code giving
credit would be courteous but is not required.

Larry Wall,
Roderick Schertler,
Gurusamy Sarathy,
Dean Roehrich,
Raphael Manfredi,
Brent Halsey,
Greg Bacon,
Brad Appleton,
and many others for their helpful comments. 

=encoding utf8

switch; see 0 and 0. The second biggest trap is not
making your entire program runnable under 0.  The third biggest
trap is not reading the list of changes in this version of Perl; see
0.

do an implicit loop with 0 or 0.

), as though they were in 0; see 0 for details.

at the end of a block).  Newline is not a statement delimiter.

.

comparisons.

to an array yourself.  And the  operator has different
arguments than 0's.

not have the newline stripped.  ( is the name of the program
executed.)  See 0.

by the last match pattern.

you set 0 and 0.  You can set  and  if you're using
the English module.

C.

operator, as in C.)

operator, as in C.  (You know, one could get the feeling that 0 is
basically incompatible with C.)

null string would render 0".
And in fact, "." itself can be the beginning of a number.)

gives you.

and 0, respectively.  Unlike in C, these do 0 work within a
0 construct.  See 0.

perl 5.10 or newer. See 0.

comments as division operators, unterminated regular expressions or
the defined-or operator.

in Perl is the backslash, which creates a reference.

ends up in 0.

success, not 0. (, however, returns zero for success.)

to find their names on your system.

do an implicit loop with 0 or 0.

in front.

the presence of single quotes in the command.

command line.  Perl does substitution in only certain constructs
such as double quotes, backticks, angle brackets, and search patterns.

entire program before executing it (except for 0 blocks, which
execute at compile time).

variables.

"-ne", "-lt" etc for numeric comparisons. This is the reverse of Perl, which
uses 0, 0, 0 for string comparisons, and 0, 0  etc
for numeric comparisons.

context than they do in a scalar one.  See 0 for details.

You can't tell by just looking at it whether a bareword is
a function or a string.  By using quotes on strings and
parentheses on function calls, you won't ever get them confused.

are unary operators (like  and )
and which are list operators (like  and ).
(Unless prototyped, user-defined subroutines can 0 be list
operators, never unary ones.)  See 0 and 0.

default to , or @ARGV, or whatever, but that others which
you might expect to do not.

operation on that handle.  The data read is assigned to  only if the
file read is the sole condition in a while loop:

these two constructs are quite different:

loop control on.

it (but see 0 for where you can't).
Using 0 actually gives a local value to a global
variable, which leaves you open to unforeseen side-effects
of dynamic scoping.

not change.  The local name becomes an alias to a new value but the
external name is still an alias for the original.

Perl4-to-Perl5 specific traps.

or deprecated as a perl4 feature with the intent to encourage usage of
some other perl5 feature.

code.

and sorting, along with sorting subroutines.

please submit it to <0 for inclusion.
Also note that at least some of these can be caught with the
0 pragma or the 0 switch.

a bug from perl4.

for 0 itself (and 0, etc.).

behave differently in perl4 vs. perl5, because the packages don't exist.

whether this should be classed as a bug or not.
(The older package delimiter, ' ,is used here)

always explicitly include the package name:

context (as the Camel says) rather than list context.

of a variable, or as a delimiter for any kind of quote construct.
Double darn.

It was documented to work this way before, but didn't.

list which is not an array.  This used to assign the list to a
temporary array, but no longer does so (for efficiency).  This means
that you'll now be iterating over the actual values, not over copies of
the values.  Modifications to the loop variable can change the original
values.

explicitly to a temporary array and then iterate over that.  For
example, you might need to change

happens when you use 0 for the loop variable, and call subroutines in
the loop that don't properly localize 0.)

return an initial null field if  starts with whitespace), it used to
behave like 0 (which does).

always taking the code snippet from the following arg.  Additionally, it
would silently accept an 0 switch without a following arg.  Both of
these behaviors have been fixed.

actually the last value being pushed onto the target list.  In Perl 5
the return value of 0 is documented, but has changed, it is the
number of elements in the resulting list.

0 were 0, the result would be placed in 0 as well as
being returned.   Perl 5 has more respect for your subroutine arguments.

are to used around the name.

starts a BLOCK or a hash reference. If it guesses wrong, it will report
a syntax error near the 0 and the missing (or unexpected) comma.

to the first thing in a BLOCK (after 0), for perl to guess right all
the time. (See 0.)

operands, or output from same.

tries to be more precise.  For example, on a Solaris Sparc:

and even floating point format may be slightly different.

operator would not catch when a number went over the signed int limit.  Fixed
in version 5.003_04.  But always be wary when using large integers.
If in doubt:

does not work in perl5 when the test evaluates to false (0).
Logical tests now return a null, instead of 0

for another example of this new feature...

strings (0) are given only strings as arguments, perl4 would
treat the operands as bitstrings so long as the program contained a call
to the 0 function. perl5 treats the string operands as bitstrings.
(See 0 for more details.)

within certain expressions and/or context.

impossible to recover.

defined(%h).

variable is localized subsequent to the assignment

it undefines the associated scalar (but may have other side effects
including SEGVs). Perl 5 will also warn if 0 is assigned to a
typeglob. (Note that assigning 0 to a typeglob is different
than calling the 0 function on a typeglob (0), which
has quite a few effects.

This change effects both the return value and what it
does to auto(magic)increment.

Perl5 exhibits the same behavior for hashes and scalars,
that perl4 exhibits for only scalars.

context.  This means you can interpolate list values now.

if there is no caller.  This lets library files determine if they're
being required.

scalar context to its last argument. It gives scalar or void context
to any preceding arguments, depending on circumstances.

context. Thus, if passed an array, it will probably not do what you want,
unlike Perl 4:

that they both have.  Perl 4 however, seems to have had some
inconsistencies that made the behavior differ from what was documented.

in perl4, second in perl5; this can affect the relationship
between side-effects in sub-expressions.

of assignment.  Perl 4 mistakenly gave them the precedence of the associated
operator.  So you now must parenthesize them in expressions like

Otherwise, perl5 leaves the statement as its default precedence:

treats 0 as main 0

the assignment operators.  Thus, although the precedence table
for perl4 leads one to believe 0 should parse as
0, it actually parses as 0.
In perl5, the precedence is as documented.

that operated on a single hash, but in perl5, they are regular named unary
operators.  As documented, named unary operators have lower precedence
than the arithmetic and concatenation operators 0, but the perl4
variants of these operators actually bind tighter than 0.
Thus, for:

interpolate  but not .  (And still does not match a literal
'$' in string)

regular expression.  (Once the scope of a block is left for the sub, the
state of the searched string is lost)

within an anonymous sub, 0 closures generated from that anonymous
sub will use the regular expression as it was compiled when it was used
the very first time in any such closure.  For instance, if you say

ok
not ok
not ok

 and  as they were the 0 time that 
was called, not as they are in the current call.

the whole match, just like 0. Perl5 does not.

backtick expansion

the actual value of the s'd string after the substitution.
0 is a character class in perl4 and an array subscript in perl5

repeatedly, like 0 or 0.

(, , ..., 0, ...).

Signals, Sorting, and their related subroutines, as well as
general subroutine traps.  Includes some OS-Specific traps.

calls if a subroutine by that name is defined before the compiler sees them.

filehandle in perl4.  With perl5 it does not.

within  the signal handler function, each time a signal was handled with
perl4.  With perl5, the reset is now done correctly.  Any code relying
on the handler _not_ being reset will have to be reworked.

the right thing w.r.t. the  manpage. e.g., - When a file is opened
for append,  it  is  impossible to overwrite information already in
the file.

within certain expressions, statements, contexts, or whatever.

within double quotes (usually when the opening brace is preceded by 0
or 0).

now tries to dereference .  0 by itself still works fine, however.

0's to be protected in the specification of the hash name, or both curlies
to be protected.  If both curlies are protected, the result will be compatible
with perl4 and perl5.  This is a very common practice, and should be changed
to use the block form of 0  if possible.

interpolation.

brackets, as well as an ending bracket of the appropriate type.  In order
to mimic the behavior of Perl 4, you must escape the bracket like so.

happy just to expand  to "baz" by itself.  Watch out for this
especially in 0's.

may cause the same script, run under perl5, to fail.  The build of perl5
must have been linked with the same dbm/ndbm as the default for 0
to function properly without 0'ing to an extension dbm implementation.

may cause the same script, run under perl5, to fail.  The error generated
when exceeding the limit on the key/value size will cause perl5 to exit
immediately.

returns an empty list.

they'll be fixed and removed. 

=encoding utf8

implement the Unicode standard or the accompanying technical reports
from cover to cover, Perl does support many Unicode features.

the 0 and
0, before reading
this reference document.

Read 0.

on full internal Unicode support unless the pragma
0 is specified.  (This is automatically
selected if you use 0 or higher.)  Failure to do this can
trigger unexpected surprises.  See 0 below.

where Unicode isn't fully supported, such as in filenames.

(UTF-8, or UTF-EBCDIC if in EBCDIC) if the filehandle is opened with
the ":encoding(utf8)" layer.  Other encodings can be converted to Perl's
encoding on input or from Perl's encoding on output by use of the
":encoding(...)"  layer.  See 0.

included to enable recognition of UTF-8 in the Perl scripts themselves
(in string or regular expression literals, or in identifier names) on
ASCII-based machines or to recognize UTF-EBCDIC on EBCDIC-based
machines.  B<These are the only times when an explicit 0  See 0.

or UTF-8), or if the script looks like non-BOM-marked UTF-16 of either
endianness, Perl will correctly read in the script as Unicode.
(BOMless UTF-8 cannot be effectively recognized or differentiated from
ISO 8859-1 or other eight-bit encodings.)

implicit upgrading from byte strings to Unicode strings assumes that
they were encoded in 0, but Unicode strings are
downgraded with UTF-8 encoding.  This happens because the first 256
codepoints in Unicode happens to agree with Latin-1.

represent strings internally.

characters rather than bytes within the scope of a
C<0 (or equivalently
0 or higher).  (This is not true if bytes have been
explicitly requested by C<0, nor necessarily true
for interactions with the platform's operating system.)

provides a fairly safe environment that can handle both types of
semantics in programs.  For operations where Perl can unambiguously
decide that the input data are characters, Perl switches to character
semantics.  For operations where this determination cannot be made
without additional information from the user, Perl decides in favor of
compatibility and chooses to use byte semantics.

0 in the same scope), Perl uses the
semantics associated
with the current locale.  Otherwise, Perl uses the platform's native
byte semantics for characters whose code points are less than 256, and
Unicode semantics for those greater than 255.  On EBCDIC platforms, this
is almost seamless, as the EBCDIC code pages that Perl handles are
equivalent to Unicode's first 256 code points.  (The exception is that
EBCDIC regular expression case-insensitive matching rules are not as
as robust as Unicode's.)   But on ASCII platforms, Perl uses US-ASCII
(or Basic Latin in Unicode terminology) byte semantics, meaning that characters
whose ordinal numbers are in the range 128 - 255 are undefined except for their
ordinal numbers.  This means that none have case (upper and lower), nor are any
a member of character classes, like 0 or 0.  (But all do belong
to the 0 class or the Perl regular expression extension 0.)

which allowed byte semantics in Perl operations only if
none of the program's inputs were marked as being a source of Unicode
character data.  Such data may come from filehandles, from calls to
external programs, from information provided by the system (such as %ENV),
or from literals and constants in the source text.

recognition of UTF-(8|EBCDIC) in literals encountered by the parser.
Note that this pragma is only required while Perl defaults to byte
semantics; when character semantics become the default, this pragma
may become a no-op.  See 0.

character data are concatenated, the new string will have
character semantics.  This can cause surprises: See 0, below.
You can choose to be warned when this happens.  See 0.

bytes now operate on characters. A character in Perl is
logically just a number ranging from 0 to 2**31 or so. Larger
characters may encode into longer sequences of bytes internally, but
this internal detail is mostly hidden for Perl code.
See 0 for more.

contain characters that have an ordinal value larger than 255.

occur directly within the literal strings in UTF-8 encoding, or UTF-16.
(The former requires a BOM or 0, the latter requires a BOM.)

notation.  The Unicode code for the desired character, in hexadecimal,
should be placed in the braces, after the 0. For instance, a smiley face is
0.

above.  For characters below 0x100 you may get byte semantics instead of
character semantics;  see 0.  On EBCDIC machines there is
the additional problem that the value for such characters gives the EBCDIC
character rather than the Unicode one.

character name within the braces, such as 0.
See 0.

Perl script may contain Unicode alphanumeric characters, including
ideographs.  Perl does not currently attempt to canonicalize variable
names.

a character instead of a byte.

bytes and match against the character properties specified in the
Unicode properties database.  0 can be used to match a Japanese
ideograph, for instance.

character classes) by using the 0 "matches property" construct and
the 0 negation, "doesn't match property".
See 0 for more details.

in the regular expression with the 0 or 0 construct.
See 0 for more details.

cluster" in Standardese.  In Unicode what appears to the user to be a single
character, for example an accented 0, may in fact be composed of a sequence
of characters, in this case a 0 followed by an accent character.  0
will match the entire sequence.

that the 0 functionality has been removed.  For similar
functionality see pack('U0', ...) and pack('C0', ...).

when character input is provided.  Note that 0, or 0 in
interpolated strings, translates to uppercase, while 0,
or 0 in interpolated strings, translates to titlecase in languages
that make the distinction (which is equivalent to uppercase in languages
without the distinction).

automatically switch to using character positions, including
0, 0, 0, 0, 0, 0,
0, 0, and 0.  An operator that
specifically does not switch is 0.  Operators that really don't
care include operators that treat strings as a bucket of bits such as
0, and operators dealing with filenames.

used for byte-oriented formats.  Again, think 0 in the C language.

and code points. There is also a 0 specifier that is the equivalent of
0/0 and properly handles character values even if they are above 255.

0 and 0, 0 0 and
0.  0 and 0 are methods for
emulating byte-oriented 0 and 0 on Unicode strings.
While these methods reveal the internal encoding of Unicode strings,
that is not something one normally needs to care about at all.

However, for backward compatibility, such as when using bit string
operations when characters are all less than 256 in ordinal value, one
should not use 0 (the bit complement) with characters of both
values less than 256 and values greater than 256.  Most importantly,
DeMorgan's laws (0 and 0)
will not hold.  The reason for this mathematical 0 is that
the complement cannot return 0 the 8-bit (byte-wide) bit
complement 0 the full character-wide bit complement.

0, 0, and 0 (or their double-quoted string inlined
versions such as 0). See
0
for more details.

points as a single logical character is in the 0 construct, already
mentioned above.   Therefore "character" in this discussion means a single
Unicode code point.)

regular expressions by using the 0 "matches property" construct
and the 0 "doesn't match property" for its negation.

"Uppercase" property, while 0 matches any character with a
General_Category of "L" (letter) property.  Brackets are not
required for single letter property names, so 0 is equivalent to 0.

Uppercase property value is True, and 0 matches any character
whose Uppercase property value is False, and they could have been written as
0 and 0, respectively.

take on more values than just True and False.  For example, the Bidi_Class (see
0 below), can take on several different
values, such as Left, Right, Whitespace, and others.  To match these, one needs
to specify the property name (Bidi_Class), AND the value being matched against
(Left, Right, etc.).  This is done, as in the examples above, by having the
two components separated by an equal sign (or interchangeably, a colon), like
0.

of 0 or 0, but Perl provides some
additional properties that are written only in the single form, as well as
single-form short-cuts for all binary properties and certain others described
below, in which you may omit the property name and the equals or colon
separator.

prefer): a short one that is easier to type and a longer one that is more
descriptive and hence easier to understand.  Thus the "L" and "Letter" properties
above are equivalent and can be used interchangeably.  Likewise,
"Upper" is a synonym for "Uppercase", and we could have written
0 equivalently as 0.  Also, there are typically
various synonyms for the values the property can be.   For binary properties,
"True" has 3 synonyms: "T", "Yes", and "Y"; and "False has correspondingly "F",
"No", and "N".  But be careful.  A short form of a value for one property may
not mean the same thing as the same short form for another.  Thus, for the
General_Category property, "L" means "Letter", but for the Bidi_Class property,
"L" means "Left".  A complete list of properties and synonyms is in
0.

thus 0 means the same thing as 0 or even 0.
Similarly, you can add or subtract underscores anywhere in the middle of a
word, so that these are also equivalent to 0.  And white space
is irrelevant adjacent to non-word characters, such as the braces and the equals
or colon separators, so 0 and 0 are
equivalent to these as well.  In fact, white space and even
hyphens can usually be added or deleted anywhere.  So even 0 is
equivalent.  All this is called "loose-matching" by Unicode.  The few places
where stricter matching is used is in the middle of numbers, and in the Perl
extension properties that begin or end with an underscore.  Stricter matching
cares about white space (except adjacent to non-word characters),
hyphens, and non-interior underscores.

(^) between the first brace and the property name: 0 is
equal to 0.

adding a 0 regular expression modifier does not change what they
match.  There are two sets that are affected.
The first set is
0,
0,
and 0,
all of which match 0 under 0 matching.
And the second set is
0,
0,
and 0,
all of which match 0 under 0 matching.
This set also includes its subsets 0 and 0 both
of which under 0 matching match 0.
(The difference between these sets is that some things, such as Roman
numerals, come in both upper and lower case so they are 0, but aren't considered
letters, so they aren't 0s.)

usual categorization of a character" (from
0).

(short, 0).  But Perl furnishes shortcuts in which everything up
through the equal or colon separator is omitted.  So you can instead just write
0.

two-letter sub-properties starting with the same letter.
0 and 0 are special: both are aliases for the set consisting of everything matched by 0, 0, and 0.

written right to left, for example) Unicode supplies these properties in
the Bidi_Class class:

For example, 0 matches characters that are normally
written right to left.

(unless you're reading it in translation) is written in Latin, while Russian is
written in Cyrillic, and Greek is written in, well, Greek; Japanese mainly in
Hiragana or Katakana.  There are many more.

and the property can be specified with the compound form like
0 (short: 0).  Perl furnishes shortcuts for all
script names.  You can omit everything up through the equals (or colon), and
simply write 0 or 0.

so far may have 0 or 0 prepended to their name, so 0, for
example, is equal to 0, and 0 is equal to
0.

characters.  The difference between scripts and blocks is that the
concept of scripts is closer to natural languages, while the concept
of blocks is more of an artificial grouping based on groups of Unicode
characters with consecutive ordinal values. For example, the "Basic Latin"
block is all characters whose ordinals are between 0 and 127, inclusive; in
other words, the ASCII characters.  The "Latin" script contains some letters
from this as well as several other blocks, like "Latin-1 Supplement",
"Latin Extended-A", etc., but it does not contain all the characters from
those blocks. It does not, for example, contain the digits 0-9, because
those digits are shared across many scripts. The digits 0-9 and similar groups,
like punctuation, are in the script called 0.  There is also a
script called 0 for characters that modify other characters,
and inherit the script value of the controlling character.  (Note that
there are several different sets of digits in Unicode that are
equivalent to 0-9 and are matchable by 0 in a regular expression.
If they are used in a single language only, they are in that language's
script.  Only sets are used across several languages are in the
0 script.)

0

natural language; the Block property may occasionally be useful in working
with the nuts and bolts of Unicode.

0.  Unlike most other properties, only a few block names have a
Unicode-defined short name.  But Perl does provide a (slight) shortcut:  You
can say, for example 0 or 0.  For backwards
compatibility, the 0 prefix may be omitted if there is no naming conflict
with a script or any other property, and you can even use an 0 prefix
instead in those cases.  But it is not a good idea to do this, for a couple
reasons:

For example, 0 means the 0 Hebrew, and NOT the 0
Hebrew.  But would you remember that 6 months from now?

creating a property with the same name.  There was a time in very early Unicode
releases when 0 would have matched the 0 Hebrew; now it
doesn't.

instead of the shortcuts, whether for clarity, because they can't remember the
difference between 'In' and 'Is' anyway, or they aren't confident that those who
eventually will read their code will know that difference.

A complete list is in 0.

properties are Perl extensions.  Most of these are just synonyms for the
Unicode ones, but some are genuine extensions, including several that are in
the compound form.  And quite a few of these are actually recommended by Unicode
(in 0).

compound-form Unicode properties (for those, you'll have to refer to the
0.

0.

0.

which is a subset of Unicode.

category is not Unassigned (or equivalently, not Cn).

spacing horizontally.

necessary to know some basics about decomposition.
Consider a character, say H.  It could appear with various marks around it,
such as an acute accent, or a circumflex, or various hooks, circles, arrows,
0, above, below, to one side or the other, etc.  There are many
possibilities among the world's languages.  The number of combinations is
astronomical, and if there were a character for each combination, it would
soon exhaust Unicode's more than a million possible characters.  So Unicode
took a different approach: there is a character for the base H, and a
character for each of the possible marks, and these can be variously combined
to get a final logical character.  So a logical character--what appears to be a
single character--can be a sequence of more than one individual characters.
This is called an "extended grapheme cluster";  Perl furnishes the 0
regular expression construct to match such sequences.

practices, and several pre-existing standards have single characters that
mean the same thing as some of these combinations.  An example is ISO-8859-1,
which has quite a few of these in the Latin-1 range, an example being "LATIN
CAPITAL LETTER E WITH ACUTE".  Because this character was in this pre-existing
standard, Unicode added it to its repertoire.  But this character is considered
by Unicode to be equivalent to the sequence consisting of the character
"LATIN CAPITAL LETTER E" followed by the character "COMBINING ACUTE ACCENT".

its equivalence with the sequence is called canonical equivalence.  All
pre-composed characters are said to have a decomposition (into the equivalent
sequence), and the decomposition type is also called canonical.

"compatible" or "non-canonical" decomposition.  The sequences that form these
decompositions are not considered canonically equivalent to the pre-composed
character.  An example, again in the Latin-1 range, is the "SUPERSCRIPT ONE".
It is somewhat like a regular digit 1, but not exactly; its decomposition
into the digit 1 is called a "compatible" decomposition, specifically a
"super" decomposition.  There are several such compatibility
decompositions (see 0), including one
called "compat", which means some miscellaneous type of decomposition
that doesn't fit into the decomposition categories that Unicode has chosen.

decomposition type is "None".

type to mean any of the several compatibility decompositions.

that on a printer would cause ink to be used.

spacing horizontally.

notation for Posix classes and are described in
0.

character is.

0 or 0; or the "*" can also be 0.  This property will
match the code points whose final disposition has been settled as of the
Unicode release given by the version number; 0
will match those code points whose meaning has yet to be assigned.

Unicode release available, which is 0, so this property is true for all
valid "*" versions.  On the other hand, 0 was not assigned until version
5.1 when it became "LATIN SMALL LETTER Y WITH LOOP", so the only "*" that
would match it are 5.1, 5.2, and later.

with Age is that a strict interpretation of it (which Perl takes) has it
matching the precise release a code point's meaning is introduced in.  Thus
0 would match only 1.1; and 0 only 5.1.  This is not usually what
you want.

the same as the Perl Present_In property; just be aware of that.

that the code point has been 0, but that the meaning of the code point
has been 0.  This is because 66 code points will always be
unassigned, and so the Age for them is the Unicode version in which the decision
to make them so was made.  For example, 0 is to be permanently
unassigned to a character, and the decision to do that was made in version 3.1,
so 0 matches this character, as also does 0 and up.

which both the Posix standard and Unicode consider white space.)

extended to the full Unicode range.  They are described in
0.

whose names begin with "In" or "Is".  The subroutines can be defined in any
package.  The user-defined properties can be used in the regular expression
0 and 0 constructs; if you are using a user-defined property from a
package other than the one you are in, you must specify its package in the
0 or 0 construct.

However, the subroutines are passed a single parameter, which is 0 if
case-sensitive matching is in effect and non-zero if caseless matching
is in effect.  The subroutine may return different values depending on
the value of the flag, and one set of values will immutably be in effect
for all case-sensitive matches, and the other set for all case-insensitive
matches.

than calling the subroutine, where the name of the subroutine is
determined by the tainted data.

or more newline-separated lines.  Each line must be one of the following:

tabular characters) denoting a range of Unicode code points to include.

property (prefixed by "utf8::") or a user-defined character property,
to represent all the characters in that property; two hexadecimal code
points for a range; or a single hexadecimal code point.

property (prefixed by "utf8::") or a user-defined character property,
to represent all the characters in that property; two hexadecimal code
points for a range; or a single hexadecimal code point.

property (prefixed by "utf8::") or a user-defined character property,
to represent all the characters in that property; two hexadecimal code
points for a range; or a single hexadecimal code point.

property (prefixed by "utf8::") or a user-defined character property,
for all the characters except the characters in the property; two
hexadecimal code points for a range; or a single hexadecimal code point.

syllabaries (hiragana and katakana), you can define

Now you can use 0 and 0
The CPAN module 0 provides better functionality
without the drawbacks described below.

0, 0, and 0 (or their string-inlined versions,
0, 0, 0, and 0).  The mappings are currently only valid
on strings encoded in UTF-8, but see below for a partial workaround for
this restriction.

properties: define subroutines that do the mappings.
0 is used for 0, 0, 0, and 0; 0 for
0 and 0; and 0 for 0 and 0.

to 0x100, and all other characters map to themselves.  The first
returned line means to map the code point at 0x61 ("a") to 0x41 ("A"),
the code point at 0x62 ("b") to 0x42 ("B"),  ..., 0x7A ("z") to 0x5A
("Z").  The second line maps just the code point 0x101 to 0x100.  Since
there are no other mappings defined, all other code points map to
themselves.

and scopes.  All non-threaded programs have exactly one uppercasing
behavior, one lowercasing behavior, and one titlecasing behavior in
effect for utf8-encoded strings for the duration of the program.  Each
of these behaviors is irrevocably determined the first time the
corresponding function is called to change a utf8-encoded string's case.
If a corresponding 0 function has been defined in the package that
makes that first call, the mapping defined by that function will be the
mapping used for the duration of the program's execution across all
packages and scopes.  If no corresponding 0 function has been
defined in that package, the standard official mapping will be used for
all packages and scopes, and any corresponding 0 function anywhere
will be ignored.  Threaded programs have similar behavior.  If the
program's casing behavior has been decided at the time of a thread's
creation, the thread will inherit that behavior.  But, if the behavior
hasn't been decided, the thread gets to decide for itself, and its
decision does not affect other threads nor its creator.

you can't just override a couple of characters and leave the rest
unchanged.  You can find all the official mappings in the directory
00.  The mapping data is returned as the
here-document.  The C<utf8::ToSpec0 hashes in those files are special
exception mappings derived from
00.  (The "Digit" and
"Fold" mappings that one can see in the directory are not directly
user-accessible, one can use either the 0 module, or just match
case-insensitively, which is what uses the "Fold" mapping.  Neither are user
overridable.)

change by hand the affected code points, and place the whole thing into your
subroutine.  But this will only be valid on Perls that use the same Unicode
version.  Another option would be to have your subroutine read the official
mapping files and overwrite the affected code points.

following trick, here illustrated for Turkish.

LETTER I".  The keys to the hash must be the bytes that form the UTF-8
(on EBCDIC platforms, UTF-EBCDIC) of the character, as illustrated by
the inverse function.

bytes that together form the UTF-8 that represents 0, 0.  You can avoid having to figure out
these bytes, and at the same time make it work on all platforms by
instead writing:

converts it to the sequence of bytes that constitute it.  Note that we took
advantage of the fact that 0 is the same in UTF-8 or UTF_EBCIDIC as not;
otherwise we would have had to write

is that they work only on strings encoded in UTF-8.  You can partially
get around this by using 0.  (But better to just convert to
use 0.)  For example:
(The trick illustrated here does work in earlier releases, but only if all the
characters you want to override have ordinal values of 256 or higher, or
if you use the other tricks given just below.)

on scalars that have been marked as having Unicode characters, for example by
using 0.  Although probably not advisable, you can
cause the mappings to be used globally by importing into 0
(see 0).

must be in utf8 by using 0 (or by importing into 0) by:

call the corresponding official function, which will use the 0 and
0 functions you have defined.
(For Turkish, there are other required functions: 0, 0,
and 0. These are very similar to the ones given above.)

0, 0, and 0 case-change operations in regular expressions,
which still require the source to be encoded in utf8 (see 0). (Again, use 0 instead.)

that context-dependent casing suffers from the problem that the string
passed to the casing function may not have sufficient context to make
the proper choice. Also, it will not be called for 0, 0, 0,
and 0.

all features currently directly supported by core Perl.  The references to "Level N"
and the section numbers refer to the Unicode Technical Standard #18,
"Unicode Regular Expressions", version 13, from August 2008.

For example, what UTS#18 might write as

UTS#18 grouping, intersection, union, and removal (subtraction) syntax.

(see 0)

numbers.  To use these numbers, various encodings are needed.

encoding. For ASCII (and we really do mean 7-bit ASCII, not another
8-bit encoding), UTF-8 is transparent.

caused by legal UTF-8 avoiding non-shortest encodings: it is technically
possible to UTF-8-encode a single code point in different ways, but that is
explicitly forbidden, and the shortest possible encoding should always be used
(and that is what Perl does).

leading bits of the start byte tell how many bytes there are in the
encoded character.

encoding of numbers up to 0x7FFF_FFFF.  Perl continues to allow those,
and has extended that up to 13 bytes to encode code points up to what
can fit in a 64-bit word.  However, Perl will warn if you output any of
these as being non-portable; and under strict UTF-8 input protocols,
they are forbidden.

"open interchange".  See 0.

knowledge, Perl doesn't use these constructs internally.

UTF-8 uses 8-bit code units, UTF-16 uses 16-bit code units.
All code points occupy either 2 or 4 bytes in UTF-16: code points
0 are stored in a single 16-bit unit, and code
points 0 in two 16-bit units.  The latter case is
using 0, the first 16-bit unit being the 0, and the second being the 0.

range of Unicode code points in pairs of 16-bit units.  The 0 are the range 0 and the 0
are the range 0.  The surrogate encoding is

itself can be used for in-memory computations, but if storage or
transfer is required either UTF-16BE (big-endian) or UTF-16LE
(little-endian) encodings must be chosen.

is UTF-16, but you don't know which endianness?  Byte Order Marks, or
BOMs, are a solution to this.  A special character has been reserved
in Unicode to function as a byte order marker: the character with the
code point 0 is the BOM.

since if it was written on a big-endian platform, you will read the
bytes 0, but if it was written on a little-endian platform,
you will read the bytes 0.  (And if the originating platform
was writing in UTF-8, you will read the bytes 0.)

0 is not supposed to be in input streams, so the
sequence of bytes 0 is unambiguously "BOM, represented in
little-endian format" and cannot be 0, represented in big-endian
format".

represent other code points.  However, Perl allows them to be
represented individually internally, for example by saying
0, so that all code points, not just those valid for open
interchange, are
representable.  Unicode does define semantics for them, such as their
General Category is "Cs".  But because their use is somewhat dangerous,
Perl will warn (using the warning category "surrogate", which is a
sub-category of "utf8") if an attempt is made
to do things like take the lower case of one, or match
case-insensitively, or to output them.  (But don't try this on Perls
before 5.14.)

the units are 32-bit, and therefore the surrogate scheme is not
needed.  UTF-32 is a fixed-width encoding.  The BOM signatures are
0 for BE and 0 for LE.

encoding.  Unlike UTF-16, UCS-2 is not extensible beyond 0,
because it does not use surrogates.  UCS-4 is a 32-bit encoding,
functionally identical to UTF-32 (the difference being that
UCS-4 forbids neither surrogates nor code points larger than 0x10_FFFF).

transport or storage is not eight-bit safe.  Defined by RFC 2152.

These all have the Unassigned (Cn) General Category, and they never will
be assigned.  These are never supposed to be in legal Unicode input
streams, so that code can use them as sentinels that can be mixed in
with character data, and they always will be distinguishable from that data.
To keep them out of Perl input streams, strict UTF-8 should be
specified, such as by using the layer 0.  The
non-character code points are the 32 between U+FDD0 and U+FDEF, and the
34 code points U+FFFE, U+FFFF, U+1FFFE, U+1FFFF, ... U+10FFFE, U+10FFFF.
Some people are under the mistaken impression that these are "illegal",
but that is not true.  An application or cooperating set of applications
can legally use them at will internally; but these code points are
"illegal for open interchange".  Therefore, Perl will not accept these
from input streams unless lax rules are being used, and will warn
(using the warning category "nonchar", which is a sub-category of "utf8") if
an attempt is made to output them.

points up to the maximum permissible unsigned number available on the
platform.  However, Perl will not accept these from input streams unless
lax rules are being used, and will warn (using the warning category
"non_unicode", which is a sub-category of "utf8") if an attempt is made to
operate on or output them.  For example, 0 will generate
this warning, returning the input parameter as its result, as the upper
case of every non-Unicode code point is the code point itself.

Also, note the following:

interpretation of how many bytes of encoded output one should generate
from one input Unicode character.  Strictly speaking, the shortest
possible sequence of UTF-8 bytes should be generated,
because otherwise there is potential for an input buffer overflow at
the receiving end of a UTF-8 connection.  Perl always generates the
shortest length UTF-8, and with warnings on, Perl will warn about
non-shortest length UTF-8 along with other malformations, such as the
surrogates, which are not Unicode code points valid for interchange.

accustomed to Unicode.  Starting in Perl 5.14, several pattern
modifiers are available to control this, called the character set
modifiers.  Details are given in 0.

each of two worlds: the old world of bytes and the new world of
characters, upgrading from bytes to characters when necessary.
If your legacy code does not explicitly use Unicode, no automatic
switch-over to characters should happen.  Characters shouldn't get
downgraded to bytes, either.  It is possible to accidentally mix bytes
and characters, however (see 0), in which case 0 in
regular expressions might start behaving differently (unless the 0
modifier is in effect).  Review your code.  Use warnings and the 0 pragma.

experimental.  On such platforms, references to UTF-8 encoding in this
document and elsewhere should be read as meaning the UTF-EBCDIC
specified in Unicode Technical Report 16, unless ASCII vs. EBCDIC issues
are specifically discussed. There is no 0 pragma or
":utfebcdic" layer; rather, "utf8" and ":utf8" are reused to mean
the platform's "natural" 8-bit encoding of Unicode. See 0
for more discussion of the issues.

and a few other "entry points" like the @ARGV array (which can sometimes be
interpreted as UTF-8), there are still many places where Unicode
(in some encoding or another) could be given as arguments or received as
results, or both, but it is not.

For all of these interfaces Perl
currently (as of 5.8.3) simply assumes byte strings both as arguments
and results, or UTF-8 strings if the (problematic) 0 pragma has been used.

these situations is that the answers are highly dependent on the operating
system and the file system(s).  For example, whether filenames can be
in Unicode and in exactly what kind of encoding, is not exactly a
portable concept.  Similarly for 0 and 0: how well will the
"command-line interface" (and which of them?) handle Unicode?

rename, rmdir, stat, symlink, truncate, unlink, utime, -X

on ASCII platforms with the
Unicode code points in the Latin-1 Supplement block, that
is, between 128 and 255.  Without a locale specified, unlike all other
characters or code points, these characters have very different semantics in
byte semantics versus character semantics, unless
0 is specified.
(The lesson here is to specify 0 to avoid the
headaches.)

they have the same semantics as Latin-1 (ISO-8859-1).

that the only semantics they have is their ordinal numbers, and that they are
not members of various character classes.  None are considered to match 0
for example, but all match 0.

and 0, or 0, 0, 0 and 0 in regular expression
substitutions.

0, 0, 0, 0, 0, and all the Posix character classes
0 0.

code points above 127 are quoted in UTF-8 encoded strings, but in
byte encoded strings, code points between 128-255 are always quoted.

example, which overrides Perl's built-in case mappings.  The scalar must be
encoded in utf8 for your function to actually be invoked.

suddenly change if a code point above 255 is appended to or removed from it,
which changes the string's semantics from byte to character or vice versa.  As
an example, consider the following program and its output:

didn't use Unicode, and hence had no semantics for characters outside of the
ASCII range (except in a locale), along with Perl's desire to add Unicode
support seamlessly.  The result wasn't seamless: these characters were
orphaned.

cause Perl to use Unicode semantics on all string operations within the
scope of the feature subpragma.  Regular expressions compiled in its
scope retain that behavior even when executed or compiled into larger
regular expressions outside the scope.  (The pragma does not, however,
affect the 0 behavior.  Nor does it affect the deprecated
user-defined case changing operations--these still require a UTF-8
encoded string to operate.)

expressions.  See 0 for details on how this pragma works in
combination with various others for casing.

subpragma's scope, a workaround is to always call 0,
or to use the standard module 0.   Also, a scalar that has any characters
whose ordinal is above 0x100, or which were specified using either of the
0 notations, will automatically have character semantics.

there are situations where you simply need to force a byte
string into UTF-8, or vice versa.  The low-level calls
utf8:: and utf8::downgrade([, FAIL_OK]) are
the answers.

that don't fit into a byte.

no-op.

following C APIs useful.  See also 0 for an
explanation about Unicode at the XS level, and 0 for the API
details.

pragma is not in effect.  0 returns true if the 0
flag is on; the bytes pragma is ignored.  The 0 flag being on
does 0 mean that there are any characters of code points greater
than 255 (or 127) in the scalar or that there are even any characters
in the scalar.  What the 0 flag means is that the sequence of
octets in the representation of the scalar is the sequence of UTF-8
encoded code points of the characters of a string.  The 0 flag
being off means that each octet in this representation encodes a
single character with code point 0..255 within the string.  Perl's
Unicode model is not to use UTF-8 until it is absolutely necessary.

a buffer encoding the code point as UTF-8, and returns a pointer
pointing after the UTF-8 bytes.  It works appropriately on EBCDIC machines.

returns the Unicode character code point and, optionally, the length of
the UTF-8 byte sequence.  It works appropriately on EBCDIC machines.

in characters.  0 returns the length of the UTF-8 encoded
scalar.

encoded form.  0 does the opposite, if
possible.  0 is like sv_utf8_upgrade except that
it does not set the 0 flag.  0 does the
opposite of 0.  Note that none of these are to be
used as general-purpose encoding or decoding interfaces: 0
for that.  0 is affected by the encoding pragma
but 0 is not (since the encoding pragma is
designed to be a one-way street).

character.

are valid UTF-8.

character in the buffer.  0 will return the number of bytes
required to UTF-8-encode the Unicode character code point.  0
is useful for example for iterating over the characters of a UTF-8
encoded buffer; 0 is useful, for example, in computing
the size required for a UTF-8 encoded buffer.

two pointers pointing to the same UTF-8 encoded buffer.

that is 0 (positive or negative) Unicode characters displaced
from the UTF-8 buffer 0.  Be careful not to overstep the buffer:
0 will merrily run off the end or the beginning of the
buffer if told to do so.

0 are useful for debugging the
output of Unicode strings and scalars.  By default they are useful
only for debugging--they display 0 characters as hexadecimal code
points--but with the flags 0,
0, and 0 you can make the
output more readable.

compare two strings case-insensitively in Unicode.  For case-sensitive
comparisons you can just use 0 and 0 as usual, except
if one string is in utf8 and the other isn't.

in the Perl source code distribution.

you can change to use any earlier one.

site 0).  These should replace the existing files in
0 in the Perl source tree.  Follow the instructions in
0 in that directory to change some of their names, and then build
perl (see 0).

change 0 in the directory 0 to point to the
new directory, or maybe make a copy of that directory before making the change,
and using 0 or the 0 run-time flag to switch between versions at will
(but because of caching, not in the middle of a process), but all this is
beyond the scope of these instructions.

able to understand the UTF8 flag and act accordingly. If the
extension doesn't recognize that flag, it's likely that the extension
will return incorrectly-flagged data.

every module you're using if there are any issues with Unicode data
exchange. If the documentation does not talk about Unicode at all,
suspect the worst and probably look at the source to learn how the
module is implemented. Modules written completely in Perl shouldn't
cause problems. Modules that directly or indirectly access code written
in other programming languages are at risk.

to always make the encoding of the exchanged data explicit. Choose an
encoding that you know the extension can handle. Convert arguments passed
to the extensions to that encoding and convert results back from that
encoding. Write wrapper functions that do the conversions for you, so
you can later change the functions when the extension catches up.

function doesn't deal with Unicode data yet. The wrapper function
would convert the argument to raw UTF-8 and convert the result back to
Perl's internal representation like so:

and retrieves them, you will be able to use the otherwise
dangerous Encode:: function. Let's say the popular
0 extension, written in C, provides a 0 method that
lets you store and retrieve data according to these prototypes:

derived class with such a 0 method:

DB_File::filter_store_key and family. Look out for such filters in
the documentation of your extensions, they can make the transition to
Unicode data much easier.

on byte encoded strings.  All functions that need to hop over
characters such as ,  or , or matching regular
expressions can work 0 faster when the underlying data are
byte-encoded.

a caching scheme was introduced which will hopefully make the slowness
somewhat less spectacular, at least for some operations.  In general,
operations with UTF-8 encoded strings are still slower. As an example,
the Unicode properties (character classes) like 0 are known to
be quite a bit slower (5-20 times) than their simpler counterparts
like 0 (then again, there are hundreds of Unicode characters matching 0
compared with the 10 ASCII characters matching 0).

want to use Perl there, send email to perlbug@perl.org.

the new string was sometimes created by
decoding the byte strings as 0, even if the
old Unicode string used EBCDIC.

was required to use the 0 pragma to declare that a given scope
expected to deal with Unicode data and had to make sure that only
Unicode data were reaching that scope. If you have code that is
working with 5.6, you will need some of the following adjustments to
your code. The examples are written such that the code will continue
to work under 5.6, so you should be safe to try them out.

mention of Unicode in the manpage, you need to make sure that the
UTF8 flag is stripped off. Note that at the time of this writing
(October 2002) the mentioned modules are not UTF-8-aware. Please
check the documentation to verify if this is still true.

want the UTF8 flag restored:

a convenient way to replace all your fetchrow_array and
fetchrow_hashref calls. A wrapper function will also make it easier to
adapt to future enhancements in your database driver. Note that at the
time of this writing (October 2002), the DBI has no standardized way
to deal with UTF-8 data. Please check the documentation to verify if
that is still true.

a drag to your program. If you recognize such a situation, just remove
the UTF8 flag:

0, 0
0).

=encoding utf8

read after 0.

is actually a generic 0 tutorial and 0= 1.32 to function correctly, even though the
changelog is silent about this.

(The binmode is needed because otherwise Perl may convert line endings on Win32
systems.)

need text in a binary stream, encode your text strings first using the
appropriate encoding, then join them with binary strings. See also: "What if I
don't encode?".

process, like a database, a text file, a socket, or another program. Even if
the thing you're communicating with is also written in Perl.

will assume that your binary string was encoded with ISO-8859-1, also known as
latin-1. If it wasn't latin-1, then your data is unpleasantly converted. For
example, if it was UTF-8, the individual bytes of multibyte characters are seen
as separate characters, and then again converted to UTF-8. Such double encoding
can be compared to double HTML encoding (0), or double URI encoding
(0).

positive, but it's best to avoid it.

some cases, Perl will warn you that you're doing something wrong, with a
friendly warning:

because UTF-8 is usually the encoding you wanted! But don't be lazy, and don't
use the fact that Perl's internal format is UTF-8 to your advantage. Encode
explicitly to avoid weird bugs, and to show to maintenance programmers that you
thought this through.

way, you can tell the PerlIO system to automatically decode everything, with
the 0 layer. If you do this, you can't accidentally forget to decode
or encode anymore, on things that use the layered handle.

that is sometimes limited to the UTF-8 encoding.

document your guess with a comment.)

character encoding until you can visually confirm that all characters look the
way they should.

keep sending you data without charset indication, you may have to educate them.

0 pragma.

the way your sources are read. You can use Unicode in string literals, in
identifiers (but they still have to be "word characters" according to 0),
and even in custom delimiters.

some complaints that it should restore the UTF8 flag when the data is read
again with 0. However, you should really not look at the flag, and
nothing indicates that Data::Dumper should break this rule.

encoding as long as it can. (But perhaps originally it was internally encoded
as UTF-8, when you dumped it.) When it has to give that up because other
characters are added to the text string, it silently upgrades the string to
UTF-8.

concern, and you can just 0 dumped data as always.

0 near the beginning of your program.
Within its lexical scope you shouldn't have this problem.  It also is
automatically enabled under 0 or using 0 on the
command line for Perl 5.12 or higher.

rely on the way things worked before Unicode came along.  Those older
programs knew only about the ASCII character set, and so may not work
properly for additional characters.  When a string is encoded in UTF-8,
Perl assumes that the program is prepared to deal with Unicode, but when
the string isn't, Perl assumes that only ASCII (unless it is an EBCDIC
platform) is wanted, and so those characters that are not ASCII
characters aren't recognized as to what they would be in Unicode.
0 tells Perl to treat all characters as
Unicode, whether the string is encoded in UTF-8 or not, thus avoiding
the problem.

the feature's scope, you can force Unicode semantics by changing the
encoding to UTF-8 by doing 0.

characters with an ordinal value greater than 255, or any character occupying
more than one byte, depending on the context.

ordinal value greater than 255. With no specified encoding layer, Perl tries to
fit things in ISO-8859-1 for backward compatibility reasons. When it can't, it
emits this warning (if warnings are enabled), and outputs UTF-8 encoded data
instead.

stream, always specify an encoding explicitly, for example with a PerlIO layer:

think about the UTF8 flag at all. That means that you very probably shouldn't
use 0, 0 or 0 at all.

current internal representation is UTF-8. Without the flag, it is assumed to be
ISO-8859-1. Perl converts between these automatically.  (Actually Perl usually
assumes the representation is ASCII; see 0 above.)

keep a secret, so everyone knows about this. That is the source of much
confusion. It's better to pretend that the internal format is some unknown
encoding, and that you always have to encode and decode explicitly.

makes no sense to deal with characters in a byte string. Do the proper
conversions (by decoding/encoding), and things will work out well: you get
character counts for decoded data, and byte counts for encoded data.

about it.

that of the user will use the same encoding. It will use the same encoding for
the source code and for STDIN and STDOUT. When a program is copied to another
machine, the source code does not change, but the STDIO environment might.

file and 0.

based on the user's locale, 0.

encoding or decoding step, and manipulate the UTF8 flag directly.

encoding step if the data was already represented as UTF8 internally. This is
widely accepted as good behavior when you're writing, but it can be dangerous
when reading, because it causes internal inconsistency when you have invalid
byte sequences. Using 0 for input can sometimes result in security
breaches, so please use 0 instead.

but this is considered bad style. Especially 0 can be dangerous, for
the same reason that 0 can.

what it accepts. If you have to communicate with things that aren't so liberal,
you may want to consider using 0. If you have to communicate with things
that are too liberal, you may have to use 0. The full explanation is in
0.

consistently, even where utf8 is actually used internally, because the
distinction can be hard to make, and is mostly irrelevant.

9999999, but if you encode that to UTF-8, you get a substitution character (by
default; see 0 for more ways of dealing with
this.)

some other encoding.)

format being any specific encoding. But since you asked: by default, the
internal format is either ISO-8859-1 (latin-1), or utf8, depending on the
history of the string. On EBCDIC platforms, this may be different even.

when you 0. In other words: don't try to find out what the internal
encoding for a certain string is, but instead just encode it into the encoding
that you want.

=encoding utf8

in Perl.  See 0 for references to more in-depth
treatments of Unicode.

writing systems of the world, plus many other symbols.

almost all other modern character set standards,
covering more than 80 writing systems and hundreds of languages,
including all commercially-important modern languages.  All characters
in the largest Chinese, Japanese, and Korean dictionaries are also
encoded. The standards will eventually cover almost all characters in
more than 250 writing systems and thousands of languages.
Unicode 1.0 was released in October 1991, and 6.0 in October 2010.

particular integer width, especially not to the C language 0 and unique numbers for the characters, in this
case 0x0041 and 0x03B1, respectively.  These unique numbers are called
0.  A code point is essentially the position of the
character within the set of all possible Unicode characters, and thus in
Perl, the term 0 is often used interchangeably with it.

points.  If numbers like 0 are unfamiliar to you, take a peek
at a later section, 0.  The Unicode standard
uses the notation 0, to give the
hexadecimal code point and the normative name of the character.

"uppercase" or "lowercase", "decimal digit", or "punctuation";
these properties are independent of the names of the characters.
Furthermore, various operations on the characters like uppercasing,
lowercasing, and collating (sorting) are defined.

0 "character" or code point.  For Western languages, this is adequately
modelled by a 0 (like 0) followed
by one or more 0 (like 0).  This sequence of
base character and modifiers is called a 0.  Some non-western languages require more complicated
models, so Unicode created the 0 concept, which was
later further refined into the 0.  For
example, a Korean Hangul syllable is considered a single logical
character, but most often consists of three actual
Unicode characters: a leading consonant followed by an interior vowel followed
by a trailing consonant.

point of view. If you are a programmer, you probably would tend towards seeing
each element in the sequences as one unit, or "character".  However from
the user's point of view, the whole sequence could be seen as one
"character" since that's probably what it looks like in the context of the
user's language.  In this document, we take the programmer's point of
view: one "character" is one Unicode code point.

0 characters.  There is a single character equivalent, for
example, to the sequence 0 followed by
0.  It is called  0.  These precomposed characters are, however, only available for
some combinations, and are mainly meant to support round-trip
conversions between Unicode and legacy standards (like ISO 8859).  Using
sequences, as Unicode does, allows for needing fewer basic building blocks
(code points) to express many more potential grapheme clusters.  To
support conversion between equivalent forms, various 0 are also defined.  Thus, 0 is
in 0, (abbreviated NFC), and the sequence
0 followed by 0
represents the same character in 0 (NFD).

number for every character" idea breaks down a bit: instead, there is
"at least one number for every character".  The same character could
be represented differently in several legacy encodings.  The
converse is not also true: some code points do not have an assigned
character.  Firstly, there are unallocated code points within
otherwise used blocks.  Secondly, there are special Unicode control
characters that do not represent true characters.

Unicode is only represented as 0 (or 65536) characters from
0 to 0.  0  Since Unicode 2.0 (July
1996), Unicode has been defined all the way up to 21 bits (0),
and since Unicode 3.1 (March 2001), characters have been defined
beyond 0.  The first 0 characters are called the
0, or the 0 (BMP).  With Unicode
3.1, 17 (yes, seventeen) planes in all were defined--but they are
nowhere near full of defined characters, yet.

do with languages--that each block would define the characters used
by a language or a set of languages.  0
The division into blocks exists, but it is almost completely
accidental--an artifact of how the characters have been and
still are allocated.  Instead, there is a concept called 0, which is
more useful: there is 0 script, 0 script, and so on.  Scripts
usually span varied parts of several blocks.  For more information about
scripts, see 0.

output these abstract numbers, the numbers must be 0 or
0 somehow.  Unicode defines several 0, of which 0 is perhaps the most popular.  UTF-8 is a
variable length encoding that encodes Unicode characters as 1 to 6
bytes.  Other encodings
include UTF-16 and UTF-32 and their big- and little-endian variants
(UTF-8 is byte-order independent) The ISO/IEC 10646 defines the UCS-2
and UCS-4 encoding forms.

0 and 0 (BOMs) are--see 0.

natively.  Perl 5.8.0, however, is the first recommended release for
serious Unicode work.  The maintenance release 5.6.1 fixed many of the
problems of the initial Unicode implementation, but for example
regular expressions still do not work with Unicode in 5.6.1.
Perl 5.14.0 is the first release where Unicode support is
(almost) seamlessly integrable without some gotchas (the exception being
some differences in 0).   To enable this
seamless support, you should 0 (which is
automatically selected if you 0 or higher).  See 0.
(5.14 also fixes a number of bugs and departures from the Unicode
standard.)

that operations in the current block or file would be Unicode-aware.
This model was found to be wrong, or at least clumsy: the "Unicodeness"
is now carried with the data, instead of being attached to the
operations.
Starting with Perl 5.8.0, only one case remains where an explicit 0 is needed: if your Perl script itself is encoded in UTF-8, you can
use UTF-8 in your identifier names, and in string and regular expression
literals, by saying 0.  This is not the default because
scripts with legacy 8-bit data in them would break.  See 0.

strings of Unicode characters.  The general principle is that Perl tries
to keep its data as eight-bit bytes for as long as possible, but as soon
as Unicodeness cannot be avoided, the data is transparently upgraded
to Unicode.  Prior to Perl 5.14, the upgrade was not completely
transparent (see 0), and for backwards
compatibility, full transparency is not gained unless 0 (see 0) or 0 (or higher) is
selected.

character set of the platform (for example Latin-1) is, defaulting to
UTF-8, to encode Unicode strings. Specifically, if all code points in
the string are 0 or less, Perl uses the native eight-bit
character set.  Otherwise, it uses UTF-8.

happens to encode its internal strings, but it becomes relevant when
outputting Unicode strings to a stream without a PerlIO layer (one with
the "default" encoding).  In such a case, the raw bytes used internally
(the native character set or UTF-8, as appropriate for each string)
will be used, and a "Wide character" warning will be issued if those
strings contain a character beyond 0x00FF.

as a warning:

and removes the program's warning.

handles, default 0 layer, and 0 by using either
the 0 command line switch or the 0 environment
variable, see 0 for the documentation of the 0 switch.

way:
if Perl has been led to believe that STDIN should be UTF-8, but then
STDIN coming in from another command is not UTF-8, Perl will likely
complain about the malformed UTF-8.

PerlIO feature.  Almost all Perl 5.8 platforms do use PerlIO, though:
you can see whether yours is by running "perl -V" and looking for
0.

Unicode support is somewhat more complex to implement since
additional conversions are needed at every step.

no one has complained, so the divergence has continued.  If you want to run
Perl on an EBCDIC platform, send email to perlbug@perl.org

instead of UTF-8.  The difference is that as UTF-8 is "ASCII-safe" in
that ASCII characters encode to UTF-8 as-is, while UTF-EBCDIC is
"EBCDIC-safe".

use the 0 notation in double-quoted strings:

a code point.

and 0 for arguments less than 0 (decimal 256)
generate an eight-bit character for backward compatibility with older
Perls.  For arguments of 0 or more, Unicode characters are
always produced. If you want to force the production of Unicode
characters regardless of the numeric value, use 0
instead of 0, 0, or 0.

by name in double-quoted strings:

characters:

constants: you cannot use variables in them.  if you want similar
run-time functionality, use 0 and 0.

0 prefix.  It consumes no arguments but causes the following bytes
to be interpreted as the UTF-8 encoding of Unicode characters:

0 prefix.

strings as usual.  Functions like 0, 0, and
0 will work on the Unicode characters; regular expressions
will work on the Unicode characters (see 0 and 0).

example

have 0 for matching an extended grapheme cluster.  (Thus 0 in a
regular expression would match the entire sequence of both the example
characters.)

encodings, I/O, and certain special cases:

to be upgraded to Unicode.  Normally the legacy data is assumed to be
ISO 8859-1 (or EBCDIC, if applicable).

for doing conversions between those encodings:

Unicode string.  Perl's internal encoding depends on the system as
well as what characters happen to be in the string at the time. If
any of the characters are at code points 0 or above, you will get
a warning.  To ensure that the output is explicitly rendered in the
encoding you desire--and to avoid the warning--open the stream with
the desired encoding. Some examples:

many encodings have several aliases.  Note that the 0 layer
must always be specified exactly like that; it is 0 subject to
the loose matching of encoding names. Also note that currently 0 is unsafe for
input, because it accepts the data without validating that it is indeed valid
UTF-8; you should instead use 0 (with or without a
hyphen).

0 for the 0 layer, and
0 for many encodings supported by the 0
module.

Unicode or legacy encodings does not magically turn the data into
Unicode in Perl's eyes.  To do that, specify the appropriate
layer when opening files

the 0 pragma.  See 0, or look at the following example.

converts data from the specified encoding when it is read in from the
stream.  The result is always Unicode.

setting default layers.  If you want to affect only certain
streams, use explicit layers directly in the 0 call.

0; see 0.

0 and 0, only with the 0 pragma.  The
0 and 0 methods do work with all of 0,
0, and the 0 pragma.

automatically convert Unicode to the specified encoding when it is
written to the stream. For example, the following snippet copies the
contents of the file "text.jis" (encoded as ISO-2022-JP, aka JIS) to
the file "text.utf8", encoded as UTF-8:

pragma allows for flexible names: 0 and 0 will both be
understood.

standardisation organisations are recognised; for a more detailed
list see 0.

0 and 0 operate on byte counts, as do 0
and 0.

conversion upon input if there is no default layer,
it is easy to mistakenly write code that keeps on expanding a file
by repeatedly encoding the data:

UTF-8 encoded.  A 0 would have avoided the
bug, or explicitly opening also the 0 for input as UTF-8.

Perl has been built with the new PerlIO feature (which is the default
on most systems).

simple ASCII (or EBCDIC) text.  The following subroutine converts
its argument so that Unicode characters with code points greater than
255 are displayed as 0, control characters (like 0) are
displayed as 0, and the rest of the characters as themselves:

used on strings containing characters with ordinal values above
255. In such a case, the results are consistent with the internal
encoding of the characters, but not with much else. So don't do
that. Similarly for 0: you will be operating on the
internally-encoded bit patterns of the Unicode characters, not on
the code point values, which is very probably not what you want.

Unicode string (because the normal ways to get at the contents of a
string with Unicode--via input and output--should always be via
explicitly-defined I/O layers). But if you must, there are two
ways of looking behind the scenes.

is to use 0 to get the bytes of whatever the string
encoding happens to be, or 0 to get the bytes of the
UTF-8 encoding:

and Unicode characters in 0.  See also later in this document
the discussion about the 0 function.

in Unicode: what do you mean by "equal"?

0?)

0) based only on code points of the characters.  In the above
case, the answer is no (because 0x00C1 != 0x0041).  But sometimes, any
CAPITAL LETTER A's should be considered equal, or even A's of any case.

and casing issues: see 0, Unicode Technical Report #15,
0 and
sections on case mapping in the 0 is implemented, but bugs remain in 0 with them,
mostly fixed by 5.14.

parlance goes, collated.  But again, what do you mean by collate?

0?)

0, 0, 0, 0) based only on the code points of the
characters.  In the above case, the answer is "after", since
0 0.

given without knowing (at the very least) the language context.
See 0, and 0
0

0) and in the 0 (also known as 0) operator are not
magically Unicode-aware.  What this means is that 0 will not
magically start to mean "all alphabetic letters" (not that it does mean that
even for 8-bit characters; for those, if you are using locales (0),
use 0; and if not, use the 8-bit-aware property 0).

character classes that are Unicode-aware.  There are dozens of them, see
0.

range will include all Unicode code points that lie between those end points.

besides the familiar 0 to 9, such as the Arabic and Indic digits.
Perl does not support string-to-number conversion for digits other
than ASCII 0 to 9 (and ASCII a to f for hexadecimal).
To get safe conversions from any Unicode string, use
0.

somehow, old behaviour should be preserved.  About the only behaviour
that has changed and which could start generating Unicode is the old
behaviour of 0 where supplying an argument more than 255
produced a character modulo 255.  0, for example, was equal
to 0 or "-" (in ASCII), now it is LATIN CAPITAL LETTER I WITH
BREVE.

generate Unicode data.  The most important thing is getting input as
Unicode; for that, see the earlier I/O discussion.
To get full seamless Unicode support, add
0 (or 0 or higher) to your
script.

or you haven't specified 0 or 0 (or higher) because otherwise the semantics of the code points
in the range 128 to 255 are different depending on
whether the string they are contained within is in Unicode or not.
(See 0.)

string are necessary UTF-8 encoded, or that any of the characters have
code points greater than 0xFF (255) or even 0x80 (128), or that the
string has any characters at all.  All the 0 does is to
return the value of the internal "utf8ness" flag attached to the
0.  If the flag is off, the bytes in the scalar are interpreted
as a single byte encoding.  If the flag is on, the bytes in the scalar
are interpreted as the (variable-length, potentially multi-byte) UTF-8 encoded
code points of the characters.  Bytes added to a UTF-8 encoded string are
automatically upgraded to UTF-8.  If mixed non-UTF-8 and UTF-8 scalars
are merged (double-quoted interpolation, explicit concatenation, or
printf/sprintf parameter substitution), the result will be UTF-8 encoded
as if copies of the byte strings were upgraded to UTF-8: for example,

0 will stay byte-encoded.

instead of the character length. For that use either the
0 function or the 0 pragma
and the 0 function:

For example,

"process the string character per character".  Without that, the
0 would work in 0 mode (the default if the format
string starts with 0) and it would return the bytes making up the UTF-8
encoding of the target string, something that will always work.

Normally, you shouldn't need to.

are for characters, and binary data are not "characters", so converting
"data" into some encoding isn't meaningful unless you know in what
character set and encoding the binary data is in, in which case it's
not just binary data, now is it?

interpreted via a particular encoding, you can use 0:

material about the nature of the string has changed as far as Perl is
concerned.  Both before and after the call, the string 0
contains just a bunch of 8-bit bytes. As far as Perl is concerned,
the encoding of the string remains as "system-native 8-bit bytes".

Perl doesn't know any more after the call than before that the
contents of the string indicates the affirmative.

native 8-bit encoding (e.g. Latin-1, EBCDIC, etc.), you can use
pack/unpack to convert to/from Unicode.

but Perl doesn't know it yet, you can make Perl a believer, too:

0

are treated as Unicode; those below 256, generally as locale.  This
works reasonably well except in some case-insensitive regular expression
pattern matches that in Unicode would cross the 255/256 boundary.  These
are disallowed.
Also, the 0 and 0 constructs silently assume Unicode values
even for code points below 256.
See also 0 for the
description of the 0 switch and its environment counterpart,
0 to see how to enable various Unicode features,
for example by using locale settings.

that more clearly shows the division of Unicode into blocks of 256 characters.
Hexadecimal is also simply shorter than decimal.  You can use decimal
notation, too, but learning to use hexadecimal just makes life easier
with the Unicode standard.  The 0 notation uses hexadecimal,
for example.

a-f (or A-F, case doesn't matter).  Each hexadecimal digit represents
four bits, or half a byte.  0 will show a
hexadecimal number in decimal, and 0 will
show a decimal number in hexadecimal.  If you have just the
"hex digits" of a hexadecimal number, you can use the 0 function.

give a much more in depth treatment of Unicode:
0

0

the 0 module.

do some Unicode processing by using the modules 0,
0, and 0, available from CPAN.
If you have the GNU recode installed, you can also use the
Perl front-end 0 for character conversions.

to UTF-8 bytes and back, the code works even with older Perl 5 versions.

0, 0, 0, 0,
0

perl-unicode@perl.org, linux-utf8@nl.linux.org, and unicore@unicode.org
mailing lists for their valuable feedback.

=encoding utf8

modern programs need to be capable of communicating funny accented letters, and
things like euro symbols. This means that programmers need new habits. It's
easy to program Unicode capable software, but it does require discipline to do
it right.

best to spend a full day learning all this, but the basics can be learned in
minutes.

know the difference between bytes and characters, and realise (and accept!)
that there are many different character sets and encodings, and that your
program has to be explicit about them. Recommended reading is "The Absolute
Minimum Every Software Developer Absolutely, Positively Must Know About Unicode
and Character Sets (No Excuses!)" by Joel Spolsky, at
0.

of the wealth of character string related features that Perl has to offer. For
most projects, this information will probably suffice.

part of this tutorial. This view may conflict with other information that you
may have found on the web, but that's mostly because many sources are wrong.

value of a character is called a 0.   (But in practice, the
distinction between code point and character is blurred, so the terms often
are used interchangeably.)

room for only 256 values.  Unicode has many more characters than that,
so you need a method to make these accessible.

most used. In a Unicode encoding, multiple subsequent bytes can be used to
store a single code point, or simply: character.

the same thing, but they're not. There are more Unicode encodings, but much of
the world has standardized on UTF-8.

only one byte per character. All other characters are encoded as two or more
(up to six) bytes using a complex scheme. Fortunately, Perl handles this for
us, so we don't have to worry about this.

irrelevant here, and so are encodings. Each character is just that: the
character.

point.

characters, just bytes. All communication with the outside world (anything
outside of your current Perl process) is done in binary.

you have to supply the target encoding, for example 0 or 0.
Some encodings, like the 0 ("latin") range, do not support the full
Unicode standard; characters that can't be represented are lost in the
conversion.

know what encoding was used during the encoding phase. And most of all, it must
be something decodable. It doesn't make much sense to decode a PNG image into a
text string.

so it can store them in memory. All text strings are in this internal format.
In fact, text strings are never in any other format!

automatically done when you decode or encode.

it to a text string, of course. But in all other cases, you should decode it.

you get to choose, it's a good idea to standardize on UTF-8.

using characters instead of bytes. That's very useful if you use things like
0, or 0.

Perl has its internal encoding to store the string in memory, but ignore that.
If you have to do anything with the number of bytes, it's probably best to move
that part to step 3, just after you've encoded the string. Then you know
exactly how many bytes it will be in the destination string.

for that. Because 0 is now a byte string, 0 will report the
number of bytes, instead of the number of characters. The number of
characters is no longer known, because characters only exist in text strings.

which character encoding you used, please help the receiving end by using that
feature! For example, E-mail and HTTP support MIME headers, so you can use the
0 header. They can also have 0 to indicate the
number of 0, which is always a good idea to supply if the number is
known.

data.)

Amsterdam Perl Mongers meetings got me interested and determined to find out
how to use character encodings in Perl in ways that don't break easily.

Perl Workshop 2006) inspired me to publish my thoughts and write this tutorial.

channels, and have constantly reminded me that a simpler explanation was
needed.

They are: Benjamin Smith, Jan-Pieter Cornet, Johan Vromans, Lukas Mai, Nathan
Gray.

=encoding utf8

range of utilities on your system. There are also several utilities
which are used by the Perl distribution itself as part of the install
process. This document exists to list all of these utilities, explain
what they are for and provide pointers to each module's documentation,
if appropriate.

if you're reading this, it's more than likely that you've already found
it. 0 will extract and format the documentation from any file
in the current directory, any Perl module installed on the system, or
any of the standard documentation pages, such as this one. Use
C<perldoc 0name0 to get information on any of the utilities
described in this document.

translate POD (Plain Old Documentation - see 0 for an
explanation) into a manpage, and then run 0 to display it; if
0 isn't available, 0 will be used instead and the output
piped through your favourite pager.

produce HTML pages from POD, and 0, which produces LaTeX
files.

0 will just extract the "USAGE" section; some of
the utilities will automatically call 0 on themselves when
you call them with 0.

named sections from documents written in POD. For instance, while
utilities have "USAGE" sections, Perl modules usually have "SYNOPSIS"
sections: 0 will extract this section for
a given file.

utility will look for errors in your markup.

to it, and it'll explain it for you.

the 0 directory of your Perl source kit; it converts all the
documentation from the distribution to 0 format, and produces a
typeset PostScript or text file of the whole lot.

conversion filters:

on the simple 0 script 0 will produce a Perl program
based around this code:

on 0 will produce a Perl program based around this:

Perl.

use the 0 module. As an example,
0 produces the following callback
subroutine for 0:

0 utility will help you convert old-style Perl 4 libraries to
new-style Perl5 modules.

configuration files for features and config data.

the Perl version it was built under.  It can be used after running 0 (or your platform's equivalent procedure) to verify that perl
and its libraries have been installed correctly.

and in particular, extending Perl with C.

itself or any of the standard library modules back to the developers;
please read through the documentation for 0 thoroughly before
using it to submit a bug report.

authors and maintainers of perl. It's just 0 installed under
another name.

programmers used to get library constants by reading through the C
header files. You may still see 0 or similar
around - the 0 file should be created by running 0 on the
corresponding 0 file. See the 0 documentation for more on how
to convert a whole bunch of header files at once.

differently depending on how they are called, provide another way of
getting at C with Perl - they'll convert C structures and union declarations
to Perl code. This is deprecated in favour of 0 these days.

as much glue between C libraries and Perl modules as it can. It's also
very useful for creating skeletons of pure Perl modules.

Unicode Character Mapping files (.ucm) or Tcl Encoding Files (.enc).
Besides being used internally during the build process of the Encode
module, you can use 0 to add your own encoding to perl.
No knowledge of XS is necessary.

It is typically run by the makefiles created by 0.

necessary to let C functions manipulate Perl values and creates the glue
necessary to let Perl access those functions.

0 utility analyzes the output of this profiler and tells you
which subroutines are taking up the most run time. See 0
for more information.

of 0.  It's an alternative to 0.

were shipped with given versions of perl.

came along modules included in the perl distribution.

widely available for various Unixen today.  This script was primarily a
technology demonstrator for Perl 5.8.0, but you can use piconv in the
place of iconv for virtually any case.

archive and an unextracted one. (Note that this utility requires the
0 module to function properly; this module isn't distributed
with perl, but is available from the CPAN.)

in a tar archive.

or verify SHA checksums.

distribution.

modules or distributions from CPAN, or just get information about them, and
a lot more.  It is similar to the command line mode of the 0 module,

the 0 module as a back-end. It can be used interactively or
imperatively.

modules, then suitable for your package manager of choice. Support for
specific formats are available from CPAN as 0 modules.

validate your packlists and even create a tarball from an installed module.

0, 0, 0,
0, 0, 0,
0, 0, 0, 0,
0, 0, 0,
0, 0, 0, 0,
0, 0, 0, 0, 0, 0,
0, 0, 0, 0, 0, 0,
0

=encoding utf8

must begin with a letter or underscore, in which case they can be
arbitrarily long (up to an internal limit of 251 characters) and
may contain letters, digits, underscores, or the special sequence
0 or 0. In this case, the part before the last 0 or
0 is taken to be a 0; see 0.

punctuation or control character. These names are all reserved for
special uses by Perl; for example, the all-digits names are used
to hold data captured by backreferences after a regular expression
match. Perl has a special syntax for the single-control-character
names: It understands 0 (caret 0) to mean the control-0
character. For example, the notation 0 (dollar-sign caret
0) is the scalar variable whose name is the single character
control-0. This is better than typing a literal control-0
into your program.

strings that begin with control characters (or better yet, a caret).
These variables must be written in the form 0; the braces
are not optional. 0 denotes the scalar variable whose
name is a control-0 followed by two 0's. These variables are
reserved for future special uses by Perl, except for the ones that
begin with 0 (control-underscore or caret-underscore). No
control-character name that begins with 0 will acquire a special
meaning in any future version of Perl; such names may therefore be
used safely in programs. 0 itself, however, 0 reserved.

punctuation characters are exempt from the effects of the 0
declaration and are always forced to be in package 0; they are
also exempt from 0 errors. A few other names are also
exempt in these ways:

to be in package 0, regardless of any 0 declarations
presently in scope.

names have reasonable mnemonics, or analogs in the shells.
Nevertheless, if you wish to use long variable names, you need only say:

names in the current package. Some even have medium names, generally
borrowed from 0. To avoid a performance hit, if you don't need the
0, 0, or 0 it's best to use the 0
module without them:

first list the variables in case-insensitive, almost-lexigraphical
order (ignoring the 0 or 0 preceding words, as in 0
or 0), although 0 and 0 move up to the top of the pile.
For variables with the same identifier, we list it in order of scalar,
array, hash, and bareword.

0 0

equivalent:

hex, int, lc, lcfirst, length, log, lstat, mkdir, oct, ord, pos, print,
quotemeta, readlink, readpipe, ref, require, reverse (in scalar context only),
rmdir, sin, split (on its second argument), sqrt, stat, study, uc, ucfirst,
unlink, unpack.

See 0

when used without an 0 operator.

variable is supplied.

operation's result is tested by itself as the sole criterion of a 0
test. Outside a 0 test, this will not happen.

side-effects. As of perl 5.9.1, you can now use a lexical version of
0 by declaring it in a file or in a block with 0. Moreover,
declaring 0 restores the global 0 in the current scope.

0 0

that subroutine. Inside a subroutine, 0 is the default array for
the array operators 0, 0, 0, and 0.

0 0

string or a similar context such as 0, its elements are
separated by this value. Default is a space. For example, this:

0 0 0

consider this variable read-only, although it will be altered
across 0 calls.

0 return different values from different threads. In order to
be portable, this behavior is not reflected by 0, whose value remains
consistent across threads. If you want to call the underlying 0,
you may use the CPAN module 0.

0 0 0

membership in multiple groups simultaneously, gives a space separated
list of groups you are in. The first number is the one returned by
0, and the subsequent ones by 0, one of which may be
the same as the first number.

set the real gid. So the value given by 0 should 0 be assigned
back to 0 without being forced numeric, such as by adding zero. Note
that this is different to the effective gid (0) which does take a
list.

time by using 0. Changes to 0 require a check to 0
to detect any possible errors after an attempted change.

group you 0, if you're running setgid.

0 0 0

supports membership in multiple groups simultaneously, gives a space
separated list of groups you are in. The first number is the one
returned by 0, and the subsequent ones by 0,
one of which may be the same as the first number.

list of numbers. The first number sets the effective gid, and
the rest (if any) are passed to 0. To get the effect of an
empty list for 0, just repeat the new effective gid; that is,
to force an effective gid of 5 and an effectively empty 0
list, say 0.

time by using 0 (use only a single numeric argument).
Changes to 0 require a check to 0 to detect any possible errors
after an attempted change.

machines that support the corresponding 0 routine. 0
and 0 can be swapped only on machines supporting 0.

is the group that's 0 for you, if you're running setgid.

0 0

the argument area that the 0 program sees. On some platforms you
may have to use special 0 options or a different 0 to see the
changes. Modifying the 0 is more useful as a way of indicating the
current program state than it is for hiding the program you're
running.

length of 0. In the most extreme case it may be limited to the
space occupied by the original 0.

example space characters, after the modified name as shown by 0.
In some platforms this padding may extend all the way to the original
length of the argument area, no matter what you do (this is the case
for example with Linux 2.2).

from the  output. For example, setting 0 to 0 may
result in 0 (whether both the 0 prefix
and the " (perl)" suffix are shown depends on your exact BSD variant
and version). This is an operating system feature, Perl cannot help it.

thread may modify its copy of the 0 and the change becomes visible
to  (assuming the operating system plays along). Note that
the view of 0 the other threads have will not change since they
have their own copies of it.

0 will contain the string 0.

0, in addition to altering the POSIX name via 0 as
perl has done since version 4.000. Now system utilities that read the
legacy process name such as ps, top and killall will recognize the
name you set when assigning to 0. The string you supply will be
cut off at 16 bytes, this is a limitation imposed by Linux.

0 0 0

refer to a hash element as

binary data there might not be any safe value for 0.

in 0.

 0 0

effective uid at the same time by using 0. Since
changes to  require a system call, check 0 after a change
attempt to detect any possible errors.

 0 0

time by using 0. Changes to  require a check
to 0 to detect any possible errors after an attempted change.

supporting 0.

0 0

Because of this specialness 0 and 0 don't need to be declared
(using 0, or 0) even when using the 0
pragma. Don't lexicalize them with 0 or 0 if you want to
be able to use them in the 0 comparison block or function.

0 0

Mainly of use with 0 to allow code to alter its behavior
when being compiled, such as for example to 0 at compile
time rather than normal, deferred loading. Setting
0 is similar to calling 0.

0 0

command-line equivalent, you can use numeric or symbolic values, eg
0 or 0.

0

the source code to Unicode. Thanks to this variable your Perl script
does not have to be written in UTF-8. Default is 0. The direct
manipulation of this variable is highly discouraged.

0

value in 0 changes the environment for any child processes
you subsequently 0 off.

0 0

descriptors are passed to 0ed processes, while higher file
descriptors are not. Also, during an 0, system file descriptors are
preserved even if the 0 fails (ordinary file descriptors are
closed before the 0 is attempted). The close-on-exec
status of a file descriptor will be decided according to the value of
0 when the corresponding file, pipe, or socket was opened, not the
time of the 0.

0

mode is turned on. See 0 for the 0 switch. This array
is package-specific, and must be declared or given a full package name
if not in package main when running under 0.

0

value is mostly there for completeness and for use via the
underlying C variable 0. It's not really possible for Perl
code to be executed unless construction of the interpreter is
finished.

0 block executed directly or indirectly from during the
compile-time of the top-level program.

0-blocks, as those are executed during compile-time of any
compilation unit, not just the top-level program. A new, localised
compile-time entered at run-time, for example by constructs as
0 are not global interpreter phases, and
therefore aren't reflected by 0.

those are run for each compilation unit individually, and therefore is
not a global interpreter phase.

transition from one phase to another can only happen in the order
described in the above list.

0

behavior, and contents are subject to change without notice.

end of compilation of a BLOCK the value of this variable is restored to the
value when the interpreter started to compile the BLOCK.

(e.g., eval body, required file, subroutine body, loop body, or conditional
block), the existing value of 0 is saved, but its value is left unchanged.
When the compilation of the block is completed, it regains the saved value.
Between the points where its value is saved and restored, code that
executes within BEGIN blocks is free to change the value of 0.

for instance, the 0 pragma.

different pragmatic flags. Here's an example:

the BEGIN block has already been compiled, but the body of 0 is still
being compiled. The new value of 0 will therefore be visible only while
the body of 0 is being compiled.

version of the same lexical pragma:

0

useful for implementation of lexically scoped pragmas. See 0.

0

0, or 0 constructs look for their library files. It
initially consists of the arguments to any 0 command-line
switches, followed by the default Perl library, probably
0, followed by ".", to represent the current
directory. ("." will not be appended if taint checks are enabled,
either by 0 or by 0.)  If you need to modify this at runtime,
you should use the 0 pragma to get the machine-dependent
library properly loaded also:

code directly into 0. Those hooks may be subroutine references, array
references or blessed objects. See 0 for details.

0

0, 0, or 0 operators. The key is the filename
you specified (with module names converted to pathnames), and the
value is the location of the file found. The 0
operator uses this hash to determine whether a particular file has
already been included.

0 for a description of these hooks), this hook is
by default inserted into 0 in place of a filename. Note, however,
that the hook may have set the 0 entry by itself to provide some more
specific info.

0 0

inplace editing.

0

However, if suitably built, Perl can use the contents of 0
as an emergency memory pool after 0ing. Suppose that your Perl
were compiled with 0 and used Perl's malloc.
Then

0 file in the Perl distribution for information on how to
add custom C compilation flags when compiling perl. To discourage casual
use of this advanced feature, there is no 0 long name for
this variable.

0 0

built, as determined during the configuration process. For examples
see 0.

and the 0 command-line switch documented in 0.

0, it doesn't tell the difference between
95/98/ME/NT/2000/XP/CE/.NET. Use 0 or
Win32:: (see 0 and 0) to distinguish
between the variants.

0

by a 0 byte, the first part describes the input layers, the second
part describes the output layers.

0 0

various bits are subject to change, but currently indicate:

statement executed. Also causes saving source code lines (like 0x400).

were compiled.

run-time only. This is a new mechanism and the details may change.
See also 0.

0

signal, except for the 0 signal. See 0 for more about
this special case.

lest you inadvertently call it.

are installed using it. This means you get reliable signal handling.

immediate (also known as "unsafe") to deferred, also known as "safe
signals". See 0 for more information.

routine indicated by 0 is called when a warning
message is about to be printed. The warning message is passed as the
first argument. The presence of a 0 hook causes the
ordinary printing of warnings to 0 to be suppressed. You can
use this to save warnings in a variable, or turn warnings into fatal
errors, like this:

disable warnings using the empty subroutine:

exception is about to be thrown. The error message is passed as the
first argument. When a 0 hook routine returns, the exception
processing continues as it would have in the absence of the hook,
unless the hook routine itself exits via a 0, a loop exit, or a
0. The 0 handler is explicitly disabled during the
call, so that you can die from a 0 handler. Similarly for
0.

even inside an 0. Do not use this to rewrite a pending
exception in 0, or as a bizarre substitute for overriding
0. This strange action at a distance may be fixed
in a future release so that 0 is only called if your
program is about to exit, as was the original intent. Any other use is
deprecated.

may be called to report (probable) errors found by the parser. In such
a case the parser may be in inconsistent state, so any attempt to
evaluate Perl code from such a handler will probably result in a
segfault. This means that warnings or errors that result from parsing
Perl should be used with extreme caution, like this:

called the handler. The second line will print backtrace and die if
0 was available. The third line will be executed only if 0 was
not available.

handlers is simply wrong. 0 as currently implemented
invites grievous and difficult to track down errors. Avoid it
and use an 0 or CORE::GLOBAL::die override instead.

0 for additional information.

0 0

epoch (beginning of 1970). The values returned by the 0, 0,
and 0 filetests are based on this value.

0

0), 0 for off, -1 when only taint warnings are enabled (i.e. with
0 or 0).

0

documentation for the 0 switch for more information about
the possible values.

0

1 for on (the default), 0 for off, -1 to debug the caching code by checking
all its results against linear scans, and panicking on any discrepancy.

0

startup. This information is used by perl when it's in
adjust-utf8ness-to-locale mode (as when run with the 0 command-line
switch); see 0 for more info on this.

0 0

represented as a 0 object.

will see an undefined value. Before perl 5.10.0 0 was represented
as a v-string.

a script is in the right range of versions. For example:

0 conversion:

for a convenient way to fail if the running Perl interpreter is too old.

0 0 0

not try to open the file. This means that the link count cannot be
determined and file attributes may be out of date if additional
hardlinks to the file exist. On the other hand, not opening the file
is considerably faster, especially for files on network drives.

configure the local Perl installation to use "sloppy" 0 by
default. See the documentation for 0 in
0 for more information about site
customization.

0 0

0 or (where supported) 0.

a relative or absolute pathname of the perl program file, or may
be the string used to invoke perl but not the pathname of the
perl program file. Also, most operating systems permit invoking
programs that are not in the PATH environment variable, so there
is no guarantee that the value of 0 is in PATH. For VMS, the
value may or may not include a version number.

copy of the same perl that is currently running, e.g.,

capturing of the output of commands, so this complex statement
may not be portable.

as some operating systems that have a mandatory suffix on
executable files do not require use of the suffix when invoking
a command. To convert the value of 0 to a path name, use the
following statements:

the Perl program file to make a copy of it, patch the copy, and
then execute the copy, the security-conscious Perl programmer
should take care to invoke the installed copy of perl, not the
copy referenced by 0. The following statements accomplish
this goal, and produce a pathname that can be invoked as a
command or referenced as a file.

effects. Perl sets these variables when it has a successful match, so
you should check the match result before using them. For instance:

otherwise.

their value is limited to the block that they are in, as demonstrated
by this bit of code:

and 0 are from the match against 0. Inside the 0
block, the values of 0 and 0 are from the match against
0, but only until the end of the block (i.e. the dynamic
scope). After the 0 block completes, the values of 0 and
0 return to the values for the match against 0 imposes a considerable performance penalty on all regular
expression matches in a program because it uses the 0, 0, and
0, regardless of whether they occur in the scope of 0. For that reason, saying 0 in libraries is
strongly discouraged unless you import it without the match variables:

modules can help you find uses of these
problematic match variables in your code.

0, 0, and 0 variables instead
so you only suffer the performance penalties.

0 0 0

parentheses from the last successful pattern match, not counting patterns
matched in nested blocks that have been exited already.

0 0

any matches hidden within a BLOCK or 0 enclosed by the current
BLOCK).

performance penalty on all regular expression matches. To avoid this
penalty, you can extract the same substring by using 0. Starting
with Perl 5.10, you can use the </p> match flag and the 0
variable to do the same thing for particular match operations.

0

performance penalty associated with that variable, and is only guaranteed
to return a defined value when the pattern was compiled or executed with
the 0 modifier.

0 0 0

pattern match, not counting any matches hidden within a BLOCK or 0
enclosed by the current BLOCK.

performance penalty on all regular expression matches. To avoid this
penalty, you can extract the same substring by using 0. Starting
with Perl 5.10, you can use the </p> match flag and the
0 variable to do the same thing for particular match
operations.

0 0

performance penalty associated with that variable, and is only guaranteed
to return a defined value when the pattern was compiled or executed with
the 0 modifier.

0 0 0 0

pattern match (not counting any matches hidden within a BLOCK or 0
enclosed by the current BLOCK). Example:

performance penalty on all regular expression matches.
To avoid this penalty, you can extract the same substring by
using 0. Starting with Perl 5.10, you can use the </p> match flag
and the 0 variable to do the same thing for particular
match operations.

0 0 0

performance penalty associated with that variable, and is only guaranteed
to return a defined value when the pattern was compiled or executed with
the 0 modifier.

0 0

This is useful if you don't know which one of a set of alternative patterns
matched. For example:

0 0

with the rightmost closing parenthesis) of the last successful search
pattern.

recently matched. For example, to effectively capture text to a variable
(in addition to 0, 0, etc.), replace 0 with

worry about exactly which numbered set of parentheses they are.

0 0

submatches in the currently active dynamic scope. 0 is
the offset into the string of the end of the entire match. This
is the same value as what the 0 function returns when called
on the variable that was matched against. The 0th element
of this array holds the offset of the 0th submatch, so
0 is the offset past where 0 ends, 0 the offset
past where 0 ends, and so on. You can use 0 to determine
how many subgroups were in the last successful match. See the
examples given for the 0 variable.

0 0

buffers, should they exist, in the last successful match in the
currently active dynamic scope.

captured (and that are thus associated to defined values).

0 module.

associated with the last successful regular expression. Therefore mixing
iterative access to them via 0 may have unpredictable results.
Likewise, if the last successful match changes, then the results may be
surprising.

0 0

000 is the offset of the start of the substring matched by
0. Similarly,  coincides with 0 if 0 is defined, and $+ coincides with
0. One can use 0 to find the last
matched subgroup in the last successful match. Contrast with
0, the number of subgroups in the regular expression. Compare
with 0.

successful submatches in the currently active dynamic scope.
0 is the offset into the string of the beginning of the
entire match. The 0th element of this array holds the offset
of the 0th submatch, so 0 is the offset where 0
begins, 0 the offset where 0 begins, and so on.

0 0

in the last successful match in the currently active dynamic scope. To
each capture group name found in the regular expression, it associates a
reference to an array containing the list of values captured by all
buffers with that name (should there be several of them), in the order
where they appear.

the regular expression.

0 module.

associated with the last successful regular expression. Therefore mixing
iterative access to them via 0 may have unpredictable results.
Likewise, if the last successful match changes, then the results may be
surprising.

0 0

regular expression assertion (see 0). May be written to.

0

even when the 0 module is loaded. See 0 for details.

0

utilize. This value by default is 65536 which corresponds to a 512kB temporary
cache. Set this to a higher value to trade memory for speed when matching
large alternations. Set it to a lower value if you want the optimisations to
be as conservative of memory as possible but still occur, and set it to a
negative value to prevent the optimisation and conserve the most memory.
Under normal situations this variable should be of no interest to you.

by calling an appropriate object method on the 0 object,
although this is less efficient than using the regular built-in
variables. (Summary lines below for this contain the word HANDLE.)
First you must say

methods each take an optional EXPR, which, if supplied, specifies the
new value for the 0 attribute in question. If not
supplied, most methods do nothing to the current value--except for
0, which will assume a 1 for you, just to be different.

you should learn how to use the regular built-in variables.

if you try to assign to this variable, either directly or indirectly
through a reference, you'll raise a run-time exception.

special variables described in this document. In most cases you want
to localize these variables before changing them, since if you don't,
the change may affect other modules which rely on the default values
of the special variables that you have changed. This is one of the
correct ways to read the whole file at once:

default "line mode", so if the code we have just presented has been
executed, the global value of 0 is now changed for any other code
running inside the same Perl interpreter.

change affects the shortest scope possible. So unless you are already
inside some short 0 block, you should create one yourself. For
example:

first. The value you set in  0 is still there when you
return. The fix is to add 0 so the value doesn't leak out of
0:

complicated code you are looking for trouble if you don't localize
changes to the special variables.

0

0

the script. 0 is generally the number of arguments minus
one, because 0 is the first argument, 0 the program's
command name itself. See 0 for the command name.

0

0. Usually written as the null filehandle in the angle operator
. Note that currently 0 only has its magical effect
within the  operator; elsewhere it is just a plain filehandle
corresponding to the last file opened by . In particular,
passing 0 as a parameter to a function that expects a filehandle
may not cause your function to automatically read the contents of all the
files in 0.

0

when doing edit-in-place processing with 0. Useful when you have
to do a lot of inserting and don't want to keep modifying 0. See
0 for the 0 switch.

0 0 0

value is printed between each of print's arguments. Default is 0.

0 0 0 0

from it. (Depending on the value of 0, Perl's idea of what
constitutes a line may not match yours.)  When a line is read from a
filehandle (via 0 or ), or when 0 or
0 is called on it, 0 becomes an alias to the line counter
for that filehandle.

actually move the seek pointer. I<Localizing 0. Instead, it will localize perl's notion
of which filehandle 0 is currently aliased to.

filehandle is reopened without an intervening 0. For more
details, see L<perlop/"I0. Because  never does
an explicit close, line numbers increase across 0 files (but see
examples in 0).

line counter for a given filehandle without having to worry about
which handle you last accessed.

0 0 0

idea of what a "line" is. Works like 0's RS variable, including
treating empty lines as a terminator if set to the null string (an
empty line cannot contain any spaces or tabs). You may set it to a
multi-character string to match a multi-character terminator, or to
0 to read through the end of file. Setting it to 0
means something slightly different than setting to 0, if the file
contains consecutive empty lines. Setting to 0 will treat two or
more consecutive empty lines as a single empty line. Setting to
0 will blindly assume that the next input character belongs to
the next paragraph, even if it's a newline.

be better for something. :-)

integer, or scalar that's convertible to an integer will attempt to
read records instead of lines, with the maximum record size being the
referenced integer. So this:

not reading from a record-oriented file (or your OS doesn't have
record-oriented files), then you'll likely get a full chunk of data
with every read. If a record is larger than the record size you've
set, you'll get the record back in pieces. Trying to set the record
size to zero or less will cause reading in the (rest of the) whole file.

so it's best not to mix record and non-record reads on the same
file. (This is unlikely to be a problem, because any file you'd
want to read in record mode is probably unusable in line mode.)
Non-VMS systems do normal I/O, so it's safe to mix record and
non-record reads of a file.

0 0 0

value is printed after the last of print's arguments. Default is 0.

Also, it's just like 0, but it's what you get "back" from Perl.

0 0 0 0

print on the currently selected output channel. Default is 0
(regardless of whether the channel is really buffered by the system or
not; 0 tells you only whether you've asked Perl explicitly to
flush after each write). STDOUT will typically be line buffered if
output is to the terminal and block buffered otherwise. Setting this
variable is useful primarily when you are outputting to a pipe or
socket, such as when you are running a Perl program under 0 and
want to see the output as it's happening. This has no effect on input
buffering. See 0 for that. See 0 on
how to select the output channel. See also 0.

filehandles. See 0 for more information about Perl's
formats.

0 0

A format contains 0 calls that put their result into
0. After calling its format, 0 prints out the contents
of 0 and empties. So you never really see the contents of 0
unless you call 0 yourself and then look at it. See
0 and 0.

0 0

0 0

0 0

channel.

0 0

fill continuation fields (starting with 0) in a format. The default is
0, to break on a space, newline, or a hyphen.

0 0

output channel. The default is 60.

0 0

output channel. The default is the name of the filehandle with 0
appended. For example, the default format top name for the 0
filehanlde is 0.

0 0

output channel. The default format name is the same as the filehandle
name. For example, the default format name for the 0
filehandle is just 0.

0 0

about different types of error conditions that may appear during
execution of a Perl program. The variables are shown ordered by
the "distance" between the subsystem which reported the error and
the Perl process. They correspond to errors detected by the Perl
interpreter, C library, operating system, or an external program,
respectively.

following Perl expression, which uses a single-quoted string. After
execution of this statement, perl may have set all four special error
variables:

0, , and 0 calls in the C run-time library
and thence to the operating system kernel. perl sets 0 to
the C library's 0 if one of these calls fails.

happen if 0 or 0 were imported with bad prototypes), or
if Perl code executed during evaluation 0d. In these cases the
value of 0 is the compile error, or the argument to 0 (which
will interpolate 0 and 0). (See also 0, though.)

indicator, such as in this case, "CDROM tray not closed." Systems that
do not support extended error messages leave 0 the same as 0.

0 fails. The upper eight bits reflect specific error
conditions encountered by the program (the program's 0 value).
The lower eight bits reflect mode of failure, like signal death and
core dump information. See 0 for details. In contrast to
0 and 0, which are set only if error condition is detected,
the variable 0 is set on each 0 or pipe 0,
overwriting the old value. This is more like 0, which on every
0 is always set on failure and cleared on success.

0, and 0.

0

command, successful call to 0 or 0, or from the
0 operator. On POSIX-like systems this value can be decoded
with the WIFEXITED, WEXITSTATUS, WIFSIGNALED, WTERMSIG, WIFSTOPPED,
WSTOPSIG and WIFCONTINUED functions provided by the 0 module.

same as 0 when the pragma 0 is in effect.

0 0

moment, this differs from 0 under only VMS, OS/2, and Win32 (and
for MacPerl). On all other platforms, 0 is always just the same
as 0.

error. This is more specific information about the last system error
than that provided by 0. This is particularly important when 0
is set to 0.

API either via CRT, or directly from perl.

by the Win32 call 0 which describes the last error
from within the Win32 API. Most Win32-specific code will report errors
via 0. ANSI C and Unix-like calls set 0 and so most
portable Perl code will report errors via 0.

0, also.

0 0

handlers.

0 0

used, false otherwise, but directly modifiable.

0

See the documentation of 0 for more details.

0 0 0

variable, or in other words, if a system or library call fails, it
sets this variable. This means that the value of 0 is meaningful
only 0 after a 0:

0. A successful system or library call does 0 set the
variable to zero.

can assign a number to 0 to set 0 if, for instance, you
want 0 to return the string for error 0, or you want to set
the exit value for the 0 operator.

0 0 0

value. For example, 0 is true if and only if the current
value of 0 is 0; that is, if the most recent error was "No
such file or directory" (or its moral equivalent: not all operating
systems give that exact error, and certainly not all languages). To
check if a particular key is meaningful on your system, use 0; for a list of legal keys, use 0. See 0
for more information, and also see 0.

0 0

successful call to 0 or 0, or from the 0
operator. This is just the 16-bit status word returned by the
traditional Unix 0 system call (or else is made up to look
like it). Thus, the exit value of the subprocess is really (C<<< $? >>
8 >>>), and 0 gives which signal, if any, the process died
from, and 0 reports whether there was a core dump.

is returned via 0 if any 0 function fails.

value of 0 will usually be wrong outside that handler.

given to 0. You can modify 0 in an 0 subroutine to
change the exit status of your program. For example:

actual VMS exit status, instead of the default emulation of POSIX
status; see 0 for details.

0 0

the null string, the last 0 parsed and executed correctly
(although the operations you invoked may have failed in the normal
fashion).

set up a routine to process warnings by setting 0 as
described in 0.

eventually remove the variable from the langauge. It may still be
available despite its status. Using a deprecated variable triggers
a warning.

the variable is unsupported.

0 0

After a deprecation cycle, its magic was removed in Perl 5.10 and
using it now triggers a warning: 0.

last index, like 0. That's still how you get the last index
of an array in Perl. The two have nothing to do with each other.

0

After a deprecation cycle, its magic was removed in Perl 5.10.
Using it now triggers a warning: 0.
You should use the 0 and 0 regexp modifiers instead.

0 0

of the first character in a substring. The default is 0, but you could
theoretically set it to 1 to make Perl behave more like 0 (or Fortran)
when subscripting and when evaluating the  and  functions.

directive, and cannot influence the behavior of any other file.
(That's why you can only assign compile-time constants to it.)
Its use is highly discouraged.

scopes in the same file, unlike other compile-time directives (such as
0). Using  on it would bind its value strictly to a lexical
block. Now it is always lexically scoped.

0 0

accurate string comparisons.

can be used to determine whether the Perl interpreter executing a
script is in the right range of versions:

numeric comparisons.

for a convenient way to fail if the running Perl interpreter is too old.

=encoding utf8

behavior on VMS.  They are a supplement to the regular Perl 5
documentation, so we have focussed on the ways in which Perl
5 functions differently under VMS than it does under Unix,
and on the interactions between Perl and the rest of the
operating system.  We haven't tried to duplicate complete
descriptions of Perl features from the main Perl
documentation, which can be found in the 0
subdirectory of the Perl distribution.

sleep when writing Perl scripts on VMS.  If you find we've
missed something you think should appear here, please don't
hesitate to drop a line to vmsperl@perl.org.

the file 0 in the main source directory of the
Perl distribution..

0 is an executable image which contains all of
the basic functionality of Perl, but cannot take advantage of
Perl extensions.  It is used to generate several files needed
to build the complete Perl and various extensions.  Once you've
finished installing Perl, you can delete this image.

0, which provides a core to which the Perl executable
image and all Perl extensions are linked.  You should place this
image in 0, or define the logical name 0 to
translate to the full file specification of this image.  It should
be world readable.  (Remember that if a user has execute only access
to 0, VMS will treat it as if it were a privileged shareable
image, and will therefore require all downstream shareable images to be
INSTALLed, etc.)

entry point for Perl, as well as some initialization code.  It
should be placed in a public directory, and made world executable.
In order to run Perl with command line arguments, you should
define a foreign command to invoke this image.

to add new functionality to perl.  (XS is a meta-language which
simplifies writing C code which interacts with Perl, see
0 for more details.)  The Perl code for an
extension is treated like any other library module - it's
made available in your script through the appropriate
0 or 0 statement, and usually defines a Perl
package containing the extension.

connected to the rest of Perl in either of two ways.  In the
0 configuration, the object code for the extension is
linked directly into 0, and is initialized whenever
Perl is invoked.  In the 0 configuration, the extension's
machine code is placed into a separate shareable image, which is
mapped by Perl's DynaLoader when the extension is 0d or
0d in your script.  This allows you to maintain the
extension as a separate entity, at the cost of keeping track of the
additional shareable image.  Most extensions can be set up as either
static or dynamic.

directory.  At least three files are generally provided:
00 (where 0 is the portion of
the extension's name following the last 0), containing
the XS code, 00, the Perl library module
for the extension, and 0, a Perl script which uses
the 0 library modules supplied with Perl to generate
a 0 file for the extension.

0, you'll have to rebuild Perl to incorporate a
new extension.  You should edit the main 0 or 0
you use to build Perl, adding the extension's name to the 0
macro, and the extension's object file to the 0 macro.
You'll also need to build the extension's object file, either
by adding dependencies to the main 0, or using a
separate 0 for the extension.  Then, rebuild
0 to incorporate the new code.

module to the 000 subdirectory under one
of the directories in 0, where 0 is the name
of the extension, with all 0 replaced by 0 (e.g.
the library module for extension Foo::Bar would be copied
to a 0 subdirectory).

a file named Makefile.PL, which is a Perl program which is used
to create a 0 file which can be used to build and
install the files required by the extension.  The kit should be
unpacked into a directory tree 0 under the main Perl source
directory, and the procedure for building the extension is simply

tested creates several levels (at least 4) under the
directory in which the extension's source files live.
For this reason if you are running a version of VMS prior
to V7.1 you shouldn't nest the source directory
too deeply in your directory structure lest you exceed RMS'
maximum of 8 levels of subdirectory in a filespec.  (You
can use rooted logical names to get another 8 levels of
nesting, if you can't place the files near the top of
the physical directory structure.)

is sufficient to handle most extensions.  However, it does
not yet recognize extra libraries required to build shareable
images which are part of an extension, so these must be added
to the linker options file for the extension by hand.  For
instance, if the 0 extension to Perl requires the
0 shareable image in order to properly link
the Perl extension, then the line 0 must
be added to the linker options file 0 produced
during the build process for the Perl extension.

the 00.00 directory of the
installed Perl directory tree (where 0 is 0 or
0, and 0 is the name of the extension, with
each 0 translated to 0).  (See the MakeMaker documentation
for more details on installation options for extensions.)
However, it can be manually placed in any of several locations:

of one of the directories in 0 (where 0
is the version of Perl you're using, as supplied in 0,
with '.' converted to '_'), or

passes to the DynaLoader when asking it to map
the shareable image, or

to define a logical name 0, where 0
is the portion of the extension's name after the last 0, which
translates to the full file specification of the shareable image.

specifications wherever possible.  You may use either style, or both,
on the command line and in scripts, but you may not combine the two
styles within a single file specification.  VMS Perl interprets Unix
pathnames in much the same way as the CRTL (0 the first component
of an absolute path is read as the device name for the VMS file
specification).  There are a set of functions provided in the
0 package for explicit interconversion between VMS and
Unix syntax; its documentation provides more details.

modules on Unix syntax, but you may find that some of these,
as well as some scripts written for Unix systems, will
require that you use Unix syntax, since they will assume that
'/' is the directory separator, 0  If you find instances
of this in the Perl distribution itself, please let us know,
so we can try to work around them.

in a specific operating system format, then you need either to
check the appropriate DECC$ feature logical, or call a conversion
routine to force it to that format.

Perl behavior in the conversion of file specifications from Unix to VMS
format in order to follow the extended character handling rules now
expected by the CRTL.  Specifically, when this feature is in effect, the
0 in a Unix path is now translated to 0 instead of
the traditional VMS 0.  To be compatible with what MakeMaker
expects, if a VMS path cannot be translated to a Unix path, it is
passed through unchanged, so 0 will return 0.

VMS-specific C infrastructure of Perl, but more work is still needed to
fully support extended syntax filenames in several core modules.  In
particular, at this writing PathTools has only partial support for
directories containing some extended characters.

determine whether an input filename is in Unix format or in VMS format,
since now both VMS and Unix file specifications may have characters in
them that could be mistaken for syntax delimiters of the other type. So
some pathnames simply cannot be used in a mode that allows either type
of pathname to be present.  Perl will tend to assume that an ambiguous
filename is in Unix format.

determining whether a pathname is in VMS format or in Unix format with
extended file syntax.  There is no way to know whether "perl-5.8.6" is a
Unix "perl-5.8.6" or a VMS "perl-5.8;6" when passing it to  or
.

filenames to the extent that Perl uses the CRTL internally for many
purposes, and attempts to follow CRTL conventions for reporting
filenames.  The DECC feature differs in that it
expects all filenames passed to the C run-time to be already in Unix
format.  This feature is not yet supported in Perl since Perl uses
traditional OpenVMS file specifications internally and in the test
harness, and it is not yet clear whether this mode will be useful or
useable.  The feature logical name DECC is new
with the RMS Symbolic Link SDK and included with OpenVMS v8.3, but is
not yet supported in Perl.

preserving) filename case.  Case is not preserved on ODS-2 formatted
volumes on any architecture.  On ODS-5 volumes, filenames may be case
preserved depending on process and feature settings.  Perl now honors
DECC and DECC on those systems where
the CRTL supports these features.  When these features are not enabled
or the CRTL does not support them, Perl follows the traditional CRTL
behavior of downcasing command-line arguments and returning file
specifications in lower case only.

programs, external utilities, and Perl scripts that are in varying
states of being able to handle case preservation.  For example, a file
created by an older version of an archive utility or a build utility
such as MMK or MMS may generate a filename in all upper case even on an
ODS-5 volume.  If this filename is later retrieved by a Perl script or
module in a case preserving environment, that upper case name may not
match the mixed-case or lower-case exceptions of the Perl code.  Your
best bet is to follow an all-or-nothing approach to case preservation:
either don't use it at all, or make sure your entire toolchain and
application environment support and use it.

case sensitivity as a process setting (see 0). Perl does not currently support case
sensitivity on VMS, but it may in the future, so Perl programs should
use the  method to determine the state, and
not the 0 variable.

default supports symbolic links when the requisite support is available
in the filesystem and CRTL (generally 64-bit OpenVMS v8.3 and later).
There are a number of limitations and caveats to be aware of when
working with symbolic links on VMS.  Most notably, the target of a valid
symbolic link must be expressed as a Unix-style path and it must exist
on a volume visible from your POSIX root (see the 0 command
in DCL help).  For further details on symbolic link capabilities and
requirements, see chapter 12 of the CRTL manual that ships with OpenVMS
v8.3 or later.

the command line and within Perl globs (e.g. C<0*.c0).  If
the wildcard filespec uses VMS syntax, the resultant
filespecs will follow VMS syntax; if a Unix-style filespec is
passed in, Unix-style filespecs will be returned.
Similar to the behavior of wildcard globbing for a Unix shell,
one can escape command line wildcards with double quotation
marks 0 around a perl program command line argument.  However,
owing to the stripping of 0 characters carried out by the C
handling of argv you will need to escape a construct such as
this one (in a directory containing the files 0, 0,
0, and 0):

to 0 VMS wildcard expansion is performed. (csh-style
wildcard expansion is available if you use 0.)
If the wildcard filespec contains a device or directory
specification, then the resultant filespecs will also contain
a device and directory; otherwise, device and directory
information are removed.  VMS-style resultant filespecs will
contain a full device and directory, while Unix-style
resultant filespecs will contain only as much of a directory
path as was present in the input filespec.  For example, if
your default directory is Perl_Root:[000000], the expansion
of 0 will yield filespecs  like
"perl_root:[t]base.dir", while the expansion of 0 will
yield filespecs like "t/base.dir".  (This is done to match
the behavior of glob expansion performed by Unix shells.)

only if one was present in the input filespec.

"file name" is passed to  for asynchronous
execution.  You should be careful to close any pipes you have
opened in a Perl script, lest you leave any "orphaned"
subprocesses around when Perl exits.

output is used as the return value of the expression.  The
string between the backticks is handled as if it were the
argument to the 0 operator (see below).  In this case,
Perl will wait for the subprocess to complete before continuing.

defaults to a buffer size of 8192 on 64-bit systems, 512 on VAX.  The
default buffer size is adjustable via the logical name PERL_MBX_SIZE
provided that the value falls between 128 and the SYSGEN parameter
MAXBUF inclusive.  For example, to set the mailbox size to 32767 use
0 and then open and use pipe constructs.
An alternative would be to issue the command:

improve performance at the expense of the BYTLM UAF quota.

except that the element separator is '|' instead of ':'.  The
directory specifications may use either VMS or Unix syntax.

separate X-11 terminal window so that commands and output from multiple
processes are not mixed together.

run on a VMS system that has X11 support installed.

X-11 Server and some environment variables set that Unix expects.

and the environment variable 0 to exist.  0 must be in
lower case.

to be the hostname of the display, the server and screen in Unix notation.  In
the future the value of DISPLAY may be honored by Perl instead of using the
default display.

separated from debugger I/O.  You can force the debugger to be forked by
assigning a value to the logical name <PERLDB_PIDS> that is not a process
identification number.

debugger to be invoked if a fatal exception that is not otherwise
handled is raised.  The purpose of this is to allow debugging of
internal Perl problems that would cause such a condition.

find out the cause of the exception.  As the debugger is being invoked as
the Perl interpreter is about to do a fatal exit, continuing the execution
in debug mode is usally not practical.

profile in a way that such problems are not reproduced.

a program.

name is actually checked in a case insensitive mode, and it is considered
enabled if it is the value "T","1" or "E".

command line, using a subset of Bourne shell syntax:

character '|'.  Anything after this character on the command
line is passed to a subprocess for execution; the subprocess
takes the output of Perl as its input.

command is run in the background as an asynchronous
subprocess.

VMS than described in 0.  Note also that in order
to pass uppercase switches to Perl, you need to enclose
them in double-quotes on the command line, since the CRTL
downcases all unquoted strings.

controls if the quoting is needed to preserve the case of
command line arguments.

copy is given, then inplace editing creates a new version of
a file; the existing copy is not deleted.  (Note that if
an extension is given, an existing file is renamed to the backup
file, as is the case under other operating systems, so it does
not remain as a previous version under the original filename.)

name does not contain a directory, then Perl translates the
logical name DCL as a searchlist, using each translation
as a directory in which to look for the script.  In addition,
if no file type is specified, Perl looks in each directory
for a file matching the name specified, with a blank type,
a type of 0, and a type of 0, in that order.

after the Perl program is compiled, but before it has
run.  It does not create a core dump file.

Perl functions were implemented in the VMS port of Perl
(functions marked with * are discussed in more detail below):

and calling them produces a fatal error (usually) or
undefined behavior (rarely, we hope):

5.2 or greater and running VMS 7.0 or greater:

greater:

depending on what type of socket support you've built into
your copy of Perl:

with hard links enabled on an ODS-5 formatted build disk.  CRTL support
is in principle available as of OpenVMS v7.3-1, and better configuration
support could detect this.

v8.2 and later.  CRTL support is in principle available as of OpenVMS
v7.3-2, and better configuration support could detect this.

and later.

0, 0, 0, 0, 0, 0, and 0 work as
advertised.  The return values for 0, 0, and 0
tell you whether you can actually access the file; this may
not reflect the UIC-based file protections.  Since real and
effective UIC don't differ under VMS, 0, 0, 0,
and 0 are equivalent to 0, 0, 0, and 0.
Similarly, several other tests, including 0, 0, 0,
0, 0, and 0, aren't particularly meaningful under
VMS, and the values returned by these tests reflect whatever
your CRTL 0 routine does to the equivalent bits in the
st_mode field.  Finally, 0 returns true if passed a device
specification without an explicit directory (e.g. 0), as
well as if passed a directory.

also control what values are returned for the date fields.

tests (0, 0, and 0) on files accessed via DEC's DFS.
Specifically, since DFS does not currently provide access to the
extended file header of files on remote volumes, attempts to
examine the ACL fail, and the file tests will return false,
with 0 indicating that the file does not exist.  You can
use 0 on these files, since that checks UIC-based protection
only, and then manually check the appropriate bits, as defined by
your C compiler's 0, in the mode value it returns, if you
need an approximation of the file's protections.

to it for execution as a DCL command.  Since the subprocess is
created directly via 0, any valid DCL command string
may be specified.

of carriage control occurs on input from or output to this filehandle.
Since this involves reopening the file and then restoring its
file position indicator, if this function returns FALSE, the
underlying filehandle may no longer point to an open file, or may
point to a different position in the file than before 0
was called.

filehandles; it is provided so that you can control I/O to existing
record-structured files when necessary.  You can also use the
0 function in the VMS::Stdio extension to gain finer
control of I/O to files and devices with different record structures.

service to generate the hashed representation of PLAINTEXT.
If USER is a valid username, the algorithm and salt values
are taken from that user's UAF record.  If it is not, then
the preferred algorithm and a salt of 0 are used.  The
quadword encrypted value is returned as an 8-character string.

the encrypted password from the UAF returned by the 0
functions, in order to authenticate users.  If you're
going to do this, remember that the encrypted password in
the UAF was generated using uppercase username and
password strings; you'll have to upcase the arguments to
0 to insure that you'll get the proper value:

if neither of the $! or $? status values are ones that would cause
the native status to be interpreted as being what VMS classifies as
SEVERE_ERROR severity for DCL error handling.

status value will have either one of the 0 or 0 or 0 or
the Unix value 255 encoded into it in a way that the effective original
value can be decoded by other programs written in C, including Perl
and the GNV package.  As per the normal non-VMS behavior of 0 if
either 0 or 0 are non-zero, one of those values will be
encoded into a native VMS status value.  If both of the Unix status
values are 0, and the 0 value is set one of ERROR or SEVERE_ERROR
severity, then the 0 value will be used as the exit code as is.
If none of the above apply, the Unix value of 255 will be encoded into
a native VMS exit status value.

the 0 mode is that it does not force a VMS
SEVERE_ERROR status on exit.  The Unix exit values of 2 through
255 will be encoded in VMS status values with severity levels of
SUCCESS.  The Unix exit value of 1 will be encoded in a VMS status
value with a severity level of ERROR.  This is to be compatible with
how the VMS C library encodes these values.

may be changed to be ERROR or higher in the future depending on the
results of testing and further review.

produce a native VMS status containing it.

operator invokes the VMS debugger.  If you continue to
execute the Perl program under the debugger, control will
be transferred to the label specified as the argument to
0, or, if no label was specified, back to the
beginning of the program.  All other state of the program
(0 values of variables, open file handles) are not
affected by calling 0.

given as an argument to 0 via 0.  If the
argument begins with '@' or '$' (other than as part of a filespec),
then it is executed as a DCL command.  Otherwise, the first token on
the command line is treated as the filespec of an image to run, and
an attempt is made to invoke it (using 0 and the process
defaults to expand the filespec) and pass the rest of 0's
argument to it as parameters.  If the token has no file type, and
matches a file with null type, then an attempt is made to determine
whether the file is an executable image which should be invoked
using 0 or a text file which should be passed to DCL as a
command procedure.

(and with the same rather severe limitations as) the CRTL 0
routine, and while some internal support to do just that is in
place, the implementation has never been completed, making 0
currently unavailable.  A true kernel 0 is expected in a
future version of VMS, and the pseudo-fork based on interpreter
threads may be available in a future version of Perl on VMS (see
0).  In the meantime, use 0, backticks, or piped
filehandles to create subprocesses.

if you have the privileges necessary to retrieve the named user's
UAF information via 0.  If not, then only the 0,
0, and 0 items are returned.  The 0 item contains
the login directory in VMS syntax, while the 0 item
contains the login directory in Unix syntax. The 0 item
contains the owner field from the UAF record.  The 0
item is not used.

working CRTL 0 routine, or if the logical name
SYS is defined as the number of seconds
which must be added to UTC to yield local time.  (This logical
name is defined automatically if you are running a version of
VMS with built-in UTC support.)  If neither of these cases is
true, a warning message is printed, and 0 is returned.

service 0, which has the same calling sequence as 0, but
throws an exception in the target process rather than forcing it to call
0.  Generally speaking, 0 follows the behavior of the
CRTL's 0 function, but unlike that function can be called from
within a signal handler.  Also, unlike the 0 in some versions of
the CRTL, Perl's 0 checks the validity of the signal passed in and
returns an error rather than attempting to send an unrecognized signal.

VMS; they're just converted to the corresponding positive value.

version of 0 is not available at all.  If socket
support is present, then the system call version of
0 functions only for file descriptors attached
to sockets.  It will not provide information about regular
files or pipes, since the CRTL 0 routine does not
provide this functionality.

than Unix, it's not really possible to represent the file's ID
in the 0 and 0 fields of a 0.  Perl
tries its best, though, and the values it uses are pretty unlikely
to be the same for two different files.  We can't guarantee this,
though, so caveat scriptor.

arguments to the subprocess for execution as a DCL command.
Since the subprocess is created directly via 0, any
valid DCL command string may be specified.  If the string begins with
'@', it is treated as a DCL command unconditionally.  Otherwise, if
the first token contains a character used as a delimiter in file
specification (e.g. 0 or 0), an attempt is made to expand it
using  a default type of 0 and the process defaults, and if
successful, the resulting file is invoked via 0. This allows you
to invoke an image directly simply by passing the file specification
to 0, a common Unixish idiom.  If the token has no file type,
and matches a file with null type, then an attempt is made to
determine whether the file is an executable image which should be
invoked using 0 or a text file which should be passed to DCL
as a command procedure.

interactive DCL subprocess, in the same fashion as typing
0 at the DCL prompt.

execution in the current process.  As described in 0,
the return value of 0 is a fake "status" which follows
POSIX semantics unless the pragma 0 is in
effect; see the description of 0 in this document for more
detail.

01-JAN-1970 00:00:00 (just like the CRTL's  routine), in order
to make life easier for code coming in from the POSIX/Unix world.

according to the same rules the CRTL 0 routine.
Therefore, the "system time" elements will always be 0, since
there is no difference between "user time" and "system" time
under VMS, and the time accumulated by a subprocess may or may
not appear separately in the "child time" field, depending on
whether 0 keeps track of subprocesses separately.  Note
especially that the VAXCRTL (at least) keeps track only of
subprocesses spawned using 0 and 0; it will not
accumulate the times of subprocesses spawned via pipes, 0,
or backticks.

order to delete all versions, you need to say

Unix system which expect that after a call to 0,
no files with the names passed to 0 will exist.
(Note: This can be changed at compile time; if you
0 and 0 is
0, then 0 will delete all versions of a
file on the first call.)

requires changing file protection (though it won't try to
change the protection of the parent directory).  You can tell
whether you've got explicit delete access to a file by using the
0 operator.  For instance, in order
to delete only files to which you have delete access, you could
say something like

the VMS::Stdio extension distributed with Perl). If 0 has to
change the file protection to delete the file, and you interrupt it
in midstream, the file may be left intact, but with a changed ACL
allowing you delete access.

and not traditional VMS behavior.

revision date) on ODS-2 volumes and ODS-5 volumes without access
dates enabled. On ODS-5 volumes with access dates enabled, the
true access time is modified.

0 will wait for that subprocess, and return its final status
value in 0.  If PID is a subprocess created in some other way (e.g.
SPAWNed before Perl was invoked), 0 will simply check once per
second whether the process has completed, and return when it has.  (If
PID specifies a process that isn't a subprocess of the current process,
and you invoked Perl with the 0 switch, a warning will be issued.)

in all cases.

"special" Perl variables, in addition to the general information
in 0.  Where there is a conflict, this information
takes precedence.

of the logical name 0.  If defined, it should
be a search list, each element of which specifies a location
for 0 elements.  If you tell Perl to read or set the
element 000, then Perl uses the translations of
0 as follows:

array of key-value pairs, using 0 as the key.  In most cases,
this contains only a few keys, but if Perl was invoked via the C
0 function, as is the case for CGI processing by some
HTTP servers, then the 0 array may have been populated by
the calling program.

symbol tables, using 0 as the name of the symbol.  When reading
an element of 0, the local symbol table is scanned first, followed
by the global symbol table..  The characters following 0 are
significant when an element of 0 is set or deleted: if the
complete string is 0, the change is made in the local
symbol table; otherwise the global symbol table is changed.

that string is used as the name of a logical name table, which is
consulted using 0 as the logical name.  The normal search
order of access modes is used.

you make while Perl is running do not affect the behavior of 0.
If 0 is not defined, then Perl defaults to consulting
first the logical name tables specified by 0, and then
the CRTL 0 array.

were entirely uppercase, regardless of the case actually
specified in the Perl expression.

0 points are checked in order, and the value
obtained from the first successful lookup is returned.  If the
name of the 0 element contains a semi-colon, it and
any characters after it are removed.  These are ignored when
the CRTL 0 array or a CLI symbol table is consulted.
However, the name is looked up in a logical name table, the
suffix after the semi-colon is treated as the translation index
to be used for the lookup.   This lets you look up successive values
for search list logical names.  For instance, if you say

that 0 is set up so that the logical name 0
is found, rather than a CLI symbol or CRTL 0 element with
the same name.

corresponding definition is made in the location to which the
first translation of 0 points.  If this causes a
logical name to be created, it is defined in supervisor mode.
(The same is done if an existing logical name was defined in
executive or kernel mode; an existing user or supervisor mode
logical name is reset to the new value.)  If the value is an empty
string, the logical name's translation is defined as a single NUL
(ASCII 00) character, since a logical name cannot translate to a
zero-length string.  (This restriction does not apply to CLI symbols
or CRTL 0 values; they are set to the empty string.)
An element of the CRTL 0 array can be set only if your
copy of Perl knows about the CRTL's 0 function.  (This is
present only in some versions of the DECCRTL; check 0
to see whether your copy of Perl was built with a CRTL that has this
function.)

the element is looked up as if it were being read, and if it is
found, it is deleted.  (An item "deleted" from the CRTL 0
array is set to the empty string; this can only be done if your
copy of Perl knows about the CRTL 0 function.)  Using
0 to remove an element from 0 has a similar effect,
but after the element is deleted, another attempt is made to
look up the element, so an inner-mode logical name or a name in
another location will replace the logical name just deleted.
In either case, only the first value found searching PERL_ENV_TABLES
is altered.  It is not possible at present to define a search list
logical name via %ENV.

Perl's current default device and directory, and when set, it
resets them, regardless of the definition of 0.
It cannot be cleared or deleted; attempts to do so are silently
ignored.

C-local environ array to a subprocess which isn't
started by fork/exec, or isn't running a C program, you
can "promote" them to logical names in the current
process, which will then be inherited by all subprocesses,
by saying

Perl optimizer is smart enough to elide the expression.)

a fatal error.  This is equivalent to doing the following from DCL:

or SYS logical names were deleted.

0, or 0,  you will incur a time penalty as all
logical names are read, in order to fully populate %ENV.
Subsequent iterations will not reread logical names, so they
won't be as slow, but they also won't reflect any changes
to logical name tables caused by other programs.

process-permanent files, such as 0 and 0.
The translations for these logical names are prepended with a
two-byte binary value (0x1B 0x00) that needs to be stripped off
if you wantto use it. (In previous versions of Perl it wasn't
possible to get the values of these logical names, as the null
byte acted as an end-of-string marker)

 function, so it will include the VMS message for
VMS-specific errors.  The numeric value of 0 is the
value of 0, except if errno is EVMSERR, in which
case 0 contains the value of vaxc.  Setting 0
always sets errno to the value specified.  If this value is
EVMSERR, it also sets vaxc to 4 (NONAME-F-NOMSG), so
that the string value of 0 won't reflect the VMS error
message from before 0 was set.

in vaxc, which are often more specific than the
generic Unix-style error messages in 0.  Its numeric value
is the value of vaxc, and its string value is the
corresponding VMS message string, as retrieved by .
Setting 0 sets vaxc to the value specified.

errno is not EVMSERR, it may not be from the current operation.

actual exit status of the subprocess in a way that approximates
POSIX  semantics, in order to allow Perl programs to
portably test for successful completion of subprocesses.  The
low order 8 bits of 0 are always 0 under VMS, since the
termination status of a process may or may not have been
generated by an exception.

compiled with the _POSIX_EXIT macro set, the status value will
contain the actual value of 0 to 255 returned by that program
on a normal exit.

represented as a VMS native status of 1, and the Unix values
from 2 to 255 are encoded by the equation:

subprocess's exit status is used: if the severity was success or
informational, these bits are all 0; if the severity was
warning, they contain a value of 1; if the severity was
error or fatal error, they contain the actual severity bits,
which turns out to be a value of 2 for error and 4 for severe_error.
Fatal is another term for the severe_error status.

status indicated successful completion, and non-zero if a
warning or error occurred or a program compliant with encoding
_POSIX_EXIT values was run and set a status.

the result of a VMS native error status or an encoded Unix status?
You can not unless you look at the ${^CHILD_ERROR_NATIVE} value.
The ${^CHILD_ERROR_NATIVE} value returns the actual VMS status value
and check the severity bits. If the severity bits are equal to 1,
then if the numeric value for 0 is between 2 and 255 or 0, then
0 accurately reflects a value passed back from a Unix application.
If 0 is 1, and the severity bits indicate a VMS error (2), then
0 is from a Unix application exit value.

type status values will be expecting those values, and programs that
call traditional VMS programs will either be expecting the previous
behavior or just checking for a non-zero status.

internally the 0 value will be set to the closest Unix errno
value to that error so that Perl scripts that test for error
messages will see the expected Unix style error message instead
of a VMS message.

to convert the POSIX value into a native status intelligible to
the operating system upon exiting Perl.  What this boils down to
is that setting 0 to zero results in the generic success value
SS, and setting 0 to a non-zero value results in the
generic failure status SS.  See also 0.

setting 0 will cause the new value to be encoded into 0
so that either the original parent or child exit status values

_POSIX_EXIT behavior.  If both a parent and a child exit value are
non-zero, then it will be assumed that this is actually a VMS native
status value to be passed through.  The special value of 0xFFFF is
almost a NOOP as it will cause the current native VMS status in the
C library to become the current native Perl VMS status, and is handled
this way as it is known to not be a valid native VMS status value.
It is recommend that only values in the range of normal Unix parent or
child status numbers, 0 to 255 are used.

VMS exit status instead of the default emulation of POSIX status
described above.  This pragma also disables the conversion of
non-zero values to SS when setting 0 in an END
block (but zero will still be converted to SS).

enabled, as they are at times requesting conflicting actions and the
consequence of ignoring this advice will be undefined to allow future
improvements in the POSIX exit handling.

will be available in the exit status for DCL scripts or other native VMS tools,
and will give the expected information for Posix programs.  It has not been
made the default in order to preserve backward compatibility.

0.

all the way to disk on each write (0 not just to
the underlying RMS buffers for a file).  In other words,
it's equivalent to calling  and  from C.

difference. The database directory file created has a 0
extension rather than a 0 extension. 0 files are VMS filesystem
directory files, and using them for other purposes could cause unacceptable
problems.

Craig Berry  craigberry@mac.com
Dan Sugalski  dan@sidhe.org
John Malmberg wb8tyw@qsl.net 

=encoding utf8

interface between Perl and C code (or a C library) which one wishes
to use with Perl.  The XS interface is combined with the library to
create a new library which can then be either dynamically loaded
or statically linked into perl.  The XS interface description is
written in the XS language and is the core component of the Perl
extension interface.

by the 0 compiler, each XSUB amounts to a C function definition
which will provide the glue between Perl calling conventions and C
calling conventions.

Perl values to the formats expected by a C function, call this C function,
transfers the return values of the C function back to Perl.
Return values here may be a conventional C return value or any C
function arguments that may serve as output parameters.  These return
values may be passed back to Perl either by putting them on the
Perl stack, or by modifying the arguments supplied from the Perl side.

Perl allows more flexible calling conventions than C, XSUBs may do much
more in practice, such as checking input parameters for validity,
throwing exceptions (or returning undef/empty list) if the return value
from the C function indicates failure, calling different C functions
based on numbers and types of the arguments, providing an object-oriented
interface, etc.

would be a tedious task, especially if one needs to write glue for
multiple C functions, and/or one is not familiar enough with the Perl
stack discipline and other such arcana.  XS comes to the rescue here:
instead of writing this glue C code in long-hand, one can write
a more concise short-hand 0 of what should be done by
the glue, and let the XS compiler 0 handle the rest.

routine is used, and how the corresponding Perl routine is used.  It
also allows creation of Perl routines which are directly translated to
C code and which are not related to a pre-existing C function.  In cases
when the C interface coincides with the Perl interface, the XSUB
declaration is almost identical to a declaration of a C function (in K&R
style).  In such circumstances, there is another tool called 0
that is able to translate an entire C header file into a corresponding
XS file that will provide glue to the functions/macros described in
the header file.

the constructs necessary to let an XSUB manipulate Perl values, and
creates the glue necessary to let Perl call the XSUB.  The compiler
uses 0 to determine how to map C function parameters
and output values to Perl values and back.  The default typemap
(which comes with Perl) handles many common C types.  A supplementary
typemap may also be needed to handle any special structures and types
for the library being linked.

first C<MODULE =Z<>> directive.  Other XS directives and XSUB definitions
may follow this line.  The "language" used in this part of the file
is usually referred to as the XS language.  0 recognizes and
skips POD (see 0) in both the C and XS language sections, which
allows the XS file to contain embedded documentation.

significantly more convenient mechanism for creating the extension
glue code.  See 0 for more information.

between Perl and the ONC+ RPC bind library functions.  The 
function is used to demonstrate many features of the XS language.  This
function has two parameters; the first is an input parameter and the second
is an output parameter.  The function also returns a status value.

statements.

and Perl, then this XSUB will be used from Perl with the following code.
The  and  variables will contain the output of the function.

demonstrates one possible interface to the 
function.  This XSUB represents a direct translation between
C and Perl and so preserves the interface even from Perl.
This XSUB will be invoked from Perl with the usage shown
above.  Note that the first three #include statements, for
0, 0, and 0, will always be present at the
beginning of an XS file.  This approach and others will be
expanded later in this document.

should have a Perl module to serve as the bootstrap which
pulls the extension into Perl.  This module will export the
extension's functions and variables to the Perl program and
will cause the extension's XSUBs to be linked into Perl.
The following module will be used for most of the examples
in this document and should be used from Perl with the 0
command as shown earlier.  Perl modules are explained in
more detail later in this document.

XSUB will be explored.  The XSUBs will take their parameters in different
orders or will take different numbers of parameters.  In each case the
XSUB is an abstraction between Perl and the real C 
function, and the XSUB must always ensure that the real 
function is called with the correct parameters.  This abstraction will
allow the programmer to create a more Perl-like interface to the C
function.

value, the name of the XSUB routine and the names of its arguments,
and a description of types or formats of the arguments.

called .  The XSUB will imitate the C function which takes a single
argument and returns a single value.

argument names, rewriting this as

semicolon is allowed after the argument list, as in

with similar declarations

could be described 0 like this:

different semantics, see 0.

0 should be considered as a part of the type and the address operator 0
should be considered part of the variable.  See 0
for more info about handling qualifiers and unary operators in C types.

separate lines and should be flush left-adjusted.

following example shows a function with its body left-adjusted.  Most
examples in this document will indent the body for better readability.

an XSUB starts with the corresponding keyword, such as INIT: or CLEANUP:.
However, the first two lines of an XSUB always contain the same data:
descriptions of the return type and the names of the function and its
parameters.  Whatever immediately follows these is considered to be
an INPUT: section unless explicitly marked with another keyword.
(See 0.)

sent as parameters to the XSUB and to store the XSUB's
return value(s).  In reality all Perl functions (including non-XSUB
ones) keep their values on this stack all the same time, each limited
to its own range of positions on the stack.  In this document the
first position on that stack which belongs to the active
function will be referred to as position 0 for that function.

refers to a position in this XSUB's part of the stack.  Position 0 for that
function would be known to the XSUB as .  The XSUB's incoming
parameters and outgoing return values always begin at .  For many
simple cases the 0 compiler will generate the code necessary to
handle the argument stack by embedding code fragments found in the
typemaps.  In more complex cases the programmer must supply the code.

for you.  The C type of RETVAL matches the return type of the C library
function.  The 0 compiler will declare this variable in each XSUB
with non-0 return type.  By default the generated C function
will use RETVAL to hold the return value of the C library function being
called.  In simple cases the value of RETVAL will be placed in  of
the argument stack where it can be received by Perl as the return value
of the XSUB.

not declare a RETVAL variable for that function.  When using
a PPCODE: section no manipulation of the RETVAL variable is required, the
section may use direct stack manipulation to place output values on the stack.

only for subroutines which do not return a value, 0 CODE:
directive is used which sets  explicitly.

value in such cases. It was discovered that this could lead to
segfaults in cases when XSUB was 0 0. This practice is
now deprecated, and may be not supported at some future version. Use
the return value 0 in such cases. (Currently 0 contains
some heuristic code which tries to disambiguate between "truly-void"
and "old-practice-declared-as-void" functions. Hence your code is at
mercy of this heuristics unless you use 0 as return value.)

going on behind the scenes that should be mentioned. When you're
manipulating the argument stack using the ST(x) macro, for example,
you usually have to pay special attention to reference counts. (For
more about reference counts, see 0.) To make your life
easier, the typemap file automatically makes 0 mortal when
you're returning an 0. Thus, the following two XSUBs are more
or less equivalent:

this works fine for an 0, it's unfortunately not as easy
to have 0 or 0 as a return value. You 0 be
able to write:

CPAN modules) in the typemap file, the reference count of the 0
is not properly decremented. Thus, the above XSUB would leak memory
whenever it is being called. The same problem exists for 0.

their reference count is decremented by making the AV or HV mortal:

of the functions which are being defined.  All text preceding the first
MODULE keyword is considered C code and is passed through to the output with
POD stripped, but otherwise untouched.  Every XS module will have a
bootstrap function which is used to hook the XSUBs into Perl.  The package
name of this bootstrap function will match the value of the last MODULE
statement in the XS source files.  The value of MODULE should always remain
constant within the same XS file, though this is not required.

all functions in a package named RPC.

the PACKAGE keyword should be used.  This keyword is used with the MODULE
keyword and must follow immediately after it when used.

non-contiguous code. This is useful if you have a stronger ordering
principle than package names.

information it should always be used.  This keyword will ensure that the
XSUBs appear in the desired package.

removed from the Perl function names.  If the C function is
0 and the PREFIX value is 0 then Perl will
see this function as 0.

If PACKAGE is not used then PREFIX should follow the MODULE
keyword.

updated (new values made visible to Perl) when the XSUB terminates or that
certain values should be returned to the calling Perl function.  For
simple functions which have no CODE: or PPCODE: section,
such as the  function above, the RETVAL variable is
automatically designated as an output value.  For more complex functions
the 0 compiler will need help to determine which variables are output
variables.

The RETVAL variable is not recognized as an output variable when the
CODE: keyword is present.  The OUTPUT:  keyword is used in this
situation to tell the compiler that RETVAL really is an output
variable.

are output variables.  This may be necessary when a parameter has been
modified within the function and the programmer would like the update to
be seen by Perl.

be mapped to a matching piece of code rather than to a
typemap.

OUTPUT section of the XSUB, except RETVAL.  This is the usually desired
behavior, as it takes care of properly invoking 'set' magic on output
parameters (needed for hash or array element parameters that must be
created if they didn't exist).  If for some reason, this behavior is
not desired, the OUTPUT section may contain a 0 line
to disable it for the remainder of the parameters in the OUTPUT section.
Likewise,  0 can be used to reenable it for the
remainder of the OUTPUT section.  See 0 for more details
about 'set' magic.

indicates that while the C subroutine we provide an interface to has
a non-0 return type, the return value of this C subroutine should not
be returned from the generated Perl subroutine.

generated call to the subroutine this variable is assigned to, but the value
of this variable is not going to be used in the auto-generated code.

user-supplied code.  It is especially useful to make a function interface
more Perl-like, especially when the C return value is just an error condition
indicator.  For example,

with a meaningful error message on error.

special handling for the C function.  The RETVAL variable is
still declared, but it will not be returned unless it is specified
in the OUTPUT: section.

its parameters.  The Perl usage is given first.

the compiler generates the call to the C function.  Unlike the CODE: keyword
above, this keyword does not affect the way the compiler handles RETVAL.

making a call to the C function:

parameter is being used only as an output value.  The 0
compiler will normally generate code to read the values of
all function parameters from the argument stack and assign
them to C variables upon entry to the function.  NO_INIT
will tell the compiler that some parameters will be used for
output rather than for input and that they will be handled
before the function terminates.

This function uses the timep variable only as an output variable and does
not care about its initial contents.

the argument stack (which in turn contains the parameters that were
passed to the XSUB from Perl).  The typemaps contain the
code segments which are used to translate the Perl values to
the C parameters.  The programmer, however, is allowed to
override the typemaps and supply alternate (or additional)
initialization code.  Initialization code starts with the first
0, 0 or 0 on a line in the INPUT: section.  The only
exception happens if this 0 terminates the line, then this 0
is quietly ignored.

function parameters.  The initialization code is eval'ed within double
quotes by the compiler before it is added to the output so anything
which should be interpreted literally [mainly 0, 0, or 0]
must be protected with backslashes.  The variables , ,
and  can be used as in typemaps.

would normally use this when a function parameter must be processed by
another library function before it can be used.  Default parameters are
covered in the next section.

the declaration for the input variable, replacing the initialization
supplied by the typemap.  If the initialization
begins with 0 or 0, then it is performed after
all of the input variables have been declared.  In the 0
case the initialization normally supplied by the typemap is not performed.
For the 0 case, the declaration for the variable will include the
initialization from the typemap.  A global
variable, 0, is available for the truly rare case where
information from one initialization is needed in another
initialization.

example has a two-fold purpose: first, when this line is processed by
0, the Perl snippet 0 is evaluated.  Second,
the text of the evaluated snippet is output into the generated C file
(inside a C comment)!  During the processing of 0 line,
 will evaluate to 0, and 0 will evaluate to
0.

assignment statement in the parameter list.  The default value may
be a number, a string or the special string 0.  Defaults should
always be used on the right-most parameters only.

value the parameters to the XSUB could be rearranged.  The
XSUB will then call the real  function with
the parameters in the correct order.  This XSUB can be called
from Perl with either of the following statements:

block  is used to call the real  function with
the parameters in the correct order for that function.

before or after the declarations of the parameters from the INPUT: section
are emitted.

code that is emitted for the input parameters.  This may result in the
declaration ending up after C code, which is C syntax error.  Similar
errors may happen with an explicit 0-type or 0-type initialization of
parameters is used (see 0).  Declaring
these variables in an INIT: section will not help.

with declarations of other variables, place the declaration into a
PREINIT: section.  The PREINIT: keyword may be used one or more times
within an XSUB.

typemaps then the first example is safer.

same C code as the PREINIT: keyword.  Another correct, but error-prone example:

processed is very handy in the cases when typemap conversions manipulate
some global state:

MyObject when processing RETVAL will modify a global variable 0.
After these conversions are performed, we restore the old value of
0 (to avoid memory leaks, for example).

declaration of C variables which do not appear in the parameter list of
a subroutine.  Thus the above code for  can be rewritten as

enabled, the XSUB will invoke ENTER and LEAVE automatically.

by an XSUB contains a comment like 0 then scoping will
be automatically enabled for that XSUB.

XSUB.  The INPUT: keyword can be used to force those parameters to be
evaluated a little later.  The INPUT: keyword can be used multiple times
within an XSUB and can be used to list one or more input variables.  This
keyword is used with the PREINIT: keyword.

evaluated late, after a PREINIT.

in the parameter list of a subroutine, this may be shortened to:

thus 0 is initialized on the declaration line, and our assignment
0 is not performed too early.  Otherwise one would need to have the
assignment 0 in a CODE: or INIT: section.)

by the 0/0/0/0/0 keywords.
0 keyword is the default, the other keywords indicate how the Perl
interface should differ from the C interface.

keywords are considered to be used by the C subroutine 0.  0/0 keywords indicate that the C subroutine
does not inspect the memory pointed by this parameter, but will write
through this pointer to provide additional return values.

signature of the generated Perl function.

parameters to the Perl function.  With the exception of
0-parameters, these parameters are converted to the corresponding
C type, then pointers to these data are given as arguments to the C
function.  It is expected that the C function will write through these
pointers.

from the function (unless the XSUB is of 0 return type or
0 was used) followed by all the 0
and 0 parameters (in the order of appearance).  On the
return from the XSUB the 0/0 Perl parameter will be
modified to have the values written by the C function.

mixed with ANSI-style declarations, as in

0 and put into the 0 section (see
0).  The 0 parameters are very similar,
the only difference being that the value C function writes through the
pointer would not modify the Perl parameter, but is put in the output
list.

parameters only by the initial value of the Perl parameter not
being read (and not being given to the C function - which gets some
garbage instead).  For example, the same C function as above can be
interfaced with as

argument 0, one can substitute the name of the length-argument by
0 in the XSUB declaration.  This argument must be omitted when
the generated Perl function is called.  E.g.,

0 in the parameter list.  This use of the ellipsis is similar to that
found in ANSI C.  The programmer is able to determine the number of
arguments passed to the XSUB by examining the 0 variable which the
0 compiler supplies for all XSUBs.  By using this mechanism one can
create an XSUB which accepts a list of parameters of unknown length.

optional so the ellipsis can be used to indicate that the
XSUB will take a variable number of parameters.  Perl should
be able to call this XSUB with either of the following statements.

calling sequence from Perl than from C, without a need to write
CODE: or PPCODE: section.  The contents of the C_ARGS: paragraph is
put as the argument to the called C function without any change.

0.  Suppose that you want to create an interface which
is called as

to tell the 0 compiler that the programmer is supplying the code to
control the argument stack for the XSUBs return values.  Occasionally one
will want an XSUB to return a list of values rather than a single value.
In these cases one must use PPCODE: and then explicitly push the list of
values on the stack.  The PPCODE: and CODE:  keywords should not be used
together within the same XSUB.

initialization of 0 macro (which stands for the 0 Perl
stack pointer), and in the handling of data on the stack when returning
from an XSUB.  In CODE: sections SP preserves the value which was on
entry to the XSUB: SP is on the function pointer (which follows the
last parameter).  In PPCODE: sections SP is moved backward to the
beginning of the parameter list, which allows 0 macros
to place output values in the place Perl expects them to be when
the XSUB returns back to Perl.

values Perl will see is either 0 or 1 (depending on the 0ness of the
return value of the C function, and heuristics mentioned in
0).  The trailer generated for a PPCODE: section
is based on the number of return values and on the number of times
0 was updated by 0 macros.

well in CODE: sections and PPCODE: sections.

and will return its two output values, timep and status, to
Perl as a single list.

to have the real  function called and to have
the return values properly placed on the argument stack.

the RETVAL variable is not needed or used and that it should not be created.
In most scenarios the void return type should be used with the PPCODE:
directive.

stack for 2 return values.  The PPCODE: directive causes the
0 compiler to create a stack pointer available as 0, and it
is this pointer which is being used in the  macro.
The values are then pushed onto the stack with the 
macro.

the following statement.

'set' magic properly.  See 0 for details about 'set' magic.

0 or an empty list if a function fails rather than a
separate status value.  The  function offers
just this situation.  If the function succeeds we would like
to have it return the time and if it fails we would like to
have undef returned.  In the following Perl code the value
of  will either be undef or it will be a valid time.

and uses a CODE: block to indicate to the compiler
that the programmer has supplied all the necessary code.  The
 call will initialize the return value to undef, making that
the default return value.

return value, should the need arise.

then not push return values on the stack.

XSUB, rather than letting control fall through to the end.  In those
situations 0 should be used, instead.  This will ensure that
the XSUB stack is properly adjusted.  Consult 0 for other
0 macros.

rewrite this example as:

with PREINIT: simplifications, this leads to:

0 compiler needed to compile the XS module.  An XS module which
contains the following statement will compile with only 0 version
1.922 or greater:

before it terminates.  When the CLEANUP:  keyword is used it must follow
any CODE:, PPCODE:, or OUTPUT: blocks which are present in the XSUB.  The
code specified for the cleanup block will be added as the last statements
in the XSUB.

executed after the C subroutine call is performed.  When the POSTCALL:
keyword is used it must precede OUTPUT: and CLEANUP: blocks which are
present in the XSUB.

call is supplied by user by providing either CODE: or PPCODE: section.

function.  The bootstrap function is generated by the 0 compiler and
normally holds the statements necessary to register any XSUBs with Perl.
With the BOOT: keyword the programmer can tell the compiler to add extra
statements to the bootstrap function.

appear on a line by itself.  The first blank line after the keyword will
terminate the code block.

0 options.  This keyword overrides the command line
options.  Version checking is enabled by default.  When version checking is
enabled the XS module will attempt to verify that its version matches the
version of the PM module.

number), it will be stringified with a possible loss of precision
(currently chopping to nine decimal places) so that it may not match
the version of the XS module anymore. Quoting the  declaration
to make it a string is recommended if long version numbers are used.

0 options.  This keyword overrides the command line options.
Prototypes are enabled by default.  When prototypes are enabled XSUBs will
be given Perl prototypes.  This keyword may be used multiple times in an XS
module to enable and disable prototypes for different parts of the module.

force 0 to use a specific prototype for the XSUB.  This keyword
overrides all other prototype options and keywords but affects only the
current XSUB.  Consult 0 for information about Perl
prototypes.

XSUB as in the following example:

and to know which of those names was used when it was invoked.  The Perl
names may be fully-qualified with package names.  Each alias is given an
index.  The compiler will setup a variable called 0 which contain the
index of the alias which was used.  When the XSUB is called with its
declared name 0 will be 0.

0 for this function.

can also use the OVERLOAD keyword to define additional Perl names
for your functions (like the ALIAS: keyword above).  However, the
overloaded functions must be defined with three parameters (except
for the  function which needs four parameters).  If any
function has the OVERLOAD: keyword, several additional lines
will be defined in the c file generated by xsubpp in order to
register with the overload magic.

to use the typemap features to preprocess parameters and extract
the actual SV stored within the blessed RV. See the sample for
T_PTROBJ_SPECIAL below.

three input parameters ( or use the c style '...' definition) like
this:

comparison operators.  For all overload operations using non-alpha
characters, you must type the parameter without quoting, separating
multiple overloads with whitespace.  Note that "" (the stringify
overload) should be entered as \"\" (i.e. escaped).

Perl autogenerates missing overloaded operators, you can set the
FALLBACK keyword in the module header section, like this:

UNDEF.  If you do not set any FALLBACK value when using OVERLOAD,
it defaults to UNDEF.  FALLBACK is not used except when one or
more functions using OVERLOAD have been defined.  Please see
0 for more details.

calling signature.  If some text follows this keyword, it is
considered as a list of functions which have this signature, and
should be attached to the current XSUB.

 all having the signature:

Perl function share names with corresponding C functions.

is no need to code a switch statement, each Perl function (which shares
the same XSUB) knows which C function it should call.  Additionally, one
can attach an extra function  at runtime by using

INTERFACE_MACRO: section, otherwise one needs to use something else instead of
0, see the next section.)

to extract a function pointer from an XSUB.  The text which follows
this keyword should give the name of macros which would extract/set a
function pointer.  The extractor macro is given return type, 0,
and 0 for this 0.  The setter macro is given cv,
and the function pointer.

An INTERFACE keyword with an empty list of functions can be omitted if
INTERFACE_MACRO keyword is used.

, , ,  are kept in a global C array
0 with offsets being 0, 0, 0,
0.  Then one can use

files may have XS code.  INCLUDE: can also be used to run a command to
generate the XS code to be pulled into the module.

the compiler will interpret the parameters as a command. This feature is
mildly deprecated in favour of the 0 directive, as documented
below.

happens to be the first in your path and not necessarily the same perl that is
used to run 0. See 0.

document. 0 assigns special meaning to the 0 token
in that it runs the same perl interpreter that is running 0:

part acting as a virtual XSUB.  CASE: is greedy and if it is used then all
other XS keywords must be contained within a CASE:.  This means nothing may
precede the first CASE: in the XSUB and anything following the last CASE: is
included in that case.

variable (see 0), or maybe via the 0 variable
(see 0).  The last CASE: becomes the
0 case if it is not associated with a conditional.  The following
example shows CASE switched via 0 with a function 0
having an alias 0.  When the function is called as
0 its parameters are the usual 0,
but when the function is called as 0 its parameters are
reversed, 0.

the different argument lists.

that it should convert a Perl value to/from C using the C type to the left
of 0, but provide a pointer to this value when the C function is called.

by reference.  Typically, the parameter should be not a pointer type (an
0 or 0 but not an 0 or 0).

turn this into code which calls 0 with parameters 0, but the real 0 wants the 0
parameter to be of type 0 rather than 0.

will now turn this into code which calls 0 correctly with
parameters 0.  It does this by carrying the
0 through, so the function call looks like 0.

PPCODE:, POSTCALL:, and CLEANUP: blocks, as well as outside the functions.
Comments are allowed anywhere after the MODULE keyword.  The compiler will
pass the preprocessor directives through untouched and will remove the
commented lines. POD documentation is allowed at any point, both in the
C and XS language sections. POD must be terminated with a 0 command;
0 will exit with an error if it does not. It is very unlikely that
human generated C code will be mistaken for POD, as most indenting styles
result in whitespace in front of any line starting with 0. Machine
generated XS files may fall into this trap unless care is taken to
ensure that a space breaks the sequence "\n=".

non-whitespace of a line.  Care should be taken to avoid making the
comment look like a C preprocessor directive, lest it be interpreted as
such.  The simplest way to prevent this is to put whitespace in front of
the 0.

versions of a function, use

definition of the function.  Also, put a blank line before the
#else/#endif so it will not be seen as part of the function body.

The generated Perl function will assume that
its first argument is an object pointer.  The object pointer
will be stored in a variable called THIS.  The object should
have been created by C++ with the  function and should
be blessed by Perl with the  macro.  The
blessing of the object by Perl can be handled by a typemap.  An example
typemap is shown at the end of this section.

to be a static method.  It will call the C++
function using the class:: syntax.  If the method is not static
the function will be called using the THIS- syntax.

name but the parameter for the object (THIS, or "self") is implicit and is
not listed.

generated C++ code the object is called 0, and the method call will
be performed on this object.  So in the C++ code the  and 
methods will be called as this:

called and 0 will be given as its parameter.  The generated C++ code for

to create a dynamic C++ object.  The XSUB will expect the class name, which
will be kept in a variable called 0, to be given as the first
argument.

example.

translation from C to XS (such as created by 0) is often sufficient.
However, sometimes the interface will look
very C-like and occasionally nonintuitive, especially when the C function
modifies one of its parameters, or returns failure inband (as in "negative
return values mean failure").  In cases where the programmer wishes to
create a more Perl-like interface the following strategy may help to
identify the more critical parts of the interface.

these functions may be able to return lists to Perl.

of failure.  They may be
candidates to return undef or an empty list in case of failure.  If the
failure may be detected without a call to the C function, you may want to use
an INIT: section to report the failure.  For failures detectable after the C
function returns one may want to use a POSTCALL: section to process the
failure.  In more complicated cases use CODE: or PPCODE: sections.

you may want to create a special typedef to handle this situation.  Put

for 0 which converts negative values to 0, or
maybe s.  After this the return value of type 0
will create more Perl-like interface.

themselves, say, when a parameter to a function should be a contents of a
global variable.  If Perl does not need to access the contents of the value
then it may not be necessary to provide a translation for that value
from C to Perl.

values.  Some pointers may be used to implement input/output or
output parameters, they can be handled in XS with the 0 unary operator,
and, possibly, using the NO_INIT keyword.
Some others will require handling of types like 0, and one needs
to decide what a useful Perl translation will do in such a case.  When
the semantic is clear, it is advisable to put the translation into a typemap
file.

cases it may be helpful to use the T_PTROBJ typemap for
these structures so they can be manipulated by Perl as
blessed objects.  (This is handled automatically by 0.)

different translations, 0 several new types mapped to this C type,
and create separate 0 entries for these new types.  Use these
types in declarations of return type and parameters to XSUBs.

0 or 0 for the XS type.  Both types are
designed to handle pointers to complex objects.  The
T_PTRREF type will allow the Perl object to be unblessed
while the T_PTROBJ type requires that the object be blessed.
By using T_PTROBJ one can achieve a form of type-checking
because the XSUB will attempt to verify that the Perl object
is of the expected type.

with ONC+ TIRPC.  The  function will return a pointer to a
C structure and has the C prototype shown below.  The example will
demonstrate how the C pointer will become a Perl reference.  Perl will
consider this reference to be a pointer to a blessed object and will
attempt to call a destructor for the object.  A destructor will be
provided in the XS source to free the memory used by .
Destructors in XS can be created by specifying an XSUB function whose name
ends with the word 0.  XS destructors can be used to free memory
which may have been malloc'd by another XSUB.

object will be blessed in a class matching the name of the C
type, with the tag 0 appended, and the name should not
have embedded spaces if it will be a Perl package name.  The
destructor will be placed in a class corresponding to the
class of the object and the PREFIX keyword will be used to
trim the name to the word DESTROY as Perl will expect.

section for more information about adding new typemaps for an extension.

object to the supplied XSUB DESTROY function.  Perl cannot determine, and
does not care, that this object is a C struct and not a Perl object.  In
this sense, there is no difference between the object created by the
 XSUB and an object created by a normal Perl subroutine.

compiler to map C function parameters and values to Perl values.  The
typemap file may consist of three sections labelled 0, 0, and
0.  An unlabelled initial section is assumed to be a 0
section.  The INPUT section tells
the compiler how to translate Perl values
into variables of certain C types.  The OUTPUT section tells the compiler
how to translate the values from certain C types into values Perl can
understand.  The TYPEMAP section tells the compiler which of the INPUT and
OUTPUT code fragments should be used to map a given C type to a Perl value.
The section labels 0, 0, or 0 must begin
in the first column on a line by themselves, and must be in uppercase.

contains many useful types which can be used by Perl extensions.  Some
extensions define additional typemaps which they keep in their own directory.
These additional typemaps may reference INPUT and OUTPUT maps in the main
typemap.  The 0 compiler will allow the extension's own typemap to
override any mappings which are in the default typemap.

section of the typemap file.  The custom typemap used in the
 example shown earlier demonstrates what may be the typical
use of extension typemaps.  That typemap is used to equate a C structure
with the T_PTROBJ typemap.  The typemap used by  is shown
here.  Note that the C type is separated from the XS type with a tab and
that the C unary operator 0 to be blessed into the class 0.  One way to do
this is to use underscores (_) to separate package names, as follows:

double-colons (::), and declare 0 to be of that type:

on the fly, giving the desired effect.  This example demonstrates some
of the power and versatility of the typemap facility.

of a given type, taking care of the possible different size of integers
and pointers.  There are also PTR2IV, PTR2UV, PTR2NV macros,
to map the other way, which may be useful in OUTPUT sections.

static data to be safely stored in XS modules that will be accessed from
a multi-threaded Perl.

have been designed so that they will work with non-threaded Perl as well.

XS modules that make use of static data.

the 0 (0) option with h2xs (see 0).

for an XS module. The suggested naming scheme, as used by h2xs, is to
use a string that consists of the module name, the string "::_guts"
and the module version number.

0 macros assume the existence of the 0 typedef name.

all the data that needs to be interpreter-local.

of 0.

are maintaining multiple interpreters, it should be called once in each
interpreter instance, except for interpreters cloned from existing ones.
(But see 0 below.)

MY_CXT.

example, if 0 is

of invoking it in each function it is possible to pass the declaration
onto other functions using the 0/0 macros, eg

first or last in multiple arguments, where an underscore represents a
comma, i.e.  0, 0, 0 and 0.

(eg via ), both interpreters share the same physical
my_cxt_t structure. Calling 0 (typically via the package's
0 function), causes a byte-for-byte copy of the structure to be
taken, and any future dMY_CXT will cause the copy to be accessed instead.

argument.

file; that is, a dMY_CTX in one source file will access a different structure
than a dMY_CTX in another source file.

system/library interfaces that have thread-aware versions
(e.g. ) into frontend macros (e.g. ) that
correctly handle the multithreaded interaction with the Perl
interpreter.  This will happen transparently, the only thing
you need to do is to instantiate a Perl interpreter.

(PERL_CORE is defined) or the Perl core extensions (PERL_EXT is
defined).  When compiling XS code outside of Perl core the wrapping
does not take place.  Note, however, that intermixing the _r-forms
(as Perl compiled for multithreaded operation will do) and the _r-less
forms is neither well-defined (inconsistent results, data corruption,
or even crashes become more likely), nor is it very portable.

=encoding utf8

a Perl extension.  The reader is assumed to have access to 0,
0 and 0.

with each new example adding new features.  Certain concepts may not be
completely explained until later in the tutorial in order to slowly ease
the reader into building extensions.

to be otherwise different for other platforms (e.g. Win32), I will list
them.  If you find something that was missed, please let me know.

use is called 0.  Instead of running "make" in the examples that
follow, you may have to substitute whatever make program Perl has been
configured to use.  Running 0 should tell you what it is.

the extension will be used with versions of Perl different from the
version available on your machine.  Since you are reading this document,
the version of Perl on your machine is probably 5.005 or later, but the users
of your extension may have more ancient versions.

case that the version of Perl on your machine is older than this document,
see the section on "Troubleshooting these Examples" for more information.

releases of Perl, your users would appreciate an early meaningful warning.
You would probably put this information into the 0 file, but nowadays
installation of extensions may be performed automatically, guided by 0
module or other tools.

opportunity to perform version checks.  One can put something like this
in 0 for this purpose:

dynamically load a library, you cannot build XSUBs.  This is incorrect.
You 0 build them, but you must link the XSUBs subroutines with the
rest of Perl, creating a new executable.  This situation is similar to
Perl 4.

will check the system and build a dynamically-loadable library if possible,
or else a static library and then, optionally, a new statically-linked
executable with that static library linked in.

can dynamically load libraries, you may, in all the following examples,
where the command "0" with no arguments is executed, run the command
"0" instead.

instead of saying "0", you should say "0".
On systems that cannot build dynamically-loadable libraries at all, simply
saying "0" is sufficient.

extension, it will print out a well-known message and return.

possibly under ext/ if that directory exists in the current working
directory.  Several files will be created under the Mytest dir, including
MANIFEST, Makefile.PL, lib/Mytest.pm, Mytest.xs, t/Mytest.t, and Changes.

Mytest directory.

the extension.

However, for readability purposes, it is suggested that you indent CODE:
one level and the lines following one more level.

which make needs.  Its output looks something like:

long lines have been shortened for clarity and some extraneous lines have
been deleted):

explained in 0.

example only, we'll create our own test script.  Create a file called hello
that looks like this:

and we should see the following output:

argument as input and return 1 if the number is even or 0 if the number
is odd.

line, but it is useful for improving readability.  Placing a semi-colon at
the end of that line is also optional.  Any amount and kind of whitespace
may be placed between the "0" and "0".

Makefile.PL file, and running make.

file Mytest.t.  This file is set up to imitate the same kind of testing
structure that Perl itself has.  Within the test script, you perform a
number of tests to confirm the behavior of the extension, printing "ok"
when the test is correct, "not ok" when it is not.

should see output that looks something like this:

examples we'll see how we can use h2xs to read header files and generate
templates to connect to C routines.

Makefile.PL is a perl script which will generate a true Makefile to build
the extension.  We'll take a closer look at it later.

the C routines that make up the extension.  The .pm file contains routines
that tell Perl how to load your extension.

(which stands for "build library") in the current working directory.  This
directory will contain the shared library that we will build.  Once we have
tested it, we can install it into its final location.

It invoked perl with all those 0 arguments so that it could find the
various files that are part of the extension.  It is 0 important that
while you are still testing extensions that you use "0".  If you
try to run the test script all by itself, you will get a fatal error.
Another reason it is important to use "0" to run your test
script is that if you are testing an upgrade to an already-existing version,
using "0" ensures that you will test your new extension, not the
already-existing version.

as the 0'd extension that has a .pm suffix.  If that file cannot be found,
Perl dies with a fatal error.  The default search path is contained in the
0 array.

Loader extensions.  It then sets the 0 and 0 arrays and the
0 scalar; finally it tells perl to bootstrap the module.  Perl
will call its dynamic loader routine (if there is one) and load the shared
library.

array contains a list of other packages in which to search for methods (or
subroutines) that do not exist in the current package.  This is usually
only important for object-oriented extensions (which we will talk about
much later), and so usually doesn't need to be modified.

subroutines should be placed into the calling package's namespace.  Because
you don't know if the user has already used your variable and subroutine
names, it's vitally important to carefully select what to export.  Do 0
export method or variable names 0 without a good reason.

export anything.  If it's just a collection of functions and variables, then
you can export them via another array, called 0.  This array
does not automatically place its subroutine and variable names into the
namespace unless the user specifically requests that this be done.

library are "in sync" with each other.  Any time you make changes to
the .pm or .xs files, you should increment the value of this variable.

should closely follow the "ok/not ok" style that Perl itself uses, so that
it is very easy and unambiguous to determine the outcome of each test case.
When you find and fix a bug, make sure you add a test case for it.

the correct version of your extension.  If you have many test cases,
save your test files in the "t" directory and use the suffix ".t".
When you run "0", all of these test files will be executed.

value, and set the 0 to the rounded value.

"9" and add the following tests:

scalar variable.  You might be wondering if you can round a constant or
literal.  To see what happens, temporarily add the following line to Mytest.t:

let you change the value of constants!

extra library to be linked into the extension's shared library, the math
library libm in this case.  We'll talk later about how to write XSUBs that
can call every routine in a library.

value, but by changing the value of the variable that was passed into the
function.  You might have guessed that when you saw that the return value
of round is of type "void".

after you declare the function's return value and name.  Each input parameter
line starts with optional whitespace, and may have an optional terminating
semicolon.

after the OUTPUT: directive.  The use of RETVAL tells Perl that you
wish to send this value back as the return value of the XSUB function.  In
Example 3, we wanted the "return value" placed in the original variable
which we passed in, so we listed it (and not RETVAL) in the OUTPUT: section.

C code, placing it in a file whose suffix is .c.  The C code created makes
heavy use of the C functions within Perl.

array, etc.) to C's data types (int, char, etc.).  These rules are stored
in the typemap file (/ExtUtils/typemap).  This file is split into
three parts.

somewhat with the various Perl types.  The second section contains C code
which 0 uses to handle input parameters.  The third section contains
C code which 0 uses to handle output parameters.

The file name is Mytest.c:

of the typemap file, you'll see that doubles are of type T_DOUBLE.  In the
INPUT section, an argument that is T_DOUBLE is assigned to the variable
arg by calling the routine SvNV on something, then casting it to double,
then assigned to the variable arg.  Similarly, in the OUTPUT section,
once arg has its final value, it is passed to the sv_setnv function to
be passed back to the calling subroutine.  These two functions are explained
in 0; we'll talk more later about what that "" means in the
section on the argument stack.

parameters, as in Example 3.  Instead, you should probably return multiple
values in an array and let the caller handle them (we'll do this in a later
example).  However, in order to better accommodate calling pre-existing C
routines, which often do modify their input parameters, this behavior is
tolerated.

pre-defined C libraries.  To begin with, we will build a small library of
our own, then let h2xs write our .pm and .xs files for us.

Mytest.  In the Mytest2 directory, create another directory called mylib,
and cd into that directory.

include a C source file and a header file.  We'll also create a Makefile.PL
in this directory.  Then we'll make sure that running make at the Mytest2
level will automatically run this Makefile.PL file and the resulting Makefile.

and "$(RANLIB)".  Make will not function properly if you use spaces.
It has also been reported that the "cr" argument to $(AR) is unnecessary
on Win32 systems.

above Mytest2 and run the following command:

Our files are stored in Mytest2/mylib, and will be untouched.

directory.  We need to tell it that there is a subdirectory and that we
will be generating a library in it.  Let's add the argument MYEXTLIB to
the WriteMakefile call so that it looks like this:

subroutine).  Remember to use a tab character to indent the line beginning
with "cd"!

of our extension.  The single line that says "mylib" should be replaced by
the following three lines:

the variable 0 to 0.  Finally, in the
.xs file, edit the #include line to read:

currently support the const char * type.  Create a file called typemap in
the Mytest2 directory and place the following in it:

Makefile in the mylib directory.  Run make and watch that it does cd into
the mylib directory and run make in there as well.

and add the following lines to the end of the script:

equality, but rather that the difference between the expected and actual
result is below a certain amount (called epsilon) which is 0.01 in this case)

for the Mytest2::mylib extension, but you can ignore them.

has caused some extra goodies to appear in both the .pm and .xs files.

the mylib.h header file.  We changed this to a relative path so that we
could move the extension directory if we wanted to.

of the 0 routine is to make the values that are #define'd in the
header file accessible by the Perl script (by calling either 0 or
0).  There's also some XS code to allow calls to the
0 routine.

This could lead to name clashes.  A good rule of thumb is that if the #define
is only going to be used by the C routines themselves, and not by the user,
they should be removed from the 0 array.  Alternately, if you don't
mind using the "fully qualified name" of a variable, you could move most
or all of the items from the 0 array into the 0 array.

been processed by h2xs.  There is no good solution to this right now.

subdirectory.  That required only the addition of the 0 variable
to the WriteMakefile call and the replacement of the postamble subroutine
to cd into the subdirectory and run make.  The Makefile.PL for the
library is a bit more complicated, but not excessively so.  Again we
replaced the postamble subroutine to insert our own code.  This code
simply specified that the library to be created here was a static archive
library (as opposed to a dynamically loadable library) and provided the
commands to build it.

the meaning of these elements, pay attention to the line which reads

to include, and defines some convenience functions.  No translations are
performed on this part, apart from having embedded POD documentation
skipped over (see 0) it goes into the generated output C file as is.

These descriptions are translated by 0 into C code which
implements these functions using Perl calling conventions, and which
makes these functions visible from Perl interpreter.

twice in the generated .xs file: once in the first part, as a static C
function, then another time in the second part, when an XSUB interface to
this static C function is defined.

an interface to an existing C function.  Then this C function is defined
somewhere (either in an external library, or in the first part of .xs file),
and a Perl interface to this function (i.e. "Perl glue") is described in the
second part of .xs file.  The situation in 0, 0,
and 0, when all the work is done inside the "Perl glue", is
somewhat of an exception rather than the rule.

description of an XSUB:

this description does not contain the actual 0 for what is done
during a call to Perl function .  To understand what is going
on here, one can add a CODE section to this XSUB:

compiler is smart enough to figure out the 0 section from the first
two lines of the description of XSUB.  What about 0 section?  In
fact, that is absolutely the same!  The 0 section can be removed
as well, I<as far as 0 section or 0 is not
specified: 0.  As we saw in 0, a proper place
for this definition is in the first part of .xs file.  In fact a C function

do too:

as simple as

obvious tradeoffs: if you want to change a Perl interface, you need to
change two places in your code.  However, it removes a lot of clutter,
and makes the workhorse part independent from idiosyncrasies of Perl calling
convention.  (In fact, there is nothing Perl-specific in the above description,
a different version of 0 might have translated this to TCL glue or
Python glue as well.)

real-life libraries whose interfaces may not be the cleanest in the world.
We shall now continue with a discussion of the arguments passed to the
0 compiler.

passing three pieces of information for each argument listed.  The first
piece is the order of that argument relative to the others (first, second,
etc).  The second is the type of argument, and consists of the type
declaration of the argument (e.g., int, char*, etc).  The third piece is
the calling convention for the argument in the call to the library function.

C passes arguments by value; to implement a C function which modifies data
of one of the "arguments", the actual argument of this C function would be
a pointer to the data.  Thus two C functions with declarations

of chars pointed by s, and the second one may immediately dereference 0
and manipulate 0 only (using the return value as, say, a success
indicator).  From Perl one would use these functions in
a completely different manner.

argument by 0.  0 means that the argument should be passed to a library
function by its address.  The above two function may be XSUB-ified as

to the variable a, and its address would be passed into the function foo.
The second Perl argument would be treated as a string pointer and assigned to the
variable b.  The 0 of b would be passed into the function foo.  The
actual call to the function foo that 0 generates would look like this:

next to the variable name and away from the variable type), and place a
"*" near the variable type, but away from the variable name (as in the
call to foo above).  By doing so, it is easy to understand exactly what
will be passed to the C function; it will be whatever is in the "last
column".

it wants, when possible.  It will save you a lot of trouble in the long run.

example 1, you will notice a number of references to ST(n), where n is
usually 0.  "ST" is actually a macro that points to the n'th argument
on the argument stack.   is thus the first argument on the stack and
therefore the first argument passed to the XSUB,  is the second
argument, and so on.

which argument corresponds to which of the argument stack (i.e., the first
one listed is the first argument, and so on).  You invite disaster if you
do not list them in the same order as the function expects them.

in.  When an argument is listed as being an OUTPUT value, its corresponding
value on the stack (i.e.,  if it was the first argument) is changed.
You can verify this by looking at the C code generated for Example 3.
The code for the  XSUB routine contains lines that look like this:

stored back into  at the end of the routine.

done by manipulating stack values , , etc, in a subtly
different way.  See 0 for details.

to C function arguments.  See 0 for details.  Some people prefer
manual conversion by inspecting 0 even in the cases when automatic
conversion will do, arguing that this makes the logic of an XSUB call clearer.
Compare with 0 for a similar tradeoff of
a complete separation of "Perl glue" and "workhorse" parts of an XSUB.

prefer a way which is as little Perl-guts-specific as possible, meaning
automatic conversion and automatic call generation, as in
0.  This approach has the additional
benefit of protecting the XSUB writer from future changes to the Perl API.

to assist in making the interface between Perl and your extension simpler
or easier to understand.  These routines should live in the .pm file.
Whether they are automatically loaded when the extension itself is loaded
or only loaded when called depends on where in the .pm file the subroutine
definition is placed.  You can also consult 0 for an alternate
way to store and load your extra subroutines.

Documentation belongs in the .pm file.  This file will be fed to pod2man,
and the embedded documentation will be converted to the manpage format,
then placed in the blib directory.  It will be copied to Perl's
manpage directory when the extension is installed.

In fact, if you want to use method autoloading, you must do this,
as the comment inside the .pm file explains.

is quite simple: you simply run "make install".  You will either need
to have write permission into the directories where Perl is installed,
or ask your system administrator to run the make for you.

files by placing a "PREFIX=/destination/directory" after the make install.
(or in between the make and install if you have a brain-dead version of make).
This can be very useful if you are building an extension that will eventually
be distributed to multiple systems.  You can then just archive the files in
the destination directory and distribute them to your destination systems.

previous examples have all returned only a single value.  We'll now
create an extension that returns an array.

call).  If you are not running on a Unix system, you can substitute for
statfs any other function that returns multiple values, you can hard-code
values to be returned to the caller (although this will be a bit harder
to test the error case), or you can simply not do this example.  If you
change the XSUB, be sure to fix the test cases to match the changes.

Mytest.xs:

after the include of "XSUB.h":

tests to "11":

the argument stack is decoded.  C does not allow variable declarations at
arbitrary locations inside a function,
so this is usually the best way to declare local variables needed by the XSUB.
(Alternatively, one could put the whole 0 section into braces, and
put these declarations on top.)

success or failure of the call to statfs.  If there is an error, the error
number is returned as a single-element array.  If the call is successful,
then a 7-element array is returned.  Since only one argument is passed into
this function, we need room on the stack to hold the 7 values which may be
returned.

This tells 0 that we will be managing the return values that will be
put on the argument stack by ourselves.

we use the series of macros that begin with "XPUSH".  There are five
different versions, for placing integers, unsigned integers, doubles,
strings, and Perl scalars on the stack.  In our example, we placed a
Perl scalar onto the stack.  (In fact this is the only macro which
can be used to return multiple values.)

it from being overrun.  You push values onto the stack in the order you
want them seen by the calling program.

They are made mortal so that once the values are copied by the calling
program, the SV's that held the returned values can be deallocated.
If they were not mortal, then they would continue to exist after the XSUB
routine returned, but would not be accessible.  This is a memory leak.

branch we would not use 0 macros, but 0 macros, and would
pre-extend the stack before pushing the return values:

in advance (though overextending the stack will not typically hurt
anything but memory consumption).

the stack: the Perl function reference comes to an XSUB on the stack, thus
the stack is 0 large enough to take one return value.

parameter, and return a reference to an array of hashes.  This will
demonstrate manipulation of complex Perl data types from an XSUB.

the previous example.  It calls the statfs function multiple times,
accepting a reference to an array of filenames as input, and returning
a reference to an array of hashes containing the data for each of the
filesystems.

Mytest.xs:

tests to "13":

one SV* (scalar) parameter, and returning an SV* value, and we take care of
populating these scalars within the code.  Because we are only returning
one value, we don't need a 0 directive - instead, we use 0
and 0 directives.

The 0 block first checks that
0 returns true, which indicates that paths is a valid reference.  It
then verifies that the object referenced by paths is an array, using 0
to dereference paths, and 0 to discover its type.  As an added test,
it checks that the array referenced by paths is non-empty, using the 0
function (which returns -1 if the array is empty).  The XSRETURN_UNDEF macro
is used to abort the XSUB and return the undefined value whenever all three of
these conditions are not met.

internally by an AV* pointer.  The functions and macros for manipulating
arrays are similar to the functions in Perl: 0 returns the highest
index in an AV*, much like $#array; 0 fetches a single scalar value
from an array, given its index; 0 pushes a scalar value onto the
end of the array, automatically extending the array as necessary.

store the results in an output array (results) in the same order.  If
statfs fails, the element pushed onto the return array is the value of
errno after the failure.  If statfs succeeds, though, the value pushed
onto the return array is a reference to a hash containing some of the
information in the statfs structure.

to pre-extend the return array before pushing data into it, since we know
how many elements we will return:

a new scalar under a key using 0.  A hash is represented by an HV*
pointer.  Like arrays, the functions for manipulating hashes from an XSUB
mirror the functionality available from Perl.  See 0 and 0
for details.

cast an AV* or an HV* to type SV* in this case (and many others).  This
allows you to take references to arrays, hashes and scalars with the same
function.  Conversely, the 0 function always returns an SV*, which may
need to be cast to the appropriate type if it is something other than a
scalar (check with 0).

Mytest.xs and Mytest.c are minimal.

typeglobs and stuff. Well, it isn't.

standard C library function 0. This is all we need:

calls the stdio function 0, which knows nothing about them.

0 (T_IN), 0 (T_INOUT) and 0
(T_OUT). A bare 0 is considered a T_INOUT. If it matters
in your code (see below for why it might) #define or typedef
one of the specific names and use that as the argument or result
type in your XS file.

but it has the three stream variants. Using a PerlIO * directly
is not backwards compatible unless you provide your own typemap.

0 will get the output PerlIO * - which may make
a difference on a socket. Like in our example...

(i.e. a reference to a new glob) and associated with the PerlIO *
provided. If the read/write state of the PerlIO * is not correct then you
may get errors or warnings from when the file handle is used.
So if you opened the PerlIO * as "w" it should really be an
0 if open as "r" it should be an 0.

perlio 0 function as an example.

have

reversed compared to 0, and we want to keep the arguments the same.

on a PerlIO *. This means we have to ask the perlio system for a stdio
0:

layer. If it can't find one, it will call 0 to
generate a new stdio 0. Please only call 0 if
you want a 0 0. It will generate one on each call and push a
new stdio layer. So don't call it repeatedly on the same
file. 0 will retrieve the stdio layer once it has been
generated by 0.

0 is equivalent to 0.

these example extensions, you might see if any of these help you.

1 will not function properly.  You need to change the "use lib" line to
read:

automatically created by h2xs.  This means that you cannot say "make test"
to run the test script.  You will need to add the following line before the
"use extension" statement:

to use the following line:

Some systems may have installed Perl version 5 as "perl5".

and 0.

and Tim Bunce.

by Nick Ing-Simmons.

