 Skipper walks into the room.  =>&&0042
   my $total_size = 0; =>&&0087
 find($callback2, 'lib'); =>&&007a
 skipper_greets("Gilligan"); =>&&0015
  for my $greeted (@everyone) { =>&&0036
 for my $person (qw(Skipper Gilligan)) { =>&&0032
   print "$when: $file\n"; =>&&00bf
 my $total_size = $callback->('dummy'); # dummy parameter to get size =>&&0084
 find(\&what_to_do, @starting_directories); =>&&0063
   # Back up one day =>&&00b3
 sub {. . . body of subroutine. . . }; =>&&0048
  my $count; =>&&009f
      $total_size += -s if -f; =>&&0081
 use Time::Local; =>&&00ac
  print "Skipper: Hey there, $person!\n"; =>&&000d
 Gilligan: Sir, yes, sir, Skipper! =>&&0018
 my $start = timelocal(0, 0, 0, $day, $mon, $yr);        # midnight today =>&&00b1
 $ref_to_greeter -> ( 'Gilligan' ) =>&&0028
 sub gilligan_greets { =>&&000f
 for my $file (@files) { =>&&00bc
 ## set up the subroutines =>&&008d
 my $total_size = 0; =>&&0068
   return(sub { $total_size += -s if -f }, sub { return $total_size }); =>&&0088
     $dow += 7; =>&&00b6
  $subs{$dir}{GETTER}     = $getter; =>&&0092
=head2 7. 3. =>&&0004
 for my $greeter (@everyone) { =>&&0035
 ## show the data =>&&0096
 my $callback = create_find_callback_that_sums_the_size(  ); =>&&0083
      print "Gilligan: Sir, yes, sir, $person!\n"; =>&&0050
=head2 =>&&0001
 Professor: By my calculations, you must be Skipper! =>&&0023
 find($count_em, 'bin'); =>&&008a
 Professor: By my calculations, you must be Ginger! =>&&005e
 my @everyone = sort keys %greets; =>&&0034
    $greets{$room_person}->($person); # gets reply =>&&003f
 find(sub { $total_size += -s if -f }, '. '); =>&&0069
    print "$File::Find::name found\n"; =>&&0066
 foreach my $dir (qw(bin lib man)) { =>&&008f
   my $person = shift; =>&&001e
  return sub { =>&&007d
  return(sub { $total_size += -s if -f }, sub { return $total_size }); =>&&008c
  @starting_directories,  =>&&0067
 print "my lib:\n"; =>&&0075
 Skipper: Hey there, Professor! =>&&001b
  my $sum = $subs{$_}{GETTER}->(  ); =>&&0098
  sub count_so_far { return $count } =>&&00a1
  print "Professor: By my calculations, you must be $person!\n"; =>&&002c
 sub what_to_do { =>&&0060
 & $ref_to_greeter ( 'Gilligan' ) =>&&0027
  Professor => \&professor_greets,  =>&&0030
 & { $ref_to_greeter } ( 'Gilligan' ) =>&&0026
 print "total size of bin is $total_size\n"; =>&&0085
 use File::Find; =>&&005f
 my @starting_directories = (". "); =>&&00ae
 sub create_find_callback_that_counts { =>&&0070
    print "Professor: By my calculations, you must be $person!\n"; =>&&0055
  print "$_ has $sum bytes\n"; =>&&0099
  }; =>&&0082
    if (@_) { # it's our dummy invocation =>&&007e
 my $callback; =>&&006b
=head2 7. 8. 1. =>&&000a
   print "Professor: By my calculations, you must be $person!\n"; =>&&001f
 my $callback2 = create_find_callback_that_counts(  ); =>&&0078
 my $bigger_than_1024 = print_bigger_than(1024); =>&&009d
 my @files = $yield->(  ); =>&&00bb
  Skipper   => \&skipper_greets,  =>&&002f
 my $ref_to_greeter = \&skipper_greets; =>&&0024
 while ($dow != $target_dow) { =>&&00b2
 for (keys %subs) { =>&&0094
  my $total_size = 0; =>&&007c
=head2 7. 8. =>&&0009
  sub count_one { ++$count } =>&&00a0
  },  =>&&004d
 Gilligan: Hi, Ginger! =>&&005b
   print "$File::Find::name found\n"; =>&&0061
 sub create_find_callback_that_sums_the_size { =>&&007b
  my $person = shift; =>&&000c
 Gilligan: Hi, Professor! =>&&001c
 sub skipper_greets { =>&&000b
 print 'we have seen ', count_so_far(  ), " coconuts!\n"; =>&&00a3
=head2 7. 5. =>&&0006
  } else { =>&&0012
   $start -= $seconds_per_day;        # hope no DST! :-) =>&&00b4
 my($gather, $yield)  = gather_mtime_between($start, $stop); =>&&00b9
  push @room, $person; # come in, get comfy =>&&0040
      unless $greeter eq $greeted; # no talking to yourself =>&&0038
 Ginger: (in a sultry voice) Well hello, Gilligan! =>&&005a
  sub count_remaining { $countdown } =>&&00a6
 sub professor_greets { =>&&001d
 find($bigger_than_1024, 'bin'); =>&&009e
      print "Gilligan: Hi, $person!\n"; =>&&0052
 my $callback = create_find_callback_that_counts(  ); =>&&0072
 }; =>&&0046
   return sub { print "$File::Find::name\n" if -f and -s >= $minimum_size }; =>&&009c
 find($callback1, 'bin'); =>&&0079
  $subs{$dir}{CALLBACK}   = $callback; =>&&0091
 find($callback, '. '); =>&&006f
 my ($count_em, $get_results) = create_find_callbacks_that_sum_the_size(  ); =>&&0089
 my $total_size = &$get_results(  ); =>&&008b
=head2 7. 7. =>&&0008
 { =>&&006c
 find($callback, 'bin'); =>&&0074
=head2 7. 2. =>&&0003
 Ginger: (in a sultry voice) Well hello, Skipper! =>&&0049
 my %subs; =>&&008e
  } =>&&0014
 ); =>&&0031
 Ginger: (in a sultry voice) Well hello, Professor! =>&&005d
    if ($person eq 'Skipper') { =>&&004f
 BEGIN { =>&&00aa
 Professor walks into the room.  =>&&0043
  Skipper => sub { =>&&004a
 print "my bin:\n"; =>&&0073
 my($sec, $min, $hour, $day, $mon, $yr, $dow) = localtime; =>&&00b0
  Professor => sub { =>&&0054
    print "Gilligan: Hi, $person!\n"; =>&&0013
 professor_greets('Gilligan'); =>&&0020
 my $timestamp = (stat $file_name)[9]; =>&&00ab
 find($gather, @starting_directories); =>&&00ba
  sub count_down { $countdown-- } =>&&00a5
 professor_greets('Skipper'); =>&&0021
  for my $room_person (@room) { =>&&003d
    } =>&&0053
  my $countdown = 10; =>&&00a4
  find($subs{$_}{CALLBACK}, $_); =>&&0095
  my ($callback, $getter) = create_find_callbacks_that_sum_the_size(  ); =>&&0090
  if ($person eq 'Skipper') { =>&&002b
   my $minimum_size = shift; =>&&009b
   if (--$dow < 0) { =>&&00b5
 my $seconds_per_day = 24 * 60 * 60; =>&&00af
 $ginger->('Skipper'); =>&&0047
 my $target_dow = 1;        # Sunday is 0, Monday is 1,. . .  =>&&00ad
   my $when = localtime $mtime; =>&&00be
      return $total_size; =>&&007f
 Professor: By my calculations, you must be Gilligan! =>&&0022
  sub { =>&&0065
  $greets{$person}->('Professor'); =>&&0033
 for my $person (qw(Gilligan Skipper Professor)) { =>&&003a
    print "Ginger: (in a sultry voice) Well hello, $person!\n"; =>&&0057
    $greets{$person}->($room_person); # speaks =>&&003e
   my $mtime = (stat $file)[9];        # mtime via slice =>&&00bd
 count_one(  ); =>&&00a2
=head2 7. 1. =>&&0002
 my %greets = ( =>&&002d
 count_down(  ); =>&&00a7
 print 'we're down to ', count_remaining(  ), " coconuts!\n"; =>&&00a8
 sub create_find_callbacks_that_sum_the_size { =>&&0086
    print "Gilligan: Sir, yes, sir, $person!\n"; =>&&0011
    } else { # it's a callback from File::Find: =>&&0080
 gilligan_greets('Professor'); =>&&001a
 & skipper_greets ( 'Gilligan' ) =>&&0025
 my @room; # initially empty =>&&0039
  print "$person walks into the room. \n"; =>&&003c
 sub print_bigger_than { =>&&009a
   print "Ginger: (in a sultry voice) Well hello, $person!\n"; =>&&0045
  $greet->('Professor'); =>&&002a
  $callback = sub { print ++$count, ": $File::Find::name\n" }; =>&&006e
 Ginger walks into the room.  =>&&0059
  my $count = 0; =>&&006d
 for my $greet (\&skipper_greets, \&gilligan_greets) { =>&&0029
    $greets{$greeter}->($greeted) =>&&0037
 my $stop = $start + $seconds_per_day; =>&&00b8
 print $total_size, "\n"; =>&&006a
 for my $person (qw(Gilligan Skipper Professor Ginger)) { =>&&0058
=head2 7. 6. =>&&0007
 my $callback1 = create_find_callback_that_counts(  ); =>&&0077
  Ginger => sub { =>&&0056
=head2 7. 4. =>&&0005
 find( =>&&0064
 for (sort keys %subs) { =>&&0097
  if ($person eq "Skipper") { =>&&0010
 ## gather the data =>&&0093
 } =>&&000e
    } else { =>&&0051
  Gilligan  => \&gilligan_greets,  =>&&002e
 Gilligan walks into the room.  =>&&0041
 Skipper: Hey there, Ginger! =>&&005c
 skipper_greets('Professor'); =>&&0019
   } =>&&00b7
 find($callback, 'lib'); =>&&0076
 my @starting_directories = qw(. ); =>&&0062
 my $countdown = 10; =>&&00a9
 gilligan_greets("Skipper"); =>&&0016
  print "\n"; =>&&003b
    my $person = shift; =>&&004b
  return sub { print ++$count, ": $File::Find::name\n" }; =>&&0071
 my $ginger = sub { =>&&0044
  Gilligan => sub { =>&&004e
 Skipper: Hey there, Gilligan! =>&&0017
    print "Skipper: Hey there, $person!\n"; =>&&004c
 Skipper sorts into position 5 =>&&0018
                 return; =>&&0076
   bin                             => $skipper_bin,  =>&&004c
   map [ $_, "\U$_" ],  =>&&0031
 sub dump_data_for_path { =>&&006a
 my @sorted = sort { -s $a <=> -s $b } glob "/bin/*"; =>&&007d
         for (sort keys %directory) { =>&&0079
     return \%directory; =>&&0067
 my @numerically_descending = =>&&0008
  } } =>&&003d
                 print "$path\n"; =>&&0075
 } @names_and_pineapples; =>&&0025
 Ginger sorts into position 2 =>&&001a
   eat                 => undef,  =>&&0046
                 dump_data_for_path("$path/$_", $directory{$_}); =>&&007a
     'Things_I_should_have_packed' => undef,  =>&&004b
 $string =~ tr/A-Z/a-z/;       # force all lowercase =>&&007f
 my @ranks; =>&&0010
   ask_monkey_about($b) <=> ask_monkey_about($a) =>&&001f
                     } . . .  =>&&0070
         my $path = shift; =>&&0072
     opendir PATH, $path or die "Cannot opendir $path: $!"; =>&&0060
   map [ $_, ask_monkey_about($_) ],  =>&&002a
   return undef; =>&&005c
   if (-d $path) { . . .  =>&&005a
   sort { $a->[1] cmp $b->[1] } =>&&0030
   },  =>&&0054
 my @input = qw(Gilligan Skipper Professor Ginger Mary_Ann); =>&&000d
         $directory{$name} = data_for_path("$path/$name"); =>&&0065
   [ $_, ask_monkey_about($_) ] =>&&0022
   galley, with contents: =>&&0086
     eat                 => undef,  =>&&0053
         next if $name eq '. ' or $name eq '. . '; =>&&0064
 my $skipper_bin = { =>&&0043
 uss_minnow, with contents: =>&&0083
   discipline_gilligan => undef,  =>&&0045
 use Data::Dumper; =>&&0068
   print "$input[$_] sorts into position $ranks[$_]\n"; =>&&0015
 Gilligan sorts into position 1 =>&&0017
                     print "$path\n"; =>&&006e
             my $data = shift; =>&&006c
   if ($a < $b)    { -1 } =>&&0004
   broken_radio =>&&0085
 my $skipper_home = { =>&&0048
     tuna_fish_sandwich =>&&0089
   elsif ($a > $b) { +1 } =>&&0005
   map $_->[0],  =>&&0028
   qw(Gilligan Skipper Professor Ginger Mary_Ann Thurston Lovey); =>&&001d
   cp   => undef,  =>&&0040
  }; =>&&0047
     return undef; =>&&0058
   if (-f $path or -l $path) {        # files or symbolic links =>&&005d
             } =>&&0071
 my @sorted_names_and_pineapples = sort { =>&&0023
 my $bin_directory = { =>&&003e
 my @castaways = =>&&001c
 $string =~ tr/a-z//cd;        # strip all but a-z from the string =>&&0080
 print "@ranks\n"; =>&&0012
     captain_crunch_cereal =>&&0087
 1; =>&&008c
 my @sorted_positions = sort { $input[$a] cmp $input[$b] } 0. . $#input; =>&&000e
         if (not defined $data) { # plain file =>&&0074
 Mary_Ann sorts into position 3 =>&&001b
     discipline_gilligan => undef,  =>&&0052
 sub data_for_path { =>&&0055
 my @sorted = sort qw(Gilligan Skipper Professor Ginger Mary_Ann); =>&&0001
  sort { SORT COMPARISON USING $a->[1] AND $b->[1] or =>&&0033
 @ranks[@sorted_positions] = (0. . $#sorted_positions); =>&&0011
 } 1, 2, 4, 8, 16, 32; =>&&0007
   date => undef,  . . . and so on. . .  =>&&0041
   my $path = shift; =>&&0056
 my @names_and_pineapples = map { =>&&0021
   Things_I_should_have_packed => undef,  =>&&004f
 Gilligan Ginger Mary_Ann Professor Skipper =>&&000c
  } else { =>&&003b
     navigate            => undef,  =>&&0051
         } =>&&0077
                     return; =>&&006f
 my @names = =>&&0027
    sort { $b <=> $a } 1, 2, 4, 8, 16, 32; =>&&000a
 }; =>&&0042
     } =>&&0066
 sub navigation_turn_toward_port { . . code here. .  =>&&008b
 @ranks[@sorted_positions] = (1. . @sorted_positions); =>&&0013
 my @numerically_sorted = sort { =>&&0003
     my %directory; =>&&005f
             if (not defined $data) { # plain file =>&&006d
  @input_data; =>&&0037
   @castaways; =>&&002b
 my @wrongly_sorted = sort 1, 2, 4, 8, 16, 32; =>&&0002
 print "@sorted_positions\n"; =>&&000f
     for my $name (@names) { =>&&0063
   life_preservers =>&&008a
 for (0. . $#ranks) { =>&&0014
     'Please_rescue_us. pdf'        => undef,  =>&&004a
  my $n = shift; =>&&0038
      YET ANOTHER USING $a->[3] AND $b->[3] } =>&&0035
   '. cshrc'                    => undef,  =>&&004d
             my $path = shift; =>&&006b
 sandbar, an empty directory =>&&0082
  map [ $_, SOME FUNCTION OF $_, ANOTHER, YET ANOTHER ],  =>&&0036
     gallon_of_milk =>&&0088
 my @names = map $_->[0], @sorted_names_and_pineapples; =>&&0026
   if (-f $path) { =>&&0057
   navigate            => undef,  =>&&0044
   if (-d $path) { =>&&005e
   Please_rescue_us. pdf        => undef,  =>&&004e
   bin => { =>&&0050
 find. -print =>&&007c
    reverse sort { $a <=> $b } 1, 2, 4, 8, 16, 32; =>&&0009
 my $string = 'Mary-Ann'; =>&&007e
   $b->[1] <=> $a->[1]; =>&&0024
   anchor =>&&0084
 print Dumper(data_for_path('. ')); =>&&0069
         my $data = shift; =>&&0073
   map [ $_, EXPENSIVE FUNCTION OF $_ ],  =>&&002e
   sort { SORT COMPARISON USING $a->[1] AND $b->[1] } =>&&002d
 print "@sorted\n"; =>&&000b
 } =>&&0016
 my @wasters = sort { =>&&001e
    return $n * factorial($n - 1); =>&&003c
 my @output_data = =>&&002c
   '. cshrc'                        => undef,  =>&&0049
 dump_data_for_path('. ', data_for_path('. ')); =>&&007b
   warn "$path is neither a file nor a directory\n"; =>&&005b
         my %directory = %$data; =>&&0078
    return 1; =>&&003a
 print $string;                # prints "maryann" =>&&0081
   cat  => undef,  =>&&003f
   else            {  0 } =>&&0006
   } =>&&0059
 Professor sorts into position 4 =>&&0019
     closedir PATH; =>&&0062
 } @castaways; =>&&0020
   @input_data; =>&&002f
  map $_->[0],  =>&&0032
     my @names = readdir PATH; =>&&0061
   sort { $b->[1] <=> $a->[1] } =>&&0029
          ANOTHER USING $a->[2] AND $b->[2] or =>&&0034
  if ($n <= 1) { =>&&0039
   print "Current heading is ", $current_heading, ". \n"; =>&&0004
 die $@ if $@; =>&&001c
 require 'drop_anchor. pm'; =>&&0022
   my $direction = 'right'; =>&&0006
 sub compute_heading_to_island { . . code here. .  =>&&0033
 # back to package Navigation =>&&0045
   package main;  # now in package main =>&&0042
 sub main::turn_toward_heading { . . code here. .  =>&&0040
   eval $more_code; =>&&0019
   sub turn_toward_heading {  # main::turn_toward_heading . . code here. .  =>&&0043
 {  # start scope block =>&&0041
   if ($turn > 180) { # long way around =>&&0008
 do 'navigation. pm'; =>&&001b
 drop_anchor(  ) if at_dock(  ); =>&&0021
 use lib $Bin; =>&&002a
 @destination = @Navigation::homeport; =>&&003f
 perl -I/home/skipper/perl-lib /home/skipper/bin/get_us_home =>&&002f
   die $@ if $@; =>&&001a
     print "On course (good job!). \n"; =>&&0012
 Current heading is 234.  =>&&000f
 }  # end scope block =>&&0044
   open MORE_CODE, 'navigation. pm' or die "navigation. pm: $!"; =>&&0015
 turn_toward_heading(90); . . .  =>&&0020
 unshift @INC, '/home/skipper/perl-lib'; =>&&0025
 sub load_common_subroutines { =>&&0014
 sub turn_toward_port { . . code. .  =>&&003e
   my $current_heading = current_heading(  ); =>&&0003
 1; =>&&0039
 #!/usr/bin/perl =>&&0030
 sub turn_toward_port { . . code here. .  =>&&0038
 my ($new_heading) = @_; =>&&000e
 use FindBin qw($Bin); =>&&0029
   print "by turning $direction $turn degrees. \n"; =>&&000c
 sub turn_toward_heading { . . code here. .  =>&&0037
   Navigation::turn_toward_heading(compute_heading_to_island(  )); =>&&003c
 @homeport = (21. 283, -157. 842); =>&&003d
 Come about to 234 by turning right 0 degrees.  =>&&0010
   my $turn = ($new_heading - $current_heading) % 360; =>&&0007
 }; =>&&0028
 @month = qw(diz pod bod rod sip wax lin sen kun fiz nap dep); =>&&004b
 use lib "$Bin/lib";    # in a subdirectory =>&&002b
   my $more_code = <MORE_CODE>; =>&&0017
 drop_anchor(  ) if at_dock(  ) or in_port(  ); =>&&001f
 BEGIN { =>&&0026
 require 'navigation. pm'; =>&&0023
 sub navigation_turn_toward_heading { . . code here. .  =>&&0035
 sub turn_toward_port { =>&&0031
 setenv PERL5LIB /home/skipper/perl-lib =>&&002d
   turn_toward_heading(compute_heading_to_island(  )); =>&&0032
   print "Come about to $new_heading "; =>&&0005
   my $new_heading = shift; =>&&0002
   navigation_turn_toward_heading(compute_heading_to_island(  )); =>&&0034
   my @homeport; =>&&0048
 sub turn_toward_port { # Navigation::turn_toward_port . . code here. .  =>&&0046
 my($sec, $min, $hour, $mday, $mon, $year, $wday) = localtime; =>&&004c
 PERL5LIB=/home/skipper/perl-lib; export PERL5LIB =>&&002e
 sub Navigation::turn_toward_heading { . . code here. .  =>&&003a
     $direction = 'left'; =>&&000a
     return; =>&&0013
     $turn = 360 - $turn; =>&&0009
 } =>&&000d
 sub number_to_day_name { my $num = shift @_; $day[$num]; } =>&&004a
 use lib "$Bin/. . /lib"; # up one, then down into lib =>&&002c
   unshift @INC, '/home/skipper/perl-lib'; =>&&0027
   close MORE_CODE; =>&&0018
 die $@ if $@; . . .  =>&&001e
 do 'drop_anchor. pm'; =>&&001d
   } =>&&000b
 package Navigation; =>&&0036
 @day = qw(ark dip wap sen pop sep kir); =>&&0049
 perl -le 'print for @INC' =>&&0024
 sub get_me_home { =>&&0047
   undef $/; # enable slurp mode =>&&0016
 sub turn_toward_heading { =>&&0001
 sub Navigation::turn_toward_port { . . code here. .  =>&&003b
   unless ($turn) { =>&&0011
   sub sound { "moooo" } =>&&0027
 Sheep->speak; =>&&0013
   sub speak {. . . } . . .  =>&&003d
   print "a Cow goes moooo!\n"; =>&&0002
 use Animal; =>&&0033
 Animal::speak('Cow'); =>&&0028
 sub Horse::speak { =>&&0004
 # which invokes Cow->sound, returning 'moooo', so =>&&002c
 use vars qw(@ISA); =>&&0030
 [but you can barely hear it!] =>&&003a
 a Sheep goes baaaah! =>&&000d
   sub sound { 'neigh' } =>&&0024
 $beast->method(@args); =>&&0048
   sub sound { 'moooo' } =>&&001e
     $class->Animal::speak(@_); =>&&0043
 { package Animal; =>&&0025
 foreach my $beast (@pasture) { =>&&000f
     my $class = shift; =>&&0020
     Animal::speak(. . . ); =>&&0041
 { package Cow; =>&&001d
   print "a Horse goes neigh!\n"; =>&&0005
 ('Class', @args) =>&&0049
 sub Cow::speak { =>&&0001
 print "a $class goes ", $class->sound, "!\n"; =>&&0029
 our @ISA = qw(Animal); =>&&0032
 { package Mouse; =>&&0035
 { package LivingCreature; =>&&003c
     print "a $class goes ", $class->sound, "!\n"; =>&&0021
   print "a Sheep goes baaaah!\n"; =>&&0007
 Class->method(@args); =>&&0046
   print "a $class goes neigh!\n"; =>&&001c
 @ISA = qw(Animal); =>&&0031
 @Cow::ISA = qw(Animal); =>&&002e
 a Cow goes moooo! =>&&000b
 print 'a Cow goes ', Cow->sound, "!\n"; =>&&002b
 sub Sheep::speak { =>&&0006
   my $class = shift; =>&&0019
 Horse::speak; =>&&0009
 my $beast = 'Cow'; =>&&0014
 Horse->speak; =>&&0012
 { package Horse; =>&&0023
   $beast->speak; =>&&0016
 use base qw(Animal); =>&&0034
   sub speak { . . .  =>&&0040
     print "[but you can barely hear it!]\n"; =>&&0037
 # but $class is Cow, so. . .  =>&&002a
 print 'a Cow goes ', 'moooo', "!\n"; =>&&002d
     $class->SUPER::speak; =>&&0044
 $beast->speak;                # invokes Cow->speak =>&&0015
 my @pasture = qw(Cow Cow Horse Sheep Sheep); =>&&000e
   &{$beast. "::speak"};                # Symbolic coderef =>&&0010
 Class->method(@args) =>&&0017
 Sheep::speak; =>&&000a
   print "a $class goes moooo!\n"; =>&&001b
   sub speak { =>&&001f
   } . . .  =>&&0042
   sub sound { 'squeak' } =>&&0036
 Cow::speak; =>&&0008
 Class::method('Class', @args); =>&&0018
 $class->SUPER::speak(@_); =>&&0045
   print "a $class goes baaaah!\n"; =>&&001a
 Cow->speak; =>&&0011
 Mouse->speak; =>&&0038
   # no definition for speak(  ) . . .  =>&&003f
 package Cow; =>&&002f
   @ISA = qw(Animal); =>&&0026
 } =>&&0003
   @ISA = qw(LivingCreature); =>&&003e
   } =>&&0022
 a Horse goes neigh! =>&&000c
 a Mouse goes squeak! =>&&0039
     Animal::speak($class); =>&&003b
 my $beast = 'Class'; =>&&0047
   my $input = $_; =>&&0019
 my @lunch_choices = grep &is_edible($_), @gilligans_posessions.  =>&&0004
   my @digits = split //, $input;   # Assume no nondigit characters =>&&001a
        my $sum; =>&&000e
 my $count = grep { =>&&0017
        my @digits = split //, $_; =>&&0027
 or die "Can't create 'ship. txt': $!";        # user-defined die? =>&&0030
        } =>&&002c
        my @digits = split //, $input;  # Assume no nondigit characters =>&&000d
        if ($digits[-1] =  = 4) { =>&&0028
 foreach my $operator ( qw(+ - * /) ) { =>&&0039
   $sum += $_ for @digits; =>&&001c
 &implement($_) foreach @rescue_scheme;        # die inside sub? =>&&0031
 my $average = eval { $total / $count } ; =>&&0035
 my @end_in_4 = grep /4$/, @input_numbers; =>&&0009
   my $sum; =>&&001b
 my @castaways = reverse qw(Gilligan Skipper Ginger Professor Mary-Ann); =>&&0003
 print 'Two castaways are ', 'Gilligan', ' and ', 'Skipper', "\n"; =>&&0001
 my @input_numbers = (1, 2, 4, 8, 16, 32, 64); =>&&0007
          (  ); =>&&002b
 my @results = grep EXPR, @input_list; =>&&0005
 eval { &rescue_scheme_42 } ; =>&&0034
 my @result = map { =>&&0026
 my %hash = @result; =>&&0023
 #!/usr/bin/perl =>&&0038
 eval '$sum = 2 + 2'; =>&&0036
 my @odd_digit_sum = grep { =>&&0018
 sub digit_sum_is_odd { =>&&000b
 print 'The quotient is ', eval '5 /', "\n"; =>&&003c
   code; =>&&0015
        } else { =>&&002a
   of; =>&&0014
 my @results = grep { =>&&0012
 my $average = $total / $count;                # divide by zero? =>&&002d
 print "Continuing after error: $@" if $@; =>&&0033
 my @result = map { $_, 3 * $_ } @input_numbers; =>&&0022
 eval { $average = $total / $count } ; =>&&0032
 my %hash = map { $_, 3 * $_ } @input_numbers; =>&&0024
 } @input_numbers; =>&&001e
 my @castaways = sort qw(Gilligan Skipper Ginger Professor Mary-Ann); =>&&0002
  } @input_numbers; =>&&0020
        return $sum % 2; =>&&0010
        my $input = shift; =>&&000c
 open MINNOW, '>ship. txt' =>&&002f
 } @input_list; =>&&0016
   $sum += $_ for split //; =>&&001f
 print "okay\n" unless /$match/;                # illegal pattern? =>&&002e
 my @result = map { split //, $_ } @input_numbers; =>&&0025
 my @result = map $_ + 100, @input_numbers; =>&&0021
 warn $@ if $@; =>&&003d
 print "The sum is $sum\n"; =>&&0037
 my $count   = grep EXPR, @input_list; =>&&0006
 } =>&&0011
 my @bigger_than_10 = grep $_ > 10, @input_numbers; =>&&0008
   block; =>&&0013
 syntax error at (eval 1) line 2, at EOF =>&&003e
   $sum % 2; =>&&001d
        my $result = eval "2 $operator 2"; =>&&003a
 my @odd_digit_sum = grep digit_sum_is_odd($_), @input_numbers; =>&&000a
        print "2 $operator 2 is $result\n"; =>&&003b
          @digits; =>&&0029
        $sum += $_ for @digits; =>&&000f
 my $tv_horse = =>&&0054
 $tv_horse->eat('hay'); =>&&002d
   $self->{Color} = shift; =>&&0042
     $self->{Color}; =>&&0067
 ## in Animal =>&&0033
 Mr. Ed eats hay.  =>&&002f
     : "an unnamed $either";   # it's a class, return generic =>&&001e
 my $noise = $tv_horse->sound; =>&&000e
 ## in Sheep =>&&003b
 sub default_color { 'brown' } =>&&003d
 sub named { =>&&0036
     my $old = $self->{Color}; =>&&004f
 Mr. Ed says neigh.  =>&&0013
 sub class_only { =>&&006c
   Horse->named('Mr. Ed') =>&&0055
 print $tv_horse->name, ' is colored ', $tv_horse->color, "\n"; =>&&0044
     # this method call is not in void context, so =>&&004d
     my $either = shift; =>&&0023
   $self->{Color} = [@_];                # set colors to remaining parameters =>&&005f
     $old; =>&&0051
   ref(my $self = shift) or croak "instance variable needed"; . . . use $self as the instance. . .  =>&&006b
 use Color::Conversions qw(color_name_to_rgb rgb_to_color_name); . . .  =>&&005a
   sub sound { 'neigh' } =>&&0009
   print $either->name, ' goes ', $either->sound, "\n"; =>&&0022
   if (@_) {              # are there any more parameters? =>&&0064
 { package Animal; =>&&0001
 sub color     { $_[0]->{Color} } =>&&0062
     my $class = shift; =>&&0003
   my $either = shift; =>&&001b
   if (defined wantarray) { =>&&004c
   } else { =>&&0052
 sub get_color_rgb { =>&&0060
 a Horse=SCALAR(0xaca42ac) goes neigh! =>&&0019
 instance variable needed at their_code line 1234 =>&&006e
     : "an unnamed $either"; =>&&0035
     my $self = shift; =>&&0011
     ref $either =>&&0024
 sub set_color { =>&&0041
     print "a $class goes ", $class->sound, "!\n" =>&&0004
 sub set_color_rgb { =>&&005e
 print Horse->name, "\n";      # prints "an unnamed Horse\n" =>&&001f
   rgb_to_color_name($self->{Color});               # takes arrayref =>&&005d
       : "an unnamed $either"; # it's a class, return generic =>&&0026
 { package Sheep; =>&&002b
       ? $$either # it's an instance, return name =>&&0025
     bless \$name, $class; =>&&0016
   my $name = shift; =>&&0038
 $tv_horse->speak; =>&&0018
 Animal::eat($tv_horse, 'hay'); =>&&0031
   my $class = shift; =>&&0037
 print Sheep->name, ' colored ', Sheep->color, ' goes ', Sheep->sound, "\n"; =>&&0072
 my $name = 'Mr. Ed'; =>&&000b
     print $either->name, ' goes ', $either->sound, "\n"; =>&&0027
        ->set_color('grey') =>&&0056
   $self->{Color}; =>&&0040
     # this method call is in void context =>&&0053
 $tv_horse->set_color( $eating->set_color( color_from_user(  ) )); =>&&0046
     # no, it's a getter: =>&&0066
 Horse::sound($tv_horse) =>&&000f
     ? $$either                # it's an instance, return name =>&&001d
 my $lost = bless { Name => 'Bo', Color => 'white' }, Sheep; =>&&0032
   my $old = $self->{Color}; =>&&004a
 { package Horse; =>&&0007
   $tv_horse->set_color($old_color); =>&&0049
     $self->{Color} = shift; =>&&0050
 { =>&&0047
 $tv_horse->set_color('grey'); =>&&0070
 $tv_horse->color('black-and-white'); =>&&0068
 sub default_color { 'white' } =>&&003c
 Sheep->eat('grass'); =>&&002e
     my $name = shift; =>&&0015
 an unnamed Sheep eats grass.  =>&&0030
 $tv_horse->set_color('black-and-white'); =>&&0043
 sub set_color { $_[0]->{Color} = $_[1] } =>&&0063
   ref $either =>&&001c
   my $new_color = shift; =>&&005b
 sub name { =>&&001a
     # yes, it's a setter: =>&&0065
   sub speak { =>&&0002
 my $tv_horse = \$name; =>&&000c
     # the return value matters =>&&004e
   ref(my $class = shift) and croak "class name needed"; . . . use $class as the class. . .  =>&&006d
 Mr. Ed is colored black-and-white =>&&0045
   $self->{Color} = color_name_to_rgb($new_color);  # arrayref =>&&005c
 sub speak { =>&&0021
     ? $either->{Name} =>&&0034
   sub name { =>&&0010
 print $tv_horse->name, "\n";   # prints "Mr. Ed. \n" =>&&0020
        ->set_age(4) =>&&0057
   sub eat { =>&&0028
 print $tv_horse->name, ' is ', $tv_horse->color, "\n"; =>&&0071
     print $either->name, " eats $food. \n"; =>&&002a
   sub sound { 'baaaah' } =>&&002c
   @{ $self->{Color} };                  # return RGB list =>&&0061
   @ISA = qw(Animal); =>&&0008
   my $old_color = $tv_horse->set_color('orange'); . . . do things with $tv_horse. . .  =>&&0048
 } =>&&0006
   sub named { =>&&0014
 bless $tv_horse, 'Horse'; =>&&000d
 use Carp qw(croak); =>&&0069
 my $tv_horse = Horse->named('Mr. Ed'); =>&&0017
   $old; =>&&004b
   bless $self, $class; =>&&003a
   } =>&&0005
 a Horse goes neigh! =>&&000a
 sub instance_only { =>&&006a
   $self; =>&&0059
        ->set_height('17 hands'); =>&&0058
   my $self = { Name => $name, Color => $class->default_color }; =>&&0039
   my $self = shift; =>&&003f
     my $food = shift; =>&&0029
 sub color { =>&&003e
     $$self; =>&&0012
 $tv_horse->set_name('Mister Ed'); =>&&006f
  my @data2 = qw(two too to); =>&&003d
  jacket =>&&007a
 ginger. girl. hut maryann. girl. hut 199 . . .  =>&&009d
    name     => 'Skipper',  =>&&0073
 my @data1 = qw(one won); =>&&0038
 my $ref_to_skipper_provisions; =>&&0047
  'The Skipper',  =>&&004d
 Gilligan =>&&0080
 my $not_yet; =>&&0093
    \@gilligan_with_name,  =>&&0030
  $fruits = \@secret_variable; =>&&0052
 my $top; =>&&0095
 my $second_reference_to_skipper = $reference_to_skipper; =>&&0003
 ],  =>&&0059
 push @$ref, 'sextant'; # add a new provision =>&&0016
 professor. hut gilligan. crew. hut 1250 =>&&0097
    die "I don't understand: $_"; =>&&008d
  for my $destination (sort keys %{ $total_bytes{$source} }) { =>&&00a6
    position => 'Captain',  =>&&0076
 my $ref; =>&&000f
 print "$ref->[2]\n"; # still prints jacket\n =>&&0015
 my @all_with_names; =>&&0026
 @skipper =>&&0005
 @$not_yet = (1, 2, 3); =>&&0092
  my @professor_with_name = ('The Professor', \@professor); =>&&002a
 sub get_provisions_list { =>&&0033
  [ qw(blue_shirt hat jacket preserver sunscreen) ]; =>&&0046
  name     => 'Gilligan',  =>&&005b
 my $copy_of_ref = $ref; =>&&0018
  } elsif (/^\s+(\S. *)/) { # a provision =>&&0089
 my @skipper_with_name = ( =>&&004c
  push @data1, \@data2; . . . use @data1, @data2. . .  =>&&003f
  print "$ref->[2]\n"; # prints jacket\n =>&&0013
 push @{ $provisions{'The Skipper'} }, "blue_shirt"; =>&&0090
    \@skipper_with_name,  =>&&002e
  my @professor = qw(sunscreen water_bottle slide_rule batteries radio); =>&&0034
 $not_yet = [  ]; # inserted through autovivification =>&&0094
  $ref_to_gilligan_info = \%gilligan_info; =>&&006b
  my @data1 = qw(one won); =>&&003c
 my @gilligan = qw(red_shirt hat lucky_socks water_bottle); =>&&001f
 my @professor_with_name = ('The Professor', \@professor); =>&&001e
 my $ref_to_gilligan_info; =>&&0065
   [  ] =>&&0058
  $ref        = \@skipper; =>&&0012
 my @all_with_names = ( =>&&0021
 @$third_reference_to_skipper =>&&0008
 my $ref_to_skipper_info = { =>&&006e
    ['The Professor', [qw(sunscreen water_bottle slide_rule radio)  ] ],  =>&&0055
    ['Gilligan', [qw(red_shirt hat lucky_socks water_bottle)   ] ],  =>&&0056
        \@gilligan_with_name,  =>&&0024
 initialize_provisions_list(  ); =>&&0032
  if (/^(\S. *)/) { # a person's name (no leading whitespace) =>&&0086
 my $reference_to_skipper = \@skipper; =>&&0002
   for my $destination (keys %{ $total_bytes{$source} }) { . . . .  =>&&00a4
 for my $source (sort keys %total_bytes) { =>&&00a5
        \@professor_with_name,  =>&&0023
    shirt    => 'Blue',  =>&&0075
  hat      => 'White',  =>&&005c
 for my $source (keys %total_bytes) { . . .  =>&&00a2
  @data2 = (  ); =>&&0042
 my @skipper_with_name; =>&&0043
  my @gilligan = qw(red_shirt hat lucky_socks water_bottle); =>&&002b
    position => 'First Mate',  =>&&006a
    hat      => 'Black',  =>&&0074
    push @{ $provisions{$person} }, $1; =>&&008b
 my %gilligan_info = ( =>&&005a
  shirt    => 'Blue',  =>&&0062
 my @crew = ( =>&&0070
  push @data2, \@data1; =>&&003e
  blue_shirt =>&&0078
 $ref = undef; # not yet. . .  =>&&001a
 push @data1, \@data2; =>&&003b
    hat      => 'White',  =>&&0068
       my @professor = qw(sunscreen water_bottle slide_rule batteries radio); =>&&0029
  my %gilligan_info = ( =>&&0066
 my %provisions; =>&&0083
 my @gilligan_with_name  = ('Gilligan', \@gilligan); =>&&0020
  },  =>&&0072
  position => 'First Mate',  =>&&005e
 for my $source (keys %total_bytes) { =>&&00a3
  sunscreen =>&&007c
 my $ref_to_skipper_provisions = =>&&0045
 my @passengers = (\%passenger_1, \%passenger_2); =>&&00b5
  } else { =>&&008c
    \@professor_with_name,  =>&&002f
  @data1 = (  ); =>&&0041
 Professor =>&&007d
        ); =>&&0025
  preserver =>&&007b
 $top->[2]->[4] = 'lee-lou'; =>&&0096
   $total_bytes{$source}{$destination} += $bytes; =>&&00a0
  @all_with_names = ( # set global =>&&002d
 }; =>&&006d
 { =>&&0010
 ); =>&&004f
  shirt    => 'Red',  =>&&005d
  hat =>&&0079
  } =>&&008e
  ( qw(blue_shirt hat jacket preserver sunscreen) ); =>&&0049
 print "$ref->[-1]\n"; # prints sextant\n =>&&0017
  hat           => 'bonnet',  =>&&00b3
 my %passenger_2 = { =>&&00b0
 { # naked block . . .  =>&&000c
 push @data2, \@data1; =>&&003a
  [ qw(blue_shirt hat jacket preserver sunscreen) ] =>&&004e
  my @gilligan_with_name = ('Gilligan', \@gilligan); =>&&002c
 while (<>) { =>&&0085
  return ( =>&&0035
  name       => 'Ginger',  =>&&00ab
    $provisions{$person} = [  ] unless exists $provisions{$person}; =>&&0088
  age        => 22,  =>&&00ac
    ['The Skipper', [qw(blue_shirt hat jacket preserver sunscreen)] ],  =>&&0054
  @skipper_with_name = ('The Skipper', \@skipper); =>&&0044
 my %skipper_info = ( =>&&005f
  ); =>&&0031
    $person = $1; =>&&0087
     " $total_bytes{$source}{$destination} bytes\n"; =>&&00a8
  lucky_socks =>&&0082
 professor. hut lovey. howell. hut 910 =>&&0098
 my $person; =>&&0084
    die 'No person yet!' unless defined $person; =>&&008a
 sub initialize_provisions_list { =>&&0027
    name     => 'Gilligan',  =>&&0067
 $total_bytes{'professor. hut'}{'gilligan. crew. hut'} += 1250; =>&&00a1
  name     => 'Skipper',  =>&&0060
  hat      => 'Black',  =>&&0061
 my @skipper = qw(blue_shirt hat jacket preserver sunscreen); =>&&0001
 my $not_yet;                # new undefined variable =>&&0091
  age           => 19,  =>&&00b2
  red_shirt =>&&0081
 $reference_to_skipper = undef; =>&&000a
 my @skipper =. . . ; =>&&000b
 professor. hut laser3. copyroom. hut 2924 =>&&009b
        \@skipper_with_name,  =>&&0022
 my @all_with_names = get_provisions_list(  ); =>&&0036
 my $gilligan_stuff = $all_with_names[2][1]; =>&&0037
  # at the end: =>&&0040
  real_age   => 35,  =>&&00ae
 my $third_reference_to_skipper  = \@skipper; =>&&0004
 my @professor = qw(sunscreen water_bottle slide_rule batteries radio); =>&&001d
  my @skipper_with_name = ('The Skipper', \@skipper); =>&&0028
  my @temporary_name = =>&&0048
 ['Mrs. Howell',  =>&&0057
 ginger. girl. hut professor. hut 1218 =>&&009c
 my $ref = \@skipper; . . .  . . .  =>&&000d
  favorite_food => 'corn',  =>&&00b4
  $ref_to_skipper_provisions = \@temporary_name; =>&&004a
  water_bottle =>&&007e
 @$second_reference_to_skipper =>&&0007
 check_provisions_list(\@skipper) =>&&0009
  position => 'Captain',  =>&&0063
 } =>&&0014
  hat        => undef,  =>&&00af
  name          => 'Mary Ann',  =>&&00b1
  my @secret_variable = ('pineapple', 'papaya', 'mango'); =>&&0051
 The Skipper =>&&0077
  my @skipper = qw(blue_shirt hat jacket preserver sunscreen); =>&&0011
 my @crew = (\%gilligan_info, \%skipper_info); =>&&0064
 professor. hut lovey. howell. hut 450 =>&&009a
 $copy_of_ref = undef; # poof! =>&&001b
 my %passenger_1 = { =>&&00aa
 my $copy_of_ref = \@$ref; =>&&0019
    shirt    => 'Red',  =>&&0069
 my %total_bytes; =>&&009e
  { =>&&0071
 @$reference_to_skipper =>&&0006
 my @skipper_with_name   = ('The Skipper', \@skipper); =>&&001c
 my @skipper_with_name = ('The Skipper', $ref_to_skipper_provisions); =>&&004b
 my $fruits; =>&&0050
 my $fruits = ['pineapple', 'papaya', 'mango']; =>&&0053
 } # $ref goes out of scope at this point =>&&000e
 my @data2 = qw(two too to); =>&&0039
  print "\n"; =>&&00a9
   my ($source, $destination, $bytes) = split; =>&&009f
  slide_rule =>&&007f
    ## $provisions{$person} = [  ] unless exists $provisions{$person}; =>&&008f
  occupation => 'Movie Star',  =>&&00ad
 thurston. howell. hut lovey. howell. hut 1250 =>&&0099
 my @crew = ($ref_to_gilligan_info, $ref_to_skipper_info); =>&&006f
 my $ref_to_gilligan_info = { =>&&006c
    print "$source => $destination:",  =>&&00a7
 open my $log_fh, '>>', 'castaways. log' =>&&0017
        print "I found $file!\n"; =>&&0057
 open $log_fh, '>> castaways. log' =>&&000a
      print $OUT $line; =>&&0034
        (my $out = $file) =~ s/\. input$/. output/; =>&&0023
 use IO::Scalar; =>&&0037
        } =>&&003e
 open my $fh, "castaways. log" =>&&0014
   my $fh = shift; =>&&0012
 while (@handlepairs) { =>&&0028
        print "Skipper, I found $file!\n"; =>&&0053
 $temp_fh->close; =>&&001f
        or die "Could not append to string! $!"; =>&&0040
 # prints to $log_fh and $scalar_fh =>&&004f
    defined($line = <IN>) and print $OUT $line; =>&&0036
   print $fh @_, "\n"; =>&&0013
 foreach my $file  ( readdir( $dh ) ) { =>&&0052
 my $message = <$tee_fh>; =>&&004e
 $tee_fh = IO::Tee->new( $log_fh, $scalar_fh ); =>&&004a
 # reads from $read_fh =>&&004d
    my ($IN, $OUT) = @$_; =>&&0032
 my $append_fh = IO::File->new( 'castaways. log', O_WRONLY|O_APPEND ); =>&&001d
 my @handlepairs; =>&&0021
 use IO::Dir; =>&&0054
        or die "Could not create filehandle: $!"; =>&&001a
        next unless /Gilligan/; =>&&003c
   @handlepairs = grep { =>&&0029
 Skipper: 3 coconuts =>&&005c
 $dir_fh->rewind; =>&&0059
 print {$log_fh} "We have no bananas today!\n"; =>&&0010
 while( <$scalar_fh> ) { =>&&003b
 while( <$log_fh> ) {. . . } =>&&0016
                (IO::File->new('<$file') || die),  =>&&0025
 print $tee_fh $message; =>&&0050
 use IO::File; =>&&0018
    if (defined(my $line = <$IN>)) { =>&&0033
        or die "Could not open castaways. log"; =>&&0042
         or die "Could not open castaways. log: $!"; =>&&000c
 my $write_fh = IO::File->new( 'castaways. log', 'w' ); =>&&001c
        push @handlepairs, [ =>&&0024
  @handlepairs = grep { =>&&0031
 print $log_fh    $log_message; =>&&0045
 my $scalar_fh = IO::Scalar->new( \$string_log ); =>&&0039
        print "I can still find $file!\n"; =>&&005a
 print $tee_fh "The radio works in the middle of the ocean!\n"; =>&&004b
 opendir my $dh, '. ' or die "Could not open directory: $!"; =>&&0051
  } @handlepairs; =>&&002f
  print FH @_, "\n"; =>&&0007
 while( <LOG_FH> ) {. . . } =>&&0015
    } =>&&002e
 print $scalar_fh "The Howells' private beach club is closed\n"; =>&&003a
  local *FH = shift; =>&&0006
 # time passes =>&&0058
        ]; =>&&0027
        print; =>&&003d
    if (defined(my $line = $_->[0]->getline)) { =>&&002a
                (IO::File->new('>$out') || die),  =>&&0026
      0; =>&&002d
 log_message( *LOG_FH, 'An astronaut passes overhead' ); =>&&0004
 open( my $fh, '>>', \$string_log ) =>&&003f
 my $read_fh  = IO::File->new( 'castaways. log', 'r' ); =>&&001b
 Ginger: 2 papayas =>&&005e
    my $line; =>&&0035
 my $temp_fh = IO::File->new_tmpfile; =>&&001e
 Gilligan: 1 coconut =>&&005b
 my $log_message = "The Minnow is taking on water!\n" =>&&0044
 while( defined( my $file = $dir_fh->read ) ) { =>&&0056
 open my $scalar_fh, '>>', \$string; =>&&0043
        or die "Could not open castaways. log: $!"; =>&&0002
 $tee_fh = IO::Tee->new( $read_fh, $log_fh, $scalar_fh ); =>&&004c
 my $fh = IO::File->new( '> castaways. log' ) =>&&0019
 @handlepairs = grep { CONDITION } @handlepairs; =>&&0030
 foreach my $file ( glob( '*. input' ) ) { =>&&0022
 foreach my $fh ( $log_fh, $scalar_fh ) { =>&&0047
 my $dir_fh = IO::Dir->new( '. ' ) || die "Could not open dirhandle! $!\n"; =>&&0055
 open LOG_FH, '>> castaways. log' =>&&0001
 MaryAnn: 2 papayas . . .  =>&&0060
        print $fh $log_message; =>&&0048
 } =>&&0008
 my $log_fh; =>&&0009
    } else { =>&&002c
 Professor: 3 coconuts =>&&005f
 my $log_fh = 5; =>&&000b
 print $log_fh "We have no bananas today!\n"; =>&&000f
 my $string_log = ''; =>&&0038
      print { $_->[1] } $line; =>&&002b
 print $scalar_fh $log_message; =>&&0046
 log_message( $log_fh, 'My name is Mr. Ed' ); =>&&0011
 sub log_message { =>&&0005
 my $string = ''; =>&&0041
 undef $append_fh; =>&&0020
 Gilligan: 1 banana =>&&005d
 open my $log_fh, '>> castaways. log' =>&&000e
 log_message( *LOG_FH, 'The Globetrotters are stranded with us!' ); =>&&0003
 use IO::Tee; =>&&0049
 print $log_fh "We need more coconuts!\n";   # doesn't work =>&&000d
 $ perl Makefile. PL PREFIX=/Users/home/Ginger =>&&0023
 my $filespec = File::Spec->catfile( $homedir{gilligan},  =>&&0016
 *** Please report bugs to <cpanplus-bugs@lists. sourceforge. net>.  =>&&003e
 use File::Spec; =>&&0015
 $ export PERL5LIB=/Users/home/Ginger =>&&0024
         $dirname = dirname($fullname); =>&&000b
 ReadLine support available (try 'install Bundle::CPAN') =>&&0038
 my $dirname  = dirname(  $some_full_path ); =>&&000e
 use Math::BigInt; =>&&0018
 $ cpan CGI::Prototype HTTP::Cookies::Safari Test::Pod =>&&003b
 unshift @INC, '/home/gilligan/lib';   # broken =>&&002e
 $value->bpow(1000);               # take 2**1000 =>&&001a
 $ wget http://www. cpan. org/. . . /HTTP-Cookies-Safari-1. 10. tar. gz =>&&001c
 use lib qw(/Users/home/Ginger); =>&&0026
 my $basename = basename( $some_full_path ); =>&&000d
 $ perl Build =>&&0028
 Can't locate Navigation/SeatofPants. pm in @INC (@INC contains:. . . ) =>&&002d
 $ perl Build install =>&&002a
 use constant LIB_DIR => '/home/gilligan/lib'; . . .  =>&&0034
 cpan shell -- CPAN exploration and modules installation (v1. 7601) =>&&0037
 my $dirname = File::Basename::dirname($some_path); =>&&0011
 my $basename = File::Basename::basename($some_path); =>&&0012
 $ make install =>&&0022
 $ cd HTTP-Cookies-Safari-1. 10s =>&&001e
 $ perldoc File::Basename =>&&0001
 $ perl -MCPANPLUS -e shell =>&&003c
 $ cpanp i CGI::Prototype HTTP::Cookies::Safari Test::Pod =>&&0043
 CPAN Terminal> i CGI::Prototype =>&&0042
 print $value->bstr(  ), "\n";     # print it out =>&&001b
 use Navigation::SeatOfPants; =>&&002c
       fileparse - split a pathname into pieces =>&&0003
 #!/usr/bin/perl =>&&0025
 $ make test =>&&0021
 $ tar -xzf HTTP-Cookies-Safari-1. 10. tar. gz =>&&001d
 *** Using CPANPLUS::Backend v0. 049.  =>&&003f
         $basename = basename($fullname, @suffixlist); =>&&000a
 $ perl Build test =>&&0029
 use lib '/home/gilligan/lib'; =>&&0030
 use File::Basename (  );              # no import =>&&0013
         use File::Basename; =>&&0007
 CPANPLUS::Shell::Default -- CPAN exploration and modules installation (v0. 03) =>&&003d
 cpan> =>&&0039
 $ perl -MCPAN -e shell =>&&0036
 cpan> install CGI::Prototype =>&&003a
 *** ReadLine support available (try 'i Term::ReadLine::Perl').  =>&&0040
         ($name, $path, $suffix) = fileparse($fullname, @suffixlist) =>&&0008
 SYNOPSIS =>&&0006
 NAME =>&&0002
 my $base = File::Basename::basename($some_path); =>&&0014
 $ make =>&&0020
         fileparse_set_fstype($os_string); =>&&0009
 $ perl Makefile. PL =>&&001f
 use File::Basename; =>&&000c
 my $LIB_DIR = '/home/gilligan/lib'; . . .  =>&&0032
 use lib '/home/gilligan/lib/Navigation/SeatOfPants. pm'; # WRONG =>&&0031
 use File::Basename qw( fileparse basename ); =>&&0010
 use lib $LIB_DIR;     # BROKEN =>&&0033
       dirname - extract just the directory from a path =>&&0005
 use File::Basename ('fileparse', 'basename'); =>&&000f
 my $value = Math::BigInt->new(2); # start with 2 =>&&0019
         'web_docs', 'photos', 'USS_Minnow. gif' ); =>&&0017
 use lib LIB_DIR; =>&&0035
       basename - extract just the filename from a path =>&&0004
 $ perl Build. PL =>&&0027
 BEGIN { unshift @INC, '/home/gilligan/lib'; } =>&&002f
 CPAN Terminal> =>&&0041
 $ perl Build. PL --install_base /Users/home/Ginger =>&&002b
  if (@missing) { =>&&0038
      print "$who is missing $item. \n"; =>&&0035
 my $second_reference_to_skipper = $reference_to_skipper; =>&&001a
     $crewmember->{'name'},  =>&&0071
 my @keys = keys % gilligan_info; =>&&0057
    print "Adding @missing to @$items for $who. \n"; =>&&0039
 if ($reference_to_skipper =  = $second_reference_to_skipper) { =>&&001c
 $root -> [2] -> [1] -> [0] =>&&004a
   unless (grep $item eq $_, @skipper) { # not found in list? =>&&0004
 @ { $hash_ref } { qw(name position) } =>&&0076
 check_required_items('Professor', \@professor); =>&&002a
   check_required_items($who, $provisions_reference); =>&&0046
   name     => 'Gilligan',  =>&&005c
  name     => 'Gilligan',  =>&&0050
 my $name = $hash_ref->{'name'}; =>&&005b
   my $provisions_reference = $$person[1]; =>&&0045
  printf $format, @$crewmember{qw(name shirt hat position)}; =>&&0079
 my $ref = $crew[0]; $$ref{'name'} =>&&0067
 check_required_items('skipper', @skipper); =>&&0017
 my $name = $ { $hash_ref } { 'name' }; =>&&0056
  \@skipper_with_name,  =>&&003f
 my @gilligan = qw(red_shirt hat lucky_socks water_bottle); =>&&0008
   printf $format,  =>&&0070
 my $name = $ gilligan_info { 'name' }; =>&&0055
   my $items = shift; =>&&0021
  for my $crewmember (@crew) { =>&&006f
 my @all_with_names = ( =>&&003e
 @ gilligan_info { qw(name position) } =>&&0075
     unless (grep $item eq $_, @{$items}) { # not found in list? =>&&0028
 my $reference_to_skipper = \@skipper; =>&&0019
 $crew[0]->{'name'} =>&&0068
 my @gilligan  =. . . gilligan items. . . ; =>&&007e
 for my $item (@required) { =>&&0003
 my @keys = keys %$hash_ref; =>&&005a
  printf $format, qw(Name Shirt Hat Position); =>&&006e
  hat      => 'White',  =>&&0051
  \@professor_with_name,  =>&&0040
   for my $item (@required) { =>&&0011
  my $who   = shift; =>&&0032
 my %gilligan_info = ( =>&&004f
 my @skipper  = qw(blue_shirt hat jacket preserver sunscreen); =>&&0002
 my $third_reference_to_skipper = \@skipper; =>&&001b
 my @professor_with_name = ('Professor', \@professor); =>&&003c
 Take $root.  =>&&004e
 @ $hash_ref { qw(name position) } =>&&0077
   hat      => 'White',  =>&&005d
 my $name = $$hash_ref{'name'}; =>&&0059
    unless (grep $item eq $_, @{$_[1]}) { # not found in list? =>&&002e
  position => 'First Mate',  =>&&0053
 $ginger->[2]->[1] =>&&007c
   check_required_items(@$person); =>&&0047
 ${ $items }[1] =>&&0026
   unless (grep $item eq $_, @professor) { # not found in list? =>&&000c
     $crewmember->{'hat'},  =>&&0073
  my @required = qw(preserver sunscreen water_bottle jacket); =>&&002c
  my $items = shift; =>&&0033
   print "They are identical references. \n"; =>&&001d
 for my $person (@all_with_names) { =>&&0043
     $crewmember->{'shirt'},  =>&&0072
     } =>&&0014
   position => 'Captain',  =>&&0064
 ${ $crew[0] } { 'name' } =>&&0066
      print "$_[0] is missing $item. \n"; =>&&002f
       print "$who is missing $item. \n"; =>&&0013
   name     => 'Skipper',  =>&&0061
  } =>&&0031
 ); =>&&0042
  shirt    => 'Red',  =>&&0052
 ${${${$root}[2]}[1]}[0] =>&&004c
 my @skipper   = qw(blue_shirt hat jacket preserver sunscreen); =>&&0016
    push @$items, @missing; =>&&003a
  \@gilligan_with_name,  =>&&0041
   position => 'First Mate',  =>&&005f
     print "professor is missing $item. \n"; =>&&000d
    } =>&&0030
   my $who   = shift; =>&&0027
   my $who = shift; =>&&000f
 sub check_required_items { =>&&000e
   Professor => \@professor,  =>&&0084
 my %skipper_info = ( =>&&0060
 my $hash_ref = \%gilligan_info; =>&&0054
   hat      => 'Black',  =>&&0062
  ); =>&&006a
 for my $crewmember (@crew) { =>&&0078
 my @required = qw(preserver sunscreen water_bottle jacket); =>&&0001
 @{ $items } =>&&0024
     $crewmember->{'position'}; =>&&0074
     print "skipper is missing $item. \n"; =>&&0005
  my %skipper_info = ( =>&&006b
 my @skipper = qw(blue_shirt hat jacket preserver sunscreen); =>&&001f
 $ginger->[2][1] =>&&007a
 check_required_items("The Skipper", \@skipper); =>&&0020
 my @professor = qw(sunscreen water_bottle slide_rule batteries radio); =>&&000b
     unless (grep $item eq $_, @_) { # not found in list? =>&&0012
 check_required_items('gilligan', @gilligan); =>&&0015
  my @crew = (\%gilligan_info, \%skipper_info); =>&&006c
 my @skipper   =. . . skipper items. . . ; =>&&007f
 @{$root->[2][1]} =>&&004d
 $crew[0]{'name'} =>&&0069
  my $format = "%-15s %-7s %-7s %-15s\n"; =>&&006d
 my @professor =. . . professor items. . . ; =>&&0080
 $  skipper [1] =>&&0025
 ARRAY(0x1a2b3c) =>&&001e
  my @missing = (  ); =>&&0036
 check_required_items('The Skipper', \@skipper); =>&&0029
  for my $item (@required) { =>&&002d
   my @required = qw(preserver sunscreen water_bottle jacket); =>&&0010
 } =>&&0007
 check_required_items(@$_) for @all_with_names; =>&&0048
 check_items_for_all(\%all); =>&&0085
   my @required = qw(preserver sunscreen water_bottle jacket); . . .  =>&&0022
 my @gilligan_with_name = ('Gilligan', \@gilligan); =>&&003d
 my $root = \@all_with_names; =>&&0049
 my @crew = (\%gilligan_info, \%skipper_info); =>&&0065
    unless (grep $item eq $_, @$items) { # not found in list? =>&&0034
 my @skipper_with_name = ('Skipper', \@skipper); =>&&003b
 @  skipper =>&&0023
   Skipper   => \@skipper,  =>&&0083
      push @missing, $item; =>&&0037
 my @keys = keys % { $hash_ref }; =>&&0058
 my %all = ( =>&&0081
 check_required_items('Gilligan', \@gilligan); =>&&002b
   } =>&&0006
   my $who = $$person[0]; =>&&0044
 ${$ginger->[2]}[1] =>&&007d
 ${$ginger[2]}[1] =>&&007b
   shirt    => 'Red',  =>&&005e
     print "gilligan is missing $item. \n"; =>&&000a
   shirt    => 'Blue',  =>&&0063
   unless (grep $item eq $_, @gilligan) { # not found in list? =>&&0009
 check_required_items('professor', @professor); =>&&0018
 $root -> [2][1][0] =>&&004b
   Gilligan  => \@gilligan,  =>&&0082
  0  HASH(0x297474) =>&&005c
 $Data::Dumper::Purity = 1; =>&&00aa
 my @data1 = qw(one won); =>&&007c
    2  'thurston. howell. hut' =>&&0057
 DB<8> x $source, $destination, $bytes =>&&003d
  main::(bytecounts:8):        for my $source (sort keys %total_bytes) { =>&&0053
          [  ] =>&&00b5
 DB<9> s =>&&003f
 my @bigger_indices = grep { =>&&00c4
     'gilligan. crew. hut' => 1250 =>&&0024
 DB<6> s =>&&0034
 my @person_item_pairs = map { =>&&00db
           'thurston. howell. hut' => { =>&&006e
 my @bigger = @x[@bigger_indices]; =>&&00ca
  main::(bytecounts:4):          my ($source, $destination, $bytes) = split; =>&&0026
 'professor. hut' => 1218 =>&&005e
 professor. hut gilligan. crew. hut 1250 =>&&000c
  2  199 =>&&004e
 } 0. . $#input_numbers; =>&&00bd
 myhost% perl bytecounts2 <bytecounts-in =>&&006c
            'two',  =>&&0085
 --- #YAML:1. 0 =>&&009e
 Editor support available.  =>&&0014
 main::(bytecounts:5):          $total_bytes{$source}{$destination} += $bytes; =>&&001a
  main::(bytecounts:5):          $total_bytes{$source}{$destination} += $bytes; =>&&0027
 } 0. . $#x; =>&&00c9
              'too',  =>&&00b0
        } =>&&009c
          'one',  =>&&0082
 print Dumper(\@data1, \@data2); =>&&0080
 my ($arr1, $arr2) = @{ retrieve 'some_file' }; =>&&00b8
  while (<>) { =>&&0002
    0  ARRAY(0xf914) =>&&008e
 my @bigger = map { =>&&00cc
 'maryann. girl. hut' => 199 =>&&005d
  $_ > $#y or $x[$_] > $y[$_]; =>&&00cb
   my @items = @{ $provisions{$person} }; =>&&00dd
 DB<21> x $total_bytes{$source}{$destination} =>&&0066
 0  'professor. hut' =>&&001c
 DB<4> x \%total_bytes =>&&002e
            'too',  =>&&0086
  lovey. howell. hut: 1360 =>&&00a4
 DB<6> x $source, $destination, $bytes =>&&0035
 ginger. girl. hut: =>&&009f
          ] =>&&0089
  DB<1> s =>&&0017
 print Dump(\%total_bytes); =>&&009d
    $x[$_]; =>&&00cd
 'thurston. howell. hut' => HASH(0x2f9538) =>&&003a
    0  'two' =>&&0092
  2  1250 =>&&0037
  gilligan. crew. hut: 1250 =>&&00a3
            'won',  =>&&00ad
                                'lovey. howell. hut' => 1360 =>&&0077
                                    },  =>&&0070
 DB<3> s =>&&0025
  professor. hut: 1218 =>&&00a1
 use Data::Dumper; =>&&0068
  DB<1> x $source, $destination, $bytes =>&&001b
 my @packed_light = grep @{ $provisions{$_} } < 5, keys %provisions; =>&&00d4
 my @remapped_list = map { =>&&00d9
           'ginger. girl. hut' => { =>&&0071
   [ $_ => $provisions{$_} ]; =>&&00da
 DB<20> s =>&&0062
  0  'professor. hut' =>&&0029
    'lovey. howell. hut' => 910 =>&&0032
 -> REUSED_ADDRESS =>&&0098
  0  HASH(0x132dc) =>&&002f
    'lovey. howell. hut' => 1360 =>&&0041
  my $sum; =>&&00c0
 DB<2> x \%total_bytes =>&&0021
 store [\@data1, \@data2], 'some_file'; =>&&00a8
 $VAR2 = $VAR1->[2]; =>&&008c
 DB<18> x keys %{ $total_bytes{$source } } =>&&005f
 my @input_numbers = (1, 2, 4, 8, 16, 32, 64); =>&&00bb
            'one',  =>&&00ac
              [  ] =>&&00b2
   for my $destination (sort keys %{ $total_bytes{$source} }) { =>&&0007
  2  910 =>&&002b
 DB<7> x \%total_bytes =>&&0039
 my @indices_of_odd_digit_sums = grep { =>&&00be
 'professor. hut' => HASH(0x37a34) =>&&0030
            [  ] =>&&0088
 push @data1, \@data2; =>&&007f
 1  'gilligan. crew. hut' =>&&001d
  2  450 =>&&003e
 DB<14> x sort keys %total_bytes =>&&0054
 my @odd_digit_sums = @input_numbers[ @indices_of_odd_digit_sums ]; =>&&00c3
 thurston. howell. hut: =>&&00a5
  maryann. girl. hut: 199 =>&&00a0
 my %provisions = ( =>&&00cf
 DB<7> s =>&&0038
        my ($source, $destination, $bytes) = split; =>&&009a
 my @indices_of_odd_digit_sums = grep { . . .  =>&&00bc
 myhost% =>&&007a
          ],  =>&&00b4
  'The Professor' => [qw(sunscreen water_bottle slide_rule radio)  ],  =>&&00d1
  'professor. hut' => HASH(0x37a34) =>&&0023
            [ =>&&00ae
 myhost% perl -d bytecounts bytecounts-in =>&&0012
  lovey. howell. hut: 1250 =>&&00a6
      " $total_bytes{$source}{$destination} bytes\n"; =>&&0009
  } else { =>&&00c7
  2  1218 =>&&0046
              'to',  =>&&00b1
   $total_bytes{$source}{$destination} += $bytes; =>&&0004
 0  'one' =>&&008f
  1  'professor. hut' =>&&0045
                                },  =>&&0074
  } =>&&0005
 'ginger. girl. hut' => HASH(0x297474) =>&&0049
 ); =>&&00d3
 main::(bytecounts:2):        my %total_bytes; =>&&0016
 DB<2> s =>&&001f
 print Dumper($result); =>&&00ab
              'two',  =>&&00af
           'professor. hut' => { =>&&0075
                              } =>&&0078
 $VAR1->[2][3] = $VAR1; =>&&008b
    1  'too' =>&&0093
  my $number = $input_numbers[$_]; =>&&00bf
 push @data2, \@data1; =>&&007e
 my @all_wet = grep { =>&&00d5
 DB<8> s =>&&003c
  main::(bytecounts:10):            print "$source => $destination:",  =>&&0063
 $VAR1 = [ =>&&0081
 2  1250 =>&&001e
                                  'professor. hut' => 1218 =>&&0073
 my $result = retrieve 'some_file'; =>&&00a9
 DB<11> s =>&&0047
 2  ARRAY(0x3122a8) =>&&0091
 while (<>) { =>&&0069
 use YAML; =>&&0099
 DB<16> x $total_bytes{$source} =>&&005b
 DB<10> x $source, $destination, $bytes =>&&0043
        ]; =>&&008a
    2  'to' =>&&0094
 DB<12> x $source, $destination, $bytes =>&&004c
 } keys %provisions; =>&&00d8
    main::(bytecounts:9):     for my $destination (sort keys %{ $total_bytes{$source} }) { =>&&0059
 DB<13> s =>&&004f
                                      'lovey. howell. hut' => 1250 =>&&006f
   map [$person => $_], @items; =>&&00de
         }; =>&&0079
 professor. hut lovey. howell. hut 910 =>&&000d
 DB<12> s =>&&004b
 DB<4> s =>&&002c
  0  199 =>&&0067
    3  ARRAY(0xf914) =>&&0095
  $sum += $_ for split //, $number; =>&&00c1
    1; # yes, select it =>&&00c6
 DB<19> x sort keys %{ $total_bytes{$source } } =>&&0061
  'Gilligan'      => [qw(red_shirt hat lucky_socks water_bottle)   ],  =>&&00d2
 DB<15> x $source =>&&005a
  my @items = @{ $provisions{$_} }; =>&&00d6
 main::(bytecounts:3):        while (<>) { =>&&0018
  main::(bytecounts:3):        while (<>) { =>&&002d
 DB<10> s =>&&0042
            'to',  =>&&0087
 ginger. girl. hut maryann. girl. hut 199 =>&&0011
        $total_bytes{$source}{$destination} += $bytes; =>&&009b
 professor. hut: =>&&00a2
 DB<9> x \%total_bytes =>&&0040
    1  'professor. hut' =>&&0056
            ] =>&&00b3
  0  'maryann. girl. hut' =>&&0060
  0  'ginger. girl. hut' =>&&0044
 Enter h or 'h h' for help, or 'man perldebug' for more help.  =>&&0015
    0  HASH(0x132dc) =>&&0022
  1  'maryann. girl. hut' =>&&004d
 $Data::Dumper::Purity = 1; # declare possibly self-referencing structures =>&&007b
    0; # no, don't select it =>&&00c8
  for my $source (sort keys %total_bytes) { =>&&0006
 ginger. girl. hut professor. hut 1218 =>&&0010
 DB<3> x $source, $destination, $bytes =>&&0028
 print Dumper(\%total_bytes); =>&&006b
    (  ); =>&&00ce
  if ($_ > $#y or $x[$_] > $y[$_]) { =>&&00c5
  'The Skipper'   => [qw(blue_shirt hat jacket preserver sunscreen)],  =>&&00d0
                                  'maryann. girl. hut' => 199,  =>&&0072
  0  'thurston. howell. hut' =>&&0036
 DB<20> x $source, $destination =>&&0065
 $VAR1->[1] = $VAR1->[0][2]; =>&&00b7
 DB<15> s =>&&0058
 DB<13> x \%total_bytes =>&&0050
          [ =>&&0084
 } =>&&006a
                                'gilligan. crew. hut' => 1250,  =>&&0076
 $VAR1->[0][2][3] = $VAR1->[0]; =>&&00b6
   my $person = $_; =>&&00dc
    0  'ginger. girl. hut' =>&&0055
  grep $_ eq 'water_bottle', @items; =>&&00d7
  $VAR1 = { =>&&006d
 use Storable; =>&&00a7
    1  ARRAY(0x3122a8) =>&&0097
 DB<1> x \@data1, \@data2 =>&&008d
 professor. hut lovey. howell. hut 450 =>&&000f
   print "\n"; =>&&000b
    'maryann. girl. hut' => 199 =>&&0051
       -> REUSED_ADDRESS =>&&0096
 my %total_bytes; =>&&0001
          'won',  =>&&0083
   } =>&&000a
 main::(bytecounts:4):          my ($source, $destination, $bytes) = split; =>&&0019
     print "$source => $destination:",  =>&&0008
   main::(bytecounts:3):        while (<>) { =>&&0020
  $sum % 2; =>&&00c2
 DB<11> x \%total_bytes =>&&0048
    'professor. hut' => 1218 =>&&004a
 my @data2 = qw(two too to); =>&&007d
    'gilligan. crew. hut' => 1250 =>&&0031
  main::(bytecounts:11):              " $total_bytes{$source}{$destination} bytes\n"; =>&&0064
 DB<5> s =>&&0033
   my ($source, $destination, $bytes) = split; =>&&0003
 print Dumper(@$result); =>&&00ba
 Loading DB routines from perl5db. pl version 1. 19 =>&&0013
  1  'lovey. howell. hut' =>&&002a
 DB<14> s =>&&0052
 print Dumper($arr1, $arr2); =>&&00b9
 thurston. howell. hut lovey. howell. hut 1250 =>&&000e
 1  'won' =>&&0090
    'lovey. howell. hut' => 1250 =>&&003b
