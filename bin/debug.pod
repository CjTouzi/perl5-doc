< print "Left=$b->[0]\n"; >
< # message in a variable called $AUTOLOAD. >
< print "a=$$a\n"; >
< $ref->FETCH(@_); >
< $self->BAZ; >
<
=item 6 >
<
Note that C<SUPER> refers to the superclasses of the current package (C<Foo>), not to the superclasses of C<$self>. >
<

 sub AUTOLOAD { >
<
=item 1 >
<

 # DESTROY messages should never be propagated. >
< sub new { >
< print "in GOOP::BAZ\n"; >
< print "foo-bar = $foo{'bar'}\n"; >
< $self->{'fizzle'} = \%fizzle; >
<
Some classes, such as SDBM_File, cannot be effectively subclassed because they create foreign objects.Such a class can be extended with some sort of aggregation technique such as the "using" relationship mentioned earlier or by delegation. >
< $foo->google; >
<

 require SDBM_File; >
< print "Low=$a->{'Low'}\n"; >
<
=item 8 >
< use Fcntl qw( O_RDWR O_CREAT ); >
< $self->{'delegate'}->$AUTOLOAD(@_); >
<
=item 3 >
<



 package Bar; >
< sub goo { print "here's the goo\n" } >
< my $ref = SDBM_File->new(@_); >
<
=head1 THINKING OF CODE REUSE >
<
This example demonstrates an interface for the SDBM class.This creates a "using" relationship between the SDBM class and the new class Mydbm. >
< $self->{'buz'} = 42; >
<

 # Pass the message to the delegate. >
<

 sub new { >
< $self->{'High'} = $params{'High'}; >
<
=over 5 >
<

 # Don't try to guess if we should use %Bar::fizzle >
<

 %fizzle = ( 'Password' => 'XYZZY' ); >
< $foo->grr; >
<

 package Bar; @ISA = qw( Buz ); >
< $self->[0] = $params{'Left'}; >
<

 $b = Bar->new( 'Left' => 78, 'Right' => 40 ); >
< bless [], $type; >
< $a->baz; >
<
Do not attempt to verify the type of $self.That'll break if the class is inherited, when the type of $self is valid but its package isn't what you expect.See rule 5. >
<
To create reusable code we must modify class FOO, flattening class FOO::private.The next example shows a reusable class FOO which allows the method GOOP::BAZ() to be used in place of FOO::BAZ(). >
< sub goo { >
< $AUTOLOAD =~ s/^Mydbm:://; >
<


=head1 USING RELATIONSHIP WITH SDBM >
< sub google { print "google here\n" } >
<

 $a = Foo->new( 42 ); >
<

 $a = BAR->new; >
<
An anonymous scalar can be used when only one instance variable is needed. >
< $self = shift; >
<
The following collection of tricks and hints is intended to whet curious appetites about such things as the use of instance variables and the mechanics of object and class relationships.The reader is encouraged to consult relevant textbooks for discussion of Object Oriented definitions and methodology.This is not intended as a tutorial for object-oriented programming or as a comprehensive guide to Perl's object oriented features,  nor should it be construed as a style guide.If you're looking for tutorials,  be sure to read L<perlboot>, L<perltoot>, and L<perltooc>. >
<
An inheritable constructor should use the second form of bless() which allows blessing directly into a specified class.Notice in this example that the object will be a BAR not a FOO, even though the constructor is in class FOO. >
< @ISA = qw( Bar Baz ); >
< die "Cannot STORE an undefined key in Mydbm\n"; >
<=head1 >
< my $self = {}; >
<
The following demonstrates how one might implement "containing" and "using" relationships between objects. >
< print "buz = ", $a->{'buz'}, "\n"; >
<
=head1 INHERITING A CONSTRUCTOR >
< $self->{'biz'} = 11; >
<

 tie %foo, "Mydbm", "Sdbm", O_RDWR|O_CREAT, 0640; >
<=over >
<

 $a = Foo->new( 'High' => 42, 'Low' => 11 ); >
< $self->SUPER::google(); >
<
=head1 SCALAR INSTANCE VARIABLES >
< my $ref = $self->{'dbm'}; >
< $self->FOO::private::BAZ; >
<
=head1 DELEGATION >
<
IO syntax is certainly less noisy, but it is also prone to ambiguities that can cause difficult-to-find bugs.Allow people to use the sure-thing OO syntax, even if you don't like it. >
<

 $foo = Foo->new; >
<
Use the object to solve package and class context problems.Everything a method needs should be available via the object or should be passed as a parameter to the method. >
<
=item 5 >
<

 package BAR; >
<




=head1 OVERRIDING SUPERCLASS METHODS >
< # we should use, so just ask it. >
<
=item 4 >
<
The following example demonstrates delegation using an AUTOLOAD() function to perform message-forwarding.This will allow the Mydbm object to behave exactly like an SDBM_File object.The Mydbm class could now extend the behavior by adding custom FETCH() and STORE() methods, if this is desired. >
< $self->SUPER::mumble(); >
< $self->SUPER::goo(); >
< $bar{'Cathy'} = 456; >
< @ISA = qw(Tie::Hash); >
< bless {'delegate' => $ref}; >
< sub google { >
<
=head1 OO SCALING TIPS >
<=back 

>
< my $self; >
< print "biz = ", $a->{'biz'}, "\n"; >
<
This example demonstrates how one might inherit instance variables from a superclass for inclusion in the new class.This requires calling the superclass's constructor and adding one's own instance variables to the new object. >
< # or %Foo::fizzle.The object already knows which >
< my $self = []; >
< sub mumble { print "mumbling\n" } >
< my $ref  = $self->{'dbm'}; >
<
This first example illustrates a class which uses a fully-qualified method call to access the "private" method BAZ().The second example will show that it is impossible to override the BAZ() method. >
<

 package Baz; >
< $foo->mumble; >
< print "buz = ", $a->{'Bar'}->{'buz'}, "\n"; >
< my $self = Bar->new; >
<
The following example demonstrates how to override a superclass method and then call the overridden method.The B<SUPER> pseudo-class allows the programmer to call an overridden superclass method without actually knowing where that method is defined. >
<
Don't be trigger happy with inheritance.A "using", "containing", or "delegation" relationship (some sort of aggregation, at least) is often more appropriate.See L<OBJECT RELATIONSHIPS>, L<USING RELATIONSHIP WITH SDBM>,  and L<"DELEGATION">. >
<

 package FOO; >
< print "Right=$b->[1]\n"; >
<

 $a = FOO->new; >
<
Don't assume you know the home package of a method.You're making it difficult for someone to override that method.See L<THINKING OF CODE REUSE>. >
<
perlbot - Bag o' Object Tricks (the BOT) >
<
=head1 INSTANCE VARIABLES >
<

 # The Perl interpreter places the name of the >
<
If an object-oriented (OO) or indirect-object (IO) syntax was used, then the object is probably the correct type and there's no need to become paranoid about it.Perl isn't a paranoid language anyway.If people subvert the OO or IO syntax then they probably know what they're doing and you should let them do it.See rule 1. >
< } else { >
< $foo{'bar'} = 123; >
<
=head1 NAME >
< $a->bar; >
< $self->{'Bar'} = Bar->new; >
< my $self = shift; >
< @ISA = qw( Tie::Hash ); >
<

 package Bar; >
<

 tie %foo, "Mydbm", "adbm", O_RDWR|O_CREAT, 0640; >
< @ISA = qw( FOO ); >
< $self->{'Low'}  = $params{'Low'}; >
<
An anonymous array or anonymous hash can be used to hold instance variables.Named parameters are also demonstrated. >
< bless {}, $type; >
< print "in FOO::baz()\n"; >
<
=item 2 >
<
One strength of Object-Oriented languages is the ease with which old code can use new code.The following examples will demonstrate first how one can hinder code reuse and then how one can promote code reuse. >
<

 # Remove the package name. >
<
=head1 SEE ALSO >
<

 package Foo; >
<

 tie %bar, "Mydbm", "Sdbm2", O_RDWR|O_CREAT, 0640; >
<

 package FOO::private; >
< print "High=$a->{'High'}\n"; >
< sub STORE { >
< $b = Foo->new; >
< print "in BAR::baz()\n"; >
< return if $AUTOLOAD =~ /::DESTROY$/; >
< $a->enter; >
<

 sub enter { >
< bless {'dbm' => $ref}, $type; >
<
=item 9 >
< sub grr { print "grumble\n" } >
<

 $a = GOOP->new; >
< $foo->goo; >
<
=head1 CLASS CONTEXT AND THE OBJECT >
< bless $self, $type; >
< sub FETCH { >
< my $ref  = SDBM_File->new(@_); >
<
The object is the namespace.Make package globals accessible via the object.This will remove the guess work about the symbol's home package. See L<CLASS CONTEXT AND THE OBJECT>. >
< sub BAZ { >
<
A class will sometimes have static or global data to be used by the methods.A subclass may want to override that data and replace it with new data.When this happens the superclass may not know how to find the new copy of the data. >
<=encoding >
< @ISA = qw( Bar ); >
< my $type = shift; >
< print "in BAZ\n"; >
<
The subclass is allowed to know things about its immediate superclass, the superclass is allowed to know nothing about a subclass. >
< # >
< $b->enter; >
< my %params = @_; >
<

 print "The word is ", $fizzle->{'Password'}, "\n"; >
<

 sub TIEHASH { >
<

 sub baz { >
<
=head1 DESCRIPTION >
<
=back >
< bless \$self, $type; >
< $ref->STORE(@_); >
<
Now we try to override the BAZ() method.We would like FOO::bar() to call GOOP::BAZ(), but this cannot happen because FOO::bar() explicitly calls FOO::private::BAZ(). >
<
>
< } >
<
Do not use function-call syntax on a method.You're going to be bitten someday.Someone might move that method into a superclass and your code will be broken.On top of that you're feeding the paranoia in rule 2. >
< @ISA = qw(FOO); >
< my $fizzle = $self->{'fizzle'}; >
<
=item 7 >
< $self->[1] = $params{'Right'}; >
<




=head1 OBJECT RELATIONSHIPS >
<

 package GOOP; >
<=item >
<

 package Mydbm; >
<
The Perl motto still holds:  There's more than one way to do it. >
<

 package main; >
<
This problem can be solved by using the object to define the context of the method.Let the method look in the object for a reference to the data.The alternative is to force the method to go hunting for the data ("Is it in my class, or in a subclass?  Which subclass?"), and this can be inconvenient and will lead to hackery.It is better just to let the object tell the method where that data is located. >
<

 package Buz; >
<
Use the two-argument form of bless().Let a subclass use your constructor. See L<INHERITING A CONSTRUCTOR>. >
< require Tie::Hash; >
< sub mumble { >
< if (defined $_[0]){ >
<

 %fizzle = ( 'Password' => 'Rumple' ); >
<


=head1 INSTANCE VARIABLE INHERITANCE >
< sub bar { >
<

 sub BAZ { >
<

 $a = Bar->new; >
< print "bar-Cathy = $bar{'Cathy'}\n"; >
<

 $a = Foo->new; >
